[{"title":"Codeforces#811 Div3 题解","url":"/2022/08/02/342b271e/","content":"\n## [D. Color with Occurrences](https://codeforces.com/contest/1714/problem/D)\n\nYou are given some text t and a set of n strings $s_1, s_2, \\dots, s_n$ .\n\nIn one step, you can choose any occurrence of any string $s_i$ in the text $t$ and color the corresponding characters of the text in red. For example, if $t=\\texttt{bababa}$ and $s_1=\\texttt{ba}$ , $s_2=\\texttt{aba}$ , you can get $t=\\color{red}{\\texttt{ba}}$  $\\texttt{baba}$ , $t=\\texttt{b}\\color{red}{\\texttt{aba}}$  $\\texttt{ba}$ or $t=\\texttt{bab}$  $\\color{red}{\\texttt{aba}}$ in one step.\n\nYou want to color all the letters of the text t in red. When you color a letter in red again, it stays red.\n\nIn the example above, three steps are enough:\n\n- Let's color $t[2 \\dots 4]=s_2=\\texttt{aba}$ in red, we get $t=\\texttt{b}\\color{red}{\\texttt{aba}}$  $\\texttt{ba}$ ;\n- Let's color $t[1 \\dots 2]=s_1=\\texttt{ba}$ in red, we get $t=\\color{red}{\\texttt{baba}}$  $\\texttt{ba}$ ;\n- Let's color $t[4 \\dots 6]=s_2=\\texttt{aba}$ in red, we get $t=\\color{red}{\\texttt{bababa}}$ .\nEach string $s_i$ can be applied any number of times (or not at all). Occurrences for coloring can intersect arbitrarily.\n\nDetermine the minimum number of steps needed to color all letters t in red and how to do it. If it is impossible to color all letters of the text t in red, output -1.\n\n**Input**\n\nThe first line of the input contains an integer $q (1 \\le q \\le 100)$ —the number of test cases in the test.\n\nThe descriptions of the test cases follow.\n\nThe first line of each test case contains the text $t (1 \\le |t| \\le 100)$ , consisting only of lowercase Latin letters, where $|t|$ is the length of the text t.\n\nThe second line of each test case contains a single integer $n (1 \\le n \\le 10)$ — the number of strings in the set.\n\nThis is followed by n lines, each containing a string $s_i (1 \\le |s_i| \\le 10)$ consisting only of lowercase Latin letters, where $|s_i|$ — the length of string $s_i$ .\n\n**Output**\n\nFor each test case, print the answer on a separate line.\n\nIf it is impossible to color all the letters of the text in red, print a single line containing the number -1.\n\nOtherwise, on the first line, print the number m — the minimum number of steps it will take to turn all the letters t red.\n\nThen in the next m lines print pairs of indices: $w_j$ and $p_j (1 \\le j \\le m)$ , which denote that the string with index $w_j$ was used as a substring to cover the occurrences starting in the text t from position $p_j$ . The pairs can be output in any order.\n\nIf there are several answers, output any of them.\n\n### 解法一\n\n题目核心其实是一个区间覆盖的问题，每个 $s_i$ 在 $t$ 中能匹配上的部分就是一个区间，题目求的就是用最少的区间去覆盖整个 $t$。所以我们按照贪心的思路，从$t_0$开始找到能overlap右边界的最大区间，然后更新右边界，最后覆盖完所有的区间，得到的就是最少的覆盖次数。在过程中记录下区间信息，输出步骤即可。\n\n代码实现如下：\n\n```java\nimport java.util.*;\nimport java.io.*;\n\n// AtCoder/AcWing 提交上面部分即可，CF需要将JavaMain移到上面然后提交\npublic class D {\n    public static void main(String[] args) throws Exception {\n        // 输入重定向，通过jvm参数判断环境\n        if (args.length > 0 && \"Resolmi_DEBUG\".equals(args[0])) {\n            System.setIn(new FileInputStream(\"./input.txt\"));\n        }\n        new Main().main(args);\n    }\n}\n\nclass Main {\n\n    public static void main(String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int Q = read(br)[0];\n        while (Q-- > 0) {\n            String t = br.readLine();\n            int n = read(br)[0];\n            // match[i]: t第i个位置最远能匹配到哪里\n            var match = new int[t.length()][2];\n\n            String[] s = new String[n];\n            for (int i = 0; i < n; i++) {\n                s[i] = br.readLine();\n                // 预处理每个s[i]在t中能匹配的位置\n                for (int j = 0; j < t.length(); j++) {\n                    var flag = true;\n                    for (int k = 0; k < s[i].length(); k++) {\n                        if (j + k >= t.length() || t.charAt(j+k) != s[i].charAt(k)) {\n                            flag = false;\n                            break;\n                        }\n                    }\n                    if (!flag) continue;\n                    if (match[j][1] <= s[i].length() + j) {\n                        match[j] = new int[]{i, s[i].length() + j};\n                    }\n                }\n            }\n            // 下一次开始匹配的位置\n            var last = 0;\n            var flag = true;\n            var cnt = 0;\n            var lis = new ArrayList<String>();\n            while (last < t.length()) {\n                var temp = last;\n                int w = 0, p = 0;\n                for (int i = 0; i <= temp; i++) {\n                    if (match[i][1] >= last) {\n                        last = match[i][1];\n                        w = match[i][0]+1;\n                        p = i+1;\n                    }\n                }\n                // 没有能cover last的区间\n                if (last == temp) {\n                    flag = false;\n                    break;\n                }\n                cnt++;\n                lis.add(w + \" \" + p);\n            }\n            if (flag) {\n                out.println(cnt);\n                lis.stream().forEach(out::println);\n            } else {\n                out.println(-1);\n            }\n\n        }\n        out.flush();\n    }\n\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [E. Add Modulo 10](https://codeforces.com/contest/1714/problem/E)\n\nYou are given an array of n integers $a_1, a_2, \\dots, a_n$\n\nYou can apply the following operation an arbitrary number of times:\n\n- select an index $i (1 \\le i \\le n)$ and replace the value of the element $a_i$ with the value $a_i + (a_i \\bmod 10)$, where $a_i \\bmod 10$ is the remainder of the integer dividing $a_i$ by $10$.\n\nFor a single index (value $i$), this operation can be applied multiple times. If the operation is applied repeatedly to the same index, then the current value of $a_i$ is taken into account each time. For example, if $a_i=47$ then after the first operation we get $a_i=47+7=54$, and after the second operation we get $a_i=54+4=58$.\n\nCheck if it is possible to make all array elements equal by applying multiple (possibly zero) operations.\n\nFor example, you have an array $[6, 11]$.\n\n- Let's apply this operation to the first element of the array. Let's replace $a_1 = 6$ with $a_1 + (a_1 \\bmod 10) = 6 + (6 \\bmod 10) = 6 + 6 = 12$. We get the array $[12, 11]$.\n- Then apply this operation to the second element of the array. Let's replace $a_2 = 11$ with $a_2 + (a_2 \\bmod 10) = 11 + (11 \\bmod 10) = 11 + 1 = 12$. We get the array $[12, 12]$.\n\nThus, by applying 2 operations, you can make all elements of an array equal.\n\n**Input**\n\nThe first line contains one integer $t (1 \\le t \\le 10^4)$ — the number of test cases. What follows is a description of each test case.\n\nThe first line of each test case contains one integer $n (1 \\le n \\le 2 \\cdot 10^5)$ — the size of the array.\n\nThe second line of each test case contains n integers $a_i (0 \\le a_i \\le 10^9)$ — array elements.\n\nIt is guaranteed that the sum of n over all test cases does not exceed $2 \\cdot 10^5$.\n\n**Output**\n\nFor each test case print:\n\n- YES if it is possible to make all array elements equal;\n- NO otherwise.\n\nYou can print YES and NO in any case (for example, the strings yEs, yes, Yes and YES will be recognized as a positive answer) .\n\n### 解法一\n\n找规律，题目大意是给定一组数组，尝试替换$a_i$为$a_i+(a_i \\bmod 10)$，问能否是的数组所有元素相等。\n\n我们可以将元素替换序列都列出来，然后找规律，进行分组，具体见代码：\n\n```java\nimport java.util.*;\nimport java.io.*;\n\n// AtCoder/AcWing 提交上面部分即可，CF需要将JavaMain移到上面然后提交\npublic class E {\n    public static void main(String[] args) throws Exception{\n        // 输入重定向，通过jvm参数判断环境\n        if (args.length > 0 && \"Resolmi_DEBUG\".equals(args[0])) {\n            System.setIn(new FileInputStream(\"./input.txt\"));\n        }\n        new Main().main(args);\n    }\n}\n\nclass Main {\n\n    // 1  2  4  8  16  22  24  28  36  42  44 ...\n    // 3  6  12 14  18  26  32  34  38  46  52 ...\n    // 5  10 10 10 ....\n    // 15 20 20 20 ...\n    // 7 14 18 26 ....\n    // 9 18\n    public static void main(String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = read(br)[0];\n        // 分析发现20为一个循环，我们将20以内的元素进行分组，两组元素序列完全平行，无法相交\n        // 所以如果元素 mod 20在同一组中，那么就一定可以转化成一样的，否则一定不行\n        // 除此之外，需要额外注意5和0结尾的元素，它们最多只能转化一次，所以如果有5/0结尾的元素，那么所有元素都必须是5/0结尾，且5结尾经过转换后与0结尾相同\n        var s1 = new HashSet<>();\n        s1.add(1); s1.add(2); s1.add(4); s1.add(8); s1.add(13); s1.add(16); s1.add(17); s1.add(19);\n        var s2 = new HashSet<>();\n        s2.add(3); s2.add(6); s2.add(7); s2.add(9); s2.add(11); s2.add(12); s2.add(14); s2.add(18); \n        while (T-- > 0) {\n            read(br);\n            var a = read(br);\n            var set5 = new HashSet<Integer>();\n            var cnt5 = 0;\n\n            var ins1 = false;\n            var ins2 = false;\n            for (Integer v : a) {\n                if (v%10 == 5 || v%10 == 0) {\n                    cnt5++;\n                    set5.add(v + v%10);\n                }\n                if (s1.contains(v%20)) {\n                    ins1 = true;\n                }\n                if (s2.contains(v%20)) {\n                    ins2 = true;\n                }\n            }\n            // 既有s1中的元素，又有s2中的元素 || 有5/0结尾的但是不全是 || 全是5/0结尾的，但是转换后不想等\n            if ((ins2 && ins1) || (cnt5 != 0 && cnt5 != a.length) || (cnt5 == a.length && set5.size() != 1)) {\n                out.println(\"No\");\n            } else {\n                out.println(\"Yes\");\n            }\n        }\n        out.flush();\n    }\n\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n\n## [G. Path Prefixes](https://codeforces.com/contest/1714/problem/G)\n\nYou are given a rooted tree. It contains $n$ vertices, which are numbered from $1$ to $n$. The root is the vertex $1$.\n\nEach edge has two positive integer values. Thus, two positive integers $a_j$ and $b_j$ are given for each edge.\n\nOutput $n-1$ numbers $r_2, r_3, \\dots, r_n$, where $r_i is defined as follows.\n\nConsider the path from the root (vertex $1$) to $i (2 \\le i \\le n)$. Let the sum of the costs of $a_j$ along this path be $A_i$. Then $r_i$ is equal to the length of the maximum prefix of this path such that the sum of $b_j$ along this prefix does not exceed $A_i$.\n\n![](https://static.imlgw.top/blog/20220807214642.png)\n\n... 题目太长，懒得copy，去看原题吧\n\n### 解法一\n\ndfs栈上二分，如果这题放在D或者E我肯定能写出来，放在后面并且题目这么长，让人有点畏惧，不过说到底还是太菜了。\n\n```java\nimport java.util.*;\nimport java.io.*;\n\n// AtCoder/AcWing 提交上面部分即可，CF需要将JavaMain移到上面然后提交\npublic class G {\n    public static void main(String[] args) throws Exception{\n        // 输入重定向，通过jvm参数判断环境\n        if (args.length > 0 && \"Resolmi_DEBUG\".equals(args[0])) {\n            System.setIn(new FileInputStream(\"./input.txt\"));\n        }\n        new Main().main(args);\n    }\n}\n\nclass Main {\n\n    static int idx;\n    static int[] e, ne, h, wa, wb;\n    static int si;\n    static long[] stack;\n    static int[] res;\n\n    public static void add(int a, int b, int i, int j) {\n        e[idx] = b; ne[idx] = h[a];\n        wa[idx] = i; wb[idx] = j;\n        h[a] = idx++;\n    }\n\n    public static void main(String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = read(br)[0];\n        while (T-- > 0) {\n            int N = read(br)[0];\n            \n            idx = 0;   \n            h = new int[N+1]; Arrays.fill(h, -1);\n            e = new int[N+1]; ne = new int[N+1];\n            wa = new int[N+1]; wb = new int[N+1];\n\n            stack = new long[N+1];\n            si = 0;\n\n            res = new int[N+1];\n            for (int i = 2; i <= N; i++) {\n                int[] t = read(br);\n                add(t[0], i, t[1], t[2]);\n            }\n            dfs(1, 0, 0);\n            for (int i = 2; i <= N; i++) {\n                out.print(res[i] + \" \");\n            }\n            out.println();\n        }\n        out.flush();\n    }\n\n    public static void dfs(int x, long suma, long sumb) {\n        stack[si++] = sumb;\n        // 二分找suma\n        int left = 0, right = si-1;\n        while (left <= right) {\n            int mid = left + (right-left)/2;\n            if (stack[mid] <= suma) {\n                res[x] = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        for (int i = h[x]; i != -1; i = ne[i]) {\n            dfs(e[i], suma+wa[i], sumb+wb[i]);\n        }\n        // 出栈\n        si--;\n    }\n\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n### 解法二\n\n倍增的做法，学习下\n\n```java\nimport java.util.*;\nimport java.io.*;\n\n// AtCoder/AcWing 提交上面部分即可，CF需要将JavaMain移到上面然后提交\npublic class G_2 {\n    public static void main(String[] args) throws Exception{\n        // 输入重定向，通过jvm参数判断环境\n        if (args.length > 0 && \"Resolmi_DEBUG\".equals(args[0])) {\n            System.setIn(new FileInputStream(\"./input.txt\"));\n        }\n        new Main().main(args);\n    }\n}\n\nclass Main {\n\n    static int idx;\n    static int[] e, ne, h, wa, wb;\n    static int[] res;\n    // fa[i][j]，节点i向上跳2^j的节点\n    static int[][] fa;\n    // fsb[i][j]，节点i向上跳2^j的节点sumb总和\n    static long[][] fsb;\n    static int[] dep;\n    static long[] suma, sumb;\n\n    public static void add(int a, int b, int i, int j) {\n        e[idx] = b; ne[idx] = h[a];\n        wa[idx] = i; wb[idx] = j;\n        h[a] = idx++;\n    }\n\n    // 倍增做法\n    public static void main(String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = read(br)[0];\n        while (T-- > 0) {\n            int N = read(br)[0];\n            idx = 0;   \n            h = new int[N+1]; Arrays.fill(h, -1);\n            e = new int[N+1]; ne = new int[N+1];\n            wa = new int[N+1]; wb = new int[N+1];\n\n            suma = new long[N+1]; sumb = new long[N+1];\n            dep = new int[N+1];\n            // fa[i][j]: i向上跳2^j的节点\n            fa = new int[N+1][31];\n            fsb = new long[N+1][31];\n\n            for (int i = 2; i <= N; i++) {\n                int[] t = read(br);\n                add(t[0], i, t[1], t[2]);\n            }\n            // 构建倍增数组\n            dfs(1);\n            for (int i = 2; i <= N; i++) {\n                int res = dep[i];\n                if (suma[i] < sumb[i]) {\n                    // 向上走大于等于t距离的第一个\n                    long t = sumb[i]-suma[i];\n                    int x = i;\n                    for (int k = 30; k >= 0; k--) {\n                        if (fsb[x][k] <= t) {\n                            t -= fsb[x][k];\n                            x = fa[x][k];\n                            res = dep[x];\n                        }\n                    }\n                    // 找不到sumb刚好相差t的节点，再往上走一步\n                    if (t > 0) res--;\n                }\n                out.print(res+\" \");\n            }\n            out.println();\n        }\n        out.flush();\n    }\n\n    public static void dfs(int root) {\n\n        for (int i = 1; i < 31; i++) {\n            fa[root][i] = fa[fa[root][i-1]][i-1];\n            // root跳2^i = root跳到2^(i-1) + 2^(i-1)到2^i\n            fsb[root][i] = fsb[root][i-1] + fsb[fa[root][i-1]][i-1];\n        }\n\n        for (int i = h[root]; i != -1; i = ne[i]) {\n            int t = e[i];\n            suma[t] = suma[root] + wa[i];\n            sumb[t] = sumb[root] + wb[i];\n            dep[t] = dep[root] + 1;\n            fa[t][0] = root;\n            fsb[t][0] = wb[i];\n            dfs(t);\n        }\n    }\n\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"AtCoder Beginner Contest 261","url":"/2022/07/24/7bc5a648/","content":"\n> 比赛地址： https://atcoder.jp/contests/abc261\n> \n> 比赛只写出了 A-D。前三题比较简单，D 题是一个 DP，也比较明显，注意溢出就行。补一下 E，F（G，Ex 现阶段不考虑），完整代码 (A-F)：[Github](https://github.com/imlgw/competition-algorithm/tree/master/%E6%AF%94%E8%B5%9B/AtCoder/abc261)\n\n## [E - Many Operations](https://atcoder.jp/contests/abc261/tasks/abc261_e)\n\nWe have a variable $X$ and $N$ kinds of operations that change the value of $X$ . Operation $i$ is represented as a pair of integers $(T_i,A_i)$ , and is the following operation:\n\n- if $T_i=1$ , it replaces the value of $X$ with $X\\ {\\rm and}\\ A_i$ ;\n- if $T_i=2$ , it replaces the value of $X$ with $X\\ {\\rm or}\\ A_i$ ;\n- if $T_i=3$ , it replaces the value of $X$ with $X\\ {\\rm xor}\\ A_i$ .\n\nInitialize $X$ with the value of $C$ and execute the following procedures in order:\n\n- Perform Operation $1$ , and then print the resulting value of $X$ .\n- Next, perform Operation $1, 2$ in this order, and then print the value of $X$ .\n- Next, perform Operation $1, 2, 3$ in this order, and then print the value of $X$ .\n- $\\vdots$\n- Next, perform Operation $1, 2, \\ldots, N$ in this order, and then print the value of $X$ .\n\n**Constraints**\n\n- $1 \\leq N \\leq 2\\times 10^5$\n- $1\\leq T_i \\leq 3$\n- $0\\leq A_i \\lt 2^{30}$\n- $0\\leq C \\lt 2^{30}$\n- All values in input are integers.\n\n**Sample Input**\n```c\n3 10\n3 3\n2 5\n1 12\n```\n\n**Sample Output**\n```c\n9\n15\n12\n```\nThe initial value of $X$ is $10$ .\n\nOperation $1$ changes $X$ to $9$ .\nNext, Operation $1$ changes $X$ to $10$ , and then Operation $2$ changes it to $15$ .\nNext, Operation $1$ changes $X$ to $12$ , and then Operation $2$ changes it to $13$ , and then Operation $3$ changes it to $12$ .\n\n### 解法一\n\n题目大致意思是给你一个数，然后输出经过 $i$ 次操作后的值，每次操作都会把前面的操作再执行一遍。一共有三种操作，并，或，异或。\n\n赛后看官方题解看的不是很明白，然后看了别人的讨论，自己琢磨了一下才写出来。\n\n首先这里每次操作对于原数字的任意一位来说都是完全独立的，不会相互影响。所以我们完全可以分开考虑每一位的状态，设置 $f[i][j]$ 为**当前位**初始为 $j(0/1)$ 经历 $i$ 次操作后的结果。预先计算出当前位为 $0/1$ 时，经过 $i$ 次操作后的状态 $(0/1)$ ，然后进行递推，获得 $i$ 次操作后每一位的状态构成答案。\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        int N = in[0], C = in[1];\n        var op = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            op[i] = read(br);\n        }\n        var res = new int[N+1];\n        // f[i][j]，当前位初始为 j(0/1) 经历 i 次操作后的结果\n        var f = new int[N+1][2];\n        f[0][0] = 0;\n        f[0][1] = 1;\n        // 枚举每一位\n        for (int i = 0; i < 30; i++) {\n            int cur = (C>>>i) & 1;\n            // 枚举每种操作\n            for (int j = 1; j <= N; j++) {\n                int t = op[j-1][0],  a = op[j-1][1];\n                int x = (a>>>i) & 1;\n                if (t == 1) {\n                    f[j] = new int[]{ f[j-1][0] & x, f[j-1][1] & x};\n                }\n                \n                if (t == 2) {\n                    f[j] = new int[]{ f[j-1][0] | x, f[j-1][1] | x};\n                }\n\n                if (t == 3) {\n                    f[j] = new int[]{ f[j-1][0] ^ x, f[j-1][1] ^ x};\n                }\n                // 初始为 cur，经历 j 次操作后的值（重放）\n                cur = f[j][cur];\n                res[j] |= (cur<<i);\n            }\n        }\n\n        for (int i = 1; i <= N; i++) {\n            out.println(res[i]);\n        }\n\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n\n// AtCoder/AcWing 提交上面部分即可，CF 需要将 JavaMain 移到上面然后提交\npublic class E {\n    public static void main(String[] args) throws Exception{\n        // 输入重定向，通过 jvm 参数判断环境\n        if (args.length > 0 && \"Resolmi_DEBUG\".equals(args[0])) {\n            System.setIn(new FileInputStream(\"./input.txt\"));\n        }\n        new Main().main(args);\n    }\n}\n```\n\n## [F - Sorting Color Balls](https://atcoder.jp/contests/abc261/tasks/abc261_f)\n\nThere are $N$ balls arranged from left to right.\nThe color of the $i$ -th ball from the left is Color $C_i$ , and an integer $X_i$ is written on it.\nTakahashi wants to rearrange the balls so that the integers written on the balls are non-decreasing from left to right.\nIn other words, his objective is to reach a situation where, for every $1\\leq i\\leq N-1$ , the number written on the $(i+1)$ -th ball from the left is greater than or equal to the number written on the $i$ -th ball from the left.\nFor this, Takahashi can repeat the following operation any number of times (possibly zero):\n\n> Choose an integer $i$ such that $1\\leq i\\leq N-1$ .\nIf the colors of the $i$ -th and $(i+1)$ -th balls from the left are different, pay a cost of $1$ .\n(No cost is incurred if the colors are the same).\nSwap the $i$ -th and $(i+1)$ -th balls from the left.\n\nFind the minimum total cost Takahashi needs to pay to achieve his objective.\n\n**Constraints**\n\n- $2 \\leq N \\leq 3\\times 10^5$\n- $1\\leq C_i\\leq N$\n- $1\\leq X_i\\leq N$\n- All values in input are integers.\n\n**Sample Input**\n```c\n5\n1 5 2 2 1\n3 2 1 2 1\n```\n**Sample Output**\n```c\n6\n```\n\n### 解法一\n\n>通过交换相邻元素的操作使一个数组变得有序的最少操作次数就是逆序对的个数，也就是冒泡排序的过程。\n\n但是这题中有一些额外条件，就是相邻的逆序对气球，如果颜色一样，交换就没有消耗。所以我们可以大胆猜测，结果就是总体逆序对数量减去同颜色逆序对的数量，首先让整体交换次数最少，然后考虑减去无消耗的部分。\n\n这里使用数状数组求解逆序对，代码实现如下：\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int[] tree;\n    \n    static int len;\n    \n    public static int lowbit(int i){\n        return i & -i;\n    }\n\n    public static void add(int i, int v) {\n        while (i < len) {\n            tree[i] += v;\n            i += lowbit(i);\n        }\n    }\n\n    public static long sum(int i) {\n        long res = 0;\n        while (i > 0) {\n            res += tree[i];\n            i -= lowbit(i);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = read(br)[0];\n        var C = read(br);\n        var X = read(br);\n\n        tree = new int[N+1];\n        len = N;\n        \n        List<Integer>[] cls = new ArrayList[N+1];\n        for (int i = 0; i < N; i++) {\n            if (cls[C[i]] == null) {\n                cls[C[i]] = new ArrayList<>();\n            }\n            cls[C[i]].add(X[i]);\n        }\n\n        long res = 0;\n        for (int i = N-1; i >= 0; i--) {\n            add(X[i], 1);\n            res += sum(X[i]-1);\n        }\n        // 重置，统计相同气球逆序对\n        tree = new int[N+1];\n\n        // 注意从1开始，在这里WA了好几发\n        for (int i = 1; i <= N; i++) {\n            if (cls[i] == null) continue;\n            int sz = cls[i].size();\n            for (int j = sz-1; j >= 0; j--) {\n                int c = cls[i].get(j);\n                add(c, 1);\n                res -= sum(c-1);\n            }\n            // 还原，用于下一组\n            for (Integer c : cls[i]) {\n                add(c, -1);\n            }\n        }\n\n        out.println(res);\n        out.flush();\n    }\n\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n还有一种用map记录同色气球数量的做法，但是效率不高，[Submission #33508589](https://atcoder.jp/contests/abc261/submissions/33508589)","tags":["算法"],"categories":["算法"]},{"title":"Raft 算法","url":"/2022/06/05/bb8d01ed/","content":"\n## 复制（Replication）\n\n一致性算法的目的是让多台服务器/状态机能够计算得到相同的状态，同时，如果有部分机器宕机，集群作为一个整体依然能继续工作。\n\n**状态转移**（State Transfer）：Primary 将自己完整状态，比如说内存中的内容，拷贝并发送给 Backup。Backup 会保存收到的最近一次状态，所以 Backup 会有所有的数据。当 Primary 故障了，Backup 就可以从它所保存的最新状态开始运行。所以，状态转移就是发送 Primary 的状态。这种机制下，每过一会，Primary 就需要对自身的内存做拷贝（这里可以只发 diff），并通过网络将其发送到 Backup。\n\n**复制状态机**（Replicated State Machine）：复制状态机将来自客户端的操作日志从 Primary 顺序传输到 Backup，这样多台计算机从相同的状态开始，以相同的顺序，执行了**确定**的相同指令，达到最终一致性。这里也有一些例外，有一些指令并不是确定的，比如随机数生成器，当前时间，UUID 等，这些指令会将指令结果一起同步过去。\n\n## 脑裂（Split Brain）\n\n在一些中间件集群环境中，普遍都会有一个「大脑」去做决策。这个大脑一般通过选举产生，但是当出现网络分区的时候就有可能出现多个大脑，也就是我们说的「脑裂」\n\n### 过半票决（Majority Vote）\n\n过半票决首先得保证集群数量为奇数，这样当出现网络分区的时候，保证最多只有一个分区的数量会过半。\n\n其次就是任何时候执行任何操作，都需要超过半数服务器批准后才能执行（注意这里服务器数量指的是所有服务器数量，故障机器也包括在内）。这种模式下，2*F+1 的节点总数，可接受的最多故障节点数就是 F。\n\n>过半票决还有一个很微妙的特性，当 Leader 易主的时候，新 Leader 一定是拿到了过半的服务器选票，那么和上一任的 Leader 选举产生的过半服务器之间必然会有重叠，也就是说在新 Leader 的过半服务器中一定有包含了旧 Leader 的所有操作的节点\n\n## Raft 基础\nRaft 节点状态转换：\n![Raft 论文](https://static.imlgw.top/blog/20220601202043.png)\n\n**Follower**：从节点，初始都是 Follower。比较被动，只对其他 Server 的请求做响应，不会主动发起请求。如果选举定时器（election timeout）超时并且没有收到 Leader 任何消息，就会转变为 Candidates，发起选举请求。\n\n**Candidate**：候选节点，只存在于选举阶段。选举获得多数票就会转换为 Leader。如果发现已经有了 Leader 或者自己的 Term 过时就会重新转换为 Follower。\n\n**Leader**：主节点，负责响应客户端发起的请求。如果客户端请求到了 Follower，也会将请求转到 Leader 上。Leader 如果发现自己的 Term 过时就会重新转换为 Follower。\n\n![Raft 论文](https://static.imlgw.top/blog/20220601221351.png)\n\nRaft 生命周期中可能会有多个 Leader，使用 Term 来区分多个 Leader，Raft 保证每个 Term **最多**只有一个 Leader，如果选票比较分散，也可能没有 Leader（t3），则直接进入下一轮选举。\n\nTerm 可以看作 Raft 中的逻辑时间，每个节点都存有当前 Term 编号。节点可以通过 Term 来检查过期的消息，对齐各个节点进度。当节点进行通信的时候，如果发现其他节点的 Term 比自己大，就会将当前节点 Term 更新为较大的 Term，如果节点是 Leader 或者 Candidates 则会进入 Follower 状态。如果节点 Term 比自己小，则会直接忽略掉。\n\n![](https://static.imlgw.top/blog/20220605205548.png)\n\n## Raft 规范\n\n1. **Election Safety**：在一个任期内，最多可以选出一个 Leader\n2. **Leader Append-Only**：Leader 不会覆盖或者删除自己的 log，只会追加\n3. **Log Matching**：如果两个节点中的两个条目有相同的 log index 和 term，则它们之前的所有日志也一定相同。\n4. **Leader Completeness**：如果某条日志在某一任期被提交了，那么该日志一定会出现在所有更高任期的 Leader 日志中。\n5. **State Machine Safety**：如果一个服务器在其状态机上应用了一个给定索引的日志条目，那么没有其他服务器会在同一索引上应用一个不同的日志条目\n\n## Raft 选主\n\nRaft 使用心跳机制来触发领导选举。一开始所有节点都是 Follower，只要能收到 Leader 的心跳信息或者 Candidate 的投票信息，就会一直处于 Follower 状态。\n\n如果选举定时器超时了 Follower 还是没有收到任何信息，就认为 Leader 已经挂了，随即进入选举阶段，增加自己的 Term，进入 Candidate 状态，向其他节点发送 RequestVote。\n\n```golang\nfunc (rf *Raft) leaderElection() {\n    // 增加 Term\n    rf.currentTerm++\n    // 变为 Candidate 状态\n    rf.state = Candidate\n    rf.votedFor = rf.me\n    rf.persist()\n    rf.resetElectionTimer()\n    term := rf.currentTerm\n    // 获得选票总数，首先投给自己\n    voteCounter := 1\n    // 当前节点最后一条 log\n    lastLog := rf.log.lastLog()\n    args := RequestVoteArgs{\n        Term:         term,\n        CandidateId:  rf.me,\n        LastLogIndex: lastLog.Index,\n        LastLogTerm:  lastLog.Term,\n    }\n\n    var becomeLeader sync.Once\n    for serverId, _ := range rf.peers {\n        if serverId != rf.me {\n            // 发送 RequestVote\n            go rf.candidateRequestVote(serverId, &args, &voteCounter, &becomeLeader)\n        }\n    }\n}\n```\n\n发起投票后会发生下列三种情况：\n\n1. 获得了多数票，成为新的 Leader\n2. 其他节点已经成为了 Leader，收到了新 Leader 的心跳信息，且 Term 大于自己\n3. 选举失败，票数分散，没有 Leader 产生\n\n```golang\nfunc (rf *Raft) candidateRequestVote(serverId int, args *RequestVoteArgs,    voteCounter *int, becomeLeader *sync.Once) {\n    reply := RequestVoteReply{}\n    // 并发的发起 rpc 投票请求\n    ok := rf.sendRequestVote(serverId, args, &reply)\n    if !ok {\n        return\n    }\n    // 同步的处理投票结果\n    rf.mu.Lock()\n    defer rf.mu.Unlock()\n    // 存在更新的 Term，选举无效，更新 Term，转换为 Follower\n    if reply.Term > args.Term {\n        rf.setNewTerm(reply.Term)\n        rf.setState(Follower)\n        return\n    }\n\n    if !reply.VoteGranted {\n        return\n    }\n\n    // 收到 Follower 投票\n    *voteCounter++\n    if *voteCounter > len(rf.peers)/2 &&\n        rf.currentTerm == args.Term &&\n        rf.state == Candidate {\n\n        // 获得半数以上选票，且节点状态没变，转换为 Leader\n        becomeLeader.Do(func() {\n            rf.state = Leader\n            lastLogIndex := rf.log.lastLog().Index\n            for i, _ := range rf.peers {\n                rf.nextIndex[i] = lastLogIndex + 1\n                rf.matchIndex[i] = 0\n            }\n            rf.appendEntries(true)\n        })\n    }\n}\n```\n\n当节点收到 RequestVote RPC 后会根据 Term 和 Log 进行判断是否要投票。\n\n这里就涉及到一个选主的限制了，Raft 中并非所有节点都能成为 Leader。\n\n这里我们考虑一个场景：A、B、C 三个节点，如果 A 为主节点期间 C 挂了，此时消息被多数节点（A，B）接收，所以 A 会提交这些日志。此时若 A 挂了，而 C 恢复且被选为主节点，则 A 已经提交的日志会被 C 的日志覆盖，从而导致状态机的状态不一致。\n\n所以在 Raft 中限制了，只有包含了**所有已经提交日志**的节点，才能成为 Leader。\n\n前面提到了日志要提交，首先需要被多数节点所接受，同时要成为 Leader 也需要获得多数节点的投票，所以两者之间必然会有重叠的节点，也就是说投票的多数节点中**至少有一个节点**是包含了所有已经提交的日志的。接着我们从这半数节点中选出一个“最新”的节点出来作为 Leader，就一定是包含了所有已经提交的日志的节点。\n\n这里的”最新“比较的是两个节点最后一条 log 的 Term，如果 Term 一样，就看 Term 内最后一条 log，谁更大谁就更“新”\n\nTODO: 画例子\n\n```golang\nfunc (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) {\n    rf.mu.Lock()\n    defer rf.mu.Unlock()\n\n    // 候选节点任期大于当前节点，变为 Follower\n    if args.Term > rf.currentTerm {\n        rf.setNewTerm(args.Term)\n        rf.setState(Follower)\n    }\n\n    // 候选节点任期比当前节点小，忽略\n    if args.Term < rf.currentTerm {\n        reply.Term = rf.currentTerm\n        reply.VoteGranted = false\n        return\n    }\n\n    myLastLog := rf.log.lastLog()\n    // 候选节点最后一条 log 任期比当前节点大\n    // 或者任期相同，但是候选节点最后一条 logIndex 比当前节点大，说明候选节点比本节点日志新\n    upToDate := args.LastLogTerm > myLastLog.Term ||\n        (args.LastLogTerm == myLastLog.Term && args.LastLogIndex >= myLastLog.Index)\n    // 每个节点每一轮选举只能投给一个节点\n    if (rf.votedFor == -1 || rf.votedFor == args.CandidateId) && upToDate {\n        reply.VoteGranted = true\n        rf.votedFor = args.CandidateId\n        rf.persist()\n        rf.resetElectionTimer()\n    } else {\n        reply.VoteGranted = false\n    }\n    reply.Term = rf.currentTerm\n}\n```\n\n## Raft 日志复制\n\n当节点被选为 Leader 后就开始响应客户端请求。每个客户端请求都包含了一个**复制状态机**需要执行的命令。Leader 将命令作为一个新的条目附加到它的 Logs 队列中，然后发送 Append Entries RPCs 给其他节点。当 log 被大多数节点复制后，Leader 会将 log 提交到状态机，同时也会将之前 Term 的 Leader 创建的 log 条目提交，并将执行结果返回给客户端。\n\n> 如果 Follower 崩溃或运行缓慢，或者网络数据包丢失，Leader 会一直重试 Append Entries RPCs（甚至在它响应了客户端之后），直到所有 Follower 最终存储所有的日志条目。\n\n但是在复杂的网络环境下，节点之间的日志可能会不一致，下面的情况都有可能发生：\n\n![Raft](https://static.imlgw.top/blog/20220603225731.png)\n\n要处理不一致首先要找到不一致的位置，Leader 为每个节点维护了一个 `nextIndex[peer]`， 表示 Leader 将从哪里开始发送 log 给 peer。当 Leader 上台的时候就会将所有节点的 nextIndex 设置为自己的 `lastLog.Index + 1`。\n\n当 Leader 发送 Append Entries RPCs 给 Follower 后，Follower 会进行一致性检查，也就是判断 `nextIndex[peer]` 前一条 log 的 Term 和 Index 是否和当前节点 peer 一致，如果不一致就会拒绝该消息，一致就会添加新 log 到节点的日志队列中，`nextIndex[peer]+1`。\n\n如果 Leader 的消息被 peer 拒绝，Leader 会使 `nextIndex[peer]` 递减，然后再次发送 Append Entries RPCs，直到找到一致的位置，然后用 Leader 的 `log[nextIndex, lastLog.Index]`，覆盖 Follower 的 `log[nextIndex...]`\n\n通过上面的机制 Raft 就能保证：\n- 如果两个日志条目有相同的 log index 和 term，则它们的内容一定相同。\n- 如果两个节点中的两个条目有相同的 log index 和 term，则它们之前的所有日志一定相同。\n\nLeader 发送 Append Entries RPCs\n```golang\nfunc (rf *Raft) appendEntries() {\n    lastLog := rf.log.lastLog()\n    for peer, _ := range rf.peers {\n        if peer == rf.me {\n            rf.resetElectionTimer()\n            continue\n        }\n        // 从 nextIndex 开始发送\n        nextIndex := rf.nextIndex[peer]\n        if nextIndex <= 0 {\n            nextIndex = 1\n        }\n        // 上图（Raft 论文 Figure7）中的情况 cdf，包含额外的未提交的条目\n        // 直接回退到 lastLog.Index\n        if lastLog.Index+1 < nextIndex {\n            nextIndex = lastLog.Index\n        }\n        // 前一条 log 的 index 和 Term，用于 Follower 校验日志是否一致\n        prevLog := rf.log.at(nextIndex - 1)\n        args := AppendEntriesArgs{\n            Term:         rf.currentTerm,\n            LeaderId:     rf.me,\n            PrevLogIndex: prevLog.Index,\n            PrevLogTerm:  prevLog.Term,\n            Entries:      make([]Entry, lastLog.Index-nextIndex+1),\n            // 目前 Leader 提交到状态机的 logIndex\n            LeaderCommit: rf.commitIndex,\n        }\n        // 发送 [nextIndex, lastLog.Index]\n        copy(args.Entries, rf.log.slice(nextIndex))\n        go rf.leaderSendEntries(peer, &args)\n    }\n}\n```\n\n### 快速恢复（Fast Backup）\n\nraft 论文中日志回退是一条一条回退的，如果 Follower 掉线时间过长，一条条回退会特别慢，原文中有提到优化方法，但是没有细说\n\n> If desired, the protocol can be optimized to reduce the number of rejected AppendEntries RPCs. For example, when rejecting an AppendEntries request, the follower can include the term of the conflicting entry and the first index it stores for that term. With this information, the leader can decrement nextIndex to bypass all of the conflicting entries in that term; one AppendEntries RPC will be required for each term with conflicting entries, rather than one RPC per entry. In practice, we doubt this optimization is necessary, since failures happen infrequently and it is unlikely that there will be many inconsistent entries.\n\n> 如果需要，该协议可以被优化以减少被拒绝的 AppendEntries RPC 的数量。例如，当拒绝一个 AppendEntries 请求时，跟随者可以包括冲突条目的任期和它为该任期存储的第一个索引。有了这些信息，领导者可以递减 nextIndex 以绕过该任期中的所有冲突条目；每个有冲突条目的任期将需要一个 AppendEntries RPC，而不是每个条目一个 RPC。在实践中，我们怀疑这种优化是否有必要，因为故障不常发生，而且不太可能有很多不一致的条目。\n\nmit6.824 中 Morris 提到了一种优化方式：\n\n在 Follower 回复 Leader 的 AppendEntriesReply 中添加几个字段\n- **XTerm**: 冲突的 Term，Follower 拒绝 Leader 后会将 XTerm 设置为自己的 Term，如果 Follower 日志较少，对应位置没有 log，设置 XTerm 为 -1\n- **XIndex**: XTerm 的第一条 log 的 index\n- **XLen**: Follower 日志较少，XTerm = -1 时，log 日志长度+1，Leader 下次就从 Xlen 开始发\n\nFollower 收到消息后对应处理\n\n```golang\nfunc (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) {\n    rf.mu.Lock()\n    defer rf.mu.Unlock()\n    reply.Success = false\n    reply.Term = rf.currentTerm\n\n    // 忽略，Leader 的 Term 比自己小\n    if args.Term < rf.currentTerm {\n        return\n    }\n\n    // 比自己任期大，更新任期\n    if args.Term > rf.currentTerm {\n        rf.setNewTerm(args.Term)\n        rf.setState(Follower)\n        reply.Term = args.Term\n    }\n\n    // 重置 Election 定时器\n    rf.resetElectionTimer()\n\n    // Candidate 收到了 AppendEntries 请求，转换为 Follower\n    if rf.state == Candidate {\n        rf.setState(Follower)\n    }\n\n    // Follower 日志较少，Pre 处没有 log\n    if rf.log.lastLog().Index < args.PrevLogIndex {\n        reply.XTerm = -1\n        reply.XIndex = -1\n        reply.XLen = rf.log.len()\n        return\n    }\n\n    // Pre 处有 log 但是 Term 不一样\n    if rf.log.at(args.PrevLogIndex).Term != args.PrevLogTerm {\n        // 获取 Follower 冲突位置的 Term\n        xTerm := rf.log.at(args.PrevLogIndex).Term\n        for xIndex := args.PrevLogIndex; xIndex > 0; xIndex-- {\n            // XTerm 第一条 log 的 index\n            if rf.log.at(xIndex-1).Term != xTerm {\n                reply.XIndex = xIndex\n                break\n            }\n        }\n        reply.XTerm = xTerm\n        reply.XLen = rf.log.len()\n        return\n    }\n\n    // 匹配上了\n    for idx, entry := range args.Entries {\n        // 正常情况下 entry.Index 肯定是大于 lastLog.Index 的\n        // 这里小于等于，且任期不一致，说明 Follower 有额外的未提交的日志，需要覆盖掉\n        if entry.Index <= rf.log.lastLog().Index && rf.log.at(entry.Index).Term != entry.Term {\n            // 截断 Index 后的日志\n            rf.log.truncate(entry.Index)\n            rf.persist()\n        }\n        // Follower 复制 log\n        if entry.Index > rf.log.lastLog().Index {\n            rf.log.append(args.Entries[idx:]...)\n            rf.persist()\n            break\n        }\n    }\n\n    // 设置当前节点提交进度\n    if args.LeaderCommit > rf.commitIndex {\n        rf.commitIndex = min(args.LeaderCommit, rf.log.lastLog().Index)\n        // 应用到状态机\n        rf.apply()\n    }\n    reply.Success = true\n}\n```\n\nLeader 收到回复后就可以针对不同情况，快速回滚\n```golang\nfunc (rf *Raft) leaderSendEntries(serverId int, args *AppendEntriesArgs) {\n    var reply AppendEntriesReply\n    ok := rf.sendAppendEntries(serverId, args, &reply)\n    if !ok {\n        return\n    }\n    // 加锁，同步处理结果\n    rf.mu.Lock()\n    defer rf.mu.Unlock()\n    // 返回的 Term 比 Leader 大，当前 Leader 节点过时了\n    // 更新 Term 转换为 Follower\n    if reply.Term > rf.currentTerm {\n        rf.setNewTerm(reply.Term)\n        rf.setState(Follower)\n        return\n    }\n    // 发送到接收需要一段时间，确认状态，确认还是在自己的任期\n    if args.Term == rf.currentTerm {\n        // 没有冲突，校验成功\n        if reply.Success {\n            // 已知的 Follower 复制到的位置\n            match := args.PrevLogIndex + len(args.Entries)\n            next := match + 1\n            rf.nextIndex[serverId] = max(rf.nextIndex[serverId], next)\n            rf.matchIndex[serverId] = max(rf.matchIndex[serverId], match)\n        } else {\n            if reply.XTerm == -1 {\n                // 有冲突，且 Follower 日志少，下一次从 XLen 开始\n                // i: 1    2    3   4   5\n                //        XLen\n                // F: 4  \n                // L: 4    6    6   6\n                //             Pre     Next\n                rf.nextIndex[serverId] = reply.XLen\n            } else {\n                // 找到 Leader 中 XTerm 中后一条日志的 Index，从这条再开始\n                lastLogInXTerm := rf.findNextLogInTerm(reply.XTerm)\n                if lastLogInXTerm > 0 {\n                    // i: 1    2    3    4    5\n                    // F: 4    4    4\n                    // L: 4    6    6    6\n                    //       Last  Pre       Next\n                    rf.nextIndex[serverId] = lastLogInXTerm\n                } else {\n                    // Leader 没有 XTerm 直接从 XIndex 开始\n                    // i: 1    2    3    4    5\n                    //      XIndex\n                    // F: 4    5    5\n                    // L: 4    6    6   6\n                    //             Pre      Next\n                    rf.nextIndex[serverId] = reply.XIndex\n                }\n            }\n        }\n        // 提交 log\n        rf.leaderCommit()\n    }\n}\n```\n\nLeader 最终提交 log\n\n```golang\nfunc (rf *Raft) leaderCommit() {\n    // 确认状态\n    if rf.state != Leader {\n        return\n    }\n\n    // 从上次 commitIndex 开始提交\n    for n := rf.commitIndex + 1; n <= rf.log.lastLog().Index; n++ {\n        // 只关心自己任期内的 log 是否复制到多数节点\n        // 当前任期内日志的提交后，上一任的间接的也就提交了\n        if rf.log.at(n).Term != rf.currentTerm {\n            continue\n        }\n        counter := 1\n        for serverId := 0; serverId < len(rf.peers); serverId++ {\n            // follower 已经复制的 Index >= n\n            if serverId != rf.me && rf.matchIndex[serverId] >= n {\n                counter++\n            }\n            // 超过半数已经复制了 log[n]\n            if counter > len(rf.peers)/2 {\n                // 提交日志，并且应用到状态机\n                rf.commitIndex = n\n                rf.apply()\n                break\n            }\n        }\n    }\n}\n```\n\n## Raft 响应\nRaft Start，只能由 Leader 响应，接收一个 command，添加到 Leader 日志队列中。然后等待下一次 AppendEntries 进而同步给其他节点。这里也可以 Start 后直接发送 AppendEntries，但是如果 Start 太频繁可能会造成 RPC 频繁，需要根据不同场景进行调整，论文中也并没有明确说明。\n\n```golang\nfunc (rf *Raft) Start(command interface{}) (int, int, bool) {\n    rf.mu.Lock()\n    defer rf.mu.Unlock()\n    if rf.state != Leader {\n        return -1, rf.currentTerm, false\n    }\n    index := rf.log.lastLog().Index + 1\n    term := rf.currentTerm\n\n    log := Entry{\n        Command: command,\n        Index:   index,\n        Term:    term,\n    }\n    rf.log.append(log)\n    rf.persist()\n\n    return index, term, true\n}\n```\n\n## Raft 持久化\n\n持久化是为了在某些情况下，当服务器故障重启时，能继续之前的状态，避免丢失数据。\n\n在 Raft 论文中，标识了 currentTerm、voteFor、logs 是需要持久化的数据。\n\nlogs 需要被持久化很好理解，这是唯一记录了应用程序状态的地方，而 voteFor 和 currentTerm 需要被持久化的原因都是为了避免一个 Term 出现两个 Leader。假设一个节点刚给一个候选人投了票，结果自己 down 了，然后重启后发现自己 voteFor 是空的，那么就还可能给其他候选人投票，就违背了一个节点一个任期只能投一张票的原则。currentTerm 也类似，如果节点重启后不知道当前的任期，就可能从一个历史的任期开始工作，就可能会导致一个任期多个 Leader。\n\n## Raft 日志快照\n## Raft 成员变更","tags":["Raft","共识算法"],"categories":["共识算法"]},{"title":"力扣 295th 周赛","url":"/2022/06/01/1cbd408/","content":"\n## [2289. 使数组按非递减顺序排列](https://leetcode.cn/problems/steps-to-make-array-non-decreasing/)\n\n给你一个下标从 $0$ 开始的整数数组 $nums$ 。在一步操作中，移除所有满足  $nums[i - 1] > nums[i]$ 的 $nums[i]$ ，其中 $0 < i < nums.length$ 。\n\n重复执行步骤，直到 $nums$ 变为 非递减 数组，返回所需执行的操作数。\n\n**示例 1**：\n```c\n输入：nums = [5,3,4,4,7,3,6,11,8,5,11]\n输出：3\n解释：执行下述几个步骤：\n- 步骤 1 ：[5,3,4,4,7,3,6,11,8,5,11] 变为 [5,4,4,7,6,11,11]\n- 步骤 2 ：[5,4,4,7,6,11,11] 变为 [5,4,7,11,11]\n- 步骤 3 ：[5,4,7,11,11] 变为 [5,7,11,11]\n[5,7,11,11] 是一个非递减数组，因此，返回 3 。\n```\n\n**示例 2**：\n\n```c\n输入：nums = [4,5,7,7,13]\n输出：0\n解释：nums 已经是一个非递减数组，因此，返回 0 。\n```\n\n**提示**：\n\n- $1 <= nums.length <= 10^5$\n- $1 <= nums[i] <= 10^9$\n\n### 解法一\n首先知道了这题是单调栈，然后直接往这个方向上想，糊了一个很奇怪的解法，但是 AC 了，看了题解区没有和我一样的。\n\n我的理解是，逆序构建一个单调递减栈，栈中的元素都是待消除的，栈中相邻的元素必然**不是**同一轮被消除，所以统计最大的消除深度就是最大的轮次，时间复杂度 $O(N)$ 。\n\n```golang\n// [5,3,4,4,7,3,6,11,8,5,11]\n// [7,14,4,14,13,2,6,13] --> [7,14,14,6,13]\nfunc totalSteps(nums []int) int {\n    var stack []int\n    var res = 0\n    var maxDepth = 0\n    for i := len(nums) - 1; i >= 0; i-- {\n        for len(stack) > 0 && nums[stack[len(stack)-1]] < nums[i] {\n            stack = stack[:len(stack)-1]\n            res = Max(res, maxDepth-len(stack))\n        }\n        stack = append(stack, i)\n        maxDepth = Max(maxDepth, len(stack))\n    }\n    return res\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n### 解法二\n\n如果是比赛的时候肯定是没时间去想单调栈的解法，链表模拟是比较自然的想法。\n\n模拟的能力比较差，思路不清晰，还需要多练一下。\n\n```golang\nfunc totalSteps(nums []int) int {\n    nums = append(nums, 0x3f3f3f3f)\n    next := make([]int, len(nums))\n    var lis []int\n    for i := 0; i < len(nums)-1; i++ {\n        next[i] = i + 1\n    }\n\n    // 存放可以吞噬其它数的数，注意逆序存\n    // 3->2->1 逆序才能一次删除 2 和 1\n    for i := len(nums) - 2; i >= 0; i-- {\n        if nums[i] > nums[i+1] {\n            lis = append(lis, i)\n        }\n    }\n\n    for op := 0; ; op++ {\n        var temp []int\n        for _, i := range lis {\n            if nums[i] > nums[next[i]] {\n                // 吞噬后面的数\n                next[i] = next[next[i]]\n                // 还可能继续吞\n                temp = append(temp, i)\n            }\n        }\n        // 没有能吞的了\n        if len(temp) == 0 {\n            return op\n        }\n        lis = temp\n    }\n    return -1\n}\n```\n\n## [2290. 到达角落需要移除障碍物的最小数目](https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/)\n\n给你一个下标从 $0$ 开始的二维整数数组 $grid$ ，数组大小为 $m \\ast n$ 。每个单元格都是两个值之一：\n\n$0$ 表示一个 空 单元格，\n$1$ 表示一个可以移除的 障碍物 。\n\n你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。\n\n现在你需要从左上角  $(0, 0)$ 移动到右下角 $(m - 1, n - 1)$ ，返回需要移除的障碍物的**最小**数目。\n\n**示例 1**：\n\n![](https://static.imlgw.top/blog/20220603125628.png)\n\n```c\n输入：grid = [[0,1,1],[1,1,0],[1,1,0]]\n输出：2\n解释：可以移除位于 (0, 1) 和 (0, 2) 的障碍物来创建从 (0, 0) 到 (2, 2) 的路径。\n可以证明我们至少需要移除两个障碍物，所以返回 2 。\n注意，可能存在其他方式来移除 2 个障碍物，创建出可行的路径。\n```\n\n**示例 2**：\n\n![](https://static.imlgw.top/blog/20220603125717.png)\n\n```c\n输入：grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\n输出：0\n解释：不移除任何障碍物就能从 (0, 0) 到 (2, 4) ，所以返回 0 。\n```\n \n**提示**：\n\n- $m = grid.length$\n- $n = grid[i].length$\n- $1 <= m, n <= 10^5$\n- $2 <= m \\ast n <= 10^5$\n- $grid[i][j]$ 为 $0$ 或 $1$\n- $grid[0][0] = grid[m - 1][n - 1] = 0$\n\n### 解法一\n0-1BFS，很直白，比 t3 简单，时间复杂度 $O(M \\ast N)$\n\n```golang\nfunc minimumObstacles(grid [][]int) int {\n\n    INF := 0x3f3f3f3f\n    dir := []int{1, 0, -1, 0, 1}\n    M, N := len(grid), len(grid[0])\n    que := list.New()\n    que.PushBack([]int{0, 0})\n\n    vis := make([][]bool, M)\n    dis := make([][]int, M)\n    for i := 0; i < M; i++ {\n        vis[i] = make([]bool, N)\n        dis[i] = make([]int, N)\n        for j := 0; j < N; j++ {\n            dis[i][j] = INF\n        }\n    }\n\n    dis[0][0] = 0\n    for que.Len() > 0 {\n        t := que.Front().Value.([]int)\n        que.Remove(que.Front())\n        x, y := t[0], t[1]\n        if x == M-1 && y == N-1 {\n            break\n        }\n        if vis[x][y] {\n            continue\n        }\n        vis[x][y] = true\n        for i := 0; i < len(dir)-1; i++ {\n            nx, ny := x+dir[i], y+dir[i+1]\n            if nx < 0 || ny < 0 || nx >= M || ny >= N {\n                continue\n            }\n\n            if dis[nx][ny] > dis[x][y]+grid[nx][ny] {\n                dis[nx][ny] = dis[x][y] + grid[nx][ny]\n                if grid[nx][ny] == 1 {\n                    que.PushBack([]int{nx, ny})\n                } else {\n                    que.PushFront([]int{nx, ny})\n                }\n            }\n        }\n    }\n    return dis[M-1][N-1]\n}\n```","tags":["LeetCode","单调栈","01BFS"],"categories":["算法"]},{"title":"图论：单源最短路的综合应用","url":"/2022/05/20/d2494640/","content":"\n## [1135. 新年好](https://www.acwing.com/problem/content/1137/)\n\n重庆城里有 $n$ 个车站， $m$ 条 双向 公路连接其中的某些车站。\n\n每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。\n\n在一条路径上花费的时间等于路径上所有公路需要的时间之和。\n\n佳佳的家在车站 $1$ ，他有五个亲戚，分别住在车站 $a,b,c,d,e$ 。\n\n过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。\n\n怎样走，才需要最少的时间？\n\n**输入格式**\n\n第一行：包含两个整数 $n,m$ 分别表示车站数目和公路数目。\n\n第二行：包含五个整数 $a,b,c,d,e$ 分别表示五个亲戚所在车站编号。\n\n以下 $m$ 行，每行三个整数 $x,y,t$ 表示公路连接的两个车站编号和时间。\n\n**输出格式**\n\n输出仅一行，包含一个整数 $T$ ，表示最少的总时间。\n\n**数据范围**\n- $1≤n≤50000$\n- $1≤m≤10^5$\n- $1<a,b,c,d,e≤n$\n- $1≤x,y≤n$\n- $1≤t≤100$\n\n**输入样例：**\n```c\n6 6\n2 3 4 5 6\n1 2 8\n2 3 3\n3 4 4\n4 5 5\n5 6 2\n1 6 7\n```\n\n**输出样例：**\n```c\n21\n```\n\n### 解法一\nSPFA 会被卡，直接写的堆优化 Dijkstra，写的比较丑。\n\n首先预处理出关键点之间的最短路，然后直接 dfs 全排列求最小值就行了\n\n```java\nimport java.io.*;\nimport java.util.*;\n\nclass Main {\n\n    static int idx;\n    static int[] e, ne, h, w;\n    static int N, M;\n    static int[] tar;\n    static int INF = 0x3f3f3f3f;\n    static boolean[] vis;\n    static HashMap<String, Integer> dp = new HashMap<>();\n\n    //a->b \n    public static void add(int a, int b, int c){ \n        e[idx] = b; ne[idx] = h[a];\n        w[idx] = c; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int[] in = read(br);\n        N = in[0]; M = in[1];\n        h = new int[N+1]; e = new int[2*M+1]; ne = new int[2*M+1]; w = new int[2*M+1];\n        Arrays.fill(h, -1);\n        tar = read(br);\n        for (int i = 0; i < M; i++) {\n            int[] _in = read(br);\n            add(_in[0], _in[1], _in[2]);\n            add(_in[1], _in[0], _in[2]);\n        }\n\n        // 初始化以各个点为源点的最短路\n        dijkstra(1);\n        for (int i = 0; i < tar.length; i++) {\n            dijkstra(tar[i]);\n        }\n\n        vis = new boolean[tar.length];\n        int res = INF;\n        for (int i = 0; i < tar.length; i++) {\n            vis[i] = true;\n            res = Math.min(res, dp.get(1 + \",\" + tar[i]) + dfs(i));\n            vis[i] = false;\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static int dfs(int c) {\n        boolean flag = false;\n        int res = INF;\n        for (int i = 0; i < tar.length; i++) {\n            if (vis[i]) continue;\n            vis[i] = true;\n            res = Math.min(res, dp.get(tar[c] + \",\" + tar[i]) + dfs(i));\n            vis[i] = false;\n            flag = true;\n        }\n        if (!flag) {\n            return 0;\n        }\n        return res;\n    }\n\n    public static void dijkstra(int s) {\n        int[] dis = new int[N+1];\n        Arrays.fill(dis, INF);\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> dis[a] - dis[b]);\n        dis[s] = 0; pq.add(s);\n        boolean[] vis = new boolean[N+1];\n        while (!pq.isEmpty()) {\n            int i = pq.poll();\n            if (vis[i]) continue;\n            vis[i] = true;\n            for (int j = h[i]; j != -1; j = ne[j]) {\n                if (dis[i] + w[j] < dis[e[j]]) {\n                    dis[e[j]] = dis[i] + w[j];\n                    pq.add(e[j]);\n                }\n            }\n        }\n        for (int i = 0; i < tar.length; i++) {\n            dp.put(s + \",\" + tar[i], dis[tar[i]]);\n        }\n    }\n    \n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n\npublic class AcWing1135_新年好 {\n    public static void main(String[] args) throws Exception{\n        new Main().main();\n    }\n}\n```\n\n## [341. 最优贸易](https://www.acwing.com/problem/content/description/343/)\n\n$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。\n\n任意两个城市之间最多只有一条道路直接相连。\n\n这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。\n\n$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。\n\n商人阿龙来到 C 国旅游。当他得知“同一种商品在不同城市的价格可能会不同”这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚一点旅费。\n\n设 C 国 n 个城市的标号从 $1∼n$ ，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。\n\n在旅游的过程中，任何城市可以被重复经过多次，但不要求经过所有 n 个城市。\n\n阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。\n\n因为阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行**最多**一次，当然，在赚不到差价的情况下他就无需进行贸易。\n\n现在给出 $n$ 个城市的水晶球价格， $m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。\n\n请你告诉阿龙，他最多能赚取多少旅费。\n\n注意：本题数据有加强。\n\n**输入格式**\n\n第一行包含 $2$ 个正整数 $n$ 和 $m$ ，中间用一个空格隔开，分别表示城市的数目和道路的数目。\n\n第二行 $n$ 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 $n$ 个城市的商品价格。\n\n接下来 $m$ 行，每行有 3 个正整数， $x，y，z$ ，每两个整数之间用一个空格隔开。\n\n如果 $z=1$ ，表示这条道路是城市 $x$ 到城市 $y$ 之间的单向道路；如果 $z=2$ ，表示这条道路为城市 $x$ 和城市 $y$ 之间的双向道路。\n\n**输出格式**\n\n一个整数，表示答案。\n\n**数据范围**\n\n- $1≤n≤100000$\n- $1≤m≤500000$\n- $1≤各城市水晶球价格≤100$\n\n**输入样例：**\n```c\n5 5\n4 3 5 6 1\n1 2 1\n1 4 1\n2 3 2\n3 5 1\n4 5 2\n```\n\n**输出样例：**\n```c\n5\n```\n\n### 解法一\n\n这题目意思简化就是在一个非 DAG 的图上，求从一个点到另一个点的最大的点权值差。\n\n> 和 [abc188 的 E 题 Peddler](https://imlgw.top/2021/01/21/9edc8d3b/#E-Peddler) 还挺像的，可以对比来看。\n\n这个问题和最短路问题关联不大，主要是借助了 SPFA 的优化，实际上还是 Bellman-Ford 的 dp 思想。\n\n理解了 Bellman-Ford，再来理解这题就很容易了，其实就是把 bf 的状态定义 $dp[i][j]$ 改成了从起点经过 $i$ 条边，到达 $j$ 点的**最小点权值**。显然这里也是符合 bf 的要求的，任意两点之间的**最小点权值**最多也只需要经过 $N-1$ 条边就能知道，所以也可以直接按照 bf 的思路去做，进行 $N-1$ 次迭代，遍历所有边，求最小点权值。\n\n既然适用与 Bellman-Ford 那么我们就可以直接使用 SPFA 来做了。设置 $pMin[i]$ 为从 $1～i$ 过程中最低的价格， $pMax[i]$ 为从 $i～n$ 过程中最高的价格，最大收益为： $\\max_1^n(pMax[i]-pMin[i])$ （注意求 $pMax$ 需要建反向边，方便计算）\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int INF = 0x3f3f3f3f;\n    static int [] price;\n    static int N, M;\n    static int idx;\n    static int[] e, ne, h1, h2;\n    public static void add(int[] h, int a, int b) {\n        e[idx] = b; ne[idx] = h[a];\n        h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        N = in[0]; M = in[1];\n        h1 = new int[N+1]; h2 = new int[N+1];\n        Arrays.fill(h1, -1); Arrays.fill(h2, -1);\n        e = new int[(M+1)*4]; ne = new int[(M+1)*4];\n        int[] pMax = new int[N+1];\n        int[] pMin = new int[N+1];\n        //i-1\n        price = read(br);\n\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            int a = t[0], b = t[1];\n            add(h1, a, b); add(h2, b, a);\n            if (t[2] == 2) {\n                add(h1, b, a); add(h2, a, b);\n            }\n        }\n\n        spfa(h1, pMin, 1);\n        spfa(h2, pMax, N);\n\n        int res = 0;\n        for (int i = 1; i <= N; i++) {\n            res = Math.max(res, pMax[i] - pMin[i]);\n        }\n        System.out.println(res);        \n    }\n\n    public static void spfa(int[] h, int[] dp, int s) {\n        boolean[] vis = new boolean[N+1];\n        boolean flag = s == 1;\n        Arrays.fill(dp, flag ? INF : -INF);\n        Queue<Integer> que = new LinkedList<>();\n        que.add(s);\n        dp[s] = price[s-1];\n        vis[s] = true;\n        while (!que.isEmpty()) {\n            int i = que.poll();\n            vis[i] = false;\n            for (int j = h[i]; j != -1; j = ne[j]) {\n                int k = e[j];\n                if (flag) {\n                    if (dp[k] > Math.min(dp[i], price[k-1])) {\n                        dp[k] = Math.min(dp[i], price[k-1]);\n                        if (!vis[k]) {\n                            que.add(k);\n                            vis[k] = true;\n                        }\n                    }\n                } else {\n                    if (dp[k] < Math.max(dp[i], price[k-1])) {\n                        dp[k] = Math.max(dp[i], price[k-1]);\n                        if (!vis[k]) {\n                            que.add(k);\n                            vis[k] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public static int[] read(BufferedReader reader) throws Exception {\n        return Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n\n}\n\npublic class AcWing341_最优贸易 {\n    public static void main(String[] args) throws Exception{\n        System.setIn(new FileInputStream(\"./input.txt\"));\n        new Main().main();   \n    }\n}\n```\n\n这题其实用 SPFA 还是不太好（SPFA 已死），看见评论区还有好几种解法，分层图，缩点什么的，有时间再来看看。\n\n## [1137. 选择最佳线路](https://www.acwing.com/problem/content/1139/)\n\n有一天，琪琪想乘坐公交车去拜访她的一位朋友。 由于琪琪非常容易晕车，所以她想尽快到达朋友家。 现在给定你一张城市交通路线图，上面包含城市的公交站台以及公交线路的具体分布。\n\n已知城市中共包含 $n$ 个车站（编号 $1 \\sim n$ ）以及 $m$ 条公交线路。\n\n每条公交线路都是 单向的，从一个车站出发直接到达另一个车站，两个车站之间可能存在多条公交线路。\n\n琪琪的朋友住在 $s$ 号车站附近。\n\n琪琪可以在任何车站选择换乘其它公共汽车。\n\n请找出琪琪到达她的朋友家（附近的公交车站）需要花费的最少时间。\n\n**输入格式**\n\n输入包含多组测试数据。\n\n每组测试数据第一行包含三个整数 $n,m,s$ ，分别表示车站数量，公交线路数量以及朋友家附近车站的编号。\n\n接下来 $m$ 行，每行包含三个整数 $p,q,t$ ，表示存在一条线路从车站 $p$ 到达车站 $q$ ，用时为 $t$ 。\n\n接下来一行，包含一个整数 $w$ ，表示琪琪家附近共有 $w$ 个车站，她可以在这 $w$ 个车站中选择一个车站作为始发站。\n\n再一行，包含 $w$ 个整数，表示琪琪家附近的 $w$ 个车站的编号。\n\n**输出格式**\n\n每个测试数据输出一个整数作为结果，表示所需花费的最少时间。\n\n如果无法达到朋友家的车站，则输出 -1。\n\n每个结果占一行。\n\n**数据范围**\n\n- $n≤1000,m≤20000$\n- $1≤s≤n$\n- $0<w<n$\n- $0<t≤1000$\n\n**输入样例：**\n```c\n5 8 5\n1 2 2\n1 5 3\n1 3 4\n2 4 7\n2 5 6\n2 3 5\n3 5 1\n4 5 1\n2\n2 3\n4 3 4\n1 2 3\n1 3 4\n2 3 2\n1\n```\n\n**输出样例：**\n```c\n1\n-1\n```\n\n### 解法一\n\n多个起点，任意终点\n\n两种做法：\n1. 建立虚拟源点，连接所有起点，权值为 0，然后求从源点到终点的最短距离\n2. 建反向边，求终点到任意点的最短路，最后取到起点的最小值\n\n这里使用第二种方法\n\n```golang\npackage main\n\nimport (\n    \"bufio\"\n    \"container/heap\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar INF = int(0x3f3f3f3f)\nvar h []int\nvar e []int\nvar ne []int\nvar w []int\nvar idx int\n\nfunc Add(a, b, c int) {\n    e[idx] = b\n    w[idx] = c\n    ne[idx] = h[a]\n    h[a] = idx\n    idx++\n}\n\nfunc main() {\n    // f, _ := os.Open(\"./input.txt\")\n    // reader := bufio.NewReader(f)\n    reader := bufio.NewReader(os.Stdin)\n    for {\n        t, err := ReadArray(reader)\n        if err != nil {\n            break\n        }\n        n, m, s := t[0], t[1], t[2]\n        idx = 0\n        h = make([]int, n+1)\n        for i := 0; i <= n; i++ {\n            h[i] = -1\n        }\n        e = make([]int, m+1)\n        w = make([]int, m+1)\n        ne = make([]int, m+1)\n        for i := 0; i < m; i++ {\n            _t, _ := ReadArray(reader)\n            // 建反向边\n            Add(_t[1], _t[0], _t[2])\n        }\n        ReadArray(reader)\n        a, _ := ReadArray(reader)\n        fmt.Println(Dijkstra(n, s, a))\n    }\n\n}\n\nfunc Dijkstra(n int, s int, a []int) int {\n    pq := make(NodeHeap, 0)\n    vis := make([]bool, n+1)\n    dis := make([]int, n+1)\n    for i := 0; i <= n; i++ {\n        dis[i] = INF\n    }\n    heap.Push(&pq, &Node{\n        idx: s,\n        val: 0,\n    })\n    dis[s] = 0\n    for len(pq) > 0 {\n        cur := heap.Pop(&pq).(*Node)\n        i, v := cur.idx, cur.val\n        if vis[i] {\n            continue\n        }\n        vis[i] = true\n        for j := h[i]; j != -1; j = ne[j] {\n            if w[j]+v < dis[e[j]] {\n                dis[e[j]] = w[j] + v\n                heap.Push(&pq, &Node{e[j], dis[e[j]]})\n            }\n        }\n    }\n    min := INF\n    for _, v := range a {\n        min = Min(min, dis[v])\n    }\n    if min == INF {\n        return -1\n    }\n    return min\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\ntype Node struct {\n    idx int\n    val int\n}\n\ntype NodeHeap []*Node\n\nfunc (h NodeHeap) Len() int { return len(h) }\n\n// 小顶堆\nfunc (h NodeHeap) Less(i, j int) bool { return h[i].val < h[j].val }\nfunc (h NodeHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *NodeHeap) Push(x interface{}) {\n    // Push 和 Pop 使用 pointer receiver 作为参数，\n    // 因为它们不仅会对切片的内容进行调整，还会修改切片的长度。\n    *h = append(*h, x.(*Node))\n}\n\nfunc (h *NodeHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nfunc ReadLine(reader *bufio.Reader) (string, error) {\n    line, err := reader.ReadString('\\n')\n    return strings.TrimRight(line, \"\\n\"), err\n}\n\nfunc ReadInt(reader *bufio.Reader) (int, error) {\n    a, err := ReadLine(reader)\n    if err != nil {\n        return -1, err\n    }\n    num, _ := strconv.Atoi(a)\n    return num, err\n}\n\nfunc ReadArray(reader *bufio.Reader) ([]int, error) {\n    line, err := ReadLine(reader)\n    if err != nil {\n        return nil, err\n    }\n    strs := strings.Split(line, \" \")\n    nums := make([]int, len(strs))\n    for i, s := range strs {\n        nums[i], _ = strconv.Atoi(s)\n    }\n    return nums, err\n}\n```\n\n## [1131. 拯救大兵瑞恩](https://www.acwing.com/problem/content/description/1133/)\n\n1944 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。\n\n瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。\n\n迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列， 于是整个迷宫被划分为 $N×M$ 个单元。\n\n每一个单元的位置可用一个有序数对 （单元的行号，单元的列号） 来表示。\n\n南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。\n\n**注意**： 门可以从两个方向穿过，即可以看成一条无向边。\n\n迷宫中有一些单元存放着钥匙，同一个单元可能存放 多把钥匙，并且所有的门被分成 P 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。\n\n大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。\n\n迷宫只有一个入口，在西北角。\n\n也就是说，麦克可以直接进入 $(1,1)$ 单元。\n\n另外，麦克从一个单元移动到另一个相邻单元的时间为 $1$ ，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。\n\n试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。\n\n**输入格式**\n\n第一行有三个整数，分别表示 N,M,P 的值。\n\n第二行是一个整数 k，表示迷宫中门和墙的总数。\n\n接下来 $k$ 行，每行包含五个整数， $X_{i1},Y_{i1},X_{i2},Y_{i2},G_i$ ：当 $G_i≥1$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一扇第 $G_i$ 类的门，当 $G_i=0$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一面不可逾越的墙。\n\n接下来一行，包含一个整数 $S$ ，表示迷宫中存放的钥匙的总数。\n\n接下来 $S$ 行，每行包含三个整数 $X_{i1},Y_{i1},Q_i$ ，表示 $(X_{i1},Y_{i1})$ 单元里存在一个能开启第 $Q_i$ 类门的钥匙。\n\n**输出格式**\n\n输出麦克营救到大兵瑞恩的最短时间。\n\n如果问题无解，则输出 -1。\n\n**数据范围**\n\n- $|X_{i1}−X_{i2}|+|Y_{i1}−Y_{i2}|=1$\n- $0≤G_i≤P$\n- $1≤Q_i≤P$\n- $1≤N,M,P≤10$\n- $1≤k≤150$\n\n**输入样例**：\n```c\n4 4 9\n9\n1 2 1 3 2\n1 2 2 2 0\n2 1 2 2 0\n2 1 3 1 0 \n2 3 3 3 0\n2 4 3 4 1\n3 2 3 3 0\n3 3 4 3 0\n4 3 4 4 0\n2\n2 1 2 \n4 2 1\n```\n\n**输出样例**：\n```c\n14\n```\n\n**样例解释**：\n\n迷宫如下所示：\n\n![](https://static.imlgw.top/blog/20220411184910.png)\n\n### 解法一\n\n一开始参考了 y 总的 0-1BFS 的做法，将拿起钥匙看作权值为 0 的点，向其他方向扩展看作权值为 1 的点，但是后来发现这种思路会比较绕，没有必要。\n\n其实完全可以直接使用简单的 BFS 就可以解决，只需要在 BFS 的状态上加一维状态，表示当前位置手上拥有钥匙的状态（状态压缩），然后在 bfs 过程中，如果房间有钥匙就直接拿起来，因为拿起钥匙并没有消耗，状态也不会变差。具体代码实现如下\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int INF = 0x3f3f3f3f;\n    static int[] dir = {1, 0, -1, 0, 1};\n    static int N, M, P, K, S;\n    // 第 i 个房间的钥匙\n    static int[] key;\n    // 邻接矩阵，权值为门的种类\n    static int[][] w;\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        N = in[0]; M = in[1]; P = in[2];\n        K = read(br)[0];\n\n        w = new int[N * M + 1][N * M + 1];\n        key = new int[N * M + 2];\n        for (int i = 0; i <= N * M; i++) {\n            Arrays.fill(w[i], -1);\n        }\n\n        for (int i = 0; i < K; i++) {\n            int[] t = read(br);\n            int a = flat(t[0], t[1]);\n            int b = flat(t[2], t[3]);\n            int g = t[4];\n            // a,b 两点之间有门或者墙\n            w[a][b] = w[b][a] =  g;\n        }\n\n        S = read(br)[0];\n        for (int i = 0; i < S; i++) {\n            int[] t = read(br);\n            key[flat(t[0], t[1])] |= 1 << t[2];\n        }\n\n        out.println(bfs());\n        out.flush();\n    }\n\n    public static int bfs() {\n        // 最短距离以及手上钥匙的状态\n        Deque<int[]> queue = new ArrayDeque<>();\n        int[][] dis = new int[N * M + 1][1 << (P + 1)];\n        for (int i = 0; i < N * M + 1; i++) {\n            Arrays.fill(dis[i], INF);\n        }\n        boolean[][] vis = new boolean[N * M + 1][1 << (P + 1)];\n        dis[1][key[1]] = 0;\n        queue.offer(new int[] {1, key[1]});\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int[] t = unflat(cur[0]);\n            int i = t[0], j = t[1];\n            int st = cur[1];\n            if (vis[cur[0]][st]) {\n                continue;\n            }\n            vis[cur[0]][st] = true;\n\n            if (cur[0] == N * M) {\n                return dis[cur[0]][cur[1]];\n            }\n\n            for (int k = 0; k < 4; k++) {\n                int nx = i + dir[k];\n                int ny = j + dir[k + 1];\n                int nn = flat(nx, ny);\n                if (nx < 1 || nx > N || ny < 1 || ny > M) {\n                    continue;\n                }\n\n                // 墙或者没有对应的钥匙\n                if (w[cur[0]][nn] == 0 || (w[cur[0]][nn] != -1 && ((st >>> w[cur[0]][nn]) & 1) == 0)) {\n                    continue;\n                }\n\n                int nst = st | key[nn];\n                if (dis[nn][nst] > dis[cur[0]][st] + 1) {\n                    dis[nn][nst] = dis[cur[0]][st] + 1;\n                    queue.offer(new int[] {nn, nst});\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static int flat(int x, int y) {\n        return (x - 1) * M + y;\n    }\n\n    public static int[] unflat(int i) {\n        return new int[] {(i + M - 1) / M, (i - 1) % M + 1};\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n\npublic class AcWing1131_拯救大兵瑞恩 {\n    public static void main(String[] args) throws Exception {\n        // 输入重定向\n        System.setIn(new FileInputStream(\"./input.txt\"));\n        new Main().main();\n    }\n}\n```\n\n## [1134. 最短路计数](https://www.acwing.com/problem/content/1136/)\n\n给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1$ 到 $N$ 。\n\n问从顶点 $1$ 开始，到其他每个点的最短路有几条。\n\n**输入格式**\n\n第一行包含 $2$ 个正整数 $N,M$ ，为图的顶点数与边数。\n\n接下来 $M$ 行，每行两个正整数 $x,y$ ，表示有一条顶点 $x$ 连向顶点 $y$ 的边，请注意可能有自环与重边。\n\n**输出格式**\n\n输出 $N$ 行，每行一个非负整数，第 $i$ 行输出从顶点 $1$ 到顶点 $i$ 有多少条不同的最短路，由于答案有可能会很大，你只需要输出对 $100003$ 取模后的结果即可。\n\n如果无法到达顶点 $i$ 则输出 $0$ 。\n\n**数据范围**\n- $1≤N≤10^5$\n- $1≤M≤2×10^5$\n\n**输入样例：**\n```c\n5 7\n1 2\n1 3\n2 4\n3 4\n2 3\n4 5\n```\n**输出样例**：\n```c\n1\n2\n4\n```\n\n### 解法一\n\n求最短路条数，很显然是一个动态规划题，结合了最短路。\n\n一开始没想明白最短路更新和数量统计的关系，做了两遍 BFS。第一遍计算出最短路，第二遍利用最短路统计个数。\n\n比较直白，没啥好说的。\n<details>\n<summary>两遍 BFS 的写法</summary>\n\n```golang\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar INF = int(0x3f3f3f3f)\nvar MOD = 100003\nvar idx int\nvar h []int\nvar e []int\nvar ne []int\n\nfunc add(a, b int) {\n    e[idx] = b\n    ne[idx] = h[a]\n    h[a] = idx\n    idx++\n}\n\nfunc main() {\n    // f, _ := os.Open(\"./input.txt\")\n    // reader := bufio.NewReader(f)\n    var reader = bufio.NewReader(os.Stdin)\n    in := ReadArray(reader)\n    N, M := in[0], in[1]\n    idx = 0\n    h = make([]int, N+1)\n    for i := 0; i <= N; i++ {\n        h[i] = -1\n    }\n    e = make([]int, 2*M+1)\n    ne = make([]int, 2*M+1)\n    for i := 0; i < M; i++ {\n        t := ReadArray(reader)\n        add(t[0], t[1])\n        add(t[1], t[0])\n    }\n\n    var queue []int\n    vis := make([]bool, N+1)\n    dis := make([]int, N+1)\n    for i := 0; i <= N; i++ {\n        dis[i] = INF\n    }\n    queue = append(queue, 1)\n    dis[1] = 1\n    for len(queue) > 0 {\n        i := queue[0]\n        queue = queue[1:]\n        if vis[i] {\n            continue\n        }\n        vis[i] = true\n        for j := h[i]; j != -1; j = ne[j] {\n            k := e[j]\n            dis[k] = Min(dis[k], dis[i]+1)\n            queue = append(queue, k)\n        }\n    }\n\n    queue = make([]int, 0)\n    queue = append(queue, 1)\n    vis = make([]bool, N+1)\n    // dp[i]: 从 1 到 i 的最短路条数\n    dp := make([]int, N+1)\n\n    dp[1] = 1\n    for len(queue) > 0 {\n        i := queue[0]\n        queue = queue[1:]\n\n        if vis[i] {\n            continue\n        }\n        vis[i] = true\n        for j := h[i]; j != -1; j = ne[j] {\n            k := e[j]\n            if dis[i]+1 == dis[k] {\n                dp[k] = (dp[k] + dp[i]) % MOD\n            }\n            queue = append(queue, k)\n        }\n    }\n\n    for i := 1; i <= N; i++ {\n        fmt.Println(dp[i])\n    }\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc ReadLine(reader *bufio.Reader) string {\n    line, _ := reader.ReadString('\\n')\n    return strings.TrimRight(line, \"\\n\")\n}\n\nfunc ReadInt(reader *bufio.Reader) int {\n    num, _ := strconv.Atoi(ReadLine(reader))\n    return num\n}\n\nfunc ReadArray(reader *bufio.Reader) []int {\n    line := ReadLine(reader)\n    strs := strings.Split(line, \" \")\n    nums := make([]int, len(strs))\n    for i, v := range strs {\n        nums[i], _ = strconv.Atoi(v)\n    }\n    return nums\n}\n```\n</details>\n\n### 解法二\n\n类似的计数题其实之前也遇到过，[11. 背包问题求方案数](https://imlgw.top/2021/03/02/e60f310b/#11-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0) 这题就是类似的，不过这里把转移放在了最短路中。\n\n题目给的图是存在环的，直接 dp 肯定不行，不满足拓扑序。但是实际上这里我们在图上用 bfs 求最短路时的出队节点顺序是满足拓扑序的，一层一层的更新，出队的点最短路都是确定的，不存在环，所以可以直接在 bfs 最短路过程中转移。同理 dijkstra 的最短路序列也是满足拓扑序的，每个节点出队列时最短路就确定了，只出队一次，不会回头更新之前的状态，也不存在环。\n\n> spfa 这里是不行的，节点会多次出队入队，队首节点最短路并不确定，还可能会被其他节点更新，存在环。如果节点存在负环可以先 spfa 求出最短路拓扑序，然后再 dp 求条数\n\n$dp$ 根据 $dis$ 的值进行转移\n \n1. 当 $dis[i]+1 = dis[k]$ 时，说明两条路路径相等，直接累加起来， $dp[k] = dp[k] + dp[i]$ 。\n\n2. 当 $dis[i]+1 < dis[k]$ 时，说明有更短的路到 k，直接覆盖之前计数， $dp[k] = dp[i]$ 。\n\n```golang\npackage main\n\nimport (\n    \"bufio\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar INF = int(0x3f3f3f3f)\nvar MOD = 100003\nvar idx int\nvar h []int\nvar e []int\nvar ne []int\n\nfunc add(a, b int) {\n    e[idx] = b\n    ne[idx] = h[a]\n    h[a] = idx\n    idx++\n}\n\nfunc main() {\n    // f, _ := os.Open(\"./input.txt\")\n    // reader := bufio.NewReader(f)\n    var reader = bufio.NewReader(os.Stdin)\n    var writer = bufio.NewWriter(os.Stdout)\n\n    in := ReadArray(reader)\n    N, M := in[0], in[1]\n    idx = 0\n    h = make([]int, N+1)\n    for i := 0; i <= N; i++ {\n        h[i] = -1\n    }\n    e = make([]int, 2*M+1)\n    ne = make([]int, 2*M+1)\n    for i := 0; i < M; i++ {\n        t := ReadArray(reader)\n        add(t[0], t[1])\n        add(t[1], t[0])\n    }\n\n    var queue []int\n    dis := make([]int, N+1)\n    for i := 0; i <= N; i++ {\n        dis[i] = INF\n    }\n    dis[1] = 1\n    // dp[i]: 从 1 到 i 的最短路条数\n    dp := make([]int, N+1)\n    queue = append(queue, 1)\n    dp[1] = 1\n    for len(queue) > 0 {\n        i := queue[0]\n        queue = queue[1:]\n\n        for j := h[i]; j != -1; j = ne[j] {\n            k := e[j]\n            if dis[i]+1 == dis[k] { // 累加\n                dp[k] = (dp[k] + dp[i]) % MOD\n            } else if dis[i]+1 < dis[k] { // 有更小的，覆盖掉\n                dp[k] = dp[i]\n                dis[k] = dis[i] + 1\n                queue = append(queue, k) // 只入队一次，最短路确定\n            }\n        }\n    }\n\n    for i := 1; i <= N; i++ {\n        writer.WriteString(strconv.Itoa(dp[i]))\n        writer.WriteString(\"\\n\")\n    }\n    writer.Flush()\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc ReadLine(reader *bufio.Reader) string {\n    line, _ := reader.ReadString('\\n')\n    return strings.TrimRight(line, \"\\n\")\n}\n\nfunc ReadInt(reader *bufio.Reader) int {\n    num, _ := strconv.Atoi(ReadLine(reader))\n    return num\n}\n\nfunc ReadArray(reader *bufio.Reader) []int {\n    line := ReadLine(reader)\n    strs := strings.Split(line, \" \")\n    nums := make([]int, len(strs))\n    for i, v := range strs {\n        nums[i], _ = strconv.Atoi(v)\n    }\n    return nums\n}\n```\n\n## [383. 观光](https://www.acwing.com/problem/content/description/385/)\n\n“您的个人假期”旅行社组织了一次比荷卢经济联盟的巴士之旅。\n\n比荷卢经济联盟有很多公交线路。每天公共汽车都会从一座城市开往另一座城市。沿途汽车可能会在一些城市（零或更多）停靠。\n\n旅行社计划旅途从 $S$ 城市出发，到 $F$ 城市结束。\n\n由于不同旅客的景点偏好不同，所以为了迎合更多旅客，旅行社将为客户提供多种不同线路。\n\n游客可以选择的行进路线有所限制，要么满足所选路线总路程为 $S$ 到 $F$ 的最小路程，要么满足所选路线总路程仅比最小路程多一个单位长度。\n\n![](https://static.imlgw.top/blog/20220520194157.png)\n\n如上图所示，如果 $S=1$ ， $F=5$ ，则这里有两条最短路线 1→2→5,1→3→5，长度为 $6$ ；有一条比最短路程多一个单位长度的路线 1→3→4→5，长度为 $7$ 。\n\n现在给定比荷卢经济联盟的公交路线图以及两个城市 $S$ 和 $F$ ，请你求出旅行社最多可以为旅客提供多少种不同的满足限制条件的线路。\n\n**输入格式**\n\n第一行包含整数 $T$ ，表示共有 $T$ 组测试数据。\n\n每组数据第一行包含两个整数 $N$ 和 $M$ ，分别表示总城市数量和道路数量。\n\n接下来 $M$ 行，每行包含三个整数 $A,B,L$ ，表示有一条线路从城市 $A$ 通往城市 $B$ ，长度为 $L$ 。\n\n需注意，线路是 单向的，存在从 A 到 B 的线路不代表一定存在从 B 到 A 的线路，另外从城市 A 到城市 B 可能存在多个不同的线路。\n\n接下来一行，包含两个整数 $S$ 和 $F$ ，数据保证 $S$ 和 $F$ 不同，并且 $S、F$ 之间至少存在一条线路。\n\n**输出格式**\n\n每组数据输出一个结果，每个结果占一行。\n\n数据保证结果不超过 $10^9$ 。\n\n**数据范围**\n\n- $2≤N≤1000$\n- $1≤M≤10000$\n- $1≤L≤1000$\n- $1≤A,B,S,F≤N$\n\n**输入样例**：\n```c\n2\n5 8\n1 2 3\n1 3 2\n1 4 5\n2 3 1\n2 5 3\n3 4 2\n3 5 4\n4 5 3\n1 5\n5 6\n2 3 1\n3 2 1\n3 1 10\n4 5 2\n5 2 7\n4 1\n```\n\n**输出样例**\n```c\n3\n2\n```\n\n### 解法一\n\n和上一题类似，但是这里需要求「次短路」计数，我们可以在前面的基础上增加一维代表次短路，然后将每个点的最短路和次短路都放入 Dijkstra 中迭代更新。\n\n$dis[i][0/1]$ 代表 $s$ 到达 $i$ 的最短路和次短路长度， $cnt[i][0/1]$ 代表 $s$ 到达 $i$ 的最短路和次短路条数，然后分情况讨论。\n\n枚举 $i$ 点出边：\n1. $dis[j][0] > w_{ij} + v_{si}$ ，说明找到了 $s\\rightarrow j$ 更短的最短路，之前的最短路变为次短路\n2. $dis[j][0] = w_{ij} + v_{si}$ ，找到一条相同的最短路，累加\n3. $dis[j][1] > w_{ij} + v_{si}(dis[i][0] \\leq w_{ij} + v_{si})$ ，找到了更短的次短路\n4. $dis[j][1] = w_{ij} + v_{si}$ ，找到一条相同的次短路，累加\n\n其实我们可以发现：\n\n1. 一个点的最短路一定是由上一个节点的最短路演化而来\n2. 一个点的次短路可能是由上一个点的最短路来，也有可能由上一个点的次短路而来\n\n```golang\npackage main\n\nimport (\n    \"bufio\"\n    \"container/heap\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar INF = int(0x3f3f3f3f)\nvar h []int\nvar e []int\nvar ne []int\nvar w []int\nvar idx int\n\nfunc Add(a, b, c int) {\n    w[idx] = c\n    e[idx] = b\n    ne[idx] = h[a]\n    h[a] = idx\n    idx++\n}\n\nfunc main() {\n    reader := bufio.NewReader(os.Stdin)\n    T := ReadArray(reader)[0]\n    for ; T > 0; T-- {\n        in := ReadArray(reader)\n        N, M := in[0], in[1]\n        idx = 0\n        h = make([]int, N+1)\n        e = make([]int, M+1)\n        ne = make([]int, M+1)\n        w = make([]int, M+1)\n\n        for i := 0; i < len(h); i++ {\n            h[i] = -1\n        }\n\n        for i := 0; i < M; i++ {\n            t := ReadArray(reader)\n            Add(t[0], t[1], t[2])\n        }\n\n        sf := ReadArray(reader)\n        S, F := sf[0], sf[1]\n\n        fmt.Println(Dijkstra(S, F, N))\n    }\n}\n\nfunc Dijkstra(s, f, n int) int {\n    var pq NodeHeap\n    dis := make([][2]int, n+1)\n    cnt := make([][2]int, n+1)\n    vis := make([][2]bool, n+1)\n    heap.Push(&pq, &Node{s, 0, 0})\n    for i := 0; i <= n; i++ {\n        dis[i][0] = INF\n        dis[i][1] = INF\n    }\n    cnt[s][0] = 1\n    dis[s][0] = 0\n\n    for len(pq) > 0 {\n        cur := heap.Pop(&pq).(*Node)\n        i, v, t := cur.i, cur.v, cur.t\n        if vis[i][t] {\n            continue\n        }\n        vis[i][t] = true\n        // i 出边\n        for j := h[i]; j != -1; j = ne[j] {\n            if dis[e[j]][0] > w[j]+v { // 最短路变为次短路\n                dis[e[j]][1] = dis[e[j]][0]\n                cnt[e[j]][1] = cnt[e[j]][0] // 历史最短路覆盖次短路 cnt\n                dis[e[j]][0] = w[j] + v\n                cnt[e[j]][0] = cnt[i][t] // 新的最短路覆盖历史最短路 cnt\n                heap.Push(&pq, &Node{e[j], dis[e[j]][0], 0})\n                heap.Push(&pq, &Node{e[j], dis[e[j]][1], 1})\n            } else if dis[e[j]][0] == w[j]+v { // 找到一条新的最短路\n                cnt[e[j]][0] += cnt[i][t]\n            } else if dis[e[j]][1] > w[j]+v { // 找到更短的次短路\n                dis[e[j]][1] = w[j] + v\n                cnt[e[j]][1] = cnt[i][t] // 新次短路覆盖次最短路 cnt\n                heap.Push(&pq, &Node{e[j], dis[e[j]][1], 1})\n            } else if dis[e[j]][1] == w[j]+v {\n                cnt[e[j]][1] += cnt[i][t]\n            }\n        }\n    }\n\n    res := cnt[f][0]\n    if dis[f][1] == dis[f][0]+1 {\n        res += cnt[f][1]\n    }\n    return res\n}\n\ntype Node struct {\n    i int\n    v int\n    t int\n}\n\ntype NodeHeap []*Node\n\nfunc (h NodeHeap) Len() int { return len(h) }\n\n// 小顶堆\nfunc (h NodeHeap) Less(i, j int) bool { return h[i].v < h[j].v }\nfunc (h NodeHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *NodeHeap) Push(x interface{}) {\n    // Push 和 Pop 使用 pointer receiver 作为参数，\n    // 因为它们不仅会对切片的内容进行调整，还会修改切片的长度。\n    *h = append(*h, x.(*Node))\n}\n\nfunc (h *NodeHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nfunc ReadLine(reader *bufio.Reader) string {\n    line, _ := reader.ReadString('\\n')\n    return strings.TrimRight(line, \"\\n\")\n}\n\nfunc ReadArray(reader *bufio.Reader) []int {\n    line := ReadLine(reader)\n    strs := strings.Split(line, \" \")\n    nums := make([]int, len(strs))\n    for i := 0; i < len(strs); i++ {\n        nums[i], _ = strconv.Atoi(strs[i])\n    }\n    return nums\n}\n\nfunc init() {\n    os.Stdin, _ = os.Open(\"./input.txt\")\n}\n```\n\n## [342. 道路与航线](https://www.acwing.com/problem/content/description/344/)\n\n略。此题解法有点复杂，用的 SPFA 卡过的，以后有时间再来想吧","tags":["算法","图论"],"categories":["算法"]},{"title":"Go runtime 调度","url":"/2022/04/21/e4f51eb9/","content":"\n# Linux 进程 & 线程\n\n> 在讲解详细的线程模型前，先整理一下概念\n\nLinux 内核在 2.0.x 版本实现了**轻量级进程**（普遍意义上的线程），应用程序可以通过一个统一的`clone()`系统调用接口，用不同的`flag`参数指定创建**轻量级进程**（线程）还是普通进程。当`flag`参数设置了共享相关标识时，创建**线程**，否则创建的就是进程，二者的边界实际上很模糊。\n\n从 Linux 内核角度来看，实际上也并没有对「进程」和「线程」进行严格的区分。无论是进程还是线程，都通过 [struct task_struct](https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L728) 来表示，结构体中也并没有对进程和线程的标识位。\n\n所以在 Linux 中，线程本质还是进程，只是它会和其他进程共享地址空间和系统资源等，如此便**将进程和其占用的资源分离**，相比与传统进程就显得更加”轻量级“。\n\n进而我们可以将进程理解为**资源的容器**，其中包含一个或者多个线程，同一个进程下各个线程共享资源（地址空间，文件描述符等）。而线程则作为**内核调度的基本单位**，各个线程有各自的寄存器，线程栈，程序计数器等。\n# 线程模型\n\n## 用户级线程模型\n\n早期操作系统并没有提供对线程的支持，所以线程以**用户级线程**的形式存在。多线程的调度都由用户自己的**线程/协程库**（比如 py 的 gevent，jdk 早期的 Green Threads）来完成，包括线程的创建，调度，销毁，同步等都由库函数在用户空间完成，不需要内核的支持。只在运行时将进程中所有的线程和内核的一个调度实体动态的绑定，即 N:1 的模型。这种模型下内核对用户线程没有任何感知，仍然以进程为单位调度。\n\n![Modern Operating Systems](https://static.imlgw.top/blog/20220413181645.png)\n\n这种模型好处显而易见：\n\n1. 调度过程在用户态实现，不需要内核切换，消耗很小。\n2. 创建成本低，可支持创建的线程数量很多\n3. 可以为线程定制调度算法，比如 gc 线程，我们就可以定制调度算法，不让其随便 stop\n\n但是用户级线程也存在一些问题：\n1. 线程**阻塞调用**（如 I/O 操作）会导致进程下所有线程阻塞，因为用户线程都是挂靠在**同一个**内核进程/线程上的，在内核角度就是一个进程阻塞了，此时用户调度线程也无法再进行调度切换。一种不太优雅的解决方案就是重写系统调用库中一些阻塞的方法，将其封装为非阻塞调用，在即将阻塞的地方让出 cpu，将执行权交给其他线程，等系统准备好了不会再阻塞了再进行调用（py 的 gevent 库就是这样做的，使用的 select/epoll）\n2. 无法利用多核资源，多个线程最终还是挂靠在单个内核进程上，做不到真正的并发\n3. 不适合 CPU 密集型任务，如果用户线程是 cpu 密集型任务，没有阻塞操作，那么它就不会主动释放 CPU，其他线程就得不到执行机会，就会出现线程饥饿现象。\n\n## 内核级线程模型\n\n关于「内核线程」上面也有提到，实际上内核线程就是直接由操作系统内核支持的线程（Kernel Levvel Thread，KLT）。我们的应用程序一般不会直接去使用内核线程，而是通过创建我们前文中说到的**轻量级进程（LWP）**，进而去使用内核线程。LWP 和内核线程是一一对应的，是一个 1:1 的映射模型。这样就将线程的创建，调度，销毁等都交给内核去完成（主流 jdk 的 Thread 库就是这种模型）\n\n![深入理解 Java 虚拟机](https://static.imlgw.top/blog/20220414075456.png)\n\n这种模型的优点很明显：\n1. 内核可以感知到线程（LWP）的存在。\n2. 实现简单，每个线程都是一个独立的调度单元，直接使用内核提供的调度器，由内核去处理线程阻塞，线程切换等问题，用户不干预调度过程，只能提供调度建议。\n3. 真正做到了并行处理，充分利用了多核处理器的优势\n\n缺点也同样明显：\n1. 每一个用户线程都要对应到一个内核线程，而内核资源有限，所以能支持的线程数量也有限\n2. 线程创建，销毁，多线程之间上下文切换调度，都需要进行系统调用，需要在用户态和内核态之间进行切换，开销比较大，影响性能。\n\n## 两级（混合）线程模型\n\n「两级线程模型」就是结合了用户线程模型以及内核线程模型后的产物，**用户线程**和 **LWP** 是 M：N 的映射关系。此时用户线程还是完全建立在用户空间中，由程序的 Runtime 来负责调度，因此用户线程的创建，销毁，调度等操作仍然很廉价。并且也可以支持大规模的线程并发。\n\n这种模式下，用户线程不再唯一的绑定一个内核线程，当某个用户线程阻塞时，其他的线程可以重新与其他的内核线程绑定运行，避免了用户线程模型中整个进程被阻塞的问题。\n\n这种模型之所以被称为两级线程模型，是因为该模型中线程既不是完全靠自己调度，也不是完全靠内核去调度，而是二者协调调度。\n用户 Runtime 负责调度用户线程到内核线程的调度，而内核负责内核线程到 CPU 上的调度，故称为二级线程模型。Go 语言采用的就是这种模型。\n\n# G-P-M 模型\n\n## GPM 结构\n### G（goroutine） \n\n表示 goroutine，参与调度的最小单位。每个 Goroutine 对应一个 G 结构体，G 存储 goroutine 的运行堆栈、状态以及任务函数，因为 goroutine 在执行过程中可能因为各种原因被暂停，这时需要保存 PC 和堆栈信息，以便恢复后时继续执行。每个 G 需要绑定到 P 才能被调度执行。\n\n在函数前加 go 关键字创建一个协程，其实是调用 [newproc](https://github.com/golang/go/blob/master/src/runtime/proc.go#L4071) 函数，fn 就是 go 关键字后面函数地址\n\n```golang\ntype g struct {\n    goid           int64   // goroutine id\n    atomicstatus   uint32  // 当前状态\n    stack          stack   // g 栈区间\n    m         *m      // 当前 m\n    sched          gobuf   // 运行时信息，包含 PC 以及运行时的堆栈信息\n    stackguard0    uintptr // stackguard0 = stack.lo + StackGuard，如果要抢占当前 g 会把字段值设为 stackPreempt\n    preempt       bool // preemption signal, duplicates stackguard0 = stackpreempt\n    // ... 省略部分字段。..\n}\ntype stack struct { //栈从高地址往低地址增长\n    lo uintptr\n    hi uintptr\n}\ntype gobuf struct {\n    sp   uintptr // 堆栈指针\n    pc   uintptr // 计数器指针\n    g    guintptr\n    ctxt unsafe.Pointer\n    ret  uintptr\n    lr   uintptr\n    bp   uintptr // for framepointer-enabled architectures\n}\n```\nG 的状态\n```golang\n_Gidle  // 刚被创建，还没初始化\n_Grunnable // 在运行队列中，还没被执行，也没分配栈 \n_Grunning // 运行中\n_Gsyscall // 系统调用\n_Gwaiting // 阻塞状态，比如：等待 channel、i/o 操作被 gopark\n_Gdead // goroutine 执行结束，进入 freelist 中\n_Gpreempted // g 被通过信号方式抢占，此状态不能直接 goready\n```\n### P（Processor）\n\n逻辑处理器，对于 G 来说，只有 G 绑定到 P（进入 P 的任务队列中），才能被调度。对于 M 来说，P 提供了相关的执行环境（Context 上下文），内存分配状态，任务队列等。P 的初始化在 [schedinit](https://github.com/golang/go/blob/master/src/runtime/proc.go#L658) 中\n\n> Go1.0 时期并没有 P，所以所有的 G 的创建和调度都需要加全局的锁，性能损耗很大，所以早期 Go 并发性能并不好 \n\n```golang\n// go1.18 darwin/amd64 runtime/runtime2.go\ntype p struct {\n    id          int32 //P 的 id\n    status      uint32 //当前状态\n    mcache      *mcache //内存分配器\n    runqhead uint32 // 队列头\n    runqtail uint32 // 队列尾\n    runq     [256]guintptr //等执行的 goroutine 队列，访问时不需要加锁\n    m           muintptr //P 绑定的 m\n    // Available G's (status == Gdead)\n    gFree struct { //当 G 运行结束后，清除数据放入列表以便复用\n        gList\n        n int32\n    }\n    runnext guintptr //下个运行的 g，如果不为 nil, 则当前 g 执行完后，优先执行它\n    // ... 省略部分字段。..\n}\n```\n\nP 的状态\n```golang\n_Pidle //当 M 没有 G 可执行时，P 进入空闲列表\n_Prunning //P 和 M 绑定，正在执行 G 或在寻找可执行的 G\n_Psyscall //与之关联中的 M 进入系统调用\n_Pgcstop //GC STW\n_Pdead //调小 GOMAXPROCS 数量后多余的 p 置为此状态\n```\n### M（Machine）\n\n系统线程抽象，代表着真正执行计算的资源。M 会从 P 的队列（或者 Global 队列）中取 G 来执行，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，当 G 被暂停 M 会把上下文信息写回 G，并取下一个 G 继续执行。M 并不保留 G 状态，这也是 G 可以跨 M 调度的核心。\n\n新建 M 是通过 newm 来创建的，最终是通过 [newosproc](https://github.com/golang/go/blob/master/src/runtime/os_linux.go#L166) 函数来实现的新建线程，不通平台的 newosproc 有不同的具体实现， 比如 linux 平台下，是调用 clone 系统调用来实现创建线程，mac 平台下，是调用 pthread_create 创建线程。M 最多 10000 个，在 shedinit 中定义了 `sched.maxmcount`\n\n```golang\ntype m struct {\n    id            int64\n    g0      *g     // 用于执行调度任务的 g，使用系统栈，不受 gc 影响\n    tls           [6]uintptr   // 线程本地存储空间\n    curg          *g       // 当前正在被执行的 goroutine\n    nextp         puintptr // M 被唤醒需要立即绑定的 P\n    p             puintptr // 与 M 绑定的 P\n    spinning      bool // true 表示 M 处于自旋转状态（当前没有 g 执行，正在寻找可执行的 g)\n    mcache        *mcache //当 M 与 P 绑定后，跟 P 的 mcache 指向同一个内存分配器\n}\n```\n\n### G0 和 M0\n\n- **m0**: 表示进程启动的第一个线程，也叫主线程。它和其他的 m 没有什么区别，要说区别的话，它是进程启动通过汇编直接复制给 m0 的，m0 是个全局变量，而其他的 m 都是 runtime 内自己创建的。 一个 go 进程只有一个 m0。\n- **g0**: 每个 m 都有一个 g0，因为每个线程有一个系统堆栈，g0 虽然也是 g 的结构，但和普通的 g 还是有差别的，最重要的差别就是栈的差别。g0 上的栈是系统分配的栈，在 linux 上栈大小默认固定 8MB，不能扩展，也不能缩小。 而普通 g 一开始只有 2KB 大小，可扩展。在 g0 上也没有任何任务函数，也没有任何状态，并且它不能被调度程序抢占，因为调度就是在 g0 上跑的（参考 [allocm](https://github.com/golang/go/blob/master/src/runtime/proc.go#L1712)）。\n  \n  > runtime 通常使用 systemstack、mcall 或 asmcgocall 临时切换到系统堆栈，以执行必须不被抢占的任务、不得增加用户堆栈的任务或切换用户 goroutines。在系统堆栈上运行的代码隐式不可抢占，垃圾收集器不扫描系统堆栈。在系统堆栈上运行时，不会使用当前用户堆栈执行\n\n## Runtime 源码注释\n\nproc.go 的注释中写到：\n> The bootstrap sequence is:\n> 1. call osinit\n> 2. call schedinit\n> 3. make & queue new G\n> 4. call runtime·mstart\n> \n> （从对应的汇编也可以看出这个过程，我这里对应的是 runtime/asm_amd64.s）\n\n```golang\n//1. osinit 初始化 cpu 数量和页大小\nfunc osinit() {\n    ncpu = getproccount()\n    physHugePageSize = getHugePageSize()\n}\n\n// 2. call schedinit\nfunc schedinit() {\n    sched.maxmcount = 10000 //m 的最大数量\n    mallocinit() //内存分配相关\n    //根据环境变量，创建 GOMAXPROCS 个 G\n    sched.lastpoll = uint64(nanotime())\n    procs := ncpu\n    if n, ok := atoi32(gogetenv(\"GOMAXPROCS\")); ok && n > 0 {\n        procs = n\n    }\n    if procresize(procs) != nil {\n        throw(\"unknown runnable goroutine during bootstrap\")\n    }\n}\n// 3. 启动 main goroutine\nfunc main() {\n    g := getg()\n    // 标记 main 已经启动\n    mainStarted = true\n    //在系统栈上（也就是通过 g0) 创建 m，并执行 sysmon，所以 symon 是在单独的 m 上运行，不受 gc 影响\n    if GOARCH != \"wasm\" {\n        systemstack(func() {\n            newm(sysmon, nil)\n        })\n    }\n    //如果 main goroutine 不在 m0 上运行，肯定 bug 了\n    if g.m != &m0 {\n        throw(\"runtime.main not on m0\")\n    }\n    //执行 runtime 的 init 和用户包中 init 函数\n    doInit(&runtime_inittask)\n    doInit(&main_inittask)\n    //调用用户自定义的 main 函数\n    //从这里可以看出在 golang 中，init 函数先于 main 函数执行\n    fn := main_main\n    fn()\n    //退出主进程\n    exit(0)\n    for {\n        var x *int32\n        *x = 0\n    }\n}\n//4. call runtime·mstart（m0 启动）\n//M0 在这里调用的 https://github.com/golang/go/blob/master/src/runtime/asm_amd64.s#L225\n// mstart 是一个新 M 的入口函数。\nfunc mstart() {\n    _g_ := getg()\n    osStack := _g_.stack.lo == 0\n    if osStack {\n        // 初始化 g0 栈大小\n        size := _g_.stack.hi\n        if size == 0 {\n            size = 8192 * sys.StackGuardMultiplier\n        }\n        _g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))\n        _g_.stack.lo = _g_.stack.hi - size + 1024\n    }\n    _g_.stackguard0 = _g_.stack.lo + _StackGuard\n    _g_.stackguard1 = _g_.stackguard0\n    mstart1()\n    if GOOS == \"windows\" || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"plan9\" || GOOS == \"darwin\" || GOOS == \"aix\" {\n        osStack = true\n    }\n    // m 退出\n    mexit(osStack)\n}\nfunc mstart1() {\n    _g_ := getg()\n    if _g_ != _g_.m.g0 {//调用这个函数只，m 上只可能有 g0\n        throw(\"bad runtime·mstart\")\n    }\n    //初始化 m\n    asminit()\n    minit()\n    //执行 mspinning、sysmon 等\n    if fn := _g_.m.mstartfn; fn != nil {\n        fn()\n    }\n    //_g_所在的 m 不是 m0, 则关联 p 和 m\n    if _g_.m != &m0 {\n        acquirep(_g_.m.nextp.ptr())\n        _g_.m.nextp = 0\n    }\n    schedule()//开始调度\n}\n```\n M 启动后进入 schedule() 方法，进入调度，调度的本质其实就是查找可以运行的 G，然后去运行 G 上面的任务函数\n```golang\n//需要注意的是：schedule 函数及子函数中调用的 getg() 返回的都是 g0，因为 schedule 是运行在 g0 上的\nfunc schedule() {\n    _g_ := getg() //获取当前 g\n    var gp *g\n    var inheritTime bool\n    // .....\n    if gp == nil {\n        // 为了保证公平调度，schedule 每执行 61 次就会去全局队列拿一批 g 到 p 的本地队列，避免全局队列中的 g 饥饿\n        // 否则可能出现 2 个 g 永久占用本地队列（因为被暂停的 goroutine 唤醒后优先放入本地队列）\n        if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {\n            lock(&sched.lock)\n            gp = globrunqget(_g_.m.p.ptr(), 1)\n            unlock(&sched.lock)\n        }\n    }\n    // .....\n    if gp == nil {\n        //从本地队列中取 g\n        gp, inheritTime = runqget(_g_.m.p.ptr())\n        if gp != nil && _g_.m.spinning {\n            throw(\"schedule: spinning with local work\")\n        }\n    }\n    //如果本地队列中没有可执行的 g，则调用 findrunnable 直到有可运行的 g 为止\n    if gp == nil {\n        gp, inheritTime = findrunnable()\n    }\n    // 到这里，说明已经找到可运行的 g，如果 m 还处于自旋转状态，则置回正常状态\n    // 并唤醒 p 与之绑定\n    if _g_.m.spinning {\n        resetspinning()\n    }\n    //直接在当前 m 上执行 g\n    execute(gp, inheritTime)\n}\n```\n\nfindrunnable 查找可运行的 G\n\n```golang\n//阻塞获取可执行的 G，findrunnable 会从全局队列、其它 P 队列、netpoll 中去轮询\nfunc findrunnable() (gp *g, inheritTime bool) {\n    _g_ := getg()\ntop:\n    _p_ := _g_.m.p.ptr()\n    // 本地队列中有 g，则直接返回\n    if gp, inheritTime := runqget(_p_); gp != nil {\n        return gp, inheritTime\n    }\n    // 全局队列中如果有 g, 则从全局队列中取一批到本地队列\n    if sched.runqsize != 0 {\n        lock(&sched.lock)\n        gp := globrunqget(_p_, 0)\n        unlock(&sched.lock)\n        if gp != nil {\n            return gp, false\n        }\n    }\n    // 从 netpoll 中获取 g（非阻塞轮询已经完成的网络 io)\n    if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {\n        if list := netpoll(false); !list.empty() { //从 netpoll 中取出 i/o 读写完成的 g 列表\n            gp := list.pop()   //先取出一个让当前 m 执行，这样能提高响应速度\n            injectglist(&list) //再把剩余的 g 列表放入队列\n            casgstatus(gp, _Gwaiting, _Grunnable)\n            return gp, false\n        }\n    }\n    // 检查是否可以从其它 p 中偷一部分 g\n    procs := uint32(gomaxprocs)\n    if atomic.Load(&sched.npidle) == procs-1 {\n        //如果其它 p 全部都是 idle 的，那肯定没地方偷\n        goto stop\n    }\n    //如果当前 m 没有处于自旋转且自旋转中的 p 数量 < running 中的 p 数量/2, 则让当前 m 进入自旋转\n    if !_g_.m.spinning && 2*atomic.Load(&sched.nmspinning) >= procs-atomic.Load(&sched.npidle) {\n        goto stop\n    }\n    if !_g_.m.spinning {\n        _g_.m.spinning = true\n        atomic.Xadd(&sched.nmspinning, 1)\n    }\n\n    //随机从一个 p 中偷，最多偿试 4 次\n    for i := 0; i < 4; i++ {\n        for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {\n            if sched.gcwaiting != 0 {\n                goto top\n            }\n            stealRunNextG := i > 2\n            if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {\n                return gp, false\n            }\n        }\n    }\nstop:\n    allpSnapshot := allp\n    //再次检查全局队列，如果有 g，则取出执行，否则把 p 与当前 m 解绑\n    if sched.runqsize != 0 {\n        gp := globrunqget(_p_, 0)\n        unlock(&sched.lock)\n        return gp, false\n    }\n    if releasep() != _p_ { //p 与当前 m 解绑\n        throw(\"findrunnable: wrong p\")\n    }\n    pidleput(_p_) //解绑的 p 放入 idle 队列\n    unlock(&sched.lock)\n\n    wasSpinning := _g_.m.spinning\n    if _g_.m.spinning { //如果当前 m 还处于自旋转状态，则取消，sched.nmspinning -1\n        _g_.m.spinning = false\n        if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {\n            throw(\"findrunnable: negative nmspinning\")\n        }\n    }\n\n    // 再次检查所有 p 的队列\n    for _, _p_ := range allpSnapshot {\n        if !runqempty(_p_) {\n            lock(&sched.lock)\n            _p_ = pidleget() //如果某个 p 的队列不为空，则从 idle 列表中取出一个 p\n            unlock(&sched.lock)\n            if _p_ != nil {\n                acquirep(_p_)\n                if wasSpinning { //如果解绑以前 m 是自旋转的，则还是让它保持自旋转\n                    _g_.m.spinning = true\n                    atomic.Xadd(&sched.nmspinning, 1)\n                }\n                goto top\n            }\n            break\n        }\n    }\n    // 再次从 netpoll 中阻塞的取 g\n    if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Xchg64(&sched.lastpoll, 0) != 0 {\n        if _g_.m.p != 0 {\n            throw(\"findrunnable: netpoll with p\")\n        }\n        if _g_.m.spinning {\n            throw(\"findrunnable: netpoll with spinning\")\n        }\n        list := netpoll(true)\n        atomic.Store64(&sched.lastpoll, uint64(nanotime()))\n        if !list.empty() {\n            lock(&sched.lock)\n            _p_ = pidleget()\n            unlock(&sched.lock)\n            if _p_ != nil {\n                acquirep(_p_)\n                gp := list.pop()\n                injectglist(&list)\n                casgstatus(gp, _Gwaiting, _Grunnable)\n                if trace.enabled {\n                    traceGoUnpark(gp, 0)\n                }\n                return gp, false\n            }\n            injectglist(&list)\n        }\n    }\n    //如果始终找到不，就让 m 停止\n    stopm()\n    goto top\n}\n\n//把 g 列表放入全局队列，调用 startm 检测是否有 idle 的 p，将 idle 的 m 与之绑定或 new 一个 m\nfunc injectglist(glist *gList) {\n    if glist.empty() {\n        return\n    }\n    if trace.enabled {\n        for gp := glist.head.ptr(); gp != nil; gp = gp.schedlink.ptr() {\n            traceGoUnpark(gp, 0)\n        }\n    }\n    lock(&sched.lock)\n    var n int\n    for n = 0; !glist.empty(); n++ {\n        gp := glist.pop()\n        //队列中的 g 状态必须为_Grunnable\n        casgstatus(gp, _Gwaiting, _Grunnable)\n        globrunqput(gp)\n    }\n    unlock(&sched.lock)\n    for ; n != 0 && sched.npidle != 0; n-- {\n        startm(nil, false)\n    }\n    *glist = gList{}\n}\n\n//重置自旋转状态\nfunc resetspinning() {\n    _g_ := getg()\n    if !_g_.m.spinning {\n        throw(\"resetspinning: not a spinning m\")\n    }\n    _g_.m.spinning = false\n    nmspinning := atomic.Xadd(&sched.nmspinning, -1)\n    if int32(nmspinning) < 0 {\n        throw(\"findrunnable: negative nmspinning\")\n    }\n    //除当前 m 外没有其它 m 处于自旋转状态且还有 p 处于 idle，则唤醒一个 p，这样能让等执行的 g 尽量早的被处理。\n    if nmspinning == 0 && atomic.Load(&sched.npidle) > 0 {\n        wakep()\n    }\n}\nfunc wakep() {\n    // 如果已有 m 处于自旋转状态，则直接返回 (g 一定会被处于自旋转状态的 m 执行 [结合 findrunable 函数看])\n    if !atomic.Cas(&sched.nmspinning, 0, 1) {\n        return\n    }\n    startm(nil, true)\n}\n\n//startm 检测是否有 idle 的 p, 并将 idle 的 m 与 p 绑定或 new 一个 m\nfunc startm(_p_ *p, spinning bool) {\n    lock(&sched.lock)\n    if _p_ == nil {\n        _p_ = pidleget() //获取一个 idle 的 p\n        if _p_ == nil {\n            unlock(&sched.lock)\n            if spinning {\n                // spinning 为 true 说明 startm 的调用方对 nmspinning 加了 1，但是没发现 idle 的 p，所以要回滚 nmspinning\n                if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {\n                    throw(\"startm: negative nmspinning\")\n                }\n            }\n            return\n        }\n    }\n    //成功获取到 p, 再获取 idle 的 m\n    mp := mget()\n    unlock(&sched.lock)\n    if mp == nil { //获取 idle 的 m 失败，则创建一个 m\n        var fn func()\n        if spinning {\n            // 如果 spinning 为 true, 则标记新创建的 m 为 spinning\n            fn = mspinning\n        }\n        newm(fn, _p_) //创建新 m\n        return\n    }\n    mp.spinning = spinning\n    mp.nextp.set(_p_) // 把 p 设置为即将与 m 绑定的 p\n    notewakeup(&mp.park)\n}\nfunc newm(fn func(), _p_ *p) {\n    mp := allocm(_p_, fn) //new 一个 m 结构，并初始化\n    mp.nextp.set(_p_)     //把 p 设置为即将与 m 绑定的 p\n    mp.sigmask = initSigmask\n    newm1(mp)\n}\nfunc newm1(mp *m) {\n    execLock.rlock()\n    newosproc(mp)\n    execLock.runlock()\n}\n\n//newosproc 创建 OS 线程，不同的 OS 接口不一样，linux 用的 clone, windows 为_CreateThread\nfunc newosproc(mp *m) {\n    stk := unsafe.Pointer(mp.g0.stack.hi)\n    // clone 期间禁用信号，clone 完成再启用\n    var oset sigset\n    sigprocmask(_SIG_SETMASK, &sigset_all, &oset)\n    //调用 clone 创建 os 线程， mstart 为线程起始函数\n    ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))\n    sigprocmask(_SIG_SETMASK, &oset, nil)\n}\n```\n\n# 参考资料\n\n- [《Modern Operating Systems》](https://csc-knu.github.io/sys-prog/books/Andrew%20S.%20Tanenbaum%20-%20Modern%20Operating%20Systems.pdf)\n- 《深入理解 Java 虚拟机》\n-  https://blog.csdn.net/qq_28351465/article/details/88950311\n-  https://www.cnblogs.com/chenny7/p/14060906.html\n-  https://strikefreedom.top/high-performance-implementation-of-goroutine-pool\n-  https://lifan.tech/2020/06/01/golang/runtime/\n-  https://zboya.github.io/post/go_scheduler/\n-  https://zhuanlan.zhihu.com/p/65738076","tags":["golang","并发"],"categories":["并发"]},{"title":"DP：状态机模型","url":"/2022/01/01/2fc471b9/","content":"\n## [1049. 大盗阿福](https://www.acwing.com/problem/content/1051/)\n\n阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。\n\n这条街上一共有 N 家店铺，每家店中都有一些现金。\n\n阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。\n\n作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。\n\n他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？\n\n**输入格式**\n\n输入的第一行是一个整数 T，表示一共有 T 组数据。\n\n接下来的每组数据，第一行是一个整数 N ，表示一共有 N 家店铺。\n\n第二行是 N 个被空格分开的正整数，表示每一家店铺中的现金数量。\n\n每家店铺中的现金数量均不超过 1000。\n\n**输出格式**\n\n对于每组数据，输出一行。\n\n该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。\n\n**数据范围**\n\n- $1≤T≤50$\n- $1≤N≤10^5$\n\n**输入样例：**\n```c\n2\n3\n1 8 2\n4\n10 7 6 14\n```\n\n**输出样例：**\n```\n8\n24\n```\n\n**样例解释**\n\n对于第一组样例，阿福选择第 2 家店铺行窃，获得的现金数量为 8。\n\n对于第二组样例，阿福选择第 1 和 4 家店铺行窃，获得的现金数量为 10+14=24。\n\n### 解法一\n\n这题 lc 上写过，还是比较简单，不过不是状态机的做法， $f_i$ 代表的是偷前 $i$ 个房子的最大收益，然后直接线性 dp\n\n```python\nT = int(input())\n\nwhile T > 0:\n    n = int(input())\n    nums = list(map(int, input().split()))\n    f = [0] * (n+1)\n    for i in range(1, n+1):\n        f[i] = max(f[i-1], (f[i-2] + nums[i-1]) if i-2 >= 0 else nums[i-1])\n    print(f[i])\n    T -= 1\n```\n\n用状态机来理解，每个房子有两种状态，「偷」或则「不偷」\n- 偷，那么就得保证前一个房子「不偷」\n- 不偷，那么就可以从前一个房子「偷或者不偷」状态转移过来，不影响当前状态\n\n定义状态为 $dp_{i,j}$ ，偷前 $i$ 个房子，且第 $i$ 个房子状态为 $j$ （0 不偷，1 偷）\n\n```python\nT = int(input())\n\nwhile T > 0:\n    n = int(input())\n    nums = list(map(int, input().split()))\n    f = [[0 for _ in range(2)] for _ in range(n+1)]\n    for i in range(1, n+1):\n        f[i][0] = max(f[i-1][1], f[i-1][0])\n        f[i][1] = f[i-1][0] + nums[i-1]\n    print(max(f[n][1], f[n][0]))\n    T -= 1\n```\n比较 trick 的空间优化写法\n```python\nT = int(input())\n\nwhile T > 0:\n    n = int(input())\n    nums = list(map(int, input().split()))\n    f = [0] * 2\n    for i in range(1, n+1):\n        f[0], f[1] = max(f[1], f[0]), f[0] + nums[i-1]\n    print(max(f[1], f[0]))\n    T -= 1\n```\n\n## [1057. 股票买卖 IV](https://www.acwing.com/problem/content/1059/)\n\n给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。\n\n设计一个算法来计算你所能获取的最大利润，你最多可以完成 $k$ 笔交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。\n\n**输入格式**\n\n第一行包含整数 $N$ 和 $k$ ，表示数组的长度以及你可以完成的最大交易数量。\n\n第二行包含 $N$ 个不超过 $10000$ 的正整数，表示完整的数组。\n\n**输出格式**\n\n输出一个整数，表示最大利润。\n\n**数据范围**\n\n- $1≤N≤10^5$\n- $1≤k≤100$\n\n**输入样例 1：**\n\n```c\n3 2\n2 4 1\n```\n\n**输出样例 1：**\n\n```c\n2\n```\n\n**输入样例 2：**\n\n```c\n6 2\n3 2 6 5 0 3\n```\n\n**输出样例 2：**\n\n```c\n7\n```\n\n**样例解释**\n\n样例 1：在第 1 天 （股票价格 = 2) 的时候买入，在第 2 天 （股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n\n样例 2：在第 2 天 （股票价格 = 2) 的时候买入，在第 3 天 （股票价格 = 6) 的时候卖出，这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 （股票价格 = 0) 的时候买入，在第 6 天 （股票价格 = 3) 的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。共计利润 4+3 = 7.\n\n### 解法一\n\n也是 lc 上的题，但是这里重写的时候没写出来。重新捋了思路，比之前的要更加清晰，希望下次可以直接写出来。\n\n从状态机的角度考虑，有两个状态：「持仓」和「空仓」。围绕这两个状态进行转换。\n![](https://static.imlgw.top/20210929013038.png)\n1. 从「持仓」到「空仓」的转换，说明卖掉了昨天手中持有的股票，并且完成了一次完整交易。或者今天按兵不动，维持前一天的状态\n2. 从「空仓」到「持仓」的转换，说明今天又购入了新的股票，开始了一轮**新的交易**。或者今天按兵不动，维持前一天的状态\n\n定义状态为： $dp[i][j][k]$ ，代表购买前 $i$ 天的股票，进行了**恰好** $j$ 次交易，最终状态为 $k$ （0 空仓，1 持仓）\n- 入口： $dp[i][0][0]$ ，不交易就不会持有股票，收益为 0, 其他状态收益为 $\\inf$ ，避免非法转移\n- 状态转移：\n  - $dp[i][j][0] = \\max(dp[i-1][j][1] + price, dp[i-1][j][0])$\n  - $dp[i][j][1] = \\max(dp[i-1][j-1][0] - price, dp[i-1][j][1])$\n- 出口： $\\max_{j=0}^{k}(dp[N][j][0])$\n\n代码实现如下：\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    /*\n    6 2\n    3 2 6 5 0 3\n    */\n\n    static int INF = -0x3f3f3f3f;\n\n    public static void main(String ...args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int[] in = read(br);\n        int N = in[0], K = in[1];\n        int[] price = read(br);\n        if (K > N/2) {\n            out.println(maxProfit(price));\n            out.flush();\n            return;\n        }\n        // dp[N][K][2] 的写法\n        // 前 i 天，交易次数恰好为 j，第 i 天状态为 k（0 不持有，1 持有）\n        int[][][] dp = new int[N+1][K+1][2];\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= K; j++) {\n                Arrays.fill(dp[i][j], INF);\n            }\n            // 不交易就不会持有，收益永远为 0\n            dp[i][0][0] = 0;\n        }\n        int res = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= K; j++) {\n                dp[i][j][0] = Math.max(dp[i-1][j][1] + price[i-1], dp[i-1][j][0]);\n                // 根据题目限制，当想要再次买入的时候，应该从上一次交易完成后的状态转移过来\n                // 而买入卖出为一次完整交易，所以上一次交易完成的状态应该为不持有股票\n                dp[i][j][1] = Math.max(dp[i-1][j-1][0] - price[i-1], dp[i-1][j][1]);\n                res = Math.max(dp[i][j][0], res);\n            }\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static int maxProfit(int[] price) {\n        int N = price.length;\n        int[][] dp = new int[N+1][2];\n        for (int i = 0; i <= N; i++) {\n            Arrays.fill(dp[i], INF);\n        }\n        dp[0][0] = 0;\n        int res = 0;\n        for (int i = 1; i <= N; i++) {\n            dp[i][0] = Math.max(dp[i-1][1] + price[i-1], dp[i-1][0]);\n            dp[i][1] = Math.max(dp[i-1][0] - price[i-1], dp[i-1][1]);\n            res = Math.max(dp[i][0], res);\n        }\n        return res;\n    }\n\n    public static int[] read(BufferedReader br) throws Exception{\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray(); \n    }\n}\n```\n\n这里就不写降维的了，降维会隐藏一些信息。最好是先写出原始的，如果 MLE 了，再考虑降维。直接写降维的可能会不知道怎么对的，也不知道怎么错的（太菜了）。\n\n## [1059. 股票买卖 VI](https://www.acwing.com/problem/content/1061/)\n\n给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格，再给定一个非负整数 $f$ ，表示交易股票的手续费用。\n\n设计一个算法来计算你所能获取的最大利润。\n\n你可以无限次地完成交易，但是你每次交易都需要支付手续费。\n\n**注意**: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n**输入格式**\n\n第一行包含两个整数 N 和 f，分别表示数组的长度以及每笔交易的手续费用。\n\n第二行包含 N 个不超过 10000 的正整数，表示完整的数组。\n\n**输出格式**\n\n输出一个整数，表示最大利润。\n\n**数据范围**\n\n- $1≤N≤10^5$\n- $1≤f≤10000$\n\n**输入样例：**\n```c\n6 2\n1 3 2 8 4 9\n```\n\n**输出样例：**\n```c\n8\n```\n\n**样例解释**\n\n在第 1 天（股票价格 = 1）的时候买入，在第 4 天（股票价格 = 8）的时候卖出，这笔交易所能获得利润 = 8-1-2 = 5 。随后，在第 5 天（股票价格 = 4）的时候买入，在第 6 天 （股票价格 = 9）的时候卖出，这笔交易所能获得利润 = 9-4-2 = 3 。共得利润 5+3 = 8。\n\n### 解法一\n\n```go\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar reader = bufio.NewReader(os.Stdin)\n\nfunc main() {\n    INF := int(-0x3f3f3f3f)\n    // f, _ := os.Open(\"./input.txt\")\n    // reader := bufio.NewReader(f)\n    reader := bufio.NewReader(os.Stdin)\n    in := ReadArray(reader)\n    N, F := in[0], in[1]\n    price := ReadArray(reader)\n\n    dp := make([][]int, N+1)\n    for i := 0; i <= N; i++ {\n        dp[i] = make([]int, 2)\n        dp[i][0] = INF\n        dp[i][1] = INF\n    }\n\n    dp[0][0] = 0\n    res := 0\n    for i := 1; i <= N; i++ {\n        dp[i][0] = Max(dp[i-1][1]+price[i-1]-F, dp[i-1][0])\n        dp[i][1] = Max(dp[i-1][0]-price[i-1], dp[i-1][1])\n        res = Max(res, dp[i][0])\n    }\n    fmt.Println(res)\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc ReadLine(reader *bufio.Reader) string {\n    line, _ := reader.ReadString('\\n')\n    return strings.TrimRight(line, \"\\n\")\n}\n\nfunc ReadInt(reader *bufio.Reader) int {\n    num, _ := strconv.Atoi(ReadLine(reader))\n    return num\n}\n\nfunc ReadArray(reader *bufio.Reader) []int {\n    line := ReadLine(reader)\n    strs := strings.Split(line, \" \")\n    nums := make([]int, len(strs))\n    for i, s := range strs {\n        nums[i], _ = strconv.Atoi(s)\n    }\n    return nums\n}\n```\n\n## [1058. 股票买卖 V](https://www.acwing.com/problem/content/1060/)\n\n给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n卖出股票后，你无法在第二天买入股票 （即冷冻期为 1 天）。\n\n**输入格式**\n\n第一行包含整数 $N$ ，表示数组长度。\n\n第二行包含 $N$ 个不超过 10000 的正整数，表示完整的数组。\n\n**输出格式**\n\n输出一个整数，表示最大利润。\n\n**数据范围**\n- $1≤N≤10^5$\n\n**输入样例：**\n```c\n5\n1 2 3 0 2\n```\n\n**输出样例：**\n```c\n3\n```\n\n**样例解释**\n\n对应的交易状态为：[买入，卖出，冷冻期，买入，卖出]，第一笔交易可得利润 2-1 = 1，第二笔交易可得利润 2-0 = 2，共得利润 1+2 = 3。\n\n### 解法一\n\n个人觉得这题直接线性 DP 就好了，状态机的反而不容易理解。设置 $dp[i][j]$ 为考虑前 $i$ 天的股票，第 $i$ 天的状态为 $j$ (0 为空仓，1 为持仓）\n```golang\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar reader = bufio.NewReader(os.Stdin)\n\nfunc main() {\n    n := ReadInt(reader)\n    price := ReadArray(reader)\n    dp := make([][2]int, n+1)\n    dp[0][1] = -price[0]\n    var res = 0\n    for i := 1; i <= n; i++ {\n        dp[i][0] = Max(dp[i-1][1]+price[i-1], dp[i-1][0])\n        if i-2 >= 0 {\n            dp[i][1] = Max(dp[i-2][0]-price[i-1], dp[i-1][1])\n        } else {\n            dp[i][1] = Max(-price[i-1], dp[i-1][1])\n        }\n        res = Max(res, dp[i][0])\n    }\n    fmt.Println(res)\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc ReadLine(reader *bufio.Reader) string {\n    line, _ := reader.ReadString('\\n')\n    return strings.TrimRight(line, \"\\n\")\n}\n\nfunc ReadInt(reader *bufio.Reader) int {\n    num, _ := strconv.Atoi(ReadLine(reader))\n    return num\n}\n\nfunc ReadArray(reader *bufio.Reader) []int {\n    line := ReadLine(reader)\n    strs := strings.Split(line, \" \")\n    nums := make([]int, len(strs))\n    for i, s := range strs {\n        nums[i], _ = strconv.Atoi(s)\n    }\n    return nums\n}\n```\n\n## [1052. 设计密码](https://www.acwing.com/problem/content/1054/)\n\n你现在需要设计一个密码 $S$ ， $S$ 需要满足：\n\n- $S$ 的长度是 $N$ ；\n- $S$ 只包含小写英文字母；\n- $S$ 不包含子串 $T$ ；\n\n例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde 的子串。\n\n请问共有多少种不同的密码满足要求？\n\n由于答案会非常大，请输出答案模 $10^9+7$ 的余数。\n\n**输入格式**\n\n第一行输入整数 $N$ ，表示密码的长度。\n\n第二行输入字符串 $T$ ， $T$ 中只包含小写字母。\n\n**输出格式**\n\n输出一个正整数，表示总方案数模 $10^9+7$ 后的结果。\n\n**数据范围**\n\n- $1≤N≤50$\n- $1≤|T|≤N$ ， $|T|$ 是 $T$ 的长度\n\n**输入样例 1：**\n\n```c\n2\na\n```\n\n**输出样例 1：**\n```c\n625\n```\n\n**输入样例 2：**\n```c\n4\ncbc\n```\n\n**输出样例 2：**\n```c\n456924\n```\n\n### 解法一\n\n这里实际上是一个比较复杂的状态机，还结合了 kmp，属实是有点难了，我也看了好久。这里建议先熟悉下 kmp，这里我也更新了我之前的 kmp 的写法。\n\n```golang\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar MOD = int(1e9 + 7)\n\nfunc main() {\n    f, _ := os.Open(\"../input.txt\")\n    reader := bufio.NewReader(f)\n    // reader := bufio.NewReader(os.Stdin)\n    n := ReadInt(reader)\n    t := ReadLine(reader)\n    m := len(t)\n    dp := make(map[int]map[int]int)\n    for i := 0; i <= n; i++ {\n        dp[i] = make(map[int]int)\n    }\n    // 构建 next 数组\n    next := make([]int, m)\n    next[0] = -1\n    for i, j := -1, 1; j < m; j++ {\n        for i > -1 && t[i+1] != t[j] {\n            i = next[i]\n        }\n        if t[i+1] == t[j] {\n            i++\n        }\n        next[j] = i\n    }\n    // 长度为 0，必然不包含子串\n    dp[0][-1] = 1\n    for i := 0; i < n; i++ { // 密码长度\n        for c := 'a'; c <= 'z'; c++ { // 密码第 i-1 位字符\n            for j := -1; j < m-1; j++ { // 密码第 i-1 位在子串的状态\n                u := j\n                for u > -1 && byte(c) != t[u+1] {\n                    u = next[u]\n                }\n                if byte(c) == t[u+1] {\n                    u++\n                }\n                // j -> u 的状态变化，如果 u < m-1 也就说明下一个字符为 c 状态为 u 时仍然不匹配\n                // 故 dp[i+1][u] += dp[i][j]\n                if u < m-1 {\n                    dp[i+1][u] = (dp[i+1][u] + dp[i][j]) % MOD\n                }\n            }\n        }\n    }\n    var res = 0\n    for i := -1; i < m-1; i++ {\n        res = (res + dp[n][i]) % MOD\n    }\n    fmt.Println(res)\n}\n\nfunc ReadLine(reader *bufio.Reader) string {\n    line, _ := reader.ReadString('\\n')\n    return strings.TrimRight(line, \"\\n\")\n}\n\nfunc ReadInt(reader *bufio.Reader) int {\n    num, _ := strconv.Atoi(ReadLine(reader))\n    return num\n}\n```","tags":["DP","算法，状态机"],"categories":["算法"]},{"title":"断舍离","url":"/2021/10/04/c475803/","content":"## 前言\n\n最近笔记本抽风，经常莫名其妙启动不了主系统，每次关机都可能是永别。所以预先做好打算，万一真的有一天崩了方便自己重新配置环境。\n\n这里主要列举一下自己在新系统上需要的一些工具，同时也是一次**断舍离**，希望在这篇文章上的软件越少越好。\n\n> **2021.10.3 Append**:  deepin 崩了。（自己操作不当）\n> 我其实非常热衷于将各种数据存储在云端。包括一些配置文件，网页书签，笔记，代码甚至是帐号密码也都是存储在云端，这样在系统崩溃或则更换设备的时候代价能降到最低。这次 deepin 玩崩了重装，我本来以为又得花好多天去重新配置 (-_-)，结果却并没有花很长时间，要有很多配置都是直接用的云端同步过来的。包括 Chrome，VScode，Goland 等，下载好之后直接帐号登录，然后所有的设置，插件等就都同步过来了，省去了很多事情（注意网络问题）。这一次把 sublime 也搞了云端同步，但是不知道效果咋样，下次有机会试试，重装配置花费时间最长的就是它了，幸好我还手动保存了之前的配置，不然更麻烦。\n\n## Manjaro-Xfce 配置（Manjaro 21.2.0 Qonos）\n\n### SwitchyOmega\nXfce 系统没有全局代理的设置，懒得改配置文件，用 SwitchyOmega 手动设置下\n\nhttps://proxy-switchyomega.com/settings/\n\n### AUR 助手-yay\nArch 用户软件仓库 通常称为 AUR，是给 Arch 用户的基于社区的软件存储库。\n\n```sh\nsudo pacman -S yay\n```\n### 输入法配置\n```sh\n# Google 拼音\n# 加入～/.xprofile 中，配置环境变量，让应用可以调用 fcitx 输入法\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=@im=fcitx\n``` \n### 语言环境\n```sh\n# golang https://go.dev/dl/\nsudo ln -s /opt/go/bin/go /usr/local/bin\n\n# Py 自带 3.9\n\n# java8\nyay -S jdk8-openjdk\n\n# Node & npm\nyay -S nodejs, npm\n```\n\n## Deepin 配置（v20）\n\n### 不要乱改环境变量！\n\n2021.10.3 号下午，就在我前一天晚上呕心沥血的重装了 deepin 后下午又崩了，这次进的去系统，但是进不去桌面。**登录循环**，其实发生这个情况的原因很多，这里记录下我的经历。\n\n首先考虑的是 dde 的桌面环境出问题了，所以进不去。进 tty 模式，准备重装 dde 结果发现没网，wifi 也连接不上。没有多余的网线，于是下楼去买了一根网线（-10￥），接上后顺利的上了网。然后重装了 dde，结果发现还是不行。\n\n到这里其实有一些问题被我忽略了，一开始进 tty 的时候所有的命令都失效了，我直接 export 了。这里其实就应该意识到问题，肯定是环境变量出问题了，导致桌面环境读取不到正确的环境变量，所以启动不起来。后来搜索到了这个文章\n[deepin-bible](https://github.com/bubifengyun/deepin-bible/blob/master/rmd/302-install-deepin.Rmd)，才提醒了我\n\n然后我回想了昨天晚上修改了那些地方的环境变量，包括`/etc/profile`，`/etc/environment`等等，然后统统都改回去，然后重启，问题解决！\n\n连着崩两次也给了我一些教训，不过玩 Linux 多踩踩坑也挺好的。\n\n### git-ssh\n```sh\nssh-keygen -t rsa -C \"privateli@qq.com\"\n\n# git 配置\ngit config --global user.name \"Resolmi\"\ngit config --global user.email privateli@qq.com\n```\n### 标题栏\n```c\nvim ~/.config/kwinrc\n\n[Windows]\nBorderlessMaximizedWindows=true\n```\n\n### zsh & ohmyzsh\nzsh 直接 apt-get\n- https://zhuanlan.zhihu.com/p/35283688\n\n- https://segmentfault.com/a/1190000018093021\n\n### 键盘映射\nCAPS 映射为 Numlock，设置为输入法切换键\n```sh\n# 取消提示\ngsettings set com.deepin.dde.keybinding.mediakey capslock '[]'\n\n# 映射 numlock，加到。zshrc 中\ngsettings set com.deepin.dde.keyboard layout-options '[\"caps:numlock\"]'\n```\n### 待机\ndeepin 的待机恢复似乎有点问题，可能是太慢了，也可能是卡死，索性就直接关掉了。\n## Clash\nhttps://github.com/Dreamacro/clash/wiki/clash-as-a-daemon\n\n## 浏览器\nChrome 不用多说，需要一些插件\n- ~~**Infinity 标签页**~~\n- ~~onetab~~\n- ~~bitwarden~~\n- ~~adbplus~~\n- ~~bookmarkManager~~\n- ~~Octotree-Github code tree~~\n- ~~沙拉查词~~\n- ~~下载管理~~\n- ~~油猴（复制脚本）~~\n\n> 2021.9.5 在 deepin 上安装 Chrome，登录 Google 帐号后配置全部同步过来了，插件也全部同步过来了，非常 Nice。Infinity 登录后也全部同步过来了，非常完美\n\n## Jetbrains\nIDEA、Goland 以及 PyCharm，使用开源项目申请的 Licenses。具体的配置相对比较容易，属于开箱即用类型。\n\n### Goland 配置\nJava 的环境不太想配置，在家不写业务 Java。\n```sh\n# /usr/share/applications\n[Desktop Entry]\nType=Application\nComment=Goland\nName=Goland\nIcon=/opt/GoLand-2021.2.3/bin/goland.png\nExec=/opt/GoLand-2021.2.3/bin/goland.sh\nTerminal=false\nCategories=Application\n```\n有设置同步（Jetbrains 帐号），还是很方便的\n\n## SublimeText\n这个是肯定要留下的，个人非常喜欢的一款「文本编辑器」，平常写一些 demo 或者算法题都是使用的 st。相比之下 vscode 平常都是用来写 markdown 的，基本不会拿来写代码。\n### Crack\n\nhttps://gist.github.com/maboloshi/feaa63c35f4c2baab24c9aaf9b3f4e47\n\n### Sync\n折腾了一圈，发现还是 subl 配置最麻烦，其他都很好配置。这里查了下发现有 sync 的插件，但是不确定能同步多少，下次有机会试试（可别再下次了）\n```json\n{\n    \"access_token\": \"bitwarden\",\n    \"gist_id\": \"f5643bb6272713bc23eb50dfe41c80d6\",\n}\n```\n注意更改配置后 upload 一下\n\n> 安装配置 Manjaro 的时候尝试了同步的功能，除了 GoSublime，其他的插件以及设置都同步过来了，GoSublime 只能手动安装。build 编译脚本也没有同步，这个依赖于本地环境，还是需要手动再配置\n\n### 插件\n~~subl 没有配置同步，只能手动同步~~ 加上了，还没测试效果。\n- Package Controller\n- AdvancedNewFile\n- Alignment\n- BracketHighlighter\n- Ctags\n- FileDiffs\n- ~~GoSublime~~（不能通过 Package Control 安装，无法同步，同时也不太好配置，弃坑，换官方的 Go Build)\n    - ~~https://margo.sh/b/migrate/~~\n    - ~~https://roninwz.github.io/pages/78564e/#sublime%E9%85%8D%E7%BD%AEgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83~~\n- SideBarEnhancements\n- Golang Build，比较适合我，Sublime 我只用来写算法题，编译简单的 Go 程序绰绰有余了。因为用的原始的 GoPath，不用额外处理中文目录。且通过 Package Control 安装，支持同步\n- GoFmt（配合 GoBuild 好用的一批）\n\n### Preferences.sublime-settings\n```json\n// Settings in here override those in \"Default/Preferences.sublime-settings\",\n// and are overridden in turn by syntax-specific settings.\n{\n\t\"font_face\": \"Source Code Pro Medium\",\n\t\"font_size\":14,\n\t\"color_scheme\": \"Packages/Color Scheme - Default/Monokai.sublime-color-scheme\",\n\t\"theme\": \"Adaptive.sublime-theme\",\n\t\"highlight_line\": true,\n\t\"save_on_focus_lost\": true,\n\t\"translate_tabs_to_spaces\": true,\n\t\"ignored_packages\":\n\t[\n\t\t\"Vintage\",\n\t],\n\t\"word_wrap\": false,\n\t\"update_check\": false,\n}\n```\n### Adtivate Theme Setting\n```json\n// Documentation at https://www.sublimetext.com/docs/themes.html\n{\n    \"variables\":\n    {\n        // \"font_size\": 13,\n        // \"font_size_sm\": 12\n    },\n    \"rules\":\n    [\n        {\n            \"class\": \"sidebar_label\",\n            \"fg\": \"color(var(--background) blend(white 20%))\",\n            \"font.face\": \"var(font_face)\",\n            \"font.size\": 13\n        },\n        {\n            \"class\": \"tab_label\",\n            \"font.face\": \"var(font_face)\",\n            \"font.size\": 13\n        }\n    ]\n}\n```\n\n### Javac Build\n```json\n{\n    \"cmd\": [\"xfce4-terminal\", \"-e\", \"sh -c 'javac -encoding utf-8 $file && java $file_base_name'\", \"-H\"],\n    \"file_regex\": \"^(...*?):([0-9]*):?([0-9]*)\",\n    \"selector\": \"source.java\",\n    \"encoding\": \"utf-8\"\n}\n```\n### KeyMap\n```json\n[\n    {\n       \"keys\": [\"ctrl+alt+l\"],\n       \"command\": \"reindent\", \n       \"args\": {\n            \"single_line\": false\n        }\n    }\n]\n```\n## VSCode\n主要用途就是写 markdown，以及作为 database client（非常好用）替代 navicat，开了配置同步，不知道有没有用，后面试试看\n\n> 2021.9.5 尝试在 deepin 上安装，配置同步非常的丝滑，插件也全部同步过来了，非常 Nice\n## Hexo 博客\n目前 Hexo 博客已经完全云化，新系统上直接拉下来就行了。（需要 Node 环境做本地测试）\n\n### Node & NPM\n这里有点小坑，首先直接\n```sh\nsudo apt install nodejs, npm\n```\n但是可能会用不了，各种问题。需要升级下 npm \n```sh\nsudo npm -g install npm\n# 换 cnpm\nnpm install cnpm -g --registry=https://registry.npmmirror.com\n```\n然后再去 install 博客的依赖\n\n## Utools\n适配了 deepin，非常棒的软件。这个同步似乎是要收费，不过主要也就用几个插件\n- **图床**\n- **Host 切换**\n- JDK 文档\n- Py 文档\n\n## 星火应用商店\n\n- lcalingua：QQ 客户端\n- 死亡细胞\n\n## code-server\n配置 code-server 遇到了小问题，开代理 code-server 进不去，但是在其他电脑上是好的，把 code-server 过滤后就好了，很奇怪。\n\n相关链接\n- https://github.com/microsoft/vscode/issues/115818\n- https://github.com/cdr/code-server/issues/1500\n\n## 结语\n\n自己总是会在一些不重要的事情上花费大量的时间，付出与回报严重不成正比。但人的精力毕竟是有限的，所以需要及时的「断舍离」，放弃一些不重要事情，一些不重要的物件，一些不重要的人，给自己减负，活得更自在些。\n","tags":["折腾"],"categories":["折腾"]},{"title":"搜索：双向 BFS","url":"/2021/09/19/b9d77e2c/","content":"\n> 双向奔赴的 BFS\n\n## [190. 字串变换](https://www.acwing.com/problem/content/192/)\n\n已知有两个字串 $A, B$ 及一组字串变换的规则（至多 6 个规则）:\n\n$A1→B1$\n\n$A2→B2$\n\n…\n\n规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$ 、 $A_2$ 可以变换为 $B_2$ …\n\n例如：A＝abcd B＝xyz\n\n变换规则为：\n\nabc → xu ud → y y → yz\n\n则此时，A 可以经过一系列的变换变为 B，其变换的过程为：\n\nabcd → xud → xy → xyz\n\n共进行了三次变换，使得 A 变换为 B。\n\n**输入格式**：\n\n```c\nA B\nA1 B1\nA2 B2\n```\n\n第一行是两个给定的字符串 A 和 B。\n\n接下来若干行，每行描述一组字串变换的规则。\n\n所有字符串长度的上限为 20。\n\n**输出格式**\n\n若在 10 步（包含 10 步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出 NO ANSWER!。\n\n**输入样例：**\n```c\nabcd xyz\nabc xu\nud y\ny yz\n```\n**输出样例：**\n```c\n3\n```\n\n### 解法一\n单看题面是一个简单的 BFS 搜索，但是分析下复杂度就会发现直接暴力代价是非常高的，最多会有 $6^{10}=60466176$ 状态，需要进行优化。\n\n这里就引出「双向 BFS」的优化方法，我们平常 BFS 搜索是一个指数级别增长过程，每多搜索一层节点数量就会指数增长，那么我们肯定希望搜索的层数越少越好，那么我们就可采用「双向搜索」来优化。我们在进行**原点**->**目标**搜索的同时也进行**目标**->**原点**的搜索。\n\n![mark](https://static.imlgw.top/blog/20210904/WDw26MffWNad.png)\n\n看上图好像只少了一点状态，实际我们稍微算一下就知道这个优化效果还是很明显的，假设每个节点可以扩展 $n$ 种状态，一共需要扩展 $k$ 层，那么**可能**（不算去重）就会有 $n^k$ 个状态。如果恰好搜索在中间相遇，那么我们的状态数量就会减少为 $n^{\\frac{k}{2}}\\ast2$ 。\n对应到该题，实际上状态减少到了 $2\\ast6^5=15552$ ，指数级别的大优化。当然双向 BFS 也并不是万能的，比如这题，如果数据量稍微再大一点，也会过不了，甚至也可以刻意的构造出在限制范围内双向 BFS 也无法通过的数据。\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int n;\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int ans = bfs(br);\n        out.println(ans == -1 ? \"NO ANSWER!\" : ans);\n        out.flush();\n    }\n\n    public static int bfs(BufferedReader br) throws Exception {\n        String[] in = br.readLine().split(\" \");\n        String A = in[0], B = in[1];\n        if (A.equals(B)) {\n            return 0; \n        }\n        // 正反搜索队列\n        Deque<String> qp = new ArrayDeque<>();\n        Deque<String> qn = new ArrayDeque<>();\n        // 正反搜索步数\n        HashMap<String, Integer> dp = new HashMap<>();\n        HashMap<String, Integer> dn = new HashMap<>();\n        \n        // 转换规则\n        String[] sa = new String[7];\n        String[] sb = new String[7];\n\n        String line = null;\n        n = 0;\n        while ((line = br.readLine()) != null) {\n            String[] t = line.split(\" \");\n            sa[n] = t[0]; sb[n++] = t[1];\n        }\n\n        qp.add(A); qn.add(B);\n        dp.put(A, 0); dn.put(B, 0);\n        int ans = -1, cnt = 0;\n        while (!qp.isEmpty() && !qn.isEmpty()) {\n            if (qp.size() < qn.size()) {\n                ans = expand(qp, dp, dn, sa, sb);\n            } else {\n                ans = expand(qn, dn, dp, sb, sa);\n            }\n            ans = expand(qp, dp, dn, sa, sb);\n            if (ans <= 10) return ans;\n            if (++cnt >= 10) return -1;\n        }\n        return -1;\n    }\n\n    public static int expand(Deque<String> que, Map<String, Integer> dp, Map<String, Integer> dn, String[] sa, String[] sb) {\n        int limit = dp.get(que.peek());\n        // 一次扩展一层\n        while (!que.isEmpty() && limit == dp.get(que.peek())) {\n            String cur = que.poll();\n            for (int i = 0; i < n; i++) { // 枚举规则\n                for (int j = 0, k = sa[i].length(); k <= cur.length(); j++, k++) { // 枚举字符\n                    if (sa[i].equals(cur.substring(j, k))) {\n                        String next = cur.substring(0, j) + sb[i] + cur.substring(k);\n                        if (dn.containsKey(next)) {\n                            return dp.get(cur) + 1 + dn.get(next);\n                        }\n                        // 去重\n                        if (dp.containsKey(next)) continue;\n                        dp.put(next, dp.get(cur) + 1);\n                        que.add(next);\n                    }\n                }\n            }\n        }\n        return 123456;\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [HDU-1195 Open the Lock](https://vjudge.net/problem/HDU-1195)\n\nNow an emergent task for you is to open a password lock. The password is consisted of four digits. Each digit is numbered from $1$ to $9$ .\nEach time, you can add or minus 1 to any digit. When add 1 to '9', the digit will change to be '1' and when minus 1 to '1', the digit will change to be '9'. You can also exchange the digit with its neighbor. Each action will take one step.\n\nNow your task is to use minimal steps to open the lock.\n\n**Note:** The leftmost digit is not the neighbor of the rightmost digit.\n\n**Input**\n\nThe input file begins with an integer T, indicating the number of test cases.\n\nEach test case begins with a four digit N, indicating the initial state of the password lock. Then followed a line with anotther four dight M, indicating the password which can open the lock. There is one blank line after each test case.\n\n**Output**\n\nFor each test case, print the minimal steps in one line.\n\n**Sample Input**\n```c\n2\n1234\n2144\n\n1111\n9999\n```\n\n**Sample Output**\n```c\n2\n4\n```\n\n### 解法一\n\n这题状态最多也就 $9^4$ ，其实完全不用双向 BFS，这里主要是为了练习。经过优化后时间减少了一半，还是很明显的。\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int[] d = {1, -1};\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int T = Integer.valueOf(br.readLine());\n        while (T-- > 0) {\n            String lock = br.readLine();\n            String pwd  = br.readLine();\n            out.println(bfs(lock, pwd));\n            br.readLine(); // 空行\n        }\n        out.flush();\n    }\n\n    //11^4\n    public static int bfs(String lock, String pwd) {\n        HashMap<String, Integer> dz = new HashMap<>();\n        HashMap<String, Integer> df = new HashMap<>();\n        Deque<String> qz = new ArrayDeque<>();\n        Deque<String> qf = new ArrayDeque<>();\n\n        qz.add(lock); qf.add(pwd);\n        dz.put(lock, 0); df.put(pwd, 0);\n        int ans = -1;\n        while (!qz.isEmpty() && !qf.isEmpty()) {\n            if (qz.size() < qf.size()) {\n                ans = expand(qz, dz, df);\n            } else {\n                ans = expand(qf, df, dz);\n            }\n            if (ans != -1) break;\n        }\n        return ans;\n    }\n\n    public static int expand(Deque<String> que, HashMap<String, Integer> dz, HashMap<String, Integer> df) {\n        int step = dz.get(que.peek());\n        while (!que.isEmpty() && step == dz.get(que.peek())) {\n            char[] cs = que.poll().toCharArray();\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < 2; j++) {\n                    change(cs, i, d[j]);\n                    String next = new String(cs);\n                    if (df.containsKey(next)) {\n                        return df.get(next) + step + 1;\n                    }\n                    if (!dz.containsKey(next)) {\n                        dz.put(next, step + 1);\n                        que.add(next);\n                    }\n                    change(cs, i, -d[j]);\n                }\n            }\n            for (int i = 0, j = i+1; j < 4; i++, j++) {\n                swap(cs, i, j);\n                String next = new String(cs);\n                if (df.containsKey(next)) {\n                    return df.get(next) + step + 1;\n                }\n                if (!dz.containsKey(next)) {\n                    dz.put(next, step + 1);\n                    que.add(next);\n                }\n                swap(cs, j, i);\n            }\n        }\n        return -1;\n    }\n\n    public static void change(char[] cs, int i, int d) {\n        if (cs[i] == '1' && d == -1) {\n            cs[i] = '9';\n            return;\n        }\n        if (cs[i] == '9' && d == 1) {\n            cs[i] = '1';\n            return;\n        }\n        cs[i] += d;\n    }\n\n    public static void swap(char[] cs, int a, int b) {\n        char t = cs[a];\n        cs[a] = cs[b];\n        cs[b] = t;\n    }\n}\n```\n\n## [HDU-1401 Solitaire](https://vjudge.net/problem/HDU-1401) \n\nSolitaire is a game played on a chessboard 8x8. The rows and columns of the chessboard are numbered from 1 to 8, from the top to the bottom and from left to right respectively.\n\nThere are four identical pieces on the board. In one move it is allowed to:\n\n> move a piece to an empty neighboring field (up, down, left or right),\n\n> jump over one neighboring piece to an empty field (up, down, left or right).\n\n![](https://i.loli.net/2021/09/16/NMzImTVRGlWYyQv.png)\n\nThere are 4 moves allowed for each piece in the configuration shown above. As an example let's consider a piece placed in the row 4, column 4. It can be moved one row up, two rows down, one column left or two columns right.\n\nWrite a program that:\n\n> reads two chessboard configurations from the standard input,\n\n> verifies whether the second one is reachable from the first one in at most 8 moves,\n\n> writes the result to the standard output.\n\n### 解法一\n同样，我们先分析暴力直接搜索的状态数量。4 个棋子，8x8 的棋盘，一共会有 $\\tbinom{4}{64}$ 种状态，数量还是很大的。同时题目限制了最多走 8 步，也就是说可能会有 $16^8$ 个分支，大于状态数量，不仅会爆栈，时间也会超限。这里就可以采用「双向 BFS」优化。\n\n我这里采用的「位压缩」来表示棋盘状态，用一个 long 长整形刚好。\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    // 64!\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null && !\"\".equals(line)) {\n            int[] as = toInts(line);\n            line = br.readLine();\n            int[] at = toInts(line);\n            long s = 0L, t = 0L;\n            for (int i = 0; i < 8; i += 2) {\n                s = s | (1L << convert(as[i], as[i+1]));\n                t = t | (1L << convert(at[i], at[i+1]));\n            }\n            out.println(bfs(s, t) ? \"YES\" : \"NO\");\n        }\n        out.flush();\n    }\n\n    public static boolean bfs(long s, long t) {\n        Deque<Long> qz = new ArrayDeque<>(), qf = new ArrayDeque<>();\n        HashMap<Long, Integer> dz = new HashMap<>(), df = new HashMap<>();\n        qz.add(s); dz.put(s, 0);\n        qf.add(t); df.put(t, 0);\n        int ans = -1;\n        while (!qz.isEmpty() && !qf.isEmpty()) {\n            if (qz.size() <= qf.size()) {\n                ans = expand(qz, dz, df);\n            } else {\n                ans = expand(qf, df, dz);\n            }\n            if (ans > 8) return false;\n            if (ans >= 0) return true;\n        }\n        return false;\n    }\n\n    public static int expand(Deque<Long> que, HashMap<Long, Integer> dz, HashMap<Long, Integer> df) {\n        int step = dz.get(que.peek());\n        while (!que.isEmpty() && step == dz.get(que.peek())) {\n            long cur = que.poll();\n            long bak = cur;\n            int cnt = 0;\n            while (cur != 0) {\n                if ((cur&1) == 1) {\n                    int x = cnt / 8 + 1;\n                    int y = cnt % 8 + 1;\n                    for (int[] d : dir) {\n                        int nx = x + d[0];\n                        int ny = y + d[1];\n                        if (nx < 1 || nx > 8 || ny < 1 || ny > 8) {\n                            continue;\n                        }\n                        if (((bak>>>convert(nx, ny)) & 1) == 1) {\n                            int nnx = nx + d[0];\n                            int nny = ny + d[1];\n                            if (nnx < 1 || nnx > 8 || nny < 1 || nny > 8) {\n                                continue;\n                            }\n                            if (((bak>>>convert(nnx, nny))&1)==1) {\n                                continue;\n                            }\n                            nx = nnx; ny = nny;\n                        }\n                        long val = bak ^ (1L << cnt) | (1L << (convert(nx, ny)));\n                        if (df.containsKey(val)) {\n                            return df.get(val) + step + 1;\n                        }\n                        if (!dz.containsKey(val)) {\n                            dz.put(val, step + 1);\n                            que.add(val);\n                        }\n                    }\n                }\n                cur >>>= 1;\n                cnt++;\n            }\n        }   \n        return -1;\n    }\n\n    public static int convert(int x, int y) {\n        return (x-1)*8 + y - 1;\n    }\n\n    public static int[] toInts(String str) throws Exception {\n        return Arrays.stream(str.split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n> 不太熟 HDOJ，看样例以为是单次输入，多次执行，谁知道它是一起输入的，还得自己判断结尾。在这里卡了好几天。.. 还是别人代码才发现，一直以为是自己代码有问题，吐了。\n","tags":["搜索，算法，最短路"],"categories":["算法"]},{"title":"搜索：0-1BFS","url":"/2021/08/21/91f9d060/","content":"\n## [175. 电路维修](https://www.acwing.com/problem/content/177/)\n达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。\n\n翰翰的家里有一辆飞行车。\n\n有一天飞行车的电路板突然出现了故障，导致无法启动。\n\n电路板的整体结构是一个 $R$ 行 $C$ 列的网格 $(R,C≤500)$ ，如下图所示。\n![](https://i.loli.net/2021/08/05/QXl6n9mGEA5PDOq.png)\n\n每个格点都是电线的接点，每个格子都包含一个电子元件。\n\n电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。\n\n在旋转之后，它就可以连接另一条对角线的两个接点。\n\n电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。\n\n达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。\n\n她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。\n\n不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。\n\n**注意**：只能走斜向的线段，水平和竖直线段不能走。\n\n**输入格式**\n\n输入文件包含多组测试数据。\n\n第一行包含一个整数 $T$ ，表示测试数据的数目。\n\n对于每组测试数据，第一行包含正整数 $R$ 和 $C$ ，表示电路板的行数和列数。\n\n之后 $R$ 行，每行 $C$ 个字符，字符是\"/\"和\"\\\"中的一个，表示标准件的方向。\n\n**输出格式**\n\n对于每组测试数据，在单独的一行输出一个正整数，表示所需的缩小旋转次数。\n\n如果无论怎样都不能使得电源和发动机之间连通，输出`NO SOLUTION`。\n\n**数据范围**\n- $1≤R,C≤500$\n- $1≤T≤5$\n\n**输入样例：**\n```c\n1\n3 5\n\\\\/\\\\\n\\\\///\n/\\\\\\\\\n```\n**输出样例：**\n```c\n1\n```\n\n### 解法一\n题中元件连接的是对角线的两个节点，每一次流动横纵坐标都是同时加 1，同时减 1，或者一个加 1 一个减 1，而我们是从左上角第一个节点（0，0）开始，所以途径的点横纵坐标之和必然是偶数，奇数点是不可达的。所以可以对偶数点建图然后直接跑 [Dijkstra](https://imlgw.top/2021/03/17/c163e5c9/) 来求，但是这里有更好的处理方式「双端队列广搜（0-1BFS）」\n\n通过偶数点建图时，如果两个点之间可以通过旋转元件连通，则权值为 1，如果不用旋转则权值为 0。图的权值只有 0 和 1，当 bfs 搜索的时候将权值为 0 的点加入队列头，权值为 1 的节点放到队尾，以此来保持单调性。这样队列头就是当前距离源点最近的点，出队列的时候标识已确定最短路，然后对出边进行松弛。\n\n其实整体的思想和 Dijkstra 是一样的，只是实现的方式不一样。可以理解为对 Dijkstra 的优化，在边权值只有 0 和 1 的时候采用双端队列维护最短路的单调性，将时间复杂度优化到 $O(N)$\n```python\nfrom collections import deque\n\nT = int(input())\n\n# 格点和斜线的方向向量，顺序要对应\nd1 = [[-1, -1], [-1, 1], [1, 1], [1, -1]]\nd2 = [[-1, -1], [-1, 0], [0, 0], [0, -1]]\nchs = '\\\\/\\\\/'\nwhile T > 0:\n    T = T - 1\n    r, c = map(int, input().split())\n    # 斜线\n    w = ['' for _ in range(r)]\n    # 格点\n    dis = [[float('inf') for _ in range(c + 1)] for _ in range(r + 1)]\n    vis = [[0 for _ in range(c + 1)] for _ in range(r + 1)]\n    for i in range(r):\n        w[i] = input()\n    if (r + c) & 1:\n        print('NO SOLUTION')\n        continue\n    q = deque()\n    q.append((0, 0))\n    dis[0][0] = 0\n    while q:\n        x, y = q.popleft()\n        if x == r and y == c:\n            break\n        if vis[x][y]:\n            continue\n        vis[x][y] = 1\n        # 遍历 4 个方向的格点\n        for i in range(4):\n            nx = x + d1[i][0]\n            ny = y + d1[i][1]\n            if nx < 0 or ny < 0 or nx >= r+1 or ny >= c+1:\n                continue\n            d = 0 if chs[i] == w[x + d2[i][0]][y + d2[i][1]] else 1\n            if dis[x][y] + d < dis[nx][ny]:\n                q.append((nx, ny)) if d else q.appendleft((nx, ny))\n                dis[nx][ny] = dis[x][y] + d\n    print(dis[r][c])\n```\n\n## [340. 通信线路](https://www.acwing.com/problem/content/342/)\n在郊区有 $N$ 座通信基站， $P$ 条 **双向** 电缆，第 $i$ 条电缆连接基站 $A_i$ 和 $B_i$ 。\n\n特别地， $1$ 号基站是通信公司的总站， $N$ 号基站位于一座农场中。\n\n现在，农场主希望对通信线路进行升级，其中升级第 $i$ 条电缆需要花费 $L_i$ 。\n\n电话公司正在举行优惠活动。\n\n农产主可以指定一条从 $1$ 号基站到 $N$ 号基站的路径，并指定路径上不超过 $K$ 条电缆，由电话公司免费提供升级服务。\n\n农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。\n\n求至少用多少钱可以完成升级。\n\n**输入格式**\n\n第 $1$ 行：三个整数 $N，P，K$ 。\n\n第 $2..P+1$ 行：第 $i+1$ 行包含三个整数 $A_i,B_i,L_i$ 。\n\n输出格式\n包含一个整数表示最少花费。\n\n若 $1$ 号基站与 $N$ 号基站之间不存在路径，则输出 $−1$ 。\n\n**数据范围**\n\n- $0≤K<N≤1000$\n- $1≤P≤10000$\n- $1≤L_i≤1000000$\n\n**输入样例：**\n```C\n5 7 1\n1 2 5\n3 1 4\n2 4 8\n3 2 3\n5 2 9\n3 4 7\n4 5 6\n```\n**输出样例：**\n```C\n4\n```\n\n### 解法一\n原题是 [[USACO08JAN]Telephone Lines S](https://www.luogu.com.cn/problem/P1948)（洛谷似乎对 Java 不太友好，之前只是听说时间不放宽，但是我发现似乎连 Java8 的语法支持都不全，导致我的输入板子会直接 RE。但是在它的在线 IDE 里面又是正常的，放弃了放弃了）\n\n这题题意再简化一下就是找到一条 $1$ 到 $N$ 的路径，求修建的最低费用。路径中有 $k$ 条是不用收费的，收费的是除了 $k$ 条路径之外，权值最高的那一条的修建费用。如果路径低于 $k$ 条显然就是完全免费了\n\n这题要求的是一个最大最小值，所以我们可以直接**二分**修建费用 res。然后 check 在 res 的限制下能否找到一条路径 cover 住，check 的方法也很简单，我们把路径中大于 res 的路径看做权值为 $1$ 的边，反之则看做权值为 $0$ 的边。这里的权值为消耗**免费路径**的条数，所以大于 res 的我们就让它走免费线路消耗免费额度，反之则不走不消耗免费额度。然后我们就可以做一个 01-BFS，求出 1-N 的最短路，最后判断消耗的免费额度是否超过 $k$ 就行了。时间复杂度 $O(P\\log{\\max(L_i)})$\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int N;\n    static int P;\n    static int K;\n    static int[] A, B, L;\n    static int idx;\n    static int[] e, ne, h, w;\n    static Deque<Integer> queue = new ArrayDeque<>();\n    static int INF = 0x3f3f3f3f;\n    static int[] dis;\n\n    //a->b\n    static void add(int a, int b, int c) {\n        e[idx] = b; w[idx] = c;\n        ne[idx] = h[a]; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        N = in[0]; P = in[1]; K = in[2];\n        L = new int[P+1]; A = new int[P+1]; B = new int[P+1];\n        e = new int[2*P+1]; ne = new int[2*P+1]; w = new int[2*P+1]; h = new int[N+1];\n        for (int i = 0; i < P; i++) {\n            int[] t = read(br);\n            A[i] = t[0]; B[i] = t[1]; L[i] = t[2];\n        }\n        int left = 0, right = 1000000;\n        int res = -1;\n        while (left <= right) {\n            int mid = left + (right-left)/2;\n            if (bfs(mid)) {\n                res = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static boolean bfs(int cost) {\n        queue.clear();\n        idx = 0;\n        Arrays.fill(e, 0);\n        Arrays.fill(w, 0);\n        Arrays.fill(ne, 0);\n        Arrays.fill(h, -1);\n        dis = new int[N+1];\n        Arrays.fill(dis, INF);\n        for (int i = 0; i < P; i++) {\n            // 大于 cost 的不付钱，算在免费的 K 条电缆中，消耗免费额度，权值为 1\n            // 小于等于 cost 的部分付 cost，不算在免费额度中，权值为 0（权值为消耗免费额度的数量，最后判断最短路能否小于 k）\n            add(A[i], B[i], (L[i] > cost) ? 1 : 0);\n            add(B[i], A[i], (L[i] > cost) ? 1 : 0);\n        }\n        queue.add(1);\n        dis[1] = 0;\n        while (!queue.isEmpty()) {\n            int i = queue.pop();\n            for (int j = h[i]; j != -1; j = ne[j]) {\n                if (dis[e[j]] > dis[i] + w[j]) {\n                    dis[e[j]] = dis[i] + w[j];\n                    if (w[j] == 0) {\n                        queue.addFirst(e[j]); \n                    } else {\n                        queue.add(e[j]);\n                    }\n                }\n            }\n        }\n        //System.out.printf(\"cost = %d, dis[N] = %d \\n\", cost, dis[N]);\n        return dis[N] <= K;\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n> 这题似乎还有别的做法，以后再来研究\n\n## [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)\n\nDifficulty: **困难**\n\n给你一个 m x n 的网格图 `grid` 。 `grid` 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 `grid[i][j]` 中的数字可能为以下几种情况：\n\n- **1** ，下一步往右走，也就是你会从 `grid[i][j]` 走到 `grid[i][j + 1]`\n- **2** ，下一步往左走，也就是你会从 `grid[i][j]` 走到 `grid[i][j - 1]`\n- **3** ，下一步往下走，也就是你会从 `grid[i][j]` 走到 `grid[i + 1][j]`\n- **4** ，下一步往上走，也就是你会从 `grid[i][j]` 走到 `grid[i - 1][j]`\n\n注意网格图中可能会有 **无效数字** ，因为它们可能指向 `grid` 以外的区域。\n\n一开始，你会从最左上角的格子 `(0,0)` 出发。我们定义一条 **有效路径** 为从格子 `(0,0)` 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 `(m - 1, n - 1)` 结束的路径。有效路径 **不需要是最短路径** 。\n\n你可以花费 `cost = 1` 的代价修改一个格子中的数字，但每个格子中的数字 **只能修改一次** 。\n\n请你返回让网格图至少有一条有效路径的最小代价。\n\n**示例 1：**\n\n![](https://i.loli.net/2021/08/21/8yuC15WLEg4di7Q.png)\n\n```c\n输入：grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n输出：3\n解释：你将从点 (0, 0) 出发。\n到达 (3, 3) 的路径为： (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) 花费代价 cost = 1 使方向向下 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) 花费代价 cost = 1 使方向向下 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) 花费代价 cost = 1 使方向向下 --> (3, 3)\n总花费为 cost = 3.\n```\n\n**示例 2：**\n\n![](https://i.loli.net/2021/08/21/1NPVla4A5Mrqk23.png)\n\n```c\n输入：grid = [[1,1,3],[3,2,2],[1,1,4]]\n输出：0\n解释：不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。\n```\n\n**示例 3：**\n\n![](https://i.loli.net/2021/08/21/fmEUdVt9s5oXvAS.png)\n\n```c\n输入：grid = [[1,2],[4,3]]\n输出：1\n```\n\n**示例 4：**\n\n```c\n输入：grid = [[2,2,2],[2,2,2]]\n输出：3\n```\n\n**示例 5：**\n\n```c\n输入：grid = [[4]]\n输出：0\n```\n\n**提示：**\n\n*   $\\text{m = grid.length}$\n*   $\\text{n = grid[i].length}$\n*   $1 \\leq m, n \\leq 100$\n\n### 解法一\n将修改次数作为权值，那么当前格点与箭头所指的相邻格点权值为 0，否则为 1，然后就成了典型的 0-1BFS，时间复杂度 $O(MN)$\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        # 顺序不能乱，1234 右左下上\n        dire = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        n, m = len(grid), len(grid[0])\n        dis = [[float('inf') for _ in range(m+1)] for _ in range(n+1)]\n        vis = [[0 for _ in range(m+1)] for _ in range(n+1)]\n        q = deque()\n        q.append((0, 0))\n        dis[0][0] = 0\n        while q:\n            x, y = q.popleft()\n            if vis[x][y]:\n                continue\n            vis[x][y] = 1\n            for i in range(4):\n                nx, ny = x+dire[i][0], y+dire[i][1]\n                if nx < 0 or ny < 0 or nx >= n or ny >= m:\n                    continue\n                w = 0 if (grid[x][y]-1) == i else 1\n                if dis[nx][ny] > dis[x][y] + w:\n                    dis[nx][ny] = dis[x][y] + w\n                    q.append((nx, ny)) if w else q.appendleft((nx, ny))\n        return dis[n-1][m-1]\n```\n这题其实还有个问题需要注意，题目中说了「每个格子中的数字只能修改一次」这个条件，但是实际上这对我们没有影响，经过第二次的修改次数肯定是大于等于第一次的。官方题解给出了证明，我不再赘述，上面 [电路维修](#175-电路维修)也有这个条件\n\n## [CF1063B. Labyrinth](https://codeforces.com/problemset/problem/1063/B)\n\nYou are playing some computer game. One of its levels puts you in a maze consisting of $n$ lines, each of which contains $m$ cells. Each cell either is free or is occupied by an obstacle. The starting cell is in the row $r$ and column $c$ . In one step you can move one square up, left, down or right, if the target cell is not occupied by an obstacle. You can't move beyond the boundaries of the labyrinth.\n\nUnfortunately, your keyboard is about to break, so you can move left no more than $x$ times and move right no more than $y$ times. There are no restrictions on the number of moves up and down since the keys used to move up and down are in perfect condition.\n\nNow you would like to determine for each cell whether there exists a sequence of moves that will put you from the starting cell to this particular one. How many cells of the board have this property?\n\n**Input**\n\nThe first line contains two integers $n, m (1 ≤ n, m ≤ 2000)$ — the number of rows and the number columns in the labyrinth respectively.\n\nThe second line contains two integers $r, c (1 ≤ r ≤ n, 1 ≤ c ≤ m)$ — index of the row and index of the column that define the starting cell.\n\nThe third line contains two integers $x, y (0 ≤ x, y ≤ 109)$ — the maximum allowed number of movements to the left and to the right respectively.\n\nThe next n lines describe the labyrinth. Each of them has length of m and consists only of symbols `.` and `*`. The $j$ -th character of the $i$ -th line corresponds to the cell of labyrinth at row $i$ and column $j$ . Symbol `.` denotes the free cell, while symbol `*` denotes the cell with an obstacle.\n\nIt is guaranteed, that the starting cell contains no obstacles.\n\n**Output**\n\nPrint exactly one integer — the number of cells in the labyrinth, which are reachable from starting cell, including the starting cell itself.\n\n**Examples**\n```c\n4 5\n3 2\n1 2\n.....\n.***.\n...**\n*....\n```\n**out**\n```c\n10\n```\n\n### 解法一\n很容易写错的一道题，不细想很可能写出下面的代码\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static int N, M;\n    static int R, C;\n    static int X, Y;\n    static int[][] grid;\n    static boolean[][] vis;\n    static int[][] remainX, remainY;\n    // 左右下上\n    static int[][] dir = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] nm = read(br);\n        N = nm[0]; M = nm[1];\n        int[] rc = read(br);\n        R = rc[0]; C = rc[1];\n        int[] xy = read(br);\n        X = xy[0]; Y = xy[1];\n\n        grid = new int[N][M];\n        vis = new boolean[N+1][M+1];\n        remainX = new int[N+1][M+1];\n        remainY = new int[N+1][M+1];\n        remainX[R][C] = X;\n        remainY[R][C] = Y;\n\n        for (int i = 0; i < N; i++) {\n            grid[i] = read0(br);\n        }\n\n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.add(new int[]{R, C});\n        vis[R][C] = true;\n        int cnt = 0;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int x = cur[0], y = cur[1];\n            cnt++;\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dir[i][0];\n                int ny = y + dir[i][1];\n                if ((i==0 && remainX[x][y]==0) || (i==1 && remainY[x][y]==0)) {\n                    continue;\n                }\n                if (nx <= 0 || ny <= 0 || nx > N || ny > M || vis[nx][ny] || grid[nx-1][ny-1] == '*') {\n                    continue;\n                }\n                queue.add(new int[]{nx, ny});\n                vis[nx][ny] = true;\n                remainX[nx][ny] = remainX[x][y] - (i==0 ? 1 : 0);\n                remainY[nx][ny] = remainY[x][y] - (i==1 ? 1 : 0);\n            }\n        }\n        out.println(cnt);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n\n    public static int[] read0(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\"\")).mapToInt(c->(int)c.charAt(0)).toArray();\n    }\n}\n\n// public class CF1063B_Labyrinth {\n//     public static void main(String[] args) throws Exception {\n//         for (int i = 0; i < 3; i++) {\n//             new Main().main();\n//         }\n//     }\n// }\n```\n</details>\n\n但是上面忽略了一个很重要的问题，就是一个点可能会重复的到达，而到达的路径和方式不同消耗的左右步数也不同，很可能第一次到达该点时候消耗的左右步数并不是最少的，进而导致某些点可能明明可以到达但是漏掉了。\n\n一个很容易想到的解决方法是在再次访问到某节点的时候保留消耗最小的数据，这样就不会漏掉。这里还有一种解决方案就是本文的重点「0-1BFS」，我们将纵向的移动看做权值为 0，将横向的移动看做权值为 1，然后求最短路。这样就能保证到每个节点的时候消耗都是最小的，最终能访问到的节点也是最多的\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class CF1063B_Labyrinth {\n    public static void main(String[] args) throws Exception {\n        new Main().main();\n    }\n}\n\nclass Main {\n\n    static int N, M;\n    static int R, C;\n    static int X, Y;\n    static int[][] grid;\n    static boolean[][] vis;\n    static int[][] remainX, remainY;\n    // 左右下上\n    static int[][] dir = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] nm = read(br);\n        N = nm[0]; M = nm[1];\n        int[] rc = read(br);\n        R = rc[0]; C = rc[1];\n        int[] xy = read(br);\n        X = xy[0]; Y = xy[1];\n\n        grid = new int[N][M];\n        vis = new boolean[N+1][M+1];\n        remainX = new int[N+1][M+1];\n        remainY = new int[N+1][M+1];\n        remainX[R][C] = X;\n        remainY[R][C] = Y;\n\n        for (int i = 0; i < N; i++) {\n            grid[i] = read0(br);\n        }\n\n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.add(new int[]{R, C});\n        vis[R][C] = true;\n        int cnt = 0;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int x = cur[0], y = cur[1];\n            cnt++;\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dir[i][0];\n                int ny = y + dir[i][1];\n                if ((i==0 && remainX[x][y]==0) || (i==1 && remainY[x][y]==0)) {\n                    continue;\n                }\n                if (nx <= 0 || ny <= 0 || nx > N || ny > M || vis[nx][ny] || grid[nx-1][ny-1] == '*') {\n                    continue;\n                }\n                if (i == 2 || i == 3) {\n                    queue.addFirst(new int[]{nx, ny});\n                } else {\n                    queue.add(new int[]{nx, ny});\n                }\n                vis[nx][ny] = true;\n                remainX[nx][ny] = remainX[x][y] - (i==0 ? 1 : 0);\n                remainY[nx][ny] = remainY[x][y] - (i==1 ? 1 : 0);\n            }\n        }\n        out.println(cnt);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n\n    public static int[] read0(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\"\")).mapToInt(c->(int)c.charAt(0)).toArray();\n    }\n}\n```\n\n## [CF173B. Chamber of Secrets](https://codeforces.com/contest/173/problem/B)\n\n\"The Chamber of Secrets has been opened again\" — this news has spread all around Hogwarts and some of the students have been petrified due to seeing the basilisk. Dumbledore got fired and now Harry is trying to enter the Chamber of Secrets. These aren't good news for Lord Voldemort. The problem is, he doesn't want anybody to be able to enter the chamber. The Dark Lord is going to be busy sucking life out of Ginny.\n\nThe Chamber of Secrets is an $n × m$ rectangular grid in which some of the cells are columns. A light ray (and a basilisk's gaze) passes through the columns without changing its direction. But with some spell we can make a column magic to reflect the light ray (or the gaze) in all four directions when it receives the ray. This is shown in the figure below.\n\n![](https://espresso.codeforces.com/9cfd9e8e43fd3d2588d340d44ee464a2a0be8455.png)\n\nThe basilisk is located at the right side of the lower right cell of the grid and is looking to the left (in the direction of the lower left cell). According to the legend, anyone who meets a basilisk's gaze directly dies immediately. But if someone meets a basilisk's gaze through a column, this person will get petrified. We know that the door to the Chamber is located on the left side of the upper left corner of the grid and anyone who wants to enter will look in the direction of its movement (in the direction of the upper right cell) from that position.\n\n![](https://espresso.codeforces.com/331328766492501ef28044eb2346ca44f81d764e.png)\n\nGiven the dimensions of the chamber and the location of regular columns, Lord Voldemort has asked you to find the minimum number of columns that we need to make magic so that anyone who wants to enter the chamber would be petrified or just declare that it's impossible to secure the chamber.\n\n**Input**\n\nThe first line of the input contains two integer numbers n and m $(2 ≤ n, m ≤ 1000)$ . Each of the next $n$ lines contains $m$ characters. Each character is either \".\" or \"#\" and represents one cell of the Chamber grid. It's \".\" if the corresponding cell is empty and \"#\" if it's a regular column.\n\n**Output**\n\nPrint the minimum number of columns to make magic or -1 if it's impossible to do.\n\n**Examples**\n```C\n3 3\n.#.\n...\n.#.\n```\n\n**oUT**\n```C\n2\n```\n\n**Note**\n\nThe figure above shows the first sample test. In the first sample we should make both columns magic. The dragon figure represents the basilisk and the binoculars represent the person who will enter the Chamber of secrets. The black star shows the place where the person will be petrified. Yellow lines represent basilisk gaze moving through columns.\n\n### 解法一\n\n顺着「0-1BFS」搜索到的题，但是并没有写出对应的做法，这题「0-1BFS」并不是最优解，这题我 Java 用「0-1BFS」直接超时了。\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n \npublic class CF173B_ChamberOfSecrets {\n    public static void main(String[] args) throws Exception {\n        new Main().main();\n    }\n}\n \nclass Main {\n \n    static int N, M;\n    static char[][] grid;\n    static boolean[][][] vis;\n    static int[][][] dis;\n    static int INF = 0x3f3f3f3f;\n    static int[][] dir = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n \n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] nm = read(br);\n        N = nm[0]; M = nm[1];\n \n        grid = new char[N+1][M+1];\n        vis = new boolean[N+1][M+1][4];\n        dis = new int[N+1][M+1][4];\n \n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= M; j++) {\n                Arrays.fill(dis[i][j], INF);\n            }\n        }\n        for (int i = 1; i <= N; i++) {\n            grid[i] = (\"0\"+br.readLine()).toCharArray();\n        }\n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.add(new int[]{N, M, 0});\n        dis[N][M][0] = 0;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int x = cur[0], y = cur[1], p = cur[2];\n            if (x == 1 && y == 1 && p == 0) break;\n            if (vis[x][y][p]) continue;\n            vis[x][y][p] = true;\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dir[i][0], ny = y + dir[i][1];\n                if (nx <= 0 || nx > N || ny <= 0 || ny > M) continue;\n                if (i == p) {\n                    queue.addFirst(new int[]{nx, ny, p});\n                    dis[nx][ny][i] = dis[x][y][p];\n                } else if (grid[x][y] == '#') {\n                    if (dis[x][y][p] + 1 < dis[nx][ny][i]) {\n                        dis[nx][ny][i] = dis[x][y][p] + 1;\n                        queue.add(new int[]{nx, ny, i});\n                    }\n                }\n            }\n        }\n        out.println(dis[1][1][0]==INF ? -1 : dis[1][1][0]);\n        out.flush();\n    }\n \n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n### 解法二\n\n也是我一开始想出来的解法，直接将行列看做点，横纵之间权值为 1。从最后一行开始，然后求第一行的最短路 $dis[1]$ 就行了，权值为 1 直接 BFS 就行了，应该是最优解，时间复杂度 $O(N+M)$\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class CF173B_ChamberOfSecrets {\n    public static void main(String[] args) throws Exception {\n        new Main().main();\n    }\n}\n\nclass Main {\n\n    static int N, M;\n    static char[][] grid;\n    static boolean[] vis;\n    static int[] dis;\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] nm = read(br);\n        N = nm[0]; M = nm[1];\n\n        grid = new char[N+1][M+1];\n        vis = new boolean[N+M+1];\n        dis = new int[N+M+1];\n\n        for (int i = 1; i <= N; i++) {\n            grid[i] = (\"0\"+br.readLine()).toCharArray();\n        }\n        Deque<Integer> queue = new ArrayDeque<>();\n        queue.add(N);\n        vis[N] = true;\n        dis[N] = 0;\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            if (cur == 1) break;\n            if (cur <= N) { // 横向线条\n                for (int j = 1; j <= M; j++) {\n                    if (!vis[j+N] && grid[cur][j] == '#') {\n                        queue.add(j+N);\n                        dis[j+N] = dis[cur] + 1;\n                        vis[j+N] = true;\n                    }\n                }\n            } else {\n                for (int i = 1; i <= N; i++) {\n                    if (!vis[i] && grid[i][cur-N] == '#') {\n                        queue.add(i);\n                        dis[i] = dis[cur] + 1;\n                        vis[i] = true;\n                    }\n                }\n            }\n        }\n        out.println(dis[1]==0 ? -1 : dis[1]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n翻了一下前排的做法，发现我的代码和 [Petr](https://codeforces.com/contest/173/submission/1480876) 好像🤣","tags":["算法","搜索","最短路"],"categories":["算法"]},{"title":"算法分类导航","url":"/2021/07/20/48848a8a/","content":"\n> 博客文章链接生成方式改变，之前的链接都失效。重新整理下，文章置顶作为导航页面，后续有新文章有更新也会同步更新该页面\n\n# LeetCode\n\n| 类别                                                      | 地址                                   |\n| --------------------------------------------------------- | -------------------------------------- |\n| [链表](https://imlgw.top/2019/02/27/bef97aa3//)           | https://imlgw.top/2019/02/27/bef97aa3/ |\n| [数组](https://imlgw.top/2019/05/04/a9999be0/)            | https://imlgw.top/2019/05/04/a9999be0/ |\n| [栈 & 队列](https://imlgw.top/2019/10/01/627d9e22/)       | https://imlgw.top/2019/10/01/627d9e22/ |\n| [查找](https://imlgw.top/2019/09/15/ae50c318/)            | https://imlgw.top/2019/09/15/ae50c318/ |\n| [滑动窗口](https://imlgw.top/2019/07/20/41e491de/)        | https://imlgw.top/2019/07/20/41e491de/ |\n| [动态规划](https://imlgw.top/2019/09/01/ece53aaa/)        | https://imlgw.top/2019/09/01/ece53aaa/ |\n| [二分查找](https://imlgw.top/2019/12/06/ac033e1a/)        | https://imlgw.top/2019/12/06/ac033e1a/ |\n| [二叉树](https://imlgw.top/2019/11/06/43c532c9/)          | https://imlgw.top/2019/11/06/43c532c9/ |\n| [背包问题](https://imlgw.top/2019/11/29/f68a53d9/)        | https://imlgw.top/2019/11/29/f68a53d9/ |\n| [回溯](https://imlgw.top/2019/10/10/26679fc/)             | https://imlgw.top/2019/10/10/26679fc/  |\n| [贪心](https://imlgw.top/2020/01/21/a91acf16/)            | https://imlgw.top/2020/01/21/a91acf16/ |\n| [位运算](https://imlgw.top/2020/07/03/a9fb61a5/)          | https://imlgw.top/2020/07/03/a9fb61a5/ |\n| [单调栈](https://imlgw.top/2020/08/28/bdc9d1de/)          | https://imlgw.top/2020/08/28/bdc9d1de/ |\n| [并查集](https://imlgw.top/2020/02/02/c517589e/)          | https://imlgw.top/2020/02/02/c517589e/ |\n| [Rabin-Karp 算法](https://imlgw.top/2020/07/01/194514a9/) | https://imlgw.top/2020/07/01/194514a9/ |\n| [KMP](https://imlgw.top/2020/05/13/2da0528d/)             | https://imlgw.top/2020/05/13/2da0528d/ |\n| [排序](https://imlgw.top/2018/12/11/83535e94/)            | https://imlgw.top/2018/12/11/83535e94/ |\n\n# Competition-algorithm\n一些竞赛性质的算法学习，题目大多来源于 yxc 的 [算法提高课](https://www.acwing.com/activity/content/16/)，同时也有一些自己的理解和额外整理\n\n## 比赛\n### AtCoder\n- [ABC190](https://imlgw.top/2021/02/04/891c3448/)\n- [ABC189](https://imlgw.top/2021/01/28/e9dbbdad/)\n- [ABC188](https://imlgw.top/2021/01/21/9edc8d3b/)\n- [ABC261](https://imlgw.top/2022/07/24/7bc5a648/)\n\n### LeetCode\n- [42th 双周赛](https://imlgw.top/2021/01/06/f0b3824b/)\n- [220th 周赛](https://imlgw.top/2020/12/29/8e50a4df/)\n- [295th 周赛](https://imlgw.top/2022/06/01/1cbd408/)\n\n## 动态规划\n- [数字三角形模型](https://imlgw.top/2020/11/09/22c967e1/)\n- [最长上升子序列模型](https://imlgw.top/2020/11/14/f00d00a3/)\n- [背包模型](https://imlgw.top/2021/03/02/e60f310b/)\n- [计数 DP](https://imlgw.top/2021/04/09/b34c4165/)\n- [状态机模型](https://imlgw.top/2022/01/01/2fc471b9/)\n- 状态压缩 DP\n- 区间 DP\n- 树形 DP\n- 数位 DP\n- 单调队列优化 DP\n- 斜率优化 DP\n\n## 贪心\n- [绝对值不等式](https://imlgw.top/2021/01/10/6134a4bc/)\n- 排序不等式\n- 区间问题\n\n## 搜索\n- [Flood Fill](https://imlgw.top/2021/03/25/89c67f8e/)\n- 最短路模型\n- 多源 BFS\n- 最小步数模型\n- [双端队列广搜](https://imlgw.top/2021/08/21/91f9d060/)\n- [双向广搜](https://imlgw.top/2021/09/19/b9d77e2c/)\n- A*\n- DFS 之连通性模型\n- DFS 之搜索顺序\n- DFS 之剪枝与优化\n- 迭代加深\n- 双向 DFS\n- IDA*\n\n## 图论\n- [常见最短路模板](https://imlgw.top/2021/03/17/c163e5c9/)\n- [单源最短路的建图方式](https://imlgw.top/2021/03/28/8e9b2c41/)\n- [单源最短路的综合应用](https://imlgw.top/2022/05/20/d2494640/)\n- [单源最短路的扩展应用](https://imlgw.top/2022/05/20/d2494640/)\n- Floyd 算法\n- 最小生成树\n- 最小生成树的扩展应用\n- 负环\n- 差分约束\n- 最近公共祖先\n- 有向图的强连通分量\n- 无向图的双连通分量\n- 二分图\n- 欧拉回路和欧拉路径\n- 拓扑排序\n\n## 高级数据结构\n- [并查集](https://imlgw.top/2020/02/02/c517589e/)\n- 树状数组\n- 线段树\n- 可持久化数据结构\n- 平衡树\n- AC 自动机\n\n## 数学知识\n...\n## 基础算法\n...\n","tags":["算法"],"categories":["算法"]},{"title":"基础：前缀和&差分","url":"/2021/07/04/ba5f35c5/","content":"\n> 工作后好久没发新文章了，有些文章其实是很久之前就写完了，但是一直没发。最近搬家了，开始了新的生活，先慢慢找回之前的节奏，把坑都填完\n\n## [796. 子矩阵的和（模板题）](https://www.acwing.com/problem/content/description/798/)\n\n输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个询问，每个询问包含四个整数 $x_1,y_1,x_2,y_2$ ，表示一个子矩阵的左上角坐标和右下角坐标。\n\n对于每个询问输出子矩阵中所有数的和。\n\n**输入格式**\n\n第一行包含三个整数 $n，m，q$ 。\n\n接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。\n\n接下来 $q$ 行，每行包含四个整数 $x_1,y_1,x_2,y_2$ ，表示一组询问。\n\n**输出格式**\n\n共 $q$ 行，每行输出一个询问的结果。\n\n**数据范围**\n- $1≤n,m≤1000$\n- $1≤q≤200000$\n- $1≤x1≤x_2≤n$\n- $1≤y1≤y_2≤m$\n- $−1000≤v≤1000$\n\n**输入样例：**\n```c\n3 4 3\n1 7 2 4\n3 6 2 8\n2 1 2 3\n1 1 2 2\n2 1 3 4\n1 3 3 4\n```\n**输出样例：**\n```c\n17\n27\n21\n```\n### 解法一\n二维前缀和模板，一维的模板比较简单就不多写了\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1], Q = in[2];\n        int[][] sum = new int[N+1][M+1];\n        for (int i = 1; i <= N; i++) {\n            int[] t = read(br);\n            for (int j = 1; j <= M; j++) {\n                sum[i][j] = t[j-1] + sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1];\n            }\n        }\n        for (int i = 0; i < Q; i++) {\n            int[] q = read(br);\n            int x1 = q[0], y1 = q[1];\n            int x2 = q[2], y2 = q[3];\n            out.println(sum[x2][y2]-(sum[x1-1][y2]+sum[x2][y1-1])+sum[x1-1][y1-1]);\n        }\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [99. 激光炸弹](https://www.acwing.com/problem/content/description/101/)\n\n地图上有 $N$ 个目标，用整数 $X_i,Y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $W_i$ 。\n\n**注意**：不同目标可能在同一位置。\n\n现在有一种新型的激光炸弹，可以摧毁一个包含 $R×R$ 个位置的正方形内的所有目标。\n\n激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 $x，y$ 轴平行。\n\n求一颗炸弹最多能炸掉地图上总价值为多少的目标。\n\n**输入格式**\n\n第一行输入正整数 $N$ 和 $R$ ，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。\n\n接下来 $N$ 行，每行输入一组数据，每组数据包括三个整数 $X_i,Y_i,W_i$ ，分别代表目标的 $x$ 坐标， $y$ 坐标和价值，数据用空格隔开。\n\n**输出格式**\n\n输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。\n\n**数据范围**\n- $0≤R≤10^9$\n- $0<N≤10000$\n- $0≤X_i,Y_i≤5000$\n- $0≤W_i≤1000$\n\n**输入样例：**\n```c\n2 1\n0 0 1\n1 1 1\n```\n**输出样例：**\n```c\n1\n```\n### 解法一\n其实也是个模板题。.. 注意多个目标会在同一个点\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int MAX = 5010;\n        int N = in[0], R = in[1];\n        int[][] w = new int[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            int[] t = read(br);\n            w[t[0]][t[1]] += t[2];\n        }\n        int[][] sum = new int[MAX][MAX];\n        for (int i = 1; i < MAX; i++) {\n            for (int j = 1; j < MAX; j++) {\n                sum[i][j] = w[i-1][j-1] + sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1];\n            }\n        }\n        int res = 0;\n        for (int i = 1; i < MAX; i++) {\n            if (i+R-1 >= MAX) break;\n            for (int j = 1; j < MAX; j++) {\n                if (j+R-1 >= MAX) break;\n                int i2 = i+R-1, j2 = j+R-1;\n                res = Math.max(res, sum[i2][j2]-sum[i-1][j2]-sum[i2][j-1]+sum[i-1][j-1]);\n            }\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/) \n\n给你一个大小为 `m x n` 的矩阵 `mat` 和一个整数阈值 `threshold`。\n\n请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 $0$ 。\n\n**示例 1：**\n\n![Y2wPne.png](https://s1.ax1x.com/2020/05/17/Y2wPne.png)\n\n```c\n输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\n输出：2\n解释：总和小于 4 的正方形的最大边长为 2，如图所示。\n```\n\n**示例 2：**\n\n```c\n输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\n输出：0\n```\n\n**示例 3：**\n\n```c\n输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6\n输出：3\n```\n\n**示例 4：**\n\n```java\n输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184\n输出：2\n```\n\n**提示：**\n\n- $1 \\leq m, n \\leq 300$\n- $m = mat.length$\n- $n = mat[i].length$\n- $0 \\leq mat[i][j] \\leq 10000$\n- $0 \\leq threshold \\leq 10^5$\n\n### 解法一\n> 这里直接将之前的 [题解](https://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/#1292-%E5%85%83%E7%B4%A0%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BE%B9%E9%95%BF) 搬过来了，相对来说这题就没那么模板了，结合了二分，还是挺好的\n\n首先看到这道题就意识到了这是个二分答案的题，直接二分边长就行了，左端点 $1$ ，右端点 $\\min(m,n)$ ，某个边长 $x$ 满足的时候，大于 $x$ 的都满足，某个 $x$ 不满足的时候，小于 $x$ 的都不满足，解空间具有单调性\n\n所以关键问题就是`check`怎么写，如果直接暴力枚举所有矩形然后计算时间复杂度会很恐怖，这个时候就可以引入**二维前缀和**，在 $O(1)$ 的时间下求出子矩阵的和\n\n```java\nclass Solution {\n\n    int[][] sum;\n\n    public int maxSideLength(int[][] mat, int threshold) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int left = 1, right = Math.min(m, n);\n        sum = new int[m+1][n+1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = mat[i-1][j-1] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n            }\n        }\n        int res = 0;\n        while(left <= right){\n            int mid = left + (right-left)/2;\n            if(check(mat, mid, threshold)){\n                res = mid;\n                left = mid+1;\n            }else{\n                right = mid-1;\n            }\n        }\n        return res;\n    }\n    \n    public boolean check(int[][] mat, int side, int threshold){\n        //枚举所有的左端点\n        for (int i = 1; i+side-1 <= mat.length; i++) {\n            for (int j = 1; j+side-1 <= mat[0].length; j++) {\n                int ri = i+side-1, rj = j+side-1;\n                if(sum[ri][rj]-sum[i-1][rj]-sum[ri][j-1]+sum[i-1][j-1] <= threshold){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n## [798. 差分矩阵（模板题）](https://www.acwing.com/problem/content/description/800/)\n输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个操作，每个操作包含五个整数 $x_1,y_1,x_2,y_2,c$ ，其中 $(x_1,y_1)$ 和 $(x_2,y_2)$ 表示一个子矩阵的左上角坐标和右下角坐标。\n\n每个操作都要将选中的子矩阵中的每个元素的值加上 $c$ 。\n\n请你将进行完所有操作后的矩阵输出。\n\n**输入格式**\n\n第一行包含整数 $n,m,q$ 。\n\n接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。\n\n接下来 $q$ 行，每行包含 $5$ 个整数 $x_1,y_1,x_2,y_2,c$ ，表示一个操作。\n\n**输出格式**\n\n共 $n$ 行，每行 $m$ 个整数，表示所有操作进行完毕后的最终矩阵。\n\n**数据范围**\n- $1≤n,m≤1000$\n- $1≤q≤100000$\n- $1≤x1≤x2≤n$\n- $1≤y1≤y2≤m$\n- $−1000≤c≤1000$\n- $−1000≤v≤1000$\n\n**输入样例：**\n```c\n3 4 3\n1 2 2 1\n3 2 2 1\n1 1 1 1\n1 1 2 2 1\n1 3 2 3 2\n3 1 3 4 1\n```\n**输出样例：**\n```c\n2 3 4 1\n4 3 4 1\n2 2 2 2\n```\n### 解法一\n二维差分模板题，一维的模板也比较简单就不多写了，二维的需要多说几句\n\n和前缀和相反，矩阵中某个元素 $matrix[i][j]$ 的值是差分数组 $(0,0)$ 到 $(i,j)$ 的二维前缀和，所以当我们给某个点 $(i,j)$ 的差分值加 $c$ 的时候，会使以该点为左上角，到整个矩阵的右下角 $(n,m)$ 的矩阵区域**元素值**增加 $c$\n，如下图当给 $(x_1, y_1)$ 的差分值增加 $c$ 的时候，会使得整个蓝色框区域的矩阵元素值都增加 $c$\n![mark](https://static.imlgw.top/blog/20210404/CekHvl3vfuR8.png)\n但是这里我们只希望子矩阵 $(x_1,y_1),(x_2,y_2)$ 的值增加，所以我们需要将其它区域的值减回去。所以我们给 $(x_1,y_2+1)$ 以及 $(x_2+1,y_1)$ 的差分值减 $c$ ，注意这两块有一个重合区域 $(x_2+1,y_2+1)$ 多减了一次，我们将其加回来就行了\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int[][] diff;\n    static int n, m, q;\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        n = in[0]; m = in[1]; q = in[2];\n        diff = new int[n+2][m+2];\n        for (int i = 1; i <= n; i++) {\n            int[] t = read(br);\n            for (int j = 1; j <= m; j++) {\n                incr(i, j, i, j, t[j-1]);\n            }\n        }\n        for (int i = 0; i < q; i++) {\n            int[] q = read(br);\n            incr(q[0], q[1], q[2], q[3], q[4]);\n        }\n        int[][] matrix = new int[n+2][m+2];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                matrix[i][j] = diff[i][j] + matrix[i-1][j] + matrix[i][j-1] - matrix[i-1][j-1];\n                out.print(matrix[i][j] + \" \");\n            }\n            out.println();\n        }\n        out.flush();\n    }\n\n    public static void incr(int x1, int y1, int x2, int y2, int c) {\n        diff[x1][y1] += c;\n        diff[x1][y2+1] -= c;\n        diff[x2+1][y1] -= c;\n        diff[x2+1][y2+1] += c;\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [100. 增减序列](https://www.acwing.com/problem/content/description/102/)\n\n给定一个长度为 $n$ 的数列 $a_1,a_2,…,a_n$ ，每次可以选择一个区间 $[l,r]$ ，使下标在这个区间内的数都加一或者都减一。\n\n求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。\n\n**输入格式**\n\n第一行输入正整数 $n$ 。\n\n接下来 $n$ 行，每行输入一个整数，第 $i+1$ 行的整数代表 $a_i$ 。\n\n**输出格式**\n\n第一行输出最少操作次数。\n\n第二行输出最终能得到多少种结果。\n\n**数据范围**\n- $0<n≤105$\n- $0≤a_i<2147483648$\n\n**输入样例：**\n```c\n4\n1\n2\n```\n**输出样例：**\n```c\n1\n2\n```\n\n### 解法一\n构建差分数组 $d$ ，根据题目要求，我们的目标就是使得 $d_{i(2 \\leq i \\leq n)}=0$ 的最小操作次数，一次操作可以使得 $d$ 中任意两个元素，一个加 1，一个减 1，并且求保证最小操作次数的同时， $d_1$ 有几种取值情况\n\n这里我们可以将操作按照两个元素的位置进行分类：\n\n1.  当 $2 \\leq i \\leq j \\leq n$ 时， $d_i$ 加一（减一）， $d_j$ 减一（加一）\n2.  当 $i=1 \\And 2 \\leq j \\leq n$ 时， $d_1$ 加一（减一）， $d_j$ 减一（加一），这种情况就只会修改 $d_{j(2 \\leq j \\leq n)}$ 中的一个值，同时使得 $d_1$ 值不同\n3.  当 $2 \\leq i \\leq n \\And j=n$ 时， $d_i$ 加一（减一）， $d_n$ 减一（加一）\n4.  当 $i=1 \\And j=n$ 时，整体加减一，没有意义\n\n设 $d_{i(2 \\leq i \\leq n)}$ 中正数之和为 $p$ ，负数绝对值之和为 $q$ ，那么最快使得 $d_{i(2 \\leq i \\leq n)}=0$ 的操作方式就是每次从中选取一个正数一个负数，使得正数减一，负数加一，操作次数为 $\\min(p,q)$ ，这样正负数配对后，剩下的部分就选择操作 2 或者操作 3 进行加一或者减一使其归 0，操作次数为 $|p-q|$ ，所以操作总数为： $\\min(p,q)+|p-q| = \\max(p,q)$\n\n第二问求 $d_1$ 的取值情况，其实就是在执行完操作 1 后，剩下的部分执行 2 和 3 所能得到的不同的 $d_1$ 值，而这 2 种操作中能影响 $d_1$ 的值的就只有第 2 类操作，执行 $x$ 次第二类操作，就会使得 $d_1$ 加 $x$ 或者减 $x$ （ $p$ 较大时 $d_1$ 加 $x$ ，反之减 $x$ ），执行不同的次数，就能得到不同的 $d_1$ 值，执行完操作 1 后剩余的部分一共 $|p-q|$ ，所以操作 2 的执行次数就有 $|p-q|+1$ 种情况，对应 $|p-q|+1$ 种 $d_1$ 值\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = read(br);\n        int[] diff = new int[N+2];\n        for (int i = 1; i <= N; i++) {\n            int t = read(br);\n            diff[i] += t; diff[i+1] -= t;\n        }\n        long p = 0, q = 0;\n        for (int i = 2; i <= N; i++) {\n            if (diff[i] > 0) {\n                p += diff[i];\n            } else {\n                q -= diff[i];\n            }\n        }\n        out.println(Math.max(p, q));\n        out.println(Math.abs(p-q)+1);\n        out.flush();\n    }\n\n    public static int read(BufferedReader br) throws Exception {\n        return Integer.valueOf(br.readLine());\n    }\n}\n```\n\n## [1526. 形成目标数组的子数组最少增加次数](https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/)\n\nDifficulty: **困难**\n\n给你一个整数数组 `target` 和一个数组 `initial` ，`initial` 数组与 `target`  数组有同样的维度，且一开始全部为 0 。\n\n请你返回从 `initial` 得到  `target` 的最少操作次数，每次操作需遵循以下规则：\n\n*   在 `initial` 中选择 **任意** 子数组，并将子数组中每个元素增加 1 。\n\n答案保证在 32 位有符号整数以内。\n\n**示例 1：**\n\n```c\n输入：target = [1,2,3,2,1]\n输出：3\n解释：我们需要至少 3 次操作从 intial 数组得到 target 数组。\n[0,0,0,0,0] 将下标为 0 到 4 的元素（包含二者）加 1 。\n[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。\n[1,2,2,2,1] 将下表为 2 的元素增加 1 。\n[1,2,3,2,1] 得到了目标数组。\n```\n\n**示例 2：**\n\n```c\n输入：target = [3,1,1,2]\n输出：4\n解释：(initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target) 。\n```\n\n**示例 3：**\n\n```c\n输入：target = [3,1,5,4,2]\n输出：7\n解释：(initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] \n                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target)。\n```\n\n**示例 4：**\n\n```c\n输入：target = [1,1,1,1]\n输出：1\n```\n\n**提示：**\n\n*   $1 \\leq target.length \\leq 10^5$\n*   $1 \\leq target[i] \\leq 10^5$\n\n### 解法一\n31th 双周赛 t4，首先明白一点，将数组从 $[0...0]$ 通过加一变为`target`等价于将`target`通过减一变为 $[0...0]$\n\n和上面一题一样，不过这题是要连同 $d_1$ 一起变为 0，且 $a_i\\geq 1$ ，所以 $\\sum_{i=0}^nd_i \\geq 1$ ，对应上题中就是 $p > q$ ，所以最小操作次数就是 $p$\n\n```python\n​class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        res = target[0]\n        for i in range(1, len(target)):\n            if (d := target[i]-target[i-1]) > 0:\n                res += d\n        return res\n```","tags":["算法","前缀和","差分"],"categories":["算法"]},{"title":"LeetCode363. 矩形区域不超过 K 的最大数值和","url":"/2021/04/30/a7703ba4/","content":"\n## [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)\n\nDifficulty: **困难**\n\n给你一个 `m x n` 的矩阵 `matrix` 和一个整数 `k` ，找出并返回矩阵内部矩形区域的不超过 `k` 的最大数值和。\n\n题目数据保证总会存在一个数值和不超过 `k` 的矩形区域。\n\n**示例 1：**\n\n![](https://i.loli.net/2021/04/30/Id4qFm7B1ongP8T.png)\n\n```c\n输入：matrix = [[1,0,1],[0,-2,3]], k = 2\n输出：2\n解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。\n```\n\n**示例 2：**\n\n```c\n输入：matrix = [[2,2,-1]], k = 3\n输出：3\n```\n\n**提示：**\n\n*   $m = \\text{matrix.length}$\n*   $n = \\text{matrix[i].length}$\n*   $1 \\leq m, n \\leq 100$\n*   $-100 \\leq \\text{matrix[i][j]} \\leq 100$\n*   $-10^5 \\leq k \\leq 10^5$\n\n**进阶**：如果行数远大于列数，该如何设计解决方案？\n\n  \n### 解法一\n\n这个题给了我很大的启发，对枚举方法又多了点认识，这题常规暴力的做法是直接枚举所有的矩形，然后判断，结合二维前缀和，时间复杂度 $O(m^2n^2)$ ，已经在 T 的边缘了，所以我们要优化一下算法。\n\n这里其实就涉及到一个**优化枚举**的一般思路，前面做过的 [最大子序和](https://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C) 就可以用类似的枚举优化的思路（这题有更简单的 dp 做法），常规的暴力枚举可以借助前缀和枚举所有的子区间的和，求一个最大值，但是这样时间复杂度将会是 $O(n^2)$ ，那么我们就可以考虑优化枚举方法，我们最终的目标是求最大的 $s_j-s_i$ ，所以我们可以考虑将 $j$ 固定，然后借助一些数据结构，比如小根堆，搜索树（其实一个变量就行了。..）直接求出 $j$ 固定时，前面最小的 $s_i$ ，如此只需要遍历一遍就能得到最大的子序和。\n\n回到这个题，上面最大子序和是一维的，这里是二维的，我们可以将其抽象为一维的，我们枚举所有矩形其实就是在枚举矩形的四条边 $l,r,u,d$ ，但是时间复杂度过高，那么我们可以采用前面的优化思路，将三条边 $r,u,d$ 固定\n\n![mark](https://static.imlgw.top/blog/20210505/7nujFBoFs95s.png)\n\n我们要求的矩形面积是 $s[r]-s[l]$ ，结合这题的要求就是 $s[r]-s[l] \\leq k$ ，所以我们要求的就是 $r$ 前面满足 $s[l] \\geq s[r]-k$ 的最小 $s[l]$ ，显然只要我们将前面的所有元素 $s[i]$ 有序的存储下来，就可以使用二分来查找，这里我们就不必再造轮子了，直接借助`TreeSet`，底层结构是红黑树，查询复杂度 $O(\\log{n})$ ，整体复杂度 $O(m^2n\\log{n})$ 。进阶的做法多判断一下就行了，对复杂度没有本质的影响，不多写了。\n\n代码实现如下：\n```java\nimport java.util.*;\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] s = new int[m+1][n+1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                s[i][j] = matrix[i-1][j-1] + s[i-1][j] + s[i][j-1] -s[i-1][j-1];\n            }\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        int res = -0x3f3f3f3f;\n        for (int u = 1; u <= m; u++) {\n            for (int d = u; d <= m; d++) {\n                set.clear();\n                set.add(0);\n                //0 lv rv, rv-lv <= k  lv >= rv-k\n                for (int r = 1; r <= n; r++) {\n                    int rv = s[d][r] - s[u-1][r];\n                    Integer lv = set.ceiling(rv-k);\n                    set.add(rv);\n                    if (lv == null) continue;\n                    res = Math.max(res, rv-lv);\n                }\n            }\n        }\n        return res;\n    }\n}\n```","tags":["LeetCode","二叉搜索树"],"categories":["算法"]},{"title":"LeetCode87. 扰乱字符串","url":"/2021/04/16/65861bea/","content":"\n## [87. 扰乱字符串](https://leetcode-cn.com/problems/scramble-string/)\n\nDifficulty: **困难**\n\n使用下面描述的算法可以扰乱字符串 `s` 得到字符串 `t` ：\n\n1.  如果字符串的长度为 1 ，算法停止\n2.  如果字符串的长度 > 1 ，执行下述步骤：\n    *   在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 `s` ，则可以将其分成两个子字符串 `x` 和 `y` ，且满足 `s = x + y` 。\n    *   **随机** 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，`s` 可能是 `s = x + y` 或者 `s = y + x` 。\n    *   在 `x` 和 `y` 这两个子字符串上继续从步骤 1 开始递归执行此算法。\n\n给你两个 **长度相等** 的字符串 `s1`和 `s2`，判断 `s2`是否是 `s1`的扰乱字符串。如果是，返回 `true` ；否则，返回 `false` 。\n\n**示例 1：**\n\n```c\n输入：s1 = \"great\", s2 = \"rgeat\"\n输出：true\n解释：s1 上可能发生的一种情形是：\n\"great\" --> \"gr/eat\" // 在一个随机下标处分割得到两个子字符串\n\"gr/eat\" --> \"gr/eat\" // 随机决定：「保持这两个子字符串的顺序不变」\n\"gr/eat\" --> \"g/r / e/at\" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割\n\"g/r / e/at\" --> \"r/g / e/at\" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // 继续递归执行此算法，将 \"at\" 分割得到 \"a/t\"\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // 随机决定：「保持这两个子字符串的顺序不变」\n算法终止，结果字符串和 s2 相同，都是 \"rgeat\"\n这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true\n```\n\n**示例 2：**\n```c\n输入：s1 = \"abcde\", s2 = \"caebd\"\n输出：false\n```\n\n**示例 3：**\n\n```c\n输入：s1 = \"a\", s2 = \"a\"\n输出：true\n```\n\n**提示：**\n\n*   $\\text{s1.length = s2.length}$\n*   $1 \\leq \\text{s1.length} \\leq 30$\n*   $s_1$ 和 $s_2$ 由小写英文字母组成\n\n### 解法一\n> LeetCode4.16 每日一题，挺有意思记录一下\n\n记忆化搜索，一开始没看题解磨了好一会儿磨出来的，没经过优化，50ms 过了\n<details>\n\n```java\n​class Solution {\n\n    char[] c1, c2;\n    \n    Boolean[][][][] dp = null;\n\n    public boolean isScramble(String s1, String s2) {\n        int m = s1.length();\n        int n = s2.length();\n        dp = new Boolean[m+1][m+1][n+1][n+1];\n        c1 = s1.toCharArray();\n        c2 = s2.toCharArray();\n        if (!check(0, m-1, 0, n-1)) return false;\n        return dfs(0, m-1, 0, n-1);\n    }\n\n    public boolean dfs(int i1, int j1, int i2, int j2) {\n        if (!check(i1, j1, i2, j2)) {\n            return dp[i1][j1][i2][j2] = false;\n        }\n        if (i1 == j1) {\n            if (c1[i1] == c2[i2]) {\n                return true;\n            }\n            return false;\n        }\n        if (new String(c1, i1, j1-i1+1).equals(new String(c2, i2, j1-i1+1))) {\n            // System.out.println(new String(c1, i1, j1-i1+1));\n            return true;\n        }\n        if (dp[i1][j1][i2][j2] != null) {\n            return dp[i1][j1][i2][j2];\n        }\n        int k = i1, p = i2;\n        while (k < j1 && p < j2) {\n            if (dfs(i1, k, i2, p) && dfs(k+1, j1, p+1, j2)) {\n                dp[i1][k][i2][p] = true;\n                dp[k+1][j1][p+1][j2] = true;\n                return true;\n            }\n            k++; p++;\n        }\n        k = i1; p = j2;\n        while (k < j1 && p > 0) {\n            if (dfs(i1, k, p, j2) && dfs(k+1, j1, i2, p-1)) {\n                dp[i1][k][p][j2] = true;\n                dp[k+1][j1][i2][p-1] = true;\n                return true;\n            }\n            k++; p--;\n        }\n        return dp[i1][j1][i2][j2] = false;\n    }\n\n    public boolean check(int i1, int j1, int i2, int j2) {\n        if (j1-i1 != j2-i2) {\n            return false;\n        }\n        int[] cnt1 = new int[26];\n        int[] cnt2 = new int[26];\n        while (i1 <= j1 && i2 <= j2) {\n            cnt1[c1[i1++]-'a']++;\n            cnt2[c2[i2++]-'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (cnt1[i] != cnt2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n</details>\n\n优化后的写法，一开始设置了四维状态 $i_1,j_1,i_2,j_2$ ，然后发现其实两个子串长度必须相同，所以可以直接用一个 $len$ 省掉一维状态，然后直接搜索就行了，最后再加上记忆化就能 AC 了，其实还是挺好写的\n```java\nclass Solution {\n\n    char[] c1, c2;\n    \n    Boolean [][][] dp = null;\n\n    public boolean isScramble(String s1, String s2) {\n        int n = s1.length();\n        dp = new Boolean[n+1][n+1][n+1];\n        c1 = s1.toCharArray(); c2 = s2.toCharArray();\n        return dfs(0, 0, n);\n    }\n\n    public boolean dfs(int i1, int i2, int len) {\n        if (!check(i1, i2, len)) {\n            return dp[i1][i2][len] = false;\n        }\n        if (len == 1) {\n            return dp[i1][i2][len] = c1[i1] == c2[i2];\n        }\n        if (new String(c1, i1, len).equals(new String(c2, i2, len))) {\n            return dp[i1][i2][len] = true;\n        }\n        if (dp[i1][i2][len] != null) {\n            return dp[i1][i2][len];\n        }\n        int k = i1, p = i2;\n        int j1 = i1+len-1, j2 = i2+len-1;\n        while (k < j1 && p < j2) {\n            // j1-k+k-i1+1\n            if (dfs(i1, i2, k-i1+1) && dfs(k+1, p+1, j1-k)) {\n                return dp[i1][i2][len] = true;\n            }\n            if (dfs(i1, j2-(k-i1+1)+1, k-i1+1) && dfs(k+1, i2, j1-k)) {\n                return dp[i1][i2][len] = true;\n            }\n            k++; p++;\n        }\n        return dp[i1][i2][len] = false;\n    }\n\n    public boolean check(int i1, int i2, int len) {\n        int[] cnt1 = new int[26];\n        int[] cnt2 = new int[26];\n        int j1 = i1+len-1, j2 = i2+len-1;\n        while (i1 <= j1 && i2 <= j2) {\n            cnt1[c1[i1++]-'a']++;\n            cnt2[c2[i2++]-'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (cnt1[i] != cnt2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n### 解法二\n\n区间 DP 的写法，其实在前面写记忆化搜索的时候就意识到了这是个区间 DP，所以写完搜索后马上就写出了下面的解法。状态 $dp[i][j][len]$ 表示，子串 $s_1[i,i+len-1]$ 和 $s_2[j,j+len-1]$ 是否互为扰乱字符串\n- 入口： $dp[i][j][1]=\\text{True if } s_i = s_j$\n- 转移：$dp[i][j][len] =\n  \\begin{cases} \n  dp[i][j][k] \\ \\ \\And \\ \\ dp[i+k][j+k][len-k] \\\\\\\\\n  dp[i][j+len-k][k] \\ \\ \\And \\ \\ dp[i+k][j][len-k]\n    \\end{cases}(or)$\n- 出口： $dp[0][0][n]$\n\n```java\nclass Solution {\n\n    public boolean isScramble(String s1, String s2) {\n        int n = s1.length();\n        char[] c1 = s1.toCharArray(), c2 = s2.toCharArray();\n        boolean[][][] dp = new boolean[n+1][n+1][n+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][1] = c1[i] == c2[j];\n            }\n        }\n\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i+len-1 < n; i++) {\n                for (int j = 0; j+len-1 < n; j++) {\n                    for (int k = 1; k < len; k++) {\n                        if (dp[i][j][len]) break;\n                        boolean a = dp[i][j][k] & dp[i+k][j+k][len-k];\n                        // j+len-1 - k + 1\n                        boolean b = dp[i][j+len-1-k+1][k] & dp[i+k][j][len-k];\n                        dp[i][j][len] = a | b;\n                    }\n                }\n            }\n        }\n        return dp[0][0][n];\n    }\n}\n```","tags":["动态规划","LeetCode"],"categories":["算法"]},{"title":"DP：计数 DP","url":"/2021/04/09/b34c4165/","content":"\n## [900. 整数划分](https://www.acwing.com/problem/content/description/902/)\n\n一个正整数 $n$ 可以表示成若干个正整数之和，形如 $n=n_1+n_2+…+n_k$ ，其中 $n_1≥n_2≥…≥n_k,k≥1$ 。我们将这样的一种表示称为正整数 $n$ 的一种划分。\n\n现在给定一个正整数 $n$ ，请你求出 $n$ 共有多少种不同的划分方法。\n\n**输入格式**\n\n共一行，包含一个整数 $n$ 。\n\n**输出格式**\n\n共一行，包含一个整数，表示总划分数量。由于答案可能很大，输出结果请对 $10^9+7$ 取模。\n\n**数据范围**： $1≤n≤1000$\n\n**输入样例：**\n```c\n5\n```\n**输出样例：**\n```c\n7\n```\n### 解法一\n这个题我拿到的第一想法就是直接转换成完全背包： $n+1$ 个物品，体积就是物品下标 $[1,n]$ ，物品数量不限，求凑成体积为 $n$ 的方案数\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int MOD = (int)1e9+7;\n        int N = Integer.valueOf(br.readLine());\n        //dp[i][j]   = dp[i-1][j] + dp[i-1][j-v] + ... + dp[i-1][j mod v]\n        //dp[i][j-v] =              dp[i-1][j-v] + ... + dp[i-1][(j-v) mod v]\n        //dp[i][j] = dp[i-1][j] + dp[i][j-v]\n        long[] dp = new long[N+1];\n        dp[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            for (int j = i; j <= N; j++) {\n                dp[j] = (dp[j] + dp[j-i]) % MOD;\n            }\n        }\n        out.println(dp[N]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n### 解法二\n不使用背包的思路，设置状态 $dp[i][j]$ 为：将数字 $i$ 划分为**恰好** $j$ 份的方案数，同时我们也可以将问题建模成：将 $N$ 个苹果放到 $N$ 个盘子，有多少种放法，不考虑顺序，每个盘子至少放一个\n\n这里将 $i$ 个苹果放到 $j$ 个盘子，我们可以分两种情况来看\n1. 至少有一个盘子只放了一个苹果，这种情况下，我们可以直接将这个只有一个苹果的盘子和苹果去掉再放，并不会影响结果，所以这样就等价于将 $i-1$ 个苹果放到 $j-1$ 个盘子中\n2. 所有的盘子至少都有两个苹果，这种情况下，我们可以将所有盘子中的苹果数量减一再放，同样也不会影响结果，所以这种情况下等价于将 $i-j$ 个苹果放到 $j$ 个盘子中\n\n然后将上面两种情况加起来就行了\n- 初始状态： $dp[0][0] = 1$ ，0 划分为 0 份，只有一种分法\n- 转移方程： $dp[i][j] =dp[i-1][j-1] + dp[i-j][j],(i \\geq j)$\n- 出口： $\\sum_{i=1}^{N}{dp[N][i]}$\n\n代码实现如下：\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int MOD = (int)1e9+7;\n        int N = Integer.valueOf(br.readLine());\n        // 将 i 划分为恰好 j 份的的方案数量\n        long[][] dp = new long[N+1][N+1];\n        // 1. 最小值是 1，等价于 dp[i-1][j-1]\n        // 2. 最小值不是 1，等价于 dp[i-j][j]\n        // Arrays.fill(dp[0], 1);\n        dp[0][0] = 1;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i][j] = (dp[i-1][j-1] + dp[i-j][j]) % MOD;\n            }\n        }\n        long res = 0;\n        for (int i = 1; i <= N; i++) {\n            res = (res + dp[N][i]) % MOD;\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n其实也可以将状态方程改成将 $i$ 划分为**不超过** $j$ 份的方案数量，但是不是特别好理解，还是定义为恰好比较好理解\n<details>\n\n```java\npublic static void main(String... args) throws Exception {\n    PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n    int MOD = (int)1e9+7;\n    int N = Integer.valueOf(br.readLine());\n    // 将 i 划分为不超过 j 份的的方案数量\n    long[][] dp = new long[N+1][N+1];\n    // 0 划分为任意份都是 1 种分法\n    // dp[i][j] += dp[i][j-1]\n    Arrays.fill(dp[0], 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            //dp[i-1][j-1] 被包含在 dp[i][j-1] 中\n            //所以这里我们只需要加上 dp[i][j-1] 就行了\n            dp[i][j] = dp[i][j-1];\n            if (i >= j) {\n                //dp[i-j][j] 没有被包含，需要加上\n                dp[i][j] = (dp[i][j] + dp[i-j][j]) % MOD;\n            }\n        }\n    }\n    out.println(dp[N][N]);\n    out.flush();\n}\n```\n</details>\n\n## [1050. 鸣人的影分身](https://www.acwing.com/problem/content/description/1052/)\n\n在火影忍者的世界里，令敌人捉摸不透是非常关键的。\n\n我们的主角漩涡鸣人所拥有的一个招数——多重影分身之术——就是一个很好的例子。影分身是由鸣人身体的查克拉能量制造的，使用的查克拉越多，制造出的影分身越强。针对不同的作战情况，鸣人可以选择制造出各种强度的影分身，有的用来佯攻，有的用来发起致命一击。\n\n那么问题来了，假设鸣人的查克拉能量为 $M$ ，他影分身的个数最多为 $N$ ，那么制造影分身时有多少种不同的分配方法？\n\n**注意：**\n\n1. 影分身可以分配 $0$ 点能量。\n2. 分配方案不考虑顺序，例如： $M=7,N=3$ ，那么 $(2,2,3)$ 和 $(2,3,2)$ 被视为同一种方案。\n\n**输入格式**\n\n第一行是测试数据的数目 $t$ 。\n\n以下每行均包含二个整数 $M$ 和 $N$ ，以空格分开。\n\n**输出格式**\n\n对输入的每组数据 $M$ 和 $N$ ，用一行输出分配的方法数。\n\n**数据范围**\n- $0≤t≤20$\n- $1≤M,N≤10$\n\n**输入样例：**\n```c\n1\n7 3\n```\n**输出样例：**\n```c\n8\n```\n### 解法一\n这题和上面一题很类似，不过多了一些限制，我们将其按前面的方式建模为：将 $M$ 个苹果放到 $N$ 个盘子，不考虑顺序，有多少种放法，允许有空盘。定义状态 $dp[i][j]$ 为：将 $i$ 个苹果放到**不超过** $j$ 个盘子中方案数\n- 初始状态： $dp[0][0\\sim N]=1$\n- 转移方程： $dp[i][j]=dp[i][j-1] + dp[i-j][j]$ ，和上一题类似的转移方式，不多赘述，需要注意这里 $j$ 可能会大于 $i$\n- 出口： $dp[M][N]$\n\n代码实现如下：\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int T = Integer.valueOf(br.readLine());\n        while (T-- > 0) {\n            int[] t = read(br);\n            out.println(solve(t[0], t[1]));\n        }\n        out.flush();\n    }\n\n    public static int solve(int m, int n) {\n        // 前 i 个苹果，放到 j 个盘子，有多少种放法\n        int[][] dp = new int[m+1][n+1];\n        Arrays.fill(dp[0], 1);\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = dp[i][j-1];\n                if (i >= j) {\n                    dp[i][j] += dp[i-j][j];\n                }\n            }\n        }\n        return dp[m][n];\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n那么这题能不能将状态设置为将 $i$ 个苹果放到**恰好** $j$ 个盘子中的方案数呢？答案是不行的，原因是这题是允许空盘子的！如果有空盘子，定义状态为**恰好**，那么 $dp[i][j]$ 其实就已经包含了 $dp[i][j-1]，dp[i][j-2]...$ （相当于直接将空盘子去掉然后再将苹果放到剩余的盘子中），所以定义出来的状态只能是不超过 $j$ 个盘子，最后返回 $dp[M][N]$\n\n### 解法二\n这题同样也可以用背包来做，设置状态 $dp[i][j][k]$ 为：前 $i$ 个物品，凑成体积**恰好**为 $j$ ，物品数量不限制，物品体积为物品下标 $[0,n]$ ，使用物品总数**不超过** $k$ 的方案数\n- 初始状态： $dp[0][0][k] = 0$\n- 状态转移：枚举所有物品，枚举体积，然后枚举使用的物品总个数 $k$ ，再枚举当前物品 $i$ 使用的个数\n  $$\n  dp[i][j][k] = dp[i-1][j-i][k-1] + dp[i-1][j-2i][k-2] + ... + dp[i-1][j \\mod i][k-j \\div i]\n  $$\n- 出口： $dp[m][m][n]$ ，和上面一样，这里只能设置成不超过 $k$ ，因为物品体积可以为 $0$ ，所以使用 $k$ 个物品会将使用 $k-1$ 个物品的状态包含进去\n- 时间复杂度： $O(m^2n^2)$\n\n代码实现如下：\n```java\n//完全背包解法，m+1 种物品，体积为 [0, m] 凑齐体积 m，且总使用的物品数量不操作 n，求方案数量\npublic static int solve(int m, int n) {\n    //前 i 个数，体积恰好为 j，总物品数量不超过 k 的方案数\n    int[][][] dp = new int[m+1][m+1][n+1];\n    for (int i = 0; i <= n; i++) {\n        dp[0][0][i] = 1;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 0; j <= m; j++) {\n            for (int k = 0; k <= n; k++) {\n                for (int p = 0; p <= k && j-p*i >= 0; p++) {\n                    dp[i][j][k] += dp[i-1][j-p*i][k-p];\n                }\n            }\n        }\n    }\n    return dp[m][m][n];\n}\n```\n","tags":["算法","动态规划"],"categories":["算法"]},{"title":"Win10 美化","url":"/2021/04/02/ea16554c/","content":"\n## UPDATE\n\n> win11 取消了磁贴功能，想跑路 Ubuntu 了（\n\n2021.4.16，收到了 win10-20H 的更新推送，毫不犹豫的更新了，因为之前就听说这个更新对磁贴做了优化，背景可以透明\n\n新版磁贴效果图：\n\n![](https://i.loli.net/2021/04/16/F6EB4HLqcDrIxTg.png)\n\n下面为原文：\n\n> 更新后之前的`StartlsBack++`用不了，所以我找了最新版本的，文中的链接也更新了下\n\n---\n## 背景\n个人比较喜欢简洁干净的桌面，但是又不想使用一些第三方的主题或者插件（一方面是系统占用的问题，另一方面是感觉不太搭且折腾起来也挺麻烦），所以自己动手稍微调了下\n## 效果\n\n![](https://i.loli.net/2021/04/02/ZtIb76UVFRTQHur.png)\n\n![](https://i.loli.net/2021/04/02/wnjRzp7eduTQtas.png)\n\n应用全屏和非全屏效果\n\n![](https://i.loli.net/2021/04/02/u7AX81ItsHFecU9.png)\n![](https://i.loli.net/2021/04/02/TGo2ORNYbrHhiF6.png)\n## 桌面\n桌面直接清空，完美的展现壁纸，所以什么图标都没有。桌面只用来放一些临时文件，完事后就会删掉\n\n> 通常来说桌面都是作为一级入口，放置一些应用的快捷方式，让用户能方便的启动对应的应用程序。但是实际上我们并不需要这么多快捷方式，根据 [二八定律](https://baike.baidu.com/item/%E4%BA%8C%E5%85%AB%E5%AE%9A%E5%BE%8B)，我们常用的可能就只有那么几个，剩下的图标甚至可能自从放上去就没点开过（比如一些压缩软件）\n## 任务栏\n那么我们清空桌面后，我们常用的一些软件的快捷方式放哪里去呢？总不能去磁盘里面一个个找吧😂\n\n所以这里我们就可以利用任务栏，我们将这些软件直接固定到任务栏底部，将任务栏作为一级入口，同时对任务栏做一些美化，这里需要用到一些工具\n### 透明 & 图标居中\nStartlsBack++，可以设置任务栏图标间距，图标大小，以及图标位置，（注意是设置而不是后台运行的插件），软件安装后会嵌入控制面板的外观选项中\n![](https://i.loli.net/2021/04/02/X8myNKl9Cbiskht.gif)\n如果需要透明就勾选上 **动态透明度** 的选项\n\n下载地址：https://wwe.lanzous.com/iI8Hlo6js1i\n\n### 任务栏动态展示\n这里使用 SmartTaskBar，也是唯一一个需要后台运行的插件，占用极低，开机自启！[](https://i.loli.net/2021/04/02/pi82P1NZeKGQ6us.png)\n在微软应用商店就可以直接下载\n![](https://i.loli.net/2021/04/02/6NtSlxIr3XoUwOA.png)\n作用也很简单\n- 有窗口最大化的时候隐藏任务栏\n- 没有窗口最大化时显示任务栏\n- 鼠标放到任务栏可以自动显示\n\n也就是上面 [效果图](#效果)上的 p3 和 p4\n\n## 磁贴\n\n上面我们将常用的应用固定到了任务栏，但是哪些不常用的放哪里去呢？虽然不常用但是总归会有用的时候啊\n\n这里就可以利用 win10 的磁贴功能，将磁贴作为一个二级入口，通过 win 键打开，将一些不常用的固定到磁贴上，但是单纯的将应用固定到磁贴上也比较难看，颜色比较统一，背景无法自定义，所以这里我们用到几个工具\n### Windows Tile Color Changer\n可以修改磁贴的背景颜色（纯色）\n![](https://i.loli.net/2021/04/02/pS7OsL12eBwNAXW.png)\n除了上面展示的颜色也可以输入自定义颜色的 hex 码\n\n下载地址：https://wws.lanzous.com/ijedTnl33wh\n\n### TileMaker | TileTools\n可以给磁贴自定义背景图，详情右转 B 乎：[TileMakerWpf](https://zhuanlan.zhihu.com/p/61585535)\n\n[TileTools](https://zhuanlan.zhihu.com/p/79630122)\n\n都是绿软\n\n### 磁贴图片\n![](https://i.loli.net/2021/04/02/zIkXQSAodhC4Ws1.png)\n\n这里用到了 TileGenie：可以将图片分割后固定在磁贴中（可能需要自己拼一下）\n\n![](https://i.loli.net/2021/04/02/DwROJcEKHBNvMdk.png)\n\n在微软商店可以直接下载\n> 这里我看见评论区反映会占用很大的 C 盘空间，我用了几天并没有发现，猜测原因是他们开启了动态磁贴轮换图片，我这里只用了单张图片并没有轮换，后续如果有问题出现再说\n\n## 总结\n\n说是美化其实也称不上是美化，一切的起因也都只是因为想清空桌面罢了。.....\n","tags":["win10"],"categories":["杂项"]},{"title":"图论：单源最短路的建图方式","url":"/2021/03/28/8e9b2c41/","content":"> 相关文章：[图论：常见的最短路算法模板](https://imlgw.top/2021/03/17/c163e5c9/)\n## [1129. 热浪](https://www.acwing.com/problem/content/description/1131/)\n\n德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！\n\n他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品，农夫 John 此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。\n\nJohn 已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点一共有 $T$ 个城镇，为了方便标号为 $1$ 到 $T$ 。除了起点和终点外的每个城镇都由**双向道路**连向至少两个其它的城镇。每条道路有一个通过费用（包括油费，过路费等等）。\n\n给定一个地图，包含 $C$ 条直接连接 2 个城镇的道路。每条道路由道路的起点 $R_s$ ，终点 $R_e$ 和花费 $C_i$ 组成。求从起始的城镇 $T_s$ 到终点的城镇 $T_e$ 最小的总费用。\n\n**输入格式**\n\n第一行：4 个由空格隔开的整数： $T,C,T_s,T_e$ ;\n\n第 2 到第 $C+1$ 行：第 $i+1$ 行描述第 $i$ 条道路，包含 3 个由空格隔开的整数： $R_s,R_e,C_i$ 。\n\n**输出格式**\n\n一个单独的整数表示从 $T_s$ 到 $T_e$ 的最小总费用。数据保证至少存在一条道路。\n\n**数据范围**\n- $1≤T≤2500$\n- $1≤C≤6200$\n- $1≤Ts,Te,Rs,Re≤T$\n- $1≤Ci≤1000$\n\n**输入样例：**\n```c\n7 11 5 4\n2 4 2\n1 4 3\n7 2 2\n3 4 3\n5 7 5\n7 3 3\n6 1 1\n6 3 4\n2 4 3\n5 6 3\n7 2 1\n```\n**输出样例：**\n```c\n7\n```\n\n### 解法一\n很裸的题，正权图，数据范围不是很大，直接使用堆优化的`Dijkstra`\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int INF = 0x3f3f3f3f;\n        int T = in[0], C = in[1], Ts = in[2], Te = in[3];\n        int[][] w = new int[T+1][T+1];\n        for (int i = 1; i <= T; i++) {\n            Arrays.fill(w[i], INF);\n        }\n        for (int i = 0; i < C; i++) {\n            int[] t = read(br);\n            int x = t[0], y = t[1];\n            w[x][y] = Math.min(w[x][y], t[2]);\n            w[y][x] = Math.min(w[y][x], t[2]);\n        }\n        int[] dis = new int[T+1];\n        Arrays.fill(dis, INF);\n        dis[Ts] = 0;\n        boolean[] vis = new boolean[T+1];\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b)->dis[a]-dis[b]);\n        queue.add(Ts);\n        while (!queue.isEmpty()) {\n            int i = queue.poll();\n            if (vis[i]) continue;\n            vis[i] = true;\n            for (int j = 1; j <= T; j++) {\n                if (w[i][j] == INF) continue;\n                if (dis[j] > dis[i] + w[i][j]) {\n                    dis[j] = dis[i] + w[i][j];\n                    queue.add(j);\n                }\n            }\n        }\n        out.println(dis[Te]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n## [1128. 信使](https://www.acwing.com/problem/content/1130/)\n\n战争时期，前线有 $n$ 个哨所，每个哨所可能会与其他若干个哨所之间有通信联系。\n\n信使负责在哨所之间传递信息，当然，这是要花费一定时间的（以天为单位）。\n**指挥部设在第一个哨所**，当指挥部下达一个命令后，指挥部就派出若干个信使向与指挥部相连的哨所送信，当一个哨所接到信后，这个哨所内的信使们也以同样的方式向其他哨所送信。信在一个哨所内停留的时间可以忽略不计，直至所有 n 个哨所全部接到命令后，送信才算成功。\n\n因为准备充足，每个哨所内都安排了足够的信使（如果一个哨所与其他 k 个哨所有通信联系的话，这个哨所内至少会配备 k 个信使）。\n\n现在总指挥请你编一个程序，计算出完成整个送信过程最短需要多少时间。\n\n**输入格式**\n\n第 $1$ 行有两个整数 $n$ 和 $m$ ，中间用 $1$ 个空格隔开，分别表示有 $n$ 个哨所和 $m$ 条通信线路。\n\n第 $2$ 至 $m+1$ 行：每行三个整数 $i,j,k$ ，中间用 $1$ 个空格隔开，表示第 $i$ 个和第 $j$ 个哨所之间存在 双向 通信线路，且这条线路要花费 $k$ 天。\n\n**输出格式**\n\n一个整数，表示完成整个送信过程的最短时间，如果不是所有的哨所都能收到信，就输出-1。\n\n**数据范围**\n- $1≤n≤100$\n- $1≤m≤200$\n- $1≤k≤1000$\n\n**输入样例：**\n```c\n4 4\n1 2 4\n2 3 7\n2 4 1\n3 4 6\n```\n**输出样例：**\n```c\n11\n```\n\n### 解法一\n求至少需要多长时间其实就是求**最长的最短路**，数据范围很小，可以直接 Floyd，我这里写了个 SPFA\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        int INF = 0x3f3f3f3f;\n        int N = in[0], M = in[1];\n        int[][] w = new int[N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(w[i], INF);\n        }\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            int x = t[0], y = t[1];\n            w[x][y] = Math.min(w[x][y], t[2]);\n            w[y][x] = Math.min(w[y][x], t[2]);\n        }\n        int[] dis = new int[N+1];\n        boolean[] vis = new boolean[N+1];\n        Arrays.fill(dis, INF);\n        dis[1] = 0;\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(1); vis[1] = true;\n        while (!queue.isEmpty()) {\n            int i = queue.poll();\n            vis[i] = false;\n            for (int j = 1; j <= N; j++) {\n                if (w[i][j]==INF) continue; //其实 dis[i] 不会为 INF\n                if (dis[j] > dis[i] + w[i][j]) {\n                    dis[j] = dis[i] + w[i][j];\n                    if (!vis[j]) {\n                        queue.add(j);\n                        vis[j] = true;\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 1; i <= N; i++) {\n            res = Math.max(res, dis[i]);\n        }\n        out.println(res==INF ? -1 : res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n## [1127. 香甜的黄油](https://www.acwing.com/problem/content/description/1129/)\n\n农夫 John 发现了做出全威斯康辛州最甜的黄油的方法：糖。\n\n把糖放在一片牧场上，他知道 $N$ 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。当然，他将付出额外的费用在奶牛上。\n\n农夫 John 很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。\n\n他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。\n\n农夫 John 知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。\n\n给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。\n\n数据保证至少存在一个牧场和所有牛所在的牧场连通。\n\n**输入格式**\n\n第一行：三个数：奶牛数 $N$ ，牧场数 $P$ ，牧场间道路数 $C$ 。\n\n第二行到第 $N+1$ 行： $1$ 到 $N$ 头奶牛所在的牧场号。\n\n第 $N+2$ 行到第 $N+C+1$ 行：每行有三个数：相连的牧场 $A，B$ ，两牧场间距 $D$ ，当然，连接是双向的。\n\n**输出格式**\n\n共一行，输出奶牛必须行走的最小的距离和。\n\n**数据范围**\n- $1≤N≤500$\n- $2≤P≤800$\n- $1≤C≤1450$\n- $1≤D≤255$\n\n**输入样例：**\n```c\n3 4 5\n2\n3\n4\n1 2 1\n1 3 5\n2 3 7\n2 4 3\n3 4 5\n```\n**输出样例：**\n```c\n8\n```\n\n### 解法一\n单看题目，Floyd 肯定是比较契合的，直接求出任意两点的最短路，然后枚举所有的点，但是时间复杂度不合适，所以考虑使用堆优化的 Dijkstra，尝试以每个牧场作为源点，跑一遍最短路，然后求所有奶牛到该点的距离和，最终求一个最小的距离和，时间复杂度 $O(NM\\log N)$\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int INF = 0x3f3f3f3f;\n    static int N, P, C;\n    static int[] cow;\n    static int[] e, h, ne, w;\n    static int idx;\n    //a->b\n    public static void add(int a, int b, int c) {\n        w[idx] = c; e[idx] = b;\n        ne[idx] = h[a]; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        N = in[0]; P = in[1]; C = in[2];\n        //边数：2*C\n        e = new int[C*2+1]; ne = new int[C*2+1]; w = new int[C*2+1];\n        //点数：P\n        h = new int[P+1]; Arrays.fill(h, -1);\n        cow = new int[N+1]; // 奶牛所在牧场\n        for (int i = 1; i <= N; i++) {\n            cow[i] = read(br)[0];\n        }\n        for (int i = 0; i < C; i++) {\n            int[] t = read(br);\n            add(t[0], t[1], t[2]);\n            add(t[1], t[0], t[2]);\n        }\n        int res = INF;\n        for (int i = 1; i <= P; i++) {\n            res = Math.min(dijkstra(i), res);\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static int dijkstra(int s) {\n        int[] dis = new int[P+1];\n        boolean[] vis = new boolean[P+1];\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->dis[a]-dis[b]);\n        Arrays.fill(dis, INF);\n        dis[s] = 0; pq.add(s);\n        while (!pq.isEmpty()) {\n            int i = pq.poll();\n            if (vis[i]) continue;\n            vis[i] = true;\n            for (int j = h[i]; j != -1; j = ne[j]) { //边编号\n                int k = e[j]; //点编号\n                if (w[j] == INF || dis[i] == INF) continue; \n                if (dis[k] > dis[i] + w[j]) {\n                    dis[k] = dis[i] + w[j];\n                    pq.add(k);\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 1; i <= N; i++) {\n            if (dis[cow[i]] == INF) return INF;\n            sum += dis[cow[i]];\n        }\n        return sum;\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [1126. 最小花费](https://www.acwing.com/problem/content/1128/)\n\n在 $n$ 个人中，某些人的银行账号之间可以互相转账，这些人之间转账的手续费各不相同。\n\n给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 $A$ 最少需要多少钱使得转账后 $B$ 收到 $100$ 元。\n\n**输入格式**\n\n第一行输入两个正整数 $n,m$ ，分别表示总人数和可以互相转账的人的对数。\n\n以下 $m$ 行每行输入三个正整数 $x,y,z$ ，表示标号为 $x$ 的人和标号为 $y$ 的人之间互相转账需要扣除 $z\\%$ 的手续费 ( $z<100$ )。\n\n最后一行输入两个正整数 $A,B$ 。\n\n数据保证 $A$ 与 $B$ 之间可以直接或间接地转账。\n\n**输出格式**\n\n输出 $A$ 使得 $B$ 到账 $100$ 元最少需要的总费用。\n\n精确到小数点后 $8$ 位。\n\n**数据范围**\n- $1≤n≤2000$\n- $m≤105$\n\n**输入样例：**\n```c\n3 3\n1 2 1\n2 3 2\n1 3 3\n1 3\n```\n**输出样例：**\n```c\n103.07153164\n```\n### 解法一\n这题让我对最短路的概念有了新的理解，前面的题目都是求权值和最小的路径，而这题中我们的边权值 $w_i$ 是一个手续费的百分比数，我们设 $A$ 转出的金额为 $m$ ，根据题意可得 $m(1-w_1)(1-w_2)...(1-w_k)=100$ ，我们希望 $m$ 最小，也就是希望 $(1-w_1)(1-w_2)...(1-w_k)$ 越大，那么这里就变成了一个求乘法最长路的问题\n\n我们知道 Dijkstra 核心思想是：每次从未确定的最短路集合中选取最短的一个，从而确定该点的最短路，然后利用该点去松弛其他的点，然后重复该过程。而这题中边的权值 $w_i$ 是一个小于 $1$ 的小数（大于 $0$ ），所以路径累乘是递减的，那么我们从**未确定的乘法最长路集合**中选取一个最大的点，它也就无法通过其他未确定的点中转来增大路径积，进而便可以确定该点的**乘法最长路**，符合 Dijkstara 的思想，所以该题可以直接使用 Dijkstra。\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int INF = 0x3f3f3f3f;\n    static int N, M;\n    static int idx;\n    static int[] e, ne, h, w;\n    //a->b \n    public static void add(int a, int b, int c){ \n        e[idx] = b; ne[idx] = h[a];\n        w[idx] = c; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1];\n        e = new int[2*M+1]; ne = new int[2*M+1]; w = new int[2*M+1];\n        h = new int[N+1]; Arrays.fill(h, -1);\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            add(t[0], t[1], 100-t[2]);\n            add(t[1], t[0], 100-t[2]);\n        }\n        int[] t = read(br);\n        int A = t[0], B = t[1];\n        double[] dis = new double[N+1];\n        boolean[] vis = new boolean[N+1];\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->(dis[b]>dis[a])?1:-1);\n        dis[A] = 1.0; pq.add(A);\n        while (!pq.isEmpty()) {\n            int i = pq.poll();\n            if (vis[i]) continue;\n            vis[i] = true;\n            for (int j = h[i]; j != -1; j = ne[j]) {\n                int k = e[j];\n                if (dis[k] < dis[i] * (w[j]/100.0)) {\n                   dis[k] = dis[i] * (w[j]/100.0);\n                   pq.add(k);\n                }\n            }\n        }\n        out.printf(\"%.8f\", 100/dis[B]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n> 进一步思考，如果权值都大于 $1$ ，显然我们就只能通过 Dijkstra 求**乘法最短路**，那么如果权值既有大于 1 的也有小于 1 的（大于 0）就只能用 SPFA 类似的算法了，并且 SPFA 既可以求最大值也能求最小值。\n\n## [920. 最优乘车](https://www.acwing.com/problem/content/description/922/)\n\n$H$ 城是一个旅游胜地，每年都有成千上万的人前来观光。为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些**单程**巴士线路。\n\n每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。\n\n一名旅客最近到 $H$ 城旅游，他很想去 $S$ 公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达 $S$ 公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士，这样换乘几次后到达 $S$ 公园。\n\n现在用整数 $1,2,…N$ 给 $H$ 城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为 $1，S$ 公园巴士站的编号为 $N$ 。\n\n写一个程序，帮助这名旅客寻找一个最优乘车方案，使他在从饭店乘车到 $S$ 公园的过程中换乘的次数最少。\n\n**输入格式**\n\n第一行有两个数字 M 和 N，表示开通了 M 条单程巴士线路，总共有 N 个车站。\n\n从第二行到第 M+1 行依次给出了第 1 条到第 M 条巴士线路的信息，其中第 i+1 行给出的是第 i 条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号，相邻两个站号之间用一个空格隔开。\n\n**输出格式**\n\n共一行，如果无法乘巴士从饭店到达 S 公园，则输出 NO，否则输出最少换乘次数，换乘次数为 0 表示不需换车即可到达。\n\n**数据范围**\n- $1≤M≤100$\n- $1≤N≤500$\n\n**输入样例：**\n```c\n3 7\n6 7\n4 7 3 6\n2 1 3 5\n```\n**输出样例：**\n```c\n2\n```\n### 解法一\n关键点是如何建图，我一开始想了一个很复杂的的建图方式，然后发现太复杂了，就放弃了。这里其实直接将同一条路线的站点，从左到右任意两点用权值为 $1$ 的边进行连接就行了，然后跑一下最短路最后得到的答案减一就是最少换乘次数，算法瓶颈在建图上，时间复杂度 $O(MN^2)$\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int INF = 0x3f3f3f3f;\n    static int N, M;\n    static int[][] w;\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        M = in[0]; N = in[1];\n        w = new int[N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(w[i], INF);\n        }\n        //M*N*N\n        for (int i = 1; i <= M; i++) {\n            int[] t = read(br);\n            for (int j = 0; j < t.length; j++) {\n                for (int k = j+1; k < t.length; k++) {\n                    w[t[j]][t[k]] = 1;\n                }\n            }\n        }\n        int[] dis = new int[N+1];\n        boolean[] vis = new boolean[N+1];\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->dis[a]-dis[b]);\n        Arrays.fill(dis, INF);\n        dis[1] = 0; pq.add(1);\n        while (!pq.isEmpty()) {\n            int i = pq.poll();\n            if (vis[i]) continue;\n            vis[i] = true;\n            for (int j = 1; j <= N; j++) {\n                if (w[i][j] == INF) continue;\n                if (dis[j] > dis[i] + w[i][j]) {\n                    dis[j] = dis[i] + w[i][j];\n                    pq.add(j);\n                }\n            }\n        }\n        out.println(dis[N]==INF ? \"NO\" : dis[N]-1);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n边权值为 $1$ ，其实直接 BFS 就可以了\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int INF = 0x3f3f3f3f;\n    static int N, M;\n    static int[][] w;\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        M = in[0]; N = in[1];\n        w = new int[N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(w[i], INF);\n        }\n        //M*N*N\n        for (int i = 1; i <= M; i++) {\n            int[] t = read(br);\n            for (int j = 0; j < t.length; j++) {\n                for (int k = j+1; k < t.length; k++) {\n                    w[t[j]][t[k]] = 1;\n                }\n            }\n        }\n        int[] dis = new int[N+1];\n        Arrays.fill(dis, INF);\n        boolean[] vis = new boolean[N+1];\n        Queue<Integer> queue = new LinkedList<>();\n        dis[1] = 0; queue.add(1);\n        while (!queue.isEmpty()) {\n            int i = queue.poll();\n            for (int j = 1; j <= N; j++) {\n                if (w[i][j] == INF || dis[j] != INF) continue;\n                dis[j] = dis[i] + w[i][j]; \n                queue.add(j);\n            }\n        }\n        out.println(dis[N]==INF ? \"NO\" : dis[N]-1);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n## [903. 昂贵的聘礼](https://www.acwing.com/problem/content/905/)\n\n年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用 $10000$ 个金币作为聘礼才答应把女儿嫁给他。\n\n探险家拿不出这么多金币，便请求酋长降低要求。\n\n酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要 8000 金币。如果你能够弄来他的水晶球，那么只要 5000 金币就行了。”\n\n探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。\n\n探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。\n\n不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。\n\n探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。\n\n另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。\n\n但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。\n\n因此你需要在考虑所有的情况以后给他提供一个最好的方案。\n\n为了方便起见，我们把所有的物品从 $1$ 开始进行编号，酋长的允诺也看作一个物品，并且编号总是 $1$ 。\n\n每个物品都有对应的价格 $P$ ，主人的地位等级 $L$ ，以及一系列的替代品 $T_i$ 和该替代品所对应的”优惠” $V_i$ 。\n\n如果两人地位等级差距超过了 $M$ ，就不能”间接交易”。\n\n你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。\n\n**输入格式**\n\n输入第一行是两个整数 $M，N$ 依次表示地位等级差距限制和物品的总数。\n\n接下来按照编号从小到大依次给出了 $N$ 个物品的描述。\n\n每个物品的描述开头是三个非负整数 $P、L、X$ ，依次表示该物品的价格、主人的地位等级和替代品总数。\n\n接下来 $X$ 行每行包括两个整数 $T$ 和 $V$ ，分别表示替代品的编号和”优惠价格”。\n\n**输出格式**\n\n输出最少需要的金币数。\n\n**数据范围**\n- $1≤N≤100$\n- $1≤P≤10000$\n- $1≤L,M≤N$\n- $0≤X<N$\n\n**输入格式**\n```c\n1 4\n10000 3 2\n2 8000\n3 5000\n1000 2 1\n4 200\n3000 2 1\n4 200\n50 2 0\n```\n**输出格式**\n```c\n5250\n```\n### 解法一\n之前的解法有问题，被 Hack 了。\n```golang\npackage main\n\nimport (\n    \"bufio\"\n    \"container/heap\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar price []int\nvar rank []int\nvar w [][]int\nvar INF = int(0x3f3f3f3f)\n\nfunc main() {\n    // f, _ := os.Open(\"./input.txt\")\n    // reader := bufio.NewReader(f)\n    reader := bufio.NewReader(os.Stdin)\n    // writer := bufio.NewWriter(os.Stdout)\n    t := ReadArray(reader)\n    M, N := t[0], t[1]\n    rank = make([]int, N+1)\n    w = make([][]int, N+1)\n    for i := 0; i <= N; i++ {\n        w[i] = make([]int, N+1)\n        for j := 0; j <= N; j++ {\n            w[i][j] = INF\n        }\n    }\n    for i := 1; i <= N; i++ {\n        plx := ReadArray(reader)\n        rank[i] = plx[1]\n        // 虚拟源点，连接所有节点\n        w[0][i] = plx[0]\n        for j := 0; j < plx[2]; j++ {\n            tv := ReadArray(reader)\n            // 反向建边\n            w[tv[0]][i] = tv[1]\n        }\n    }\n    var res = INF\n    // 枚举区间 [rank[1]-m, rank[1]+m]\n    for i := rank[1] - M; i <= rank[1]; i++ {\n        res = Min(res, Dijkstra(N, i, i+M))\n    }\n    fmt.Println(res)\n}\n\nfunc Dijkstra(n int, lt int, rt int) int {\n    pq := make(NodeHeap, 0)\n    vis := make([]bool, n+1)\n    dis := make([]int, n+1)\n    for i := 0; i <= n; i++ {\n        dis[i] = INF\n    }\n    heap.Push(&pq, &Node{\n        idx: 0,\n        val: 0,\n    })\n    dis[0] = 0\n    for len(pq) > 0 {\n        cur := heap.Pop(&pq).(*Node)\n        i, v := cur.idx, cur.val\n        if vis[i] {\n            continue\n        }\n        vis[i] = true\n        for j := 1; j <= n; j++ {\n            if rank[j] > rt || rank[j] < lt {\n                continue\n            }\n            if w[i][j] == INF {\n                continue\n            }\n            if w[i][j]+v < dis[j] {\n                dis[j] = w[i][j] + v\n                heap.Push(&pq, &Node{j, dis[j]})\n            }\n        }\n    }\n    return dis[1]\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\ntype Node struct {\n    idx int\n    val int\n}\n\ntype NodeHeap []*Node\n\nfunc (h NodeHeap) Len() int { return len(h) }\n\n// 小顶堆\nfunc (h NodeHeap) Less(i, j int) bool { return h[i].val < h[j].val }\nfunc (h NodeHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *NodeHeap) Push(x interface{}) {\n    // Push 和 Pop 使用 pointer receiver 作为参数，\n    // 因为它们不仅会对切片的内容进行调整，还会修改切片的长度。\n    *h = append(*h, x.(*Node))\n}\n\nfunc (h *NodeHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nfunc ReadLine(reader *bufio.Reader) string {\n    line, _ := reader.ReadString('\\n')\n    return strings.TrimRight(line, \"\\n\")\n}\n\nfunc ReadInt(reader *bufio.Reader) int {\n    num, _ := strconv.Atoi(ReadLine(reader))\n    return num\n}\n\nfunc ReadArray(reader *bufio.Reader) []int {\n    line := ReadLine(reader)\n    strs := strings.Split(line, \" \")\n    nums := make([]int, len(strs))\n    for i, s := range strs {\n        nums[i], _ = strconv.Atoi(s)\n    }\n    return nums\n}\n\n```\n\n### 错误解法示例\n\n建图的时候直接建立当前物品和其替代品的边。记录每个物品的价格 $price$ 和主人等级 $rank$\n\n ![](https://i.loli.net/2021/03/23/SP2anNGftOmJbQU.png)\n\n优先队列中存储节点的编号 $i$ ，当前离物品 $1$ （公主）的最短路 $v$ ，以及路径上的最大等级 $max$ 和最小等级 $min$ ，在松弛的时候判断等级有没有超过限制，并且维护这两个值，然后在优先队列弹出节点的时候统计最小值（弹出节点的最短路已经确定了，尝试**在当前节点停止替换操作**，直接原价购买）\n\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static class Node {\n        int i, v;\n        int max, min;\n        public Node(int i, int v, int max, int min) {\n            this.i = i; this.v = v;\n            this.max = max; this.min = min;\n        }\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int INF = 0x3f3f3f3f;\n        int M = in[0], N = in[1];\n        int[][] w = new int[N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(w[i], INF);\n        }\n        // 记录每个物品的价格和主人等级\n        int[] price = new int[N+1];\n        int[] rank = new int[N+1];\n        for (int i = 1; i <= N; i++) {\n            int[] plx = read(br);\n            price[i] = plx[0]; rank[i] = plx[1];\n            for (int j = 1; j <= plx[2]; j++) {\n                int[] tv = read(br);\n                w[i][tv[0]] = tv[1];\n            }\n        }\n        int res = INF;\n        int[] dis = new int[N+1];\n        boolean[] vis = new boolean[N+1];\n        // pq 中存储节点的编号，以及路径上的最大和最小等级\n        PriorityQueue<Node> pq = new PriorityQueue<>((a,b)->a.v-b.v);\n        Arrays.fill(dis, INF);\n        dis[1] = 0; pq.add(new Node(1, 0, rank[1], rank[1]));\n        while (!pq.isEmpty()) {\n            Node node = pq.poll();\n            int i = node.i, v = node.v;\n            if (vis[i]) continue;\n            vis[i] = true;\n            // 在当前位置停止替换\n            res = Math.min(res, dis[i]+price[i]);\n            for (int j = 1; j <= N; j++) {\n                if (w[i][j] == INF) continue;\n                // 等级限制无法交易\n                if (Math.abs(rank[j]-node.min) > M || \n                    Math.abs(rank[j]-node.max) > M ) continue; \n                if (dis[j] > v + w[i][j]) {\n                    dis[j] = v + w[i][j];\n                    pq.add(new Node(j, dis[j], Math.max(rank[j], node.max), Math.min(rank[j], node.min)));\n                }\n            }\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n这里我写完后看了下题解，发现和 y 总的做法不一样，y 总建图是反向建的，同时增加了虚拟节点指向单个的物品，然后枚举等级限制内的所有区间，在每个区间内跑一次最短路，最后求一个最小 $dis[1]$\n> 一度以为是自己出了问题，去 POJ 上交了一下发现也是可以 AC 的\n\n嗯，确实是自己出了问题。这里的解法是错的，每个节点可能在多条路径上，所以这里统计路径上的最大最小 rank 是不准确的，每个点都可能被松弛多次，并不能保证维护的一定是最短路上的 max，min（这个解法修改一下可以正确的 AC，但是感觉有点怪，就不再记录了，具体 [参考](https://blog.csdn.net/weixin_51423794/article/details/120233619?spm=1001.2014.3001.5501)）","tags":["算法","图论"],"categories":["算法"]},{"title":"搜索：Flood Fill","url":"/2021/03/25/89c67f8e/","content":"\n## [1097. 池塘计数](https://www.acwing.com/problem/content/1099/)\n\n农夫约翰有一片 $N*M$ 的矩形土地。最近，由于降雨的原因，部分土地被水淹没了。\n\n现在用一个字符矩阵来表示他的土地。\n\n每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。\n\n现在，约翰想知道他的土地中形成了多少片池塘。\n\n每组相连的积水单元格集合可以看作是一片池塘。\n\n每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。\n\n请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。\n\n**输入格式**\n\n第一行包含两个整数 $N$ 和 $M$ 。\n\n接下来 $N$ 行，每行包含 $M$ 个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。\n\n**输出格式**\n\n输出一个整数，表示池塘数目。\n\n**数据范围**： $1≤N,M≤1000$\n\n**输入样例：**\n```c\n10 12\nW........WW.\n.WWW.....WWW\n....WW...WW.\n.........WW.\n.........W..\n..W......W..\n.W.W.....WW.\nW.W.W.....W.\n.W.W......W.\n..W.......W.\n```\n**输出样例：**\n```c\n3\n```\n\n### 解法一\n\n经典 Flood Fill，搜索或者并查集都可，没啥好说的\n```java\nimport java.io.*;\nimport java.util.*;\nclass Main {\n    \n    static int N;\n    static int M;\n    static boolean[][] vis;    \n    static char[][] board;\n    static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, -1}, {-1, 1}, {-1, -1}, {1, 1}};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        board = new char[N][M];\n        vis = new boolean[N][M];\n        for (int i = 0; i < N; i++) {\n            board[i] = sc.next().toCharArray();\n        }\n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (!vis[i][j] && board[i][j] == 'W') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        System.out.println(res);\n    }\n\n    public static void dfs (int x, int y) {\n        vis[x][y] = true;\n        for (int i = 0; i < dir.length; i++) {\n            int nx = x + dir[i][0];\n            int ny = y + dir[i][1];\n            if (nx < 0 || ny < 0 || nx >= N || ny >= M) {\n                continue;\n            }\n            if (!vis[nx][ny] && board[nx][ny] == 'W') {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n```\n\n## [1098. 城堡问题](https://www.acwing.com/problem/content/1100/)\n\n```c\n    1   2   3   4   5   6   7  \n   #############################\n 1 #   |   #   |   #   |   |   #\n   #####---#####---#---#####---#\n 2 #   #   |   #   #   #   #   #\n   #---#####---#####---#####---#\n 3 #   |   |   #   #   #   #   #\n   #---#########---#####---#---#\n 4 #   #   |   |   |   |   #   #\n   #############################\n           （图 1)\n   #  = Wall   \n   |  = No wall\n   -  = No wall\n```\n\n   方向：上北下南左西右东。\n图 1 是一个城堡的地形图。\n\n请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。\n\n城堡被分割成 m∗n 个方格区域，每个方格区域可以有 0~4 面墙。\n\n注意：墙体厚度忽略不计。\n\n**输入格式**\n\n第一行包含两个整数 m 和 n，分别表示城堡南北方向的长度和东西方向的长度。\n\n接下来 m 行，每行包含 n 个整数，每个整数都表示平面图对应位置的方块的墙的特征。\n\n每个方块中墙的特征由数字 P 来描述，我们用 1 表示西墙，2 表示北墙，4 表示东墙，8 表示南墙，P 为该方块包含墙的数字之和。\n\n例如，如果一个方块的 P 为 3，则 3 = 1 + 2，该方块包含西墙和北墙。\n\n城堡的内墙被计算两次，方块 (1,1) 的南墙同时也是方块 (2,1) 的北墙。\n\n输入的数据保证城堡至少有两个房间。\n\n**输出格式**\n\n共两行，第一行输出房间总数，第二行输出最大房间的面积（方块数）。\n\n**数据范围**： $1≤m,n≤50, 0≤P≤15$\n\n**输入样例：**\n```c\n4 7 \n11 6 11 6 3 10 6 \n7 9 6 13 5 15 5 \n1 10 12 7 13 7 5 \n13 11 10 8 10 12 13 \n```\n**输出样例：**\n```c\n5\n9\n```\n\n### 解法一\n\n题目很简单，但是怎么处理墙有点麻烦，我直接采用了最蠢的办法\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class AcWing1098_城堡问题 {\n    public static void main(String[] args) throws Exception {\n        new Main().main();\n    }\n}\n\nclass Main {\n    //     2(3)\n    //1(2)      4(1)\n    //     8(0)\n    \n    //下，右，左，上\n    static int[][] dir = {{1, 0}, {0, 1}, {0, -1}, {-1, 0}};    \n    static int n, m;\n    static boolean[][] wall;\n    static boolean[][] vis;\n    static int[][] board;\n    \n    public static void main(String... args) throws Exception {\n        Scanner sc = new Scanner(new File(\"./input.txt\"));\n        // Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        vis = new boolean[n][m];\n        wall = new boolean[16][4];\n        wall[2][3] = wall[1][2] = wall[4][1] = wall[8][0] = true;\n        wall[3][2] = wall[3][3] = true;\n        wall[5][1] = wall[5][2] = true;\n        wall[9][0] = wall[9][2] = true;\n        wall[6][1] = wall[6][3] = true;\n        wall[10][0] = wall[10][3] = true;\n        wall[12][0] = wall[12][1] = true;\n        wall[7][1] = wall[7][2] = wall[7][3] = true; \n        wall[11][0] = wall[11][2] = wall[11][3] = true;\n        wall[14][0] = wall[14][1] = wall[14][3] = true;\n        wall[13][0] = wall[13][1] = wall[13][2] = true;\n        wall[15][0] = wall[15][1] = wall[15][2] = wall[15][3] = true;\n        board = new int[n][m];\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < m; j++) {\n                board[i][j] = sc.nextInt();\n            }\n        }\n        int count = 0, max = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!vis[i][j]) {\n                    count++;\n                    max = Math.max(max, dfs(i, j));\n                }\n            }\n        }\n        System.out.println(count);\n        System.out.println(max);\n    }\n\n    public static int dfs (int x, int y) {\n        vis[x][y] = true;\n        int area = 1;\n        for (int i = 0; i < dir.length; i++) {\n            int nx = x + dir[i][0];\n            int ny = y + dir[i][1];\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m || wall[board[x][y]][i]) {\n                continue;\n            }\n            if (!vis[nx][ny]) {\n                area += dfs(nx, ny);\n            }\n        }\n        return area;\n    }\n}\n```\n### 解法二\n\n优雅的位运算，东南西北对应的墙 1，2，4，8 就是 $2^0，2^1，2^2，2^3$ ，所以我们可以根据二进制的对应位的 0，1 状态判断该方向有没有墙\n\n```java\nclass Main {\n    //        2(0010)\n    //1(0001)         4(0100)\n    //        8(1000)\n    //左，上，右，下\n    static int[][] dir = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};    \n    static int n, m;\n    static boolean[][] vis;\n    static int[][] board;\n    \n    public static void main(String... args) throws Exception {\n        Scanner sc = new Scanner(new File(\"./input.txt\"));\n        // Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        vis = new boolean[n][m];\n        board = new int[n][m];\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < m; j++) {\n                board[i][j] = sc.nextInt();\n            }\n        }\n        int count = 0, max = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!vis[i][j]) {\n                    count++;\n                    max = Math.max(max, dfs(i, j));\n                }\n            }\n        }\n        System.out.println(count);\n        System.out.println(max);\n    }\n\n    public static int dfs (int x, int y) {\n        vis[x][y] = true;\n        int area = 1;\n        for (int i = 0; i < dir.length; i++) {\n            int nx = x + dir[i][0];\n            int ny = y + dir[i][1];\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) {\n                continue;\n            }\n            if (!vis[nx][ny] && ((board[x][y]>>i)&1) == 0) {\n                area += dfs(nx, ny);\n            }\n        }\n        return area;\n    }\n}\n```\n## [1106. 山峰和山谷](https://www.acwing.com/problem/content/description/1108/)\n\nFGD 小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。\n\n为了能够对旅程有一个安排，他想知道山峰和山谷的数量。\n\n给定一个地图，为 FGD 想要旅行的区域，地图被分为 n×n 的网格，每个格子 $(i,j)$ 的高度 $w(i,j)$ 是给定的。\n\n若两个格子有公共顶点，那么它们就是相邻的格子，如与 $(i,j)$ 相邻的格子有 $(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)$ 。\n\n我们定义一个格子的集合 S 为山峰（山谷）当且仅当：\n\n- S 的所有格子都有相同的高度。\n- S 的所有格子都连通。\n- 对于 s 属于 S，与 s 相邻的 s′ 不属于 S，都有 ws>ws′（山峰），或者 ws<ws′（山谷）。\n- 如果周围不存在相邻区域，则同时将其视为山峰和山谷。\n\n你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。\n\n**输入格式**\n\n第一行包含一个正整数 n，表示地图的大小。\n\n接下来一个 n×n 的矩阵，表示地图上每个格子的高度 w。\n\n**输出格式**\n\n共一行，包含两个整数，表示山峰和山谷的数量。\n\n**数据范围** ： $1≤n≤1000, 0≤w≤10^9$\n\n**输入样例 1：**\n```c\n5\n8 8 8 7 7\n7 7 8 8 7\n7 7 7 7 7\n7 8 8 7 8\n7 8 8 8 8\n```\n**输出样例 1：**\n```c\n2 1\n```\n\n**输入样例 2：**\n```c\n5\n5 7 8 3 1\n5 5 7 6 6\n6 6 6 2 8\n5 7 2 5 8\n7 1 0 1 7\n```\n\n**输出样例 2：**\n```c\n3 3\n```\n\n### 解法一\n\n一开始没看视频，自己写了个 DFS，然后死活过不去，卡在了第 17/20 个 case，改了好久也没改好，然后改成 BFS 一发就过了，BFS 连接每个点的连通块，然后比较每个块和四周不联通的块的高度大小，进而判断该连通块是山峰还是山谷\n```java\nclass Main {\n\n    static int n;\n    static boolean[][] vis;    \n    static int[][] w;\n    static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, -1}, {-1, 1}, {-1, -1}, {1, 1}};\n    static Queue<Pair> queue = new LinkedList<>();\n    static class Pair {\n        int x, y;\n        public Pair (int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    /*\n     */\n    public static void main(String... args) throws Exception{\n        InputReader in = new InputReader(System.in);\n        // InputReader in = new InputReader(new FileInputStream(\"./input.txt\"));\n        n = in.nextInt();\n        w = new int[n][n];\n        vis = new boolean[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                w[i][j] = in.nextInt();\n            }\n        }\n        int up = 0, down = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!vis[i][j]) {\n                    int temp = bfs(i, j);\n                    if (temp == 1 || temp == 2) up++;\n                    if (temp == -1 || temp == 2) down++;\n                }\n            }\n        }\n        System.out.println(up + \" \" + down);\n    }\n\n    //对这个点进行广搜，并且进行标记\n    //返回值：-1 山谷，0 啥也不是，1 山峰，2 既是山峰也是山谷\n    public static int bfs(int x, int y) {\n        queue.clear();\n        queue.add(new Pair(x, y));\n        vis[x][y] = true;\n        boolean up = false, down = false;\n        while (!queue.isEmpty()){\n            Pair p = queue.poll();\n            for (int i = 0; i < dir.length; i++) {\n                int nx = p.x + dir[i][0];\n                int ny = p.y + dir[i][1];\n                if (nx < 0 || ny < 0 || nx >= n || ny >= n) {\n                    continue;\n                }\n                if (w[p.x][p.y] < w[nx][ny]) {\n                    down = true;\n                } else if (w[p.x][p.y] > w[nx][ny]) {\n                    up = true;\n                } else if (!vis[nx][ny]) {\n                    vis[nx][ny] = true;\n                    queue.add(new Pair(nx, ny));\n                }\n            }\n        }\n        //up 和 down 同时满足，说明周围既有比当前大的，也有比当前小的\n        if (up && down) return 0;\n        if (up) return 1;\n        if (down) return -1;\n        //up 和 down 都不满足，所有元素一样，既是山峰也是山谷\n        return 2;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"LeetCode1799.N 次操作后的最大分数和","url":"/2021/03/24/1bf1a82/","content":"\n## [1799\\. N 次操作后的最大分数和](https://leetcode-cn.com/problems/maximize-score-after-n-operations/)\n\nDifficulty: **困难**\n\n给你 `nums` ，它是一个大小为 `2 * n` 的正整数数组。你必须对这个数组执行 `n` 次操作。\n\n在第 `i` 次操作时（操作编号从 **1** 开始），你需要：\n\n*   选择两个元素 `x` 和 `y` 。\n*   获得分数 `i * gcd(x, y)` 。\n*   将 `x` 和 `y` 从 `nums` 中删除。\n\n请你返回 `n` 次操作后你能获得的分数和最大为多少。\n\n函数 `gcd(x, y)` 是 `x` 和 `y` 的最大公约数。\n\n**示例 1：**\n\n```c\n输入：nums = [1,2]\n输出：1\n解释：最优操作是：\n(1 * gcd(1, 2)) = 1\n```\n\n**示例 2：**\n\n```c\n输入：nums = [3,4,6,8]\n输出：11\n解释：最优操作是：\n(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11\n```\n\n**示例 3：**\n\n```c\n输入：nums = [1,2,3,4,5,6]\n输出：14\n解释：最优操作是：\n(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14\n```\n\n**提示：**\n\n- $1 <= n <= 7$\n- $\\text{nums.length} == 2 \\ast n$\n- $1 <= nums[i] <= 10^6$\n\n### 解法一\n48th 双周赛 t4，比较简单，看数据范围就知道是状压 DP，一开始写了个二维的状态 $dp[i][mask]$ ，包含了当前操作的次数 $i$ ，以及选取状态 $mask$ ，结果 t 了。忘记考虑 $\\gcd$ 的复杂度了，后面对 $\\gcd$ 做了预处理优化勉强过了，但是依然比较慢\n\n重新思考了递推状态，发现当前操作次数这个状态其实是没有必要的，这个状态可以通过 $mask$ 的二进制 $1$ 的位数推断出来，每操作一次多两个 $1$ ，所以操作次数为 $\\frac{\\text{bit1}(mask)}{2}$ 。\n\n所以状态变为 $dp[mask]$ ，代表经过 $\\frac{\\text{bit1}(mask)}{2}$ 次操作，选取的元素掩码为 $mask$ 时的最大得分\n- 入口： $dp[0] = 0$\n- 转移： $dp[mask] = \\max(dp[mask],\\frac{\\text{bit1}(mask)}{2} \\ast \\gcd(j,k) + dp[mask\\oplus(1<<j)\\oplus(1<<k)])$ 枚举所有状态，然后枚举所有数对 $j,k$ ，确保 $mask$ 包含 $j,k$ ，然后递推取最大值\n- 出口： $dp[1<<m-1]$ ，时间复杂度 $O(2^m*m^2)$ ， $m$ 为数组长度\n\n代码实现如下：\n```java\nimport java.util.*;\n\nclass Solution {\n\n    public int maxScore(int[] nums) {\n        int len = nums.length;\n        int n = len/2;\n        int[] dp = new int[2<<len];\n        int[][] cache = new int[len][len];\n        for (int i = 0; i < len; i++) {\n            for (int j = i+1; j < len; j++) {\n                cache[i][j] = gcd(nums[i], nums[j]);\n            }\n        }\n        for (int s = 0; s < (1<<len); s++) {\n            int cnt = countBit(s);\n            // 选取个数一定是偶数\n            if ((cnt&1)==1) continue;\n            for (int j = 0; j < len; j++) {\n                //s 必须选取 j, k\n                if (((s>>>j)&1)==0) continue;\n                for (int k = j+1; k < len; k++) {\n                    if (((s>>>k)&1)==0) continue;\n                    dp[s] = Math.max(dp[s], (countBit(s)/2)*cache[j][k] + dp[s^(1<<j)^(1<<k)]);\n                }\n            }\n        }\n        return dp[(1<<len)-1];\n    }\n\n    public int countBit(int a) {\n        int cnt = 0;\n        while (a != 0) {\n            a = a&(a-1);\n            cnt++;\n        }\n        return cnt;\n    }\n\n    public int gcd(int a, int b){\n        if(b==0) return a;\n        return gcd(b, a%b);\n    }\n}\n```\n\n### 解法二\n题解区看到的另一种写法，直接枚举 $\\text{mask}$ 的子集，思路挺好，但是时间复杂度略高， $O(2^{2n} \\ast 2^k)$ ， $k$ 是掩码中 $1$ 的个数，最多可能是 $2*n$\n```java\npublic int maxScore2(int[] nums) {\n    int len = nums.length;\n    int n = len/2;\n    int[] dp = new int[2<<len];\n    for (int i = 0; i < len; i++) {\n        for (int j = i+1; j < len; j++) {\n            dp[(1<<i)|(1<<j)] = gcd(nums[i], nums[j]);\n        }\n    }\n    //2^len\n    for (int s = 0; s < (1<<len); s++) {\n        //2^k k 是 s 中 1 的个数\n        for (int i = s; i != 0; i=(i-1)&s) {\n            if (countBit(s)-countBit(i)==2) {\n                dp[s] = Math.max(dp[s], countBit(s)/2*dp[s^i]);\n            }\n        }\n    }\n    return dp[(1<<len)-1];\n}\n```","tags":["LeetCode"],"categories":["算法"]},{"title":"图论：常见的最短路算法模板","url":"/2021/03/17/c163e5c9/","content":"\n## [849. Dijkstra 求最短路 I](https://www.acwing.com/problem/content/851/)\n\n给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。\n\n请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出-1。\n\n**输入格式**\n\n第一行包含整数 n 和 m。\n\n接下来 m 行每行包含三个整数 x，y，z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n\n**输出格式**\n\n输出一个整数，表示 1 号点到 n 号点的最短距离。\n\n如果路径不存在，则输出-1。\n\n**数据范围**： $1≤n≤500, 1≤m≤10^5$ , 图中涉及边长均不超过 10000。\n\n**进阶**： $1≤n,m≤1.5×10^5$ , 图中涉及边长均不超过 10000。\n\n**输入样例：**\n```c\n3 3\n1 2 2\n2 3 1\n1 3 4\n```\n**输出样例：**\n```c\n3\n```\n### 解法一\nDijkstra 适用于非负权图，其核心思路就是将所有的点划分为两部分，一部分是已经确定最短路的点集合 $p$ ，这个集合最开始只有源点。另一部分是未确定最短路的点集合 $q$ 。\n\n1. 首先将刚加入 $p$ 的点的所有出边进行松弛（最开始就只有源点 $s$ ）\n2. 然后在 $q$ 中找一个离源点 $s$ 最近的，那么这个点的最短路就确定了，因为这个点当前的最短路必然是经过 $p$ 集合中的点进行松弛过后的，且图**没有负权**，所以这个点不可能再通过其他未确定的点中转来缩短距离（如果有负权就可能，所以 Dijkstra 无法处理存在负权的图），将其标记进入 $p$ 集合，然后重复步骤一，直到所有点都加入 $p$ 集合\n\nDijkstra 暴力写法，这题题目数据范围比较小 $n<500$ ，所以直接建邻接矩阵然后跑 Dijkstra，时间复杂度 $O(N^2)$\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int INF = 0x3f3f3f3f;\n        int[] in = read(br);\n        int N = in[0], M = in[1];\n        //邻接矩阵\n        int[][] w = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            Arrays.fill(w[i], INF);\n        }\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br); //t[0]->t[1]\n            int x = t[0]-1, y = t[1]-1;\n            w[x][y] = Math.min(t[2], w[x][y]);\n        }\n        //dis[i]: 源点 s 到 i 的最短距离\n        int[] dis = new int[N];\n        boolean[] vis = new boolean[N];\n        Arrays.fill(dis, INF);\n        dis[0] = 0;\n        for (int i = 0; i < N; i++) {\n            int min = -1;\n            //未确定最短路的点中距离 s 最近的点\n            for (int j = 0; j < N; j++) {\n                if (!vis[j] && (min==-1 || dis[j] < dis[min])) {\n                    min = j;\n                }\n            }\n            //松弛\n            vis[min] = true;\n            for (int j = 0; j < N; j++) {\n                if (!vis[j]) {\n                    dis[j] = Math.min(dis[j], dis[min] + w[min][j]);\n                }\n            }\n        }\n        out.println(dis[N-1] == INF ? -1 : dis[N-1]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n### 解法二\n堆优化的 Dijkstra，上面的解法在数据量大的时候显然是不适用的，首先我们不能再使用邻接矩阵了，需要改用邻接表，同时采用**小根堆**来快速的获取**未确定点集**中距离源点最近的点，堆中需要存储节点编号以及当前节点最短路，时间复杂度大概 $O(m\\log n)$ ，但是最坏情况下 $m$ 边数可能会达到 $n^2$ 级别（稠密图），导致堆优化的复杂度反而低于朴素的，但是大多数情况下边数不会有这么多，除此之外还有一些其它的优化方法，详见 [OI-Wiki](https://oi-wiki.org/graph/shortest-path/#dijkstra)\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static class Node {\n        int idx, val;\n        public Node(int idx, int val) {\n            this.idx = idx;\n            this.val = val;\n        }\n    }\n\n    static int idx;\n    static int N, M;\n    static int[] h, e, ne, w;\n    //a->b\n    static void add(int a, int b, int c) {\n        w[idx] = c; e[idx] = b; \n        ne[idx] = h[a]; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int INF = 0x3f3f3f3f;\n        int[] in = read(br);\n        N = in[0]; M = in[1];\n        h = new int[N+1]; e = new int[M+1]; ne = new int[M+1]; w = new int[M+1];\n        Arrays.fill(h, -1);\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            add(t[0], t[1], t[2]);\n        }\n        PriorityQueue<Node> pq = new PriorityQueue<>((n1, n2)->n1.val-n2.val);\n        int[] dis = new int[N+1];\n        //记录已经确定最短路的点集 s\n        boolean[] vis = new boolean[N+1];\n        Arrays.fill(dis, INF);\n        dis[1] = 0;\n        pq.add(new Node(1, 0));\n        while (!pq.isEmpty()) {\n            Node node = pq.poll();\n            //从未确定最短路的点中找 dis 最小的（如果弹出来的是已经确定过的就会跳过）\n            int i = node.idx, v = node.val;\n            if (vis[i]) continue;\n            //标记该点已经确定最短路\n            vis[i] = true;\n            //松弛该点出边\n            for (int j = h[i]; j != -1; j = ne[j]) {\n                if (v+w[j] < dis[e[j]]) {\n                    dis[e[j]] = v+w[j];\n                    pq.add(new Node(e[j], v+w[j]));\n                }\n            }\n        }\n        out.println(dis[N] == INF ? -1 : dis[N]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\nJava 其实还有一种更加简洁的写法，利用闭包，不用新建 Node 类\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int idx;\n    static int N, M;\n    static int[] h, e, ne, w;\n    //a->b\n    static void add(int a, int b, int c) {\n        w[idx] = c; e[idx] = b; \n        ne[idx] = h[a]; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int INF = 0x3f3f3f3f;\n        int[] in = read(br);\n        N = in[0]; M = in[1];\n        h = new int[N]; e = new int[M]; ne = new int[M]; w = new int[M];\n        Arrays.fill(h, -1);\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            add(t[0]-1, t[1]-1, t[2]);\n        }\n        int[] dis = new int[N];\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->dis[a]-dis[b]);\n        //记录已经确定最短路的点集 s\n        boolean[] vis = new boolean[N];\n        Arrays.fill(dis, INF);\n        dis[0] = 0;\n        pq.add(0);\n        while (!pq.isEmpty()) {\n            int i = pq.poll();\n            if (vis[i]) continue;\n            //标记该点已经确定最短路\n            vis[i] = true;\n            //松弛该点能到达的点的 dis\n            for (int j = h[i]; j != -1; j = ne[j]) {\n                if (dis[i]+w[j] < dis[e[j]]) {\n                    dis[e[j]] = dis[i]+w[j];\n                    pq.add(e[j]);\n                }\n            }\n        }\n        out.println(dis[N-1] == INF ? -1 : dis[N-1]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n## [853. 有边数限制的最短路](https://www.acwing.com/problem/content/description/855/)\n\n给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。\n\n请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。\n\n注意：图中可能**存在负权回路** 。\n\n**输入格式**\n\n第一行包含三个整数 n，m，k。\n\n接下来 m 行，每行包含三个整数 x，y，z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n\n**输出格式**\n\n输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。\n\n如果不存在满足条件的路径，则输出“impossible”。\n\n**数据范围**： $1≤n,k≤500, 1≤m≤10000$ ，且任意边长的绝对值不超过 $10000$\n\n**输入样例：**\n```c\n3 3 1\n1 2 1\n2 3 1\n1 3 3\n```\n**输出样例：**\n```c\n3\n```\n\n### 解法一\nBellman−Ford，负权最短路算法，可以处理负权边，同时可以检测**负权回路**（回路的总权值为负数）。算法基于动态规划设计， $dis[i][j]$ 为源点 $s$ 经过最多 $i$ 条边到达 $j$ 节点的最短路。一共有 $N$ 个点，所以任意点的最短路最多经过的边数为 $N-1$ （负环没有最短路）\n- 入口： $dis[i][s] = 0, 0 \\leq i \\leq N-1$\n- 转移：遍历所有的边， $k \\stackrel{w}{\\longrightarrow} j$ ， $dis[i][j] = \\min(dis[i-1][j]，dis[i][j]， dis[i-1][k] + w)$\n- 出口： $dis[N-1][N]$\n- 时间复杂度： $O(MN)$\n\n本题中限制了边数，所以我们外层循环只到 $K$ 就行了，具体代码实现如下：\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static class Edge {\n        int s, e;\n        int v;\n        public Edge(int s, int e, int v) {\n            this.s = s;\n            this.e = e;\n            this.v = v;\n        }\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int INF = 0x3f3f3f3f;\n        int N = in[0], M = in[1], K = in[2];\n        Edge[] eds = new Edge[M];\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            eds[i] = new Edge(t[0], t[1], t[2]);\n        }\n        int[][] dis = new int[K+1][N+1];\n        for (int i = 0; i <= K; i++) {\n            Arrays.fill(dis[i], INF);\n            dis[i][1] = 0;\n        }\n        for (int i = 1; i <= K; i++) {\n            for (int j = 0; j < M; j++) {\n                int s = eds[j].s, e = eds[j].e;\n                if (dis[i-1][s] == INF) continue;\n                // 不加 dis[i-1][e] 也能过 OJ，但是最好还是加上\n                // dis[i][e] = Math.min(dis[i][e], dis[i-1][s] + eds[j].v); \n                dis[i][e] = Math.min(dis[i-1][e], Math.min(dis[i][e], dis[i-1][s] + eds[j].v));\n            }\n        }\n        out.println(dis[K][N] == INF ? \"impossible\" : dis[K][N]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n这里存个疑问，为什么这里转移方程不加 $dis[i-1][e]$ 也能 AC？这里加上一定不会错，但是不加会有点迷惑。 \n\n这里我的想法是，如果不加 $dis[i-1][e]$ ，状态的定义其实就变成了：**恰好**经过 $i$ 条边的时候的最短路，这样出口就是 $\\min(dp[1\\sim M][N])$ ，但是由于我们在入口定义了 $dp[1\\sim M][s]=0$ ，误打误撞的导致出口变成了 $dp[M][N]$ ，具体原因不想深究，明白错哪里就行了，总之这是一种不伦不类的写法，不要这样写，正确写法如下：\n<details>\n<summary>状态定义为恰好经过 i 条边的写法</summary>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static class Edge {\n        int s, e;\n        int v;\n        public Edge(int s, int e, int v) {\n            this.s = s;\n            this.e = e;\n            this.v = v;\n        }\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int INF = 0x3f3f3f3f;\n        int N = in[0], M = in[1], K = in[2];\n        Edge[] eds = new Edge[M];\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            eds[i] = new Edge(t[0], t[1], t[2]);\n        }\n        //恰好经过 i 条边\n        int[][] dis = new int[K+1][N+1];\n        for (int i = 0; i <= K; i++) {\n            Arrays.fill(dis[i], INF);\n        }\n        dis[0][1] = 0;\n        for (int i = 1; i <= K; i++) {\n            for (int j = 0; j < M; j++) {\n                int s = eds[j].s, e = eds[j].e;\n                if (dis[i-1][s] == INF) continue;\n                dis[i][e] = Math.min(dis[i][e], dis[i-1][s] + eds[j].v);\n            }\n        }\n        int res = INF;\n        for (int i = 0; i <= K; i++) {\n            res = Math.min(res, dis[i][N]);\n        }\n        out.println(res == INF ? \"impossible\" : res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n### 解法二\n实际中通常写的都是一维的 Bellman−Ford，降维后在 $dis[e] = \\min(dis[e],dis[s] + w)$ 中， $dis[s]$ 不仅包含了前一轮最多经过 $i-1$ 条边到达 $s$ 的最短路，同时也包含了当前轮最多经过 $i$ 条边到达 $s$ 的最短路，所以最终经过 $k$ 次松弛得到的结果 $dis[N]$ 可能不只经过了 $k$ 条边，所以在这题中我们需要保存一下上一轮的状态，用上一轮的 $dis[s]$ 来更新当前轮的 $dis[e]$ ，保证最后结果经过的边不超过 $K$\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static class Edge {\n        int s, e;\n        int v;\n        public Edge(int s, int e, int v) {\n            this.s = s;\n            this.e = e;\n            this.v = v;\n        }\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int INF = 0x3f3f3f3f;\n        int N = in[0], M = in[1], K = in[2];\n        Edge[] eds = new Edge[M];\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            eds[i] = new Edge(t[0]-1, t[1]-1, t[2]);\n        }\n        //dis[i][j]: 源点最多经过 i 条边，到达 j 点的最短路\n        int[] dis = new int[N];\n        //上一轮经过 (i-1) 次松弛后的结果，避免串联更新（当前轮更新当前轮），因为这题需要保证最多只能经过 K 条边\n        int[] last = new int[N];\n        Arrays.fill(dis, INF);\n        dis[0] = 0;\n        for (int i = 0; i < K; i++) {\n            System.arraycopy(dis, 0, last, 0, N);\n            for (int j = 0; j < M; j++) {\n                int s = eds[j].s, e = eds[j].e;\n                if (last[s] == INF) continue;\n                dis[e] = Math.min(dis[e], last[s] + eds[j].v);\n            }\n        }\n        out.println(dis[N-1] == INF ? \"impossible\" : dis[N-1]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n如果数据量比较大可以改成 SPFA，如下：\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n    \n    static int idx;\n    static int N, M, K;\n    static int[] h, e, ne, w;\n    //a->b\n    static void add(int a, int b, int c) {\n        w[idx] = c; e[idx] = b; \n        ne[idx] = h[a]; h[a] = idx++;\n    }\n        \n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        int INF = 0x3f3f3f3f;\n        N = in[0]; M = in[1]; K = in[2];\n        e = new int[M+1]; ne = new int[M+1]; w = new int[M+1];\n        h = new int[N+1]; Arrays.fill(h, -1);\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            add(t[0], t[1], t[2]);\n        }\n        //恰好经过 i 条边到达 j 的最短路\n        int[][] dis = new int[K+1][N+1];\n        boolean[][] vis = new boolean[K+1][N+1];\n        for (int i = 0; i <= K; i++) {\n            Arrays.fill(dis[i], INF);\n        }\n        dis[0][1] = 0; vis[0][1] = true;\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{1, 0});\n        while (!queue.isEmpty()) {\n            int[] top = queue.poll();\n            int i = top[0], step = top[1];\n            if (step >= K) continue;\n            vis[step][i] = false;\n            for (int j = h[i]; j != -1; j = ne[j]) {\n                int k = e[j];\n                if (w[j]==INF || dis[step][i]==INF) continue;\n                if (dis[step+1][k] > dis[step][i] + w[j]) {\n                    dis[step+1][k] = dis[step][i] + w[j];\n                    if (!vis[step+1][k]) {\n                        queue.add(new int[]{k, step+1});\n                        vis[step+1][k] = true;\n                    }\n                }\n            }\n        }\n        int res = INF;\n        for (int i = 0; i <= K; i++) {\n            res = Math.min(res, dis[i][N]);\n        }\n        out.println(res==INF ? \"impossible\" : res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n## [851. spfa 求最短路](https://www.acwing.com/problem/content/853/)\n\n给定一个 n 个点 m 条边的有向图，图中可能**存在重边和自环**， 边权可能为**负数**。\n\n请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。数据保证**不存在负权回路**。\n\n**输入格式**\n\n第一行包含整数 n 和 m。\n\n接下来 m 行每行包含三个整数 x，y，z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n\n**输出格式**\n\n输出一个整数，表示 1 号点到 n 号点的最短距离。\n\n如果路径不存在，则输出”impossible”。\n\n**数据范围**： $1≤n,m≤105$ ，图中涉及边长绝对值均不超过 10000。\n\n**输入样例：**\n```c\n3 3\n1 2 5\n2 3 -3\n1 3 4\n```\n**输出样例：**\n```c\n2\n```\n\n### 解法一\nSPFA 基于 Bellman−Ford 进行优化，最坏时间复杂度依然是 $O(MN)$ ，但是常规情况下速度还是很快的，时间复杂度不稳定。\n\n优化的点在于 BF 在松弛过程中有一些顶点可能早已经得到了最短路，后续不会再被松弛，但是依然会进行判断，浪费了时间，所以我们可以考虑只对**最短路估计值**减小了的顶点的出边进行松弛\n\n具体实现中，我们可以采用一个 FIFO 队列存储松弛成功的顶点，最开始就只有源点 $s$ ，入队的顶点需要进行标记，对队列中顶点的出边进行松弛，将松弛成功并且没有标记的顶点继续加入队列。乍一看和 BFS 类似，但是这里其实有一个很大的区别：SPFA 在队首元素出队后需要将其标记取消，因为队首顶点后续可能还会被其他顶点松弛，这也是 SPFA 时间复杂度不稳定的原因（容易被卡，但是最差也是退化到 $O(NM)$ ）。\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int idx;\n    static int[] e, h, ne, w;\n    //a->b\n    public static void add(int a, int b, int c){\n        e[idx] = b; w[idx] = c;\n        ne[idx] = h[a]; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int INF = 0x3f3f3f3f;\n        int[] in = read(br);\n        int N = in[0], M = in[1];\n        e = new int[M+1]; ne = new int[M+1]; w = new int[M+1];\n        h = new int[N+1]; Arrays.fill(h, -1);\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            add(t[0], t[1], t[2]);\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] vis = new boolean[N+1];\n        int[] dis = new int[N+1];\n        Arrays.fill(dis, INF);\n        dis[1] = 0; vis[1] = true;\n        queue.add(1);\n        while (!queue.isEmpty()) {\n            int top = queue.poll();\n            vis[top] = false;\n            for (int i = h[top]; i != -1; i = ne[i]) {\n                int j = e[i];\n                if (dis[j] > dis[top] + w[i]) {\n                    dis[j] = dis[top] + w[i];\n                    if (!vis[j]) {\n                        queue.add(j);\n                        vis[j] = true;\n                    }\n                }\n            }\n        }\n        out.println(dis[N] == INF ? \"impossible\" : dis[N]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n## [852. spfa 判断负环](https://www.acwing.com/problem/content/description/854/)\n\n给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。请你判断图中是否存在负权回路。\n\n**输入格式**\n\n第一行包含整数 n 和 m。\n\n接下来 m 行每行包含三个整数 x，y，z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n\n**输出格式**\n\n如果图中存在负权回路，则输出“Yes”，否则输出“No”。\n\n**数据范围**： $1≤n≤2000,1≤m≤10000$ ，图中涉及边长绝对值均不超过 10000。\n\n**输入样例：**\n```c\n3 3\n1 2 -1\n2 3 4\n3 1 -4\n```\n**输出样例：**\n```c\nYes\n```\n### 解法一\n题目是判断图有没有负环，但是图不一定是联通的，单纯从某个点出发并不一定能走到负环上，暴力的方法就是对每个点作为源点做一次 spfa，但是这样显然复杂度过高\n\n考虑增加一个虚拟节点，和所有的点增加一条权值为 0 的单向边，新增加的虚拟节点一定能走到负环上，所以我们对虚拟节点做一次 spfa 就能判断出原图是否有负环\n![mark](https://static.imlgw.top/blog/20210317/eYBzmdAcyRL7.png)\n模拟第一次入队出队，虚拟节点出队后就会将所有的节点入队， $dis[i]$ 为虚拟源点到当前节点的最短路，所以一开始所有的 $dis[v_i]=0$ ，不用初始化为 $\\inf$ 。\n\n然后就是关键的判环步骤，我们只需要记录下每个点到虚拟源点的边的数量就行了（初始 $cnt[v_i]=1$ ），如果有负环就会无限制的松弛负环上的边，在负环路上打转，所以如果松弛后某个点到虚拟源点的边的数量大于等于 $N+1$ 就说明存在负环\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int INF = 0x3f3f3f3f;\n    static int N, M;\n    static int idx;\n    static int[] e, h, ne, w;\n    //a->b\n    public static void add(int a, int b, int c){\n        e[idx] = b; w[idx] = c;\n        ne[idx] = h[a]; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        N = in[0]; M = in[1];\n        e = new int[M+1]; ne = new int[M+1]; w = new int[M+1];\n        h = new int[N+1]; Arrays.fill(h, -1);\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            add(t[0], t[1], t[2]);\n        }\n        out.println(spfa() ? \"Yes\" : \"No\");\n        out.flush();\n    }\n\n    public static boolean spfa() {\n        Queue<Integer> queue = new LinkedList<>();\n        int[] dis = new int[N+1];\n        boolean[] vis = new boolean[N+1];\n        int[] cnt = new int[N+1];\n        for (int i = 1; i <= N; i++) {\n            queue.add(i);\n            vis[i] = true;\n            cnt[i] = 1;\n        }\n        while (!queue.isEmpty()) {\n            int top = queue.poll();\n            vis[top] = false;\n            for (int i = h[top]; i != -1; i = ne[i]) {\n                int j = e[i];\n                if (dis[j] > dis[top] + w[i]) {\n                    dis[j] = dis[top] + w[i];\n                    cnt[j] = cnt[top] + 1;\n                    if (cnt[j] >= N+1) return true;\n                    if (!vis[j]) {\n                        queue.add(j);\n                        vis[j] = true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [854. Floyd 求最短路](https://www.acwing.com/problem/content/description/856/)\n\n给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。\n\n再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出“impossible”。\n\n数据保证图中不存在负权回路。\n\n**输入格式**：\n\n第一行包含三个整数 n，m，k\n\n接下来 m 行，每行包含三个整数 x，y，z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n\n接下来 k 行，每行包含两个整数 x，y，表示询问点 x 到点 y 的最短距离。\n\n**输出格式**\n\n共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出“impossible”。\n\n**数据范围**： $1≤n≤200,1≤k≤n^2，1≤m≤20000$ , 图中涉及边长绝对值均不超过 10000。\n\n**输入样例：**\n```c\n3 3 2\n1 2 1\n2 3 2\n1 3 1\n2 1\n1 3\n```\n**输出样例：**\n```c\nimpossible\n1\n```\n\n### 解法一\nFloyd 是一个多源的最短路算法，也就是可以同时求出图中任意两点之间的最短路，本质是一个 DP，时间复杂度较高\n- 状态定义： $dis[k][i][j]$ ，从 $i$ 到 $j$ 经过前 $k$ 个点中转后的最短路\n- 入口： $dis[0][i][i]=0,dis[0][i][j] = w_{ij}$\n- 转移： $dis[k][i][j]=\\min(dis[k-1][i][j],dis[k-1][i][k]+dis[k-1][k][j])$\n- 出口： $dis[N][i][j]$ ，时间复杂度 $O(N^3)$\n\n由于 $dis[k]$ 仅仅依赖 $dis[k-1]$ ，所以通常我们这里都会降维写二维的\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1], K = in[2];\n        int INF = 0x3f3f3f3f;\n        int[][] dis = new int[N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(dis[i], INF);\n            dis[i][i] = 0;\n        }\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            int x = t[0], y = t[1];\n            dis[x][y] = Math.min(dis[x][y], t[2]);\n        }\n        for (int k = 1; k <= N; k++) {\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; j <= N; j++) {\n                    if (dis[i][k] == INF || dis[k][j] == INF) continue;\n                    dis[i][j] = Math.min(dis[i][j], dis[i][k] + dis[k][j]);\n                }\n            }\n        }\n        for (int i = 0; i < K; i++) {\n            int[] q = read(br);\n            int res = dis[q[0]][q[1]];\n            out.println(res == INF ? \"impossible\" : res);\n        }\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n三维的写法：[854. Floyd 求最短路 三维 DP 写法，不降维](https://gist.github.com/imlgw/438e7852947958f59c86133721210d01)\n\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1], K = in[2];\n        int INF = 0x3f3f3f3f;\n        int[][][] dis = new int[N+1][N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(dis[0][i], INF);\n            dis[0][i][i] = 0;\n        }\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            int x = t[0], y = t[1];\n            dis[0][x][y] = Math.min(dis[0][x][y], t[2]);\n        }\n        for (int k = 1; k <= N; k++) {\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; j <= N; j++) {\n                    if (dis[k-1][i][k] == INF || dis[k-1][k][j] == INF) {\n                        dis[k][i][j] = dis[k-1][i][j];\n                    } else {\n                        dis[k][i][j] = Math.min(dis[k-1][i][j], dis[k-1][i][k] + dis[k-1][k][j]);   \n                    }\n                }\n            }\n        }\n        for (int i = 0; i < K; i++) {\n            int[] q = read(br);\n            int res = dis[N][q[0]][q[1]];\n            out.println(res == INF ? \"impossible\" : res);\n        }\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>","tags":["算法","图论"],"categories":["算法"]},{"title":"DP：背包模型","url":"/2021/03/02/e60f310b/","content":"> 相关文章 [LeetCode 背包问题](http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/) \n\n## [423. 采药](https://www.acwing.com/problem/content/425/)\n\n辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。\n\n医师为了判断他的资质，给他出了一个难题。\n\n医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n\n如果你是辰辰，你能完成这个任务吗？\n\n**输入格式**\n\n输入文件的第一行有两个整数 $T$ 和 $M$ ，用一个空格隔开， $T$ 代表总共能够用来采药的时间， $M$ 代表山洞里的草药的数目。\n\n接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$ ）的整数，分别表示采摘某株草药的时间和这株草药的价值。\n\n**输出格式**\n\n输出文件包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。\n\n**数据范围**\n- $1≤T≤1000$\n- $1≤M≤100$\n\n**输入样例：**\n```c\n70 3\n71 100\n69 1\n1 2\n```\n**输出样例：**\n```c\n3\n```\n\n### 解法一\n\n没啥好说的，裸的 01 背包，考虑每个物品装或者不装\n```java\n//裸 01 背包\npublic static int solve(int T, int M, int[] v, int[] cost) {\n    //考虑前 i 件药，背包大小为 j，能装的最大收益\n    int[][] dp = new int[M+1][T+1];\n    //dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])\n    for (int i = 1; i <= M; i++) {\n        for (int j = T; j >= 0; j--) {\n            dp[i][j] = Math.max(dp[i-1][j], j >= cost[i-1] ? dp[i-1][j-cost[i-1]] + v[i-1] : -1);\n        }\n    }\n    return dp[M][T];\n}\n\n//空间优化\npublic static int solveOpt(int T, int M, int[] v, int[] cost) {\n    //考虑前 i 件药，背包大小为 j，能装的最大收益\n    //dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])\n    int[] dp = new int[T+1];\n    for (int i = 0; i < M; i++) {\n        for (int j = T; j >= cost[i]; j--) {\n            //j > cost[i] dp[j] = dp[j](old)\n            dp[j] = Math.max(dp[j], dp[j-cost[i]] + v[i]);\n        }\n    }\n    return dp[T];\n}\n```\n[1024. 装箱问题](https://www.acwing.com/problem/content/1026/) 和 [278. 数字组合](https://www.acwing.com/problem/content/280/) 和这个差不多，不多写了\n\n## [8. 二维费用的背包问题](https://www.acwing.com/problem/content/8/)\n有 $N$ 件物品和一个容量是 $V$ 的背包，背包能承受的最大重量是 $M$ 。\n\n每件物品只能用一次。体积是 $v_i$ ，重量是 $m_i$ ，价值是 $w_i$ 。\n\n求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。\n输出最大价值。\n\n**输入格式**\n\n第一行三个整数 $N,V,M$ ，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。\n\n接下来有 $N$ 行，每行三个整数 $v_i,m_i,w_i$ ，用空格隔开，分别表示第 $i$ 件物品的体积、重量和价值。\n\n**输出格式**\n\n输出一个整数，表示最大价值。\n\n**数据范围**：\n- $0<N≤1000$\n- $0<V,M≤100$\n- $0<vi,mi≤100$\n- $0<wi≤1000$\n\n**输入样例**\n```c\n4 5 6\n1 2 3\n2 4 4\n3 4 5\n4 5 6\n```\n**输出样例：**\n```c\n8\n```\n\n### 解法一\n多维费用 01 背包模板题\n```java\nimport java.io.*;\nimport java.util.*;\n\nclass Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        int N = in[0], V = in[1], M = in[2];\n        int[][] dp = new int[V+1][M+1];\n        for (int i = 1; i <= N; i++) {\n            int[] vmw = read(br);\n            int vi = vmw[0], mi = vmw[1], wi = vmw[2];\n            for (int j = V; j >= vi; j--) {\n                for (int k = M; k >= mi; k--) {\n                    dp[j][k] = Math.max(dp[j][k], dp[j-vi][k-mi]+wi);\n                }\n            }\n        }\n        System.out.println(dp[V][M]);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n## [1020. 潜水员](https://www.acwing.com/problem/content/1022/)\n潜水员为了潜水要使用特殊的装备。 他有一个带 2 种气体的气缸：一个为氧气，一个为氮气。\n\n让潜水员下潜的深度需要各种数量的氧和氮。 潜水员有一定数量的气缸，每个气缸都有重量和气体容量，潜水员为了完成他的工作需要特定数量的氧和氮。\n\n他完成工作所需气缸的总重的最低限度的是多少？\n\n**输入格式**\n\n第一行有 2 个整数 $m，n$ 。它们表示氧，氮各自需要的量。\n\n第二行为整数 $k$ 表示气缸的个数。\n\n此后的 $k$ 行，每行包括 $a_i，b_i，c_i$ 。这些各自是：第 $i$ 个气缸里的氧和氮的容量及气缸重量。\n\n**输出格式**\n\n仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。\n\n**数据范围**：\n- $1≤m≤21$\n- $1≤n≤79$ \n- $1≤k≤1000$ \n- $1≤ai≤21$ \n- $1≤bi≤79$ \n- $1≤ci≤800$\n\n**输入样例：**\n```c\n5 60\n5\n3 36 120\n10 25 129\n5 50 250\n1 45 130\n4 20 119\n```\n**输出样例：**\n```c\n249\n```\n\n### 解法一\n一开始写了个记忆化递归，负数状态不保存，结果 T 了。这题也是二维费用的背包问题，但是这里是求能覆盖费用的最小重量，求的是**至少**，上面的求的是**最多**，方程其实很相似，但是细节还是不一样\n\n首先初始状态不一样，这里求最小值，初始状态应该赋值为+∞， $dp[i][j][k]$ 代表前 $i$ 个氧气罐，氧气至少为 $j$ ，氮气至少为 $k$ 的时候，气缸最小的重量，核心的递推方程仍然是下面这个，只是状态的含义变了（省略一维， $y_i,d_i,w_i$ 代表氧气，氮气，质量）\n\n$$\ndp[j][k] = \\min(dp[j][k], dp[j-y_i][k-d_i]+w_i)\n$$\n\n注意这里二个维度的状态说的都是**至少**，那么意味着 $j-y_i < 0$ 或者 $k-d_i < 0$ 也是合法的，而负数状态和 $0$ 状态（至少是 $0$ ）是等价的，所以我们可以从 $0$ 状态合法的转移过来，使得状态计算完整不遗漏。一开始自己思考的时候想到了这种情况，但是考虑的不够完全\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class AcWing1020_潜水员 {\n    public static void main(String[] args) throws Exception {\n        new Main().main();\n    }\n}\n\nclass Main {\n    \n    //dp[i][j] = Math.min(dp[i][j], dp[i-y][j-d]+w);\n    public static void main(String... args) throws Exception {\n        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int INF = 0x3f3f3f3f;\n        int[] in = read(br);\n        int Y = in[0], D = in[1], N = Integer.parseInt(br.readLine());\n        //dp[i][j]: 氧气至少 i，氮气至少 j，需要的最小重量\n        int[][] dp = new int[Y+1][D+1];\n        for (int i = 0; i <= Y; i++) {\n            Arrays.fill(dp[i], INF);\n        }\n        dp[0][0] = 0;\n        for (int i = 0; i < N; i++) {\n            int[] ydw = read(br);\n            int yi = ydw[0], di = ydw[1], wi = ydw[2];\n            for (int j = Y; j >= 0; j--) {\n                for (int k = D; k >= 0; k--) {\n                    // if (j < yi || k < di) {\n                    //     dp[j][k] = Math.min(dp[j][k], wi);\n                    // } else {\n                    //     dp[j][k] = Math.min(dp[j][k], dp[j-yi][k-di] + wi);\n                    // }\n                    // 上面的递推缺乏考虑，如果氧气和氮气只有一种超出了范围，另一维的状态不应该跟着按照 0 算\n                    dp[j][k] = Math.min(dp[j][k], dp[Math.max(j-yi, 0)][Math.max(k-di, 0)] + wi);\n                }\n            }\n        }\n        System.out.println(dp[Y][D]);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/1024/)\n\n宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。\n\n一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。\n\n小智也想收服其中的一些小精灵。然而，野生的小精灵并不那么容易被收服。\n\n对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。\n\n当皮卡丘的体力小于等于 0 时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于 0 的野生小精灵也不会被小智收服。\n\n当小智的精灵球用完时，狩猎也宣告结束。\n\n我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。\n\n如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。\n\n小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。\n\n现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。\n\n请问，小智该如何选择收服哪些小精灵以达到他的目标呢？\n\n**输入格式**\n\n输入数据的第一行包含三个整数： $N，M，K$ ，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。\n\n之后的 $K$ 行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。\n\n**输出格式**\n\n输出为一行，包含两个整数： $C，R$ ，分别表示最多收服 C 个小精灵，以及收服 C 个小精灵时皮卡丘的剩余体力值最多为 R。\n\n**数据范围**\n- $0<N≤1000$\n- $0<M≤500$\n- $0<K≤100$\n\n**输入样例 1：**\n```c\n10 100 5\n7 10\n2 40\n2 50\n1 20\n4 20\n```\n**输出样例 1：**\n```c\n3 30\n```\n**输入样例 2：**\n```c\n10 100 5\n8 110\n12 10\n20 10\n5 200\n1 110\n```\n**输出样例 2：**\n```c\n0 100\n```\n\n### 解法一\n$dp[i][j][k]$ ： 考虑前 i 个宠物，消耗 j 个精灵球和 k 点生命值，能捕获的最多的精灵数量，这里直接将一维消掉，就是个多维的 01 背包，时间复杂度 $O(NMK)\\approx 5*10^7$ 已经在 T 的边缘了\n```java\n//多维 01 背包 O(N*M*K) 5 x 10^7\npublic static int[] solve(int N, int M, int K, int[] costN, int[] costM) {\n    //dp[i][j]: 消耗最多 i 个精灵球和最多 j 点生命值，能捕捉的最多精灵数量\n    int[][] dp = new int[N+1][M+1];\n    for (int i = 0; i < K; i++) {\n        for (int j = N; j >= costN[i]; j--) {\n            for (int k = M; k >= costM[i]; k--) {\n                //注意这里 N 和 M 的 cost 都满足才能计算\n                dp[j][k] = Math.max(dp[j][k], dp[j-costN[i]][k-costM[i]] + 1);\n            }\n        }\n    }\n    int maxCnt = dp[N][M], minCost = 0;\n    //枚举出捕获 maxCnt 个精灵球，消耗的最小生命值\n    for (int i = 0; i <= M; i++) {\n        if (dp[N][i] == maxCnt) {\n            minCost = i;\n            break;\n        }\n    }\n    //最后+1，把之前的加回来\n    return new int[]{maxCnt, M+1-minCost};\n}\n```\n\n### 解法二\n\n背包维度的转换，选择范围较小的作为状态值，设置 $dp[i][j][k]$ 为：考虑前 i 个宠物，捕获 j 个精灵消耗 k 个精灵球，消耗的最少的生命值，这样时间复杂度就变成了 $O(K^2N)\\approx 10^7$ ，也是很大的一步优化了，当然也可以进一步优化成 $O(K^2M)$ 不过稍微有点难处理点，就不多写了\n\n```java\n//交换维度，降低复杂度，O(K^2*N) = 10^7 还可以优化成 k^2*m\npublic static int[] solveOpt(int N, int M, int K, int[] costN, int[] costM) {\n    //dp[i][j]: 捕捉 i 个精灵，消耗 j 个精灵球，消耗的最少的体力值\n    int[][] dp = new int[K+1][N+1];\n    for (int i = 1; i <= K; i++) {\n        for (int j = 0; j <= N; j++) {\n            dp[i][j] = 0x3f3f3f3f; \n        }\n    }\n    for (int i = 0; i < K; i++) {\n        for (int j = K; j >= 1; j--) {\n            for (int k = N; k >= costN[i]; k--) {\n                if (dp[j-1][k-costN[i]] + costM[i] <= M) {\n                    dp[j][k] = Math.min(dp[j][k], dp[j-1][k-costN[i]]+costM[i]);\n                }\n            }\n        }\n    }\n    int maxCnt = 0;\n    for (int i = K; i >= 0; i--) {\n        if (dp[i][N] <= M) {\n            maxCnt = i;\n            break;\n        }\n    }\n    //最后+1，把之前的加回来\n    return new int[]{maxCnt, M+1-dp[maxCnt][N]};\n}\n```\n\n## [HUD4501. 小明系列故事——买年货（HUDOJ）](http://acm.hdu.edu.cn/showproblem.php?pid=4501)\n\n**Problem Description**\n\n春节将至，小明要去超市购置年货，于是小明去了自己经常去的都尚超市。\n\n刚到超市，小明就发现超市门口聚集一堆人。用白云女士的话说就是：“那家伙，那场面，真是人山人海，锣鼓喧天，鞭炮齐呤，红旗招展。那可真是相当的壮观啊！”。好奇的小明走过去，奋力挤过人群，发现超市门口贴了一张通知，内容如下\n\n值此新春佳节来临之际，为了回馈广大顾客的支持和厚爱，特举行春节大酬宾、优惠大放送活动。凡是都尚会员都可用会员积分兑换商品，凡是都尚会员都可**免费拿 k 件商品**，凡是购物顾客均有好礼相送。满 100 元送 bla bla bla bla，满 200 元送 bla bla bla bla bla...blablabla....\n\n还没看完通知，小明就高兴的要死，因为他就是都尚的会员啊。迫不及待的小明在超市逛了一圈发现超市里有** n 件他想要的商品**。小明顺便对这 n 件商品打了分，表示商品的实际价值。小明发现身上带了** v1 的人民币**，会员卡里面有** v2 的积分**。他想知道他最多能买多大价值的商品。\n\n由于小明想要的商品实在太多了，他算了半天头都疼了也没算出来，所以请你这位聪明的程序员来帮帮他吧。\n \n\n**Input**\n```go\n输入包含多组测试用例。\n每组数据的第一行是四个整数 n，v1，v2，k；\n然后是 n 行，每行三个整数 a，b，val，分别表示每个商品的价钱，兑换所需积分，实际价值。\n[Technical Specification]\n1 <= n <= 100\n0 <= v1, v2 <= 100\n0 <= k <= 5\n0 <= a, b, val <= 100\n\nPs. 只要钱或者积分满足购买一件商品的要求，那么就可以买下这件商品。\n```\n\n**Output**\n```go\n对于每组数据，输出能买的最大价值。\n详细信息见 Sample。\n```\n**Sample Input**\n\n```go\n5 1 6 1\n4 3 3\n0 3 2\n2 3 3\n3 3 2\n1 0 2\n4 2 5 0\n0 1 0\n4 4 1\n3 3 4\n3 4 4\n```\n\n**Sample Output**\n\n```go\n12\n4\n```\nSource\n2013 腾讯编程马拉松初赛第〇场（3 月 20 日）\n\n### 解法一\n> 很久之前做过的题，拿出来对比下\n\n三维费用的背包，但是和前面的题有点不一样，三个维度的费用是无关的，上面的小精灵，消耗的精灵球和生命值是相关的，所以两个维度的费用需要同时满足才能做合法的计算，而这里并不需要全部满足，而是分别计算\n```java\nimport java.util.*;\nimport java.io.*;// petr 的输入模板\nimport java.math.*; // 不是大数题可以不要这个\n\npublic class Solve_HDOJ_4501 {\n\n    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) throws Exception{\n        InputReader in = new InputReader(System.in);\n        //InputReader in = new InputReader(new FileInputStream(\"./input.txt\"));\n        while(!in.EOF()) {\n            int n = in.nextInt();\n            int v1 = in.nextInt();\n            int v2 = in.nextInt();\n            int k = in.nextInt();\n            int[][] cost = new int[n][3];\n            for (int i = 0; i < n; i++) {\n                cost[i][0] = in.nextInt();\n                cost[i][1] = in.nextInt();\n                cost[i][2] = in.nextInt();\n            }\n            solve(n, v1, v2, k, cost);\n        }\n        //别忘了 flush\n        out.flush();\n        out.close();\n    }\n\n    //因为数据量不大，就直接 Scanner 了\n    public static void solve(int n, int v1, int v2, int k, int[][] cost) {\n        int[][][] dp = new int[k+1][v1+1][v2+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= 0; j--) {\n                for (int u = v1; u >= 0; u--) {\n                    for (int w = v2; w >= 0; w--) {\n                        //这里不能直接 u>=cost[i][0] w >= cost[i][1]，因为积分和钱和免费拿是分开的，没有关联的\n                        //即使我不能免费拿，但是我能用积分拿，即使不能用积分拿，我可以用钱买\n                        //dp[j][u][w] = Math.max(dp[j][u][w], dp[j-1][u-cost[i][0]][w-cost[i][1]] + cost[i][2]);\n                        int ans = 0;\n                        if (j >= 1) { //免费拿\n                            ans = Math.max(ans, dp[j-1][u][w] + cost[i][2]);\n                        }\n                        if (u >= cost[i][0]) { //钱\n                            ans = Math.max(ans, dp[j][u-cost[i][0]][w] + cost[i][2]);\n                        }\n                        if (w >= cost[i][1]) { //积分\n                            ans = Math.max(ans, dp[j][u][w-cost[i][1]] + cost[i][2]);\n                        }\n                        dp[j][u][w] = Math.max(ans, dp[j][u][w]);\n                    }\n                }\n            }\n        }\n        out.println(dp[k][v1][v2]);\n    }\n}\n\nclass InputReader {\n\n    public BufferedReader reader;\n    \n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        //char[32768]\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    //默认以\" \"作为分隔符，读一个\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    //有的题目不给有多少组测试用例，只能一直读，读到结尾，需要自己判断结束\n    //该函数也会读取一行，并初始化 tokenizer，后序直接 nextInt.. 等就可以读到该行\n    public boolean EOF() {\n        String str = null;\n        try {\n            str = reader.readLine();\n            if (str == null) {\n                return true;\n            }\n            //创建 tokenizer\n            tokenizer = new StringTokenizer(str);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }\n\n    int nextInt(){\n        return Integer.parseInt(next());\n    }\n    \n    long nextLong(){\n        return Long.parseLong(next());\n    }\n    \n    double nextDouble(){\n        return Double.parseDouble(next());\n    }\n    \n    BigInteger nextBigInteger(){\n        return new BigInteger(next());\n    }\n\n    BigDecimal nextBigDecimal(){\n        return new BigDecimal(next());\n    }\n}\n```\n\n## [1023. 买书](https://www.acwing.com/problem/content/1025/)\n\n小明手里有 $n$ 元钱全部用来买书，书的价格为 10 元，20 元，50 元，100 元。\n\n问小明有多少种买书方案？（每种书可购买多本） $0 ≤ n ≤ 1000$\n\n### 解法一\n\n完全背包，自己推下递推公式，状态定义： $dp[i][j]$ 代表前 $i$ 本书，价格恰好为 $j$ 元时，买书的方案数量，初始状态为 $dp[0][0]=1$ ，啥也不买也是一种方案。一个很显然的状态转移方程为：\n\n$dp[i][j]=dp[i-1][j]+dp[i-1][j-v]+dp[i-1][j-2v]+...+dp[i-1][j \\bmod v]$\n\n但是这个转移方程时间复杂度非常高，因为需要枚举每个物品可拿取的个数，我们再观察一下式子，列出 $dp[i][j-v]$ 的递推方程：\n\n$dp[i][j-v]=dp[i-1][j-v] + dp[i-1][j-2v] + ... + dp[i-1][j-v \\bmod v]$\n\n然后会发现 $dp[i][j-v]$ 和 $dp[i][j]$ 的后面部分其实是等价的（ $j$ 和 $j-v$ 除以 $v$ 同余），所以我们就可以将原本的递推方程转换成： $dp[i][j] = dp[i-1][j] + dp[i][j-v]$\n\n```java\n//完全背包\npublic static int solve(int N) {\n    //dp[i][j]: 考虑前 i 本书，凑齐 j 价值的种类数\n    int[][] dp = new int[5][N+1];\n    //dp[i][j] = dp[i-1][j] + dp[i-1][j-c[i]] + dp[i-1][j-2*c[i]] + ... + dp[i-1][k*c[i]]\n    //dp[i][j-c[i]] = dp[i-1][j-c[i]] + dp[i-1][j-2*c[i]] + ... + dp[i-1][k*c[i]]\n    //dp[i][j] = dp[i-1][j] + dp[i][j-c[i]]\n    dp[0][0] = 1;\n    for (int i = 1; i <= 4; i++) {\n        for (int j = 0; j <= N; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (j >= price[i-1]) {\n                dp[i][j] += dp[i][j-price[i-1]];\n            }\n        }\n    }\n    return dp[4][N];\n}\n```\n<details>\n<summary>降维写法</summary>\n```java\n//空间优化\npublic static int solveOpt(int N) {\n    //dp[i][j]: 考虑前 i 本书，凑齐 j 价值的种类数\n    int[] dp = new int[N+1];\n    dp[0] = 1;\n    for (int i = 1; i <= 4; i++) {\n        for (int j = price[i-1]; j <= N; j++) {\n            dp[j] += dp[j-price[i-1]];\n        }\n    }\n    return dp[N];\n}\n```\n</details>\n\n[1021. 货币系统](https://www.acwing.com/problem/content/1023/) 和这个一样，不多写\n\n## [532. 货币系统（NOIP2018）](https://www.acwing.com/problem/content/534/)\n\n在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a_i$ ，你可以假设每一种货币都有无穷多张。\n\n为了方便，我们把货币种数为 $n$ 、面额数组为 $a[1..n]$  的货币系统记作  $(n,a)$ 。 \n\n在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$ ，都存在 $n$ 个非负整数 $t_i$ 满足  $a_i\\ast t_i$ 的和为 $x$ 。\n\n然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额 x 不能被该货币系统表示出。\n\n例如在货币系统 $n=3, a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 \n\n两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数  $x$ ，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 \n\n现在网友们打算简化一下货币系统。\n\n他们希望找到一个货币系统 $(m,b)$ ，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。\n\n他们希望你来协助完成这个艰巨的任务：找到最小的 $m$ 。\n\n**输入格式**\n\n输入文件的第一行包含一个整数 $T$ ，表示数据的组数。\n\n接下来按照如下格式分别给出 $T$ 组数据。 \n\n每组数据的第一行包含一个正整数 $n$ 。\n\n接下来一行包含 $n$ 个由空格隔开的正整数 $a_i$ 。\n\n**输出格式**\n\n输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$ 。\n\n**数据范围**: \n- $1≤n≤100$\n- $1≤a_i≤25000$\n- $1≤T≤20$\n\n**输入样例：**\n```c\n2 \n4 \n3 19 10 6 \n5 \n11 29 13 19 17 \n```\n**输出样例：**\n```c\n2\n5\n```\n\n### 解法一\n这里用了一个看起来很显然的结论：简化后的货币系统 $(m,b)$ ，就是在原货币系统 $(m,a)$ 中，剔除所有能被自分解的数得到的。判断集合中一个数能否被其他的数构成，其实问题就变成了完全背包求方案数，最后求得方案数为 $1$ 的就是不能被分解的数，统计下结果就 ok 了\n```java\npublic static int solve(int[] w) {\n    int n = w.length;\n    int max = 0;\n    for (int i = 0; i < n; i++) {\n        max = Math.max(max, w[i]);\n    }\n    int[] dp = new int[25001];\n    dp[0] = 1;\n    //完全背包求构成每个值的方案数\n    for (int i = 0; i < n; i++) {\n        for (int j = w[i]; j <= max; j++) {\n            dp[j] += dp[j-w[i]];\n        }\n    }\n    int res = 0;\n    //方案数为 1 的就说明是不能丢掉的，统计一下就 ok\n    for (int i = 0; i < n; i++) {\n        if (dp[w[i]] == 1) {\n            res++;\n        }\n    }\n    return res;\n}\n```\n看起来很显然的结论的 [证明](https://www.cnblogs.com/UntitledCpp/p/14083854.html#day1-t2-%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F)\n\n## [6. 多重背包问题 III](https://www.acwing.com/problem/content/6/)\n有 $N$ 种物品和一个容量是 $V$ 的背包。第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$ ，价值是 $w_i$ 。\n\n求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大，输出最大价值。\n\n**输入格式**\n\n第一行两个整数， $N，V (0<N≤1000, 0<V≤20000)$ ，用空格隔开，分别表示物品种数和背包容积。\n\n接下来有 $N$ 行，每行三个整数 $v_i,w_i,s_i$ ，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。\n\n**输出格式**\n\n输出一个整数，表示最大价值。\n\n**数据范围** : \n- $0<N≤1000$\n- $0<V≤20000$\n- $0<vi,wi,si≤20000$\n\n**输入样例**\n```c\n4 5\n1 2 3\n2 4 1\n3 4 3\n4 5 2\n```\n\n**输出样例：**\n```c\n10\n```\n### 解法一\n暴力的做法，将物品限制泛化成一个个独立的物品，然后就变成 01 背包了，数据量小的时候可以，但是这里明显不行，时间复杂度 $O(NVS)\\approx4e11$ ，所以必然是过不了 OJ 的\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n\n    //dp[i][j]=Max(dp[i-1][j], dp[i-1][j-v]+w, dp[i-1][j-2*v]+2*w,... dp[i-1][j-s*v]+s*w)\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        int N = in[0];\n        int M = in[1];\n        int[][] dp = new int[N+1][M+1];\n        LinkedList<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= N; i++) {\n            int[] temp = read(br);\n            int v = temp[0], w = temp[1], s = temp[2];\n            for (int j = 0; j <= M; j++) {\n                for (int k = 0; k <= s && k*v <= j; k++) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i-1][j-k*v]+k*w);\n                }\n            }\n        }\n        System.out.println(dp[N][M]);\n    }\n\n    private static int[] read(BufferedReader br) throws IOException {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n我在第一次做这个题的时候其实就想着这个能不能用前面 [完全背包](#1023-买书）的方法去处理，降低复杂度。很显然这是不行的，考虑两个方程的最后一项，因为有了物品个数的限制 $s$ ， $dp[i][j]$ 最后一项为 $dp[i-1][j-sv]$ ，而 $dp[i][j-v]$ 为 $dp[i-1][(j-v)-sv]$ ，而这两项并不一定相等，所以上下两项并不能做替换\n### 解法二\n二进制优化的方法，明天再看😁\n### 解法三\n\n单调队列优化 DP，有点难度，看题解都看了好久才理解。\n\n首先我们很容易得到整体的递推公式： $dp[i][j]$ 代表前 i 个物品，背包体积为 j 时，能装的最大价值\n\n$$\ndp[i][j]=\\max(dp[i−1][j], dp[i−1][j−v]+w, dp[i−1][j−2∗v]+2∗w,… dp[i−1][j−s∗v]+s∗w)\n$$\n\n其实和前面完全背包差不多，只是多了一个物品数量 s 的限制。我们可以发现 $dp[j]$ 只和 $j-v$ , $j-2v$ , $j-3v$ 这些状态有关，而这些状态除以 $v$ 是同余的，所以我们可以将状态**按余数**划分为不同的组，余数 $r$ 的范围是 $[0, v)$\n\n转移方程变为\n```java\n// 0 <= r < v\ndp[i][r]    =     dp[i-1][r]\ndp[i][r+v]  = max(dp[i-1][r] +  w,  dp[i-1][r+v])\ndp[i][r+2v] = max(dp[i-1][r] + 2w,  dp[i-1][r+v] +  w, dp[i-1][r+2v])\ndp[i][r+3v] = max(dp[i-1][r] + 3w,  dp[i-1][r+v] + 2w, dp[i-1][r+2v] + w, dp[i-1][r+3v])\n```\n这个时候其实我们已经可以发现一些端倪了，后一项都是前一项加上一个值再加上一些偏移量再取 Max 的值，我们再将其变形一下\n```java\n// 0 <= r < v\ndp[i][r]    =     dp[i-1][r]\ndp[i][r+v]  = max(dp[i-1][r],  dp[i-1][r+v] - w) + w\ndp[i][r+2v] = max(dp[i-1][r],  dp[i-1][r+v] - w, dp[i-1][r+2v] - 2w) + 2w\ndp[i][r+3v] = max(dp[i-1][r],  dp[i-1][r+v] - w, dp[i-1][r+2v] - 2w, dp[i-1][r+3v] - 3w) + 3w\n```\n现在其实就很明显了，max 内就是一个简单的滑窗，我们可以用单调队列去维护滑窗的最大值（[模板](http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC)）\n\n具体代码如下，时间复杂度 $O(NM)$ ，还可以用滚动数组去优化空间，这里就不写了，不然代码变得更加难懂了\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n\n    //dp[i][j]   = Max(dp[i-1][j], dp[i-1][j-v]+w, dp[i-1][j-2*v]+2*w,... dp[i-1][j-s*v]+s*w)\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(br);\n        int N = in[0];\n        int M = in[1];\n        int[][] dp = new int[N+1][M+1];\n        //单调队列求最大值\n        LinkedList<int[]> queue = new LinkedList<>();\n        for (int i = 1; i <= N; i++) {\n            int[] temp = read(br);\n            int v = temp[0], w = temp[1], s = temp[2];\n            //枚举余数 [0, v)\n            for (int r = 0; r < v; r++) {\n                queue.clear();\n                //枚举同余所有状态 dp[j] dp[j+v] dp[j+2v]....\n                for (int k = 0; r+k*v <= M; k++) {\n                    int val = dp[i-1][r+k*v] - k*w;\n                    while (!queue.isEmpty() && queue.getLast()[0] < val) {\n                        queue.removeLast();\n                    }\n                    //同余的数组元素数量可能超过同一物品的使用次数 s\n                    //区间内使用次数：((r+k*v)-(r+q.first()[1]*v)) / v = k-q.first()[1]\n                    if (!queue.isEmpty() && k - queue.getFirst()[1] > s) {\n                        queue.removeFirst();\n                    }\n                    queue.addLast(new int[]{val, k});\n                    dp[i][r+k*v] = queue.getFirst()[0] + k*w;\n                }\n            }\n        }\n        System.out.println(dp[N][M]);\n    }\n\n    private static int[] read(BufferedReader br) throws IOException {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n还是有点难度喔，这题虽然搞懂了，但是下次遇到类似的题还是不一定会😂\n> 说来就来，220th 周赛 t3 就用到了单调队列优化，不过是个最简单的，还是自己写出来了，[详见题解](https://imlgw.top/2020/12/29/li-kou-220th-zhou-sai/#1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-VI)\n## [1019. 庆功会](https://www.acwing.com/problem/content/description/1021/)\n为了庆贺班级在校运动会上取得全校第一名成绩，班主任决定开一场庆功会，为此拨款购买奖品犒劳运动员。\n\n期望拨款金额能购买最大价值的奖品，可以补充他们的精力和体力。\n\n**输入格式**\n\n第一行二个数 $n，m$ ，其中 $n$ 代表希望购买的奖品的种数， $m$ 表示拨款金额。\n\n接下来 $n$ 行，每行 3 个数， $v、w、s$ ，分别表示第 I 种奖品的价格、价值（价格与价值是不同的概念）和能购买的最大数量（买 $0$ 件到 $s$ 件均可）。\n\n**输出格式**\n\n一行一个数，表示此次购买能获得的最大的价值（注意！不是价格）。\n\n**数据范围** ：\n- $n≤500$ \n- $m≤6000$ \n- $v≤100$\n- $w≤1000$ \n- $s≤10$\n\n**输入样例：**\n```c\n5 1000\n80 20 4\n40 50 9\n30 50 7\n40 30 6\n20 20 1\n```\n**输出样例：**\n```c\n1040\n```\n### 解法一\n\n暴力解法，这题数据较小 $3e7$ 可以过\n```java\n//每个物品有 k 个数量的限制后，问题就变成了 01 背包\n//dp[i][j] = Max(dp[i-1][j], dp[i-1][j-v[i]]+w[i], dp[i-1][j-2*v[i]]+2*w[i], ... dp[i-1][j-s[i]*v[i]] + s[i]*w[i]) \npublic static int solve (int m, int[] v, int[] w, int[] s) {\n    int n = v.length;\n    int[] dp = new int[m+1];\n    for (int i = 0; i < n; i++) {\n        //逆序避免覆盖\n        for (int j = m; j >= v[i]; j--) {\n            for (int k = s[i]; k >= 0; k--) {\n                if (j-k*v[i] < 0) continue;\n                dp[j] = Math.max(dp[j], dp[j-k*v[i]] + k*w[i]);\n            }\n        }\n    }\n    return dp[m];\n}\n```\n单调队列优化和上面一摸一样，不写了\n\n## [7. 混合背包问题](https://www.acwing.com/problem/content/7/)\n\n有 $N$ 种物品和一个容量是 $V$ 的背包。\n\n物品一共有三类：\n1. 第一类物品只能用 $1$ 次（01 背包）；\n2. 第二类物品可以用无限次（完全背包）；\n3. 第三类物品最多只能用 $s_i$ 次（多重背包）；\n\n每种体积是 $v_i$ ，价值是 $w_i$ 。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n输出最大价值。\n\n**输入格式**\n\n第一行两个整数 $N，V$ 用空格隔开，分别表示物品种数和背包容积。\n\n接下来有 $N$ 行，每行三个整数 $v_i,w_i,s_i$ ，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。\n\n- $s_i=−1$ 表示第 $i$ 种物品只能用 $1$ 次；\n- $s_i=0$ 表示第 $i$ 种物品可以用无限次；\n- $s_i>0$ 表示第 $i$ 种物品可以使用 $s_i$ 次；\n\n**输出格式**\n\n输出一个整数，表示最大价值。\n\n**数据范围**：\n- $0<N,V≤1000$\n- $0<vi,wi≤1000$\n- $−1≤si≤1000$\n\n**输入样例**\n```c\n4 5\n1 2 -1\n2 4 1\n3 4 0\n4 5 2\n```\n**输出样例：**\n```czuo1\n8\n```\n\n### 解法一\n\n实际上就是把三种背包混到一起，我们对不同的物品做不同的处理就行了，每个物品的 $s$ 并不会影响后面的物品存取\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        int[] in = read(bf);\n        int N = in[0];\n        int V = in[1];\n        int[] dp = new int[V+1];\n        for (int i = 1; i <= N; i++) {\n            int[] vws = read(bf);\n            int v = vws[0], w = vws[1], s = vws[2];\n            if (s == -1) s=1;\n            if (s == 0) {\n                for (int j = v; j <= V; j++) {\n                    dp[j] = Math.max(dp[j], dp[j-v]+w);\n                }\n            } else {\n                for (int j = V; j >= 0; j--) {\n                    for (int k = 1; k <= s && j-k*v >= 0; k++) {\n                        dp[j] = Math.max(dp[j], dp[j-k*v]+k*w);\n                    }\n                }\n            }\n        }\n        System.out.println(dp[V]);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception{\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n多重背包的情况暂时还没有做优化，等后面看了二进制优化的方法窄来补一发，单调队列优化的不太想写\n\n## [1013. 机器分配](https://www.acwing.com/problem/content/1015/)\n\n总公司拥有 $M$ 台 相同 的高效设备，准备分给下属的 $N$ 个分公司。\n\n各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。\n\n问：如何分配这 M 台设备才能使国家得到的盈利最大？求出最大盈利值。\n\n分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数 $M$ 。\n\n**输入格式**\n\n第一行有两个数，第一个数是分公司数 $N$ ，第二个数是设备台数 $M$ ；\n\n接下来是一个 $N\\ast M$ 的矩阵，矩阵中的第 $i$ 行第 $j$ 列的整数表示第 $i$ 个公司分配 $j$ 台机器时的盈利。\n\n**输出格式**\n\n第一行输出最大盈利值；\n\n接下 $N$ 行，每行有 $2$ 个数，即分公司编号和该分公司获得设备台数。\n\n答案不唯一，输入任意合法方案即可。\n\n**数据范围**：\n- $1≤N≤10$\n- $1≤M≤15$\n\n**输入样例：**\n```c\n3 3\n30 40 50\n20 30 50\n20 25 30\n```\n**输出样例：**\n```c\n70\n1 1\n2 1\n3 1\n```\n### 解法一\n其实依然是一个 01 背包的问题。 $M$ 件商品分配给 $N$ 个公司，反过来就是从 $N$ 个公司中选择几个公司，然后再选择每个公司分配多少个，直接推就行了。\n\n$dp[i][j]$ 代表前 $i$ 个公司，分配 $j$ 台设备的最大收益，不过一开始写二维的递推时写出了 bug，内循环中递推写成了 \n\n$dp[i][j] = \\max(dp[i-1][j], dp[i-1][j-k]+w[k-1])$ 。\n\n这里最内层的循环枚举的是一共 $j$ 台机器，当前公司分配的机器个数，所以应该和上一轮枚举的结果比较，求一个最大的 $dp[i][j]$ 而不是和 $dp[i-1][j]$ 比较，所以正确写法应该是：\n\n$dp[i][j] = \\max(dp[i-1][j], \\max(dp[i][j], dp[i-1][j-k]+w[k-1]))$\n\n当然如果写一维的背包这里就没问题， $dp[j]$ 直接就是上一轮个数的结果\n\n```java\n//降维 & 简化后的代码\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1];\n        int[] dp = new int[M+1];\n        int[][] back = new int[N+1][M+1];\n        for (int i = 1; i <= N; i++) {\n            int[] w = read(br);\n            for (int j = M; j >= 1; j--) {\n                for (int k = 1; k <= j; k++) {\n                    int temp = dp[j-k]+w[k-1];\n                    if (temp > dp[j]) {\n                        //记录当前子公司最优分配多少个，然后从后往前推\n                        back[i][j] = k;\n                        dp[j] = temp;\n                    }\n                }\n            }\n        }\n        int[] res = new int[N];\n        int idx = 0;\n        int x = N, y = M;\n        while(idx < N) {\n            int k = back[x][y];\n            res[idx++] = k;\n            x--; y-=k;\n        }\n        System.out.println(dp[M]);\n        for (int i = N-1; i >= 0; i--) {\n            System.out.println((N-i)+ \" \" + res[i]);\n        }\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n\npublic class AcWing1013_机器分配 {\n    public static void main(String[] args) throws Exception {\n        new Main().main();\n    }\n}\n```\n其实也可以不用 back 数组，事后我看 yxc 的做法就是直接根据 dp 值枚举每个厂分配的个数，倒推看前面是从哪个转移过来的，这样复杂度会高一点点，而且不能做降维操作，其实都一样，核心就是从后往前倒推状态转移的方向\n\n## [426. 开心的金明](https://www.acwing.com/problem/content/428/)\n\n金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。\n\n更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 N 元钱就行”。\n\n今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 N 元。\n\n于是，他把每件物品规定了一个重要度，分为 5 等：用整数 1~5 表示，第 5 等最重要。\n\n他还从因特网上查到了每件物品的价格（都是整数元）。\n\n他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 \n\n设第 j 件物品的价格为 $v_j$ ，重要度为 $w_j$ ，共选中了 $k$ 件物品，编号依次为 $j_1，j_2，…，j_k$ ，则所求的总和为： \n\n$v[j_1]∗w[j_1]+v[j_2]∗w[j_2]+…+v[j_k]∗w[j_k]$ ，请你帮助金明设计一个满足要求的购物单。\n\n### 解法一\n01 背包模板\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int M = in[0], N = in[1];\n        int[] dp = new int[M+1];\n        for (int i = 1; i <= N; i++) {\n            int[] vp = read(br);\n            int v = vp[0], p = vp[1];\n            for (int j = M; j >= v; j--) {\n                dp[j] = Math.max(dp[j], dp[j-v]+v*p);\n            }\n        }\n        System.out.println(dp[M]);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [11. 背包问题求方案数](https://www.acwing.com/problem/content/11/)\n\n有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。\n\n第 $i$ 件物品的体积是 $v_i$ ，价值是 $w_i$ 。\n\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n\n输出 最优选法的方案数。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。\n\n**输入格式**\n\n第一行两个整数， $N$ ， $V$ ，用空格隔开，分别表示物品数量和背包容积。\n\n接下来有 $N$ 行，每行两个整数 $v_i$ , $w_i$ ，用空格隔开，分别表示第 $i$ 件物品的体积和价值。\n\n**输出格式**\n\n输出一个整数，表示 方案数 模 $10^9+7$ 的结果。\n\n**数据范围**\n\n- $0<N,V≤1000$\n- $0<v_i,w_i≤1000$\n\n**输入样例**\n```c\n4 5\n1 2\n2 4\n3 4\n4 6\n```\n\n**输出样例：**\n```c\n2\n```\n\n### 解法一\n背包问题搞起来还是有点麻烦喔，递推方程都是众所周知的，但是递推的细节有点不好想。\n\n下面的解法是设置的状态是： $dp[i][j]$ ，考虑前 $i$ 个物品体积 **恰好** 是 $j$ 的时候最大价值，同时还需要一个 $cnt[i][j]$ ，考虑前 $i$ 个物品体积恰好是 $j$ 的时候最大价值的方案数量， $cnt$ 根据 $dp$ 的值进行转移\n1. 当 $dp[i-1][j-v_i]+w_i > dp[i-1][j]$ 的时候，说明 $cnt[i][j]$ 当前的价值不是最大的，所以会被 $cnt[i-1][j-v_i]$ 替代\n2. 当 $dp[i-1][j-v_i]+w_i = dp[i-1][j]$ 的时候，说明 $cnt[i][j]$ 和 $cnt[i-1][j-v_i]$ 的最大价值相同，可以累加起来\n\n初始状态： $cnt[i][0] = 1$ ， $dp[i][0] = 0\\  other\\ \\inf$ （体积恰好为 0 只有一种方案，什么都不装）\n\n最后我们需要求出最大的价值 $maxV$ ，注意这里最大价值不一定是 $dp[N][V]$ ，因为我们这里求的是体积**恰好**为 $j$ 的最大价值。然后再根据最大价值的 $dp[i][j]$ 状态求对应 $cnt[i][j]$ 的方案数之和就行了\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], V = in[1];\n        int INF = 0x3f3f3f3f;\n        int MOD = (int)1e9+7;\n        // dp[j]: 体积刚好为 j 时，最大的价值\n        int[] dp = new int[V+1];\n        // cnt[j]: 体积刚好为 j 时，最大价值方案数\n        int[] cnt = new int[V+1];\n        Arrays.fill(dp, -INF);\n        dp[0] = 0; cnt[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            int[] t = read(br);\n            int vi = t[0], wi = t[1];\n            for (int j = V; j >= vi; j--) {\n                int val = dp[j-vi] + wi;\n                if (val > dp[j]) { // 从 dp[i-1][j-vi] 推过来，val 比当前的大，所以 cnt[j] 被取代\n                    cnt[j] = cnt[j-vi];\n                    dp[j] = val;\n                } else if (val == dp[j]) { // 从 dp[i-1][j-vi] 推过来，val 和当前相同，叠加起来\n                    cnt[j] = (cnt[j] + cnt[j-vi]) % MOD;\n                }\n            }\n        }\n        int maxW = 0;\n        for (int i = 0; i <= V; i++) maxW = Math.max(maxW, dp[i]);\n        long res = 0;\n        for (int i = 0; i <= V; i++) {\n            if (dp[i] == maxW) {\n                res = (res + cnt[i]) % MOD;\n            }\n        }\n        out.println(res);\n        out.flush();\n        out.close();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n### 解法二\n\n其实和上面的解法大同小异，但是状态的定义不一样，初始值不一样，但是转移方程是一样的，这里状态定义为： $dp[i][j]$ ，考虑前 $i$ 个物品体积 **最多** 是 $j$ 的时候最大价值， $cnt[i][j]$ 同理\n\n初始状态： $cnt[0][j] = 1$ ，注意和上面的区别，这里实际上没有物品可以装，所以最大价值就是 0，那么对于任意体积 $j$ ，我们只能选择不装，方案数量为 $1$\n```java\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], V = in[1];\n        int MOD = (int)1e9+7;\n        //dp[j]: 体积小于等于 j 时，最大的价值\n        int[] dp = new int[V+1];\n        //cnt[j]: 体积小于等于 j 时，最大价值方案数\n        int[] cnt = new int[V+1];\n        //这里其实初始化的是 dp[0][i]=1，此时最大价值就是 0，什么都不装\n        Arrays.fill(cnt, 1);\n        for (int i = 0; i < N; i++) {\n            int[] t = read(br);\n            int vi = t[0], wi = t[1];\n            for (int j = V; j >= vi; j--) {\n                int val = dp[j-vi] + wi;\n                if (val > dp[j]) {\n                    dp[j] = val;\n                    cnt[j] = cnt[j-vi];\n                } else if (val == dp[j]) {\n                    cnt[j] = (cnt[j] + cnt[j-vi]) % MOD;\n                }\n            }\n        }\n        out.println(cnt[V]);\n        out.flush();\n        out.close();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n> 初始状态的定义初始化还是要好好琢磨下\n\n## [10. 有依赖的背包问题](https://www.acwing.com/problem/content/description/10/)\n有 $N$ 个物品和一个容量是 $V$ 的背包。\n\n物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。\n\n如下图所示：\n\n![](https://i.loli.net/2021/02/22/aEhD4KInUcObAMk.png)\n\n如果选择物品 $5$ ，则必须选择物品 $1$ 和 $2$ 。这是因为 $2$ 是 $5$ 的父节点， $1$ 是 $2$ 的父节点。\n\n每件物品的编号是 $i$ ，体积是 $v_i$ ，价值是 $w_i$ ，依赖的父节点编号是 pi。物品的下标范围是 $1…N$ 。\n\n求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大，输出最大价值。\n\n**输入格式**\n\n第一行有两个整数 $N，V$ ，用空格隔开，分别表示物品个数和背包容量。\n\n接下来有 $N$ 行数据，每行数据表示一个物品。\n第 $i$ 行有三个整数 $v_i,w_i,p_i$ ，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。\n如果 $pi=−1$ ，表示根节点。 数据保证所有物品构成一棵树。\n\n**输出格式**\n\n输出一个整数，表示最大价值。\n\n**数据范围**：\n- $1≤N,V≤100$\n- $1≤v_i，w_i≤100$\n\n**父节点编号范围：**\n- 内部结点： $1≤p_i≤N$\n- 根节点 $p_i=−1$ ;\n\n**输入样例**\n```c\n5 7\n2 3 -1\n2 2 1\n3 5 1\n4 7 2\n3 6 2\n```\n**输出样例**\n```c\n11\n```\n### 解法一\n参考大佬的 [解法](https://www.acwing.com/solution/content/5780/)，多叉树转二叉树 + 记忆化递归的做法，感觉相比 yxc 的分组背包更好理解，也是能想到的范围。除此之外大佬还写了一种 dfs 序的方法，但是 dfs 序我还不太了解，先埋个坑，等以后遇到再来填一下\n```java\nimport java.util.*;\nimport java.io.*;\n\n/*\n多叉树的存储（左孩子，右兄弟）+ 记忆化递归\n */\nclass Main {\n\n    static int N, M;\n    static int[][] dp;\n    //二叉树节点\n    static int[] left, right;\n    static int[] son;\n    static int[] v, w;\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        N = in[0]; M = in[1];\n        left = new int[N+1]; right = new int[N+1];\n        v = new int[N+1]; w = new int[N+1];\n        son = new int[N+1];\n        dp = new int[N+1][M+1];\n        for (int i = 0; i <= N; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        int root = 0;\n        for (int i = 1; i <= N; i++) {\n            int[] t = read(br);\n            v[i] = t[0]; w[i] = t[1];\n            if (t[2] == -1) {\n                root = i;\n            } else {\n                if (son[t[2]] == 0) {\n                    left[t[2]] = i; //pi 之前没孩子，那么 i 就是 pi 的左孩子\n                } else {\n                    //pi 之前有孩子，那么 pi 的孩子和 i 就是兄弟\n                    right[son[t[2]]] = i;\n                }\n                //记录 pi 的孩子\n                son[t[2]] = i;\n            }\n        }\n        out.println(dfs(root, M));\n        out.flush();\n    }\n\n    //在 i 子树下，体积不超过 j 的情况下，能得到的最大收益\n    //子树的选取不是孤立的，是可以一起选的，所以应该按照体积分配划分子树\n    public static int dfs(int i, int j) {\n        // i=0 子树不存在\n        if (i==0 || j < 0) return 0;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        //不选当前节点，体积 j 全部分配给兄弟节点\n        dp[i][j] = dfs(right[i], j);\n        //当前节点必选，分给子节点 k，兄弟节点 j-v[i]-k\n        for (int k = 0; k <= j-v[i]; k++) {\n            dp[i][j] = Math.max(dp[i][j], dfs(left[i], k) + dfs(right[i], j-v[i]-k) + w[i]);\n        }\n        return dp[i][j];\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n### 解法二\n这个是 ycx 讲的方法，分组背包的解法，我反正是理解不能。.. 但是这里确实 AC 了。.. 不是我等凡人能想到的做法\n<details>\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int N, V;\n    static int[] vs;\n    static int[] ws;\n    static int idx;\n    static int[] h, ne, e;\n    static int[][] dp;\n    //添加边 a->b\n    public static void add(int a, int b) {\n        e[idx] = b; ne[idx] = h[a]; h[a] = idx++;\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        N = in[0]; V = in[1];\n        vs = new int[N+1]; ws = new int[N+1];\n        h = new int[N+1]; ne = new int[N+1]; e = new int[N+1];\n        Arrays.fill(h, -1);\n        dp = new int[N+1][V+1];\n        int root = 0;\n        for (int i = 1; i <= N; i++) {\n            int[] t = read(br);\n            vs[i] = t[0]; ws[i] = t[1];\n            if (t[2] == -1) {\n                root = i;\n            } else {\n                add(t[2], i);\n            }\n        }\n        dfs(root);\n        out.println(dp[root][V]);\n        out.flush();\n    }\n\n    //dp[i][j]: 在 i 子树下，体积不操作 j 的时候最大的价值\n    public static void dfs(int u) {\n        for (int i = h[u]; i != -1; i = ne[i]) {\n            dfs(e[i]);\n            //先将根节点的体积空出来，根节点是必选的\n            for (int j = V-vs[u]; j >= 0; j--) {\n                for (int k = 0; k <= j; k++) {\n                    //这里为什么可以直接用根节点+子节点？难道不会重复吗？\n                    dp[u][j] = Math.max(dp[u][j], dp[u][j-k]+dp[e[i]][k]);\n                }\n            }\n        }\n        for (int j = V; j >= 0; j--) {\n            if (j < vs[u]) {\n                dp[u][j] = 0;\n            } else {\n                dp[u][j] = dp[u][j-vs[u]] + ws[u];\n            }\n        }\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n</details>\n\n## [12. 背包问题求具体方案](https://www.acwing.com/problem/content/12/)\n\n有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。\n\n第 $i$ 件物品的体积是 $v_i$ ，价值是 $w_i$ 。\n\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n\n输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$ 。\n\n**输入格式**\n\n第一行两个整数， $N$ ， $V$ ，用空格隔开，分别表示物品数量和背包容积。\n\n接下来有 $N$ 行，每行两个整数 $v_i$ , $w_i$ ，用空格隔开，分别表示第 $i$ 件物品的体积和价值。\n\n**输出格式**\n\n输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。\n\n物品编号范围是 $1…N$ 。\n\n**数据范围**： $0<N,V≤1000$ ， $0<v_i,w_i≤1000$\n\n**输入样例**\n```c\n4 5\n1 2\n2 4\n3 4\n4 6\n```\n**输出样例：**\n```c\n1 4\n```\n### 解法一\n一开始写了使用 back 数组的方案，但是发现并不好求字典序最小的，back 数组是通过**倒推**推出来的，所以得到的一定不是字典序最小的。所以这里我们需要正向的推，改变状态方程定义，设置递推状态为： $dp[i][j]$ ，从第 $i$ 个物品到最后一个物品（ $i$ 从 0 开始，包括 $i$ ），体积不超过 $j$ 的最大收益\n- 入口： $dp[N][0 \\backsim M] = 0$ ，不选取任何物品\n- 转移： $dp[i][j] = \\min(dp[i+1][j], dp[i+1][j-v_i]+w_i)$\n- 出口： $dp[0][M]$ 就是最大收益\n\n在状态填充完毕后，我们就可以正向的推出一个字典序最小的方案：顺序遍历物品编号，当 $dp[i][M] = dp[i+1][M-v_i] + w_i$ ，说明选取该物品可以获得最大收益，我们要求的是字典序最小的，所以我们应该**优先选取**靠前的物品，而我们是正向遍历的，所以直接选取该物品输出，然后减去对应的体积，继续循环该过程，最终结果就一定是字典序最小的方案\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1];\n        int[] v = new int[N];\n        int[] w = new int[N];\n        for (int i = 0; i < N; i++) {\n            int[] t = read(br);\n            v[i] = t[0]; w[i] = t[1];\n        }\n        //第 i 个物品到最后（包括 i），体积不超过 j 的情况下最大收益（状态不同于之前的状态）\n        //dp[i][j] = min(dp[i+1][j], dp[i+1][j-v]+w)\n        int[][] dp = new int[N+1][M+1];\n        for (int i = N-1; i >= 0; i--) {\n            for (int j = M; j >= 0; j--) {\n                dp[i][j] = dp[i+1][j];\n                if (j >= v[i]) {\n                    dp[i][j] = Math.max(dp[i+1][j-v[i]] + w[i], dp[i+1][j]);;\n                }\n            }\n        }\n        for (int i = 0; i <= N-1; i++) {\n            if (M-v[i] < 0) continue;\n            if (dp[i][M] == dp[i+1][M-v[i]] + w[i]) {\n                out.print((i+1)+\" \");\n                M -= v[i];\n            }\n        }\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [734. 能量石](https://www.acwing.com/problem/content/736/)\n岩石怪物杜达生活在魔法森林中，他在午餐时收集了 $N$ 块能量石准备开吃。由于他的嘴很小，所以一次只能吃一块能量石，能量石很硬，吃完需要花不少时间，吃完第 $i$ 块能量石需要花费的时间为 $S_i$ 秒。\n\n杜达靠吃能量石来获取能量，不同的能量石包含的能量可能不同，此外，能量石会随着时间流逝逐渐失去能量。第 $i$ 块能量石最初包含 $E_i$ 单位的能量，并且每秒将失去 $L_i$ 单位的能量。\n\n当杜达开始吃一块能量石时，他就会立即获得该能量石所含的全部能量（无论实际吃完该石头需要多少时间），能量石中包含的能量最多降低至 $0$ 。\n\n请问杜达通过吃能量石可以获得的最大能量是多少？\n\n**输入格式**\n\n第一行包含整数 $T$ ，表示共有 $T$ 组测试数据。\n\n每组数据第一行包含整数 $N$ ，表示能量石的数量。\n\n接下来 $N$ 行，每行包含三个整数 $S_i,E_i,L_i$ 。\n\n**输出格式**\n\n每组数据输出一个结果，每个结果占一行。\n\n结果表示为“Case #x: y”，其中 $x$ 是组别编号（从 $1$ 开始）， $y$ 是可以获得的最大能量值。\n\n**数据范围**\n- $1≤T≤10$\n- $1≤N≤100$\n- $1≤Si≤100$\n- $1≤Ei≤10^5$\n- $0≤Li≤10^5$\n  \n**输入样例：**\n```c\n3\n4\n20 10 1\n5 30 5\n100 30 1\n5 80 60\n3\n10 4 1000\n10 3 1000\n10 8 1000\n2\n12 300 50\n5 200 0\n```\n**输出样例：**\n```c\nCase #1: 105\nCase #2: 8\nCase #3: 500\n```\n**样例解释**\n\n在样例＃1 中：有 $N = 4$ 个宝石。杜达可以选择的一个吃石头顺序是：\n\n吃第四块石头。这需要 5 秒，并给他 80 单位的能量。\n吃第二块石头。这需要 5 秒，并给他 5 单位的能量（第二块石头开始时具有 30 单位能量，5 秒后失去了 25 单位的能量）。\n吃第三块石头。这需要 100 秒，并给他 20 单位的能量（第三块石头开始时具有 30 单位能量，10 秒后失去了 10 单位的能量）。\n吃第一块石头。这需要 20 秒，并给他 0 单位的能量（第一块石头以 10 单位能量开始，110 秒后已经失去了所有的能量）。\n他一共获得了 105 单位的能量，这是能获得的最大值，所以答案是 105。\n\n在样本案例＃2 中：有 $N = 3$ 个宝石。\n\n无论杜达选择吃哪块石头，剩下的两个石头的能量都会耗光。\n\n所以他应该吃第三块石头，给他提供 8 单位的能量。\n\n在样本案例＃3 中：有 $N = 2$ 个宝石。杜达可以：\n\n吃第一块石头。这需要 12 秒，并给他 300 单位的能量。\n吃第二块石头。这需要 5 秒，并给他 200 单位的能量（第二块石头随着时间的推移不会失去任何能量！）。\n所以答案是 500。\n\n### 解法一\n贪心+背包的解法。传统的 01 背包，我们一般都是直接遍历给定的原始物品顺序，然后进行递推，这里实际上就包含了拿取的顺序，物品靠前的会被优先拿取，只不过传统 01 背包拿取顺序对结果没有影响，所以直接顺序递推没有问题。\n\n而这题中吃石头的顺序会对结果产生影响，所以需要保证通过我们设定的排列顺序进行拿取最终一定能拿到最优解。假设最优的吃石头的顺序是 $a_0, a_1, a_2,...,a_i,a_j,...,a_k$ 。 $a_i$ 代表石头在原始序列中的位置， $k$ 为最终吃的石头个数。那么我们交换任意的**相邻**两个石头 $a_i$ 和 $a_j$ 对其他的石头是没有任何影响的，并且这种交换最终获得的能量一定是**小于等于**当前的最优解获得的能量的，即（ $t$ 为之前消耗的时间）\n\n$$\n\\begin{aligned}\nE_i-(t \\ast l_i)+E_j-(t+S_i) \\ast l_j \\geq E_j-(t \\ast l_j)+E_i-(t+S_j)\\ast l_i\n\\end{aligned}\n$$\n\n化简后为： $S_i \\ast l_j \\leq S_j \\ast l_i$ ，所以我们只要按照这一条件排列石头，然后进行递推就能保证获得最大收益\n\n排列好之后我们以时间 $S$ 作为背包的体积\n- 状态： $dp[i][j]$ 为前 $i$ 个石头，消耗时间**刚好**为 $j$ 时最大的收益\n- 转移方程： $dp[i][j] = \\max(dp[i-1][j], dp[i-1][j-s_i]+\\max(0, E_i-(j-s_i)*l_i))$\n- 出口： $\\max(dp[i][j])$\n\n注意这里必须要设置为时间**恰好为** $j$ 的最大收益，如果设置成**不超过**，这里 $E_i-(j-s_i)*l_i$ 的计算就有问题， $j-s_i$ 就不是准确的消耗时间，导致最终结果不对\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int T = read(br)[0];\n        int idx = 0;\n        while (T-- > 0) {\n            idx++;\n            int N = read(br)[0];\n            int[] s = new int[N], e = new int[N], l = new int[N];\n            for (int i = 0; i < N; i++) {\n                int[] t = read(br);\n                s[i] = t[0]; e[i] = t[1]; l[i] = t[2];\n            }\n            out.printf(\"Case #%d: %d\\n\", idx, solve(N, s, e, l));\n        }\n        out.flush();\n    }\n\n    //按照 Si/Li 排序\n    public static int solve(int N, int[] s, int[] e, int[] lo) {\n        int MAX = 10005;\n        Integer[] id = new Integer[N];\n        for (int i = 0; i < N; i++) id[i]=i;\n        Arrays.sort(id, (i1, i2)->s[i1]*lo[i2]-s[i2]*lo[i1]);\n        int[] dp = new int[MAX];\n        int res = 0;\n        for (int k = 0; k < N; k++) {\n            int i = id[k];\n            for (int j = MAX-1; j >= s[i]; j--) {\n                dp[j] = Math.max(dp[j], dp[j-s[i]] + Math.max(0, e[i]-(j-s[i])*lo[i]));\n                res = Math.max(res, dp[j]);\n            }\n        }\n        return res;\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [487. 金明的预算方案](https://www.acwing.com/problem/content/description/489/)\n\n金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。\n\n更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。\n\n今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：\n\n![](https://i.loli.net/2021/03/02/HGepaVgL4Emdfhr.png)\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。\n\n每个主件可以有 0 个、1 个或 2 个附件，附件不再有从属于自己的附件。\n\n金明想买的东西很多，肯定会超过妈妈限定的 $N$ 元，于是，他把每件物品规定了一个重要度，分为 5 等：用整数 1~5 表示，第 5 等最重要。\n\n他还从因特网上查到了每件物品的价格（都是 10 元的整数倍），他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n设第 $j$ 件物品的价格为 $v_j$ ，重要度为 $w_j$ ，共选中了 $k$ 件物品，编号依次为 $j_1$ ， $j_2$ ，…， $j_k$ ，则所求的总和为：\n\n$v[j_1]∗w[j_1]+v[j_2]∗w[j_2]+…+v[j_k]∗w[j_k]$ （其中*为乘号）\n\n请你帮助金明设计一个满足要求的购物单。\n\n**输入格式**\n\n输入文件的第 $1$ 行，为两个正整数，用一个空格隔开： $N，m$ 其中 $N$ 表示总钱数， $m$ 为希望购买物品的个数。\n\n从第 2 行到第 $m+1$ 行，第 $j$ 行给出了编号为 $j-1$ 的物品的基本数据，每行有 3 个非负整数 $v,p,q$ ，其中 $v$ 表示该物品的价格， $p$ 表示该物品的重要度（1~5）， $q$ 表示该物品是主件还是附件。\n\n如果 $q=0$ ，表示该物品为主件，如果 $q>0$ ，表示该物品为附件， $q$ 是所属主件的编号。\n\n**输出格式**\n\n输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ $<200000$ ）。\n\n**数据范围**： \n- $N<32000$\n- $m<60$\n- $v<10000$\n\n**输入样例：**\n```c\n1000 5\n800 2 0\n400 5 1\n300 5 1\n400 3 0\n500 2 0\n```\n**输出样例：**\n```c\n2200\n```\n\n### 解法一\n这题开始磨了好久，一开始没看到题目说的附件最多两个，后面看题解看见附件只有最多两个的时候马上滚回去写了下面的解法\n\n因为附件最多两个，所以我们完全可以直接枚举所有的**主件+附件**的情况，然后就是一个简单的分组背包就完事了。下面的解法是二维的，降维有时候会隐藏一些信息，让人忽略一些细节，这里就不放一维的写法了，反正也就改几行代码的事情\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int[] v, w, p;\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1];\n        v = new int[M+1]; w = new int[M+1]; p = new int[M+1];\n        //依赖关系\n        List<Integer>[] adj = new ArrayList[M+1];\n        for (int i = 1; i <= M; i++) {\n            int[] t = read(br);\n            v[i] = t[0]; w[i] = t[1]; p[i] = t[2];\n            if (adj[p[i]] == null) {\n                adj[p[i]] = new ArrayList<>();\n            }\n            adj[p[i]].add(i);\n        }\n        int Z = adj[0].size();\n        int[][] dp = new int[Z+1][N+1];\n        //将依赖关系进行分组枚举所有情况，题目中有一条关键信息就是附件最多只有两件\n        //adj[0] 就是所有的主件\n        for (int i = 1; i <= Z; i++) {\n            int pi = adj[0].get(i-1); //pi 不是必选，但是要选 pi 的附件，pi 就必选了\n            for (int j = N; j >= 0; j--) {\n                dp[i][j] = dp[i-1][j]; //不选当前主件\n                int s = adj[pi] == null ? 0 : adj[pi].size(); //附件个数，0,1,2\n                //枚举当前组内的所有情况\n                for (int k = 0; k < (1<<s); k++) {\n                    //当前组某项的体积和价值和\n                    int t = v[pi]*w[pi];\n                    int sv = v[pi];\n                    for (int c = 0; c < s; c++) {\n                        if (((k>>>c)&1)==1) {\n                            int d = adj[pi].get(c);\n                            t += v[d]*w[d];\n                            sv += v[d];\n                        }\n                    }\n                    if (j >= sv) {\n                        //注意这里应该和 dp[i][j] 比较\n                        dp[i][j] = Math.max(dp[i][j], dp[i-1][j-sv] + t);\n                    }\n                }\n            }\n        }\n        out.println(dp[Z][N]);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n题解里有一个 $O(NM)$ [解法](https://www.acwing.com/solution/content/16430/)，没咋看懂，感觉有点假","tags":["算法"],"categories":["算法"]},{"title":"LeetCode1178. 猜字谜","url":"/2021/02/27/ec37f8ae/","content":"\n## [1178. 猜字谜](https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/)\n\nDifficulty: **困难**\n\n外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。\n\n字谜的迷面 `puzzle` 按字符串形式给出，如果一个单词 `word` 符合下面两个条件，那么它就可以算作谜底：\n\n*   单词 `word` 中包含谜面 `puzzle` 的第一个字母。\n*   单词 `word` 中的每一个字母都可以在谜面 `puzzle` 中找到。  \n    例如，如果字谜的谜面是 \"abcdefg\"，那么可以作为谜底的单词有 \"faced\", \"cabbage\", 和 \"baggage\"；而 \"beefed\"（不含字母 \"a\"）以及 \"based\"（其中的 \"s\" 没有出现在谜面中）都不能作为谜底。\n\n返回一个答案数组 `answer`，数组中的每个元素 `answer[i]` 是在给出的单词列表 `words` 中可以作为字谜迷面 `puzzles[i]` 所对应的谜底的单词数目。\n\n**示例：**\n\n```c\n输入：\nwords = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], \npuzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]\n输出：[1,1,3,2,4,0]\n解释：\n1 个单词可以作为 \"aboveyz\" 的谜底 : \"aaaa\" \n1 个单词可以作为 \"abrodyz\" 的谜底 : \"aaaa\"\n3 个单词可以作为 \"abslute\" 的谜底 : \"aaaa\", \"asas\", \"able\"\n2 个单词可以作为 \"absoryz\" 的谜底 : \"aaaa\", \"asas\"\n4 个单词可以作为 \"actresz\" 的谜底 : \"aaaa\", \"asas\", \"actt\", \"access\"\n没有单词可以作为 \"gaswxyz\" 的谜底，因为列表中的单词都不含字母 'g'。\n```\n\n**提示**\n\n*   1 <= words.length <= 10^5\n*   4 <= words[i].length <= 50\n*   1 <= puzzles.length <= 10^4\n*   puzzles[i].length == 7\n*   words[i][j], puzzles[i][j] 都是小写英文字母。\n*   每个 puzzles[i] 所包含的字符都不重复。\n\n### 解法一\n前几天的每日一题，看群消息时看见了，群友提到了位运算和枚举子集，所以直接往这个方向想了，一发 AC。首先将所有的 word 进行状态压缩转换成二进制，然后用 hash 表统计下个数，再遍历所有的`puzzle`，并且枚举`puzzle`的子集，这里 puzz 比较短，所以我们直接按照 puzz 各个字符的的选取状态进行枚举，然后在 hash 表中找到对应的次数就行了，注意 puzz 的第一个字符必须包含。\n```java\n​class Solution {\n    public List<Integer> findNumOfValidWords3(String[] words, String[] puzzles) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        //50*10^5\n        for (int i = 0; i < words.length; i++) {\n            char[] word = words[i].toCharArray();\n            int key = 0;\n            for (int j = 0; j < word.length; j++) {\n                key |= 1<<(word[j]-'a');\n            }\n            map.put(key, map.getOrDefault(key, 0)+1);\n        }\n        //枚举 puzzles[i] 的子集 10^4*2^7*7\n        //word 包含 puzz 的第一个字母 & puzz 包含 word 所有字母\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < puzzles.length; i++) {\n            char[] puzz = puzzles[i].toCharArray();\n            int cnt = 0;\n            //枚举子集复杂度：2^p*p (p 为 puzz[i] 长度 7)\n            for (int s = 0; s < (1<<puzz.length); s++) {\n                int key = 0;\n                //puzz[0] 必选\n                if ((s&1)!=1) continue;\n                for (int k = 0; k < puzz.length; k++) {\n                    if (((s>>>k)&1)==1) {\n                        key |= 1<<(puzz[k]-'a');\n                    }\n                }\n                cnt += map.getOrDefault(key, 0);\n            }\n            res.add(cnt);\n        }\n        return res;\n    }\n}\n```\n\n### 解法二\n看了题解后学习到的一种更快的 **枚举二进制子集** 的方法\n```java\n//更优的枚举二进制子集的方法\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\n    HashMap<Integer, Integer> map = new HashMap<>();\n    //50*10^5\n    for (int i = 0; i < words.length; i++) {\n        char[] word = words[i].toCharArray();\n        int key = 0;\n        for (int j = 0; j < word.length; j++) {\n            key |= 1<<(word[j]-'a');\n        }\n        map.put(key, map.getOrDefault(key, 0)+1);\n    }\n    //word 包含 puzz 的第一个字母 & puzz 包含 word 所有字母\n    List<Integer> res = new ArrayList<>();\n    for (int i = 0; i < puzzles.length; i++) {\n        char[] puzz = puzzles[i].toCharArray();\n        int cnt = 0, mask = 0;\n        for (int j = 1; j < puzz.length; j++) {\n            mask |= (1<<(puzz[j]-'a'));\n        }\n        //枚举子集复杂度：2^k (k 为 mask 中 1 的个数，最多为 7)\n        int sub = mask;\n        do {\n            cnt += map.getOrDefault(sub|(1<<(puzz[0]-'a')), 0);\n            sub = (sub-1) & mask;\n        } while (sub != mask);\n        res.add(cnt);\n    }\n    return res;\n}\n\n// &mask 保证了 sub 一定是 mask 的子集，同时 sub 不断的减一，最终会减到 0\n//s = 101\n//1. sub = 101\n//2. sub = 100 & 101 = 100\n//3. sub = 011 & 101 = 001\n//4. sub = 000 & 101 = 000\n//5. sub = 111 & 101 = 101 （取反全为 1，回到 mask，将空集也包含进去）\n```\n实际上上面的解法是针对下面这种枚举二进制子集方法的优化，不过下面这个解法在这题的时间复杂度比较高 $O(2^{26})$ 会直接 T 掉\n```java\nint cnt = 0, mask = 0;\nfor (int j = 1; j < puzz.length; j++) {\n    mask |= (1<<(puzz[j]-'a'));\n}\n//枚举子集复杂度：2^n (n 为二进制长度，这里为 26)\nfor (int s = 0; s <= mask; s++) {\n    if ((s|mask) == mask) {\n        cnt += map.getOrDefault(s|(1<<(puzz[0]-'a')), 0);\n    }\n}\n```\n\n### 解法三\n字典树的做法，和上面的解法本质上一样的，只是采用的数据结构不一样，上面的解法采用的是哈希表存储，这里采用字典树存储，理论上来讲这里字典树的方法应该会比 hash 表慢，但是在 lc 提交上看这种方法是最快的，可能是哈希表常数太大了\n```java\nclass Node {\n    Node[] next;\n    int cnt;\n    public Node() {\n        next = new Node[26];\n    }\n}\n\nNode root;\n\npublic void add(Node node, String str, int index) {\n    if (index == str.length()) {\n        node.cnt++;\n        return;\n    }\n    int c = str.charAt(index)-'a';\n    if (node.next[c] == null) {\n        node.next[c] = new Node();\n    }\n    add(node.next[c], str, index+1);\n}\n\npublic int dfs(Node cur, char[] puzz, char req, int idx) {\n    if (cur == null) return 0;\n    if (idx == puzz.length) {\n        return cur.cnt;\n    }\n    int res = 0;\n    //选择当前元素\n    res += dfs(cur.next[puzz[idx]-'a'], puzz, req, idx+1);\n    //不选择当前元素（req 必须选）\n    if (puzz[idx] != req) {\n        res += dfs(cur, puzz, req, idx+1);\n    }\n    return res;\n}\n\n//2^26\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\n    root = new Node();\n    for (int i = 0; i < words.length; i++) {\n        char[] word = words[i].toCharArray();\n        Arrays.sort(word);\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < word.length; j++) {\n            if (j==0 || word[j]!=word[j-1]) {\n                sb.append(word[j]);\n            }\n        }\n        add(root, sb.toString(), 0);\n    }\n    //dfs 分解 puzz 子集\n    List<Integer> res = new ArrayList<>();\n    for (int i = 0; i < puzzles.length; i++) {\n        char[] puzz = puzzles[i].toCharArray();\n        Arrays.sort(puzz);\n        res.add(dfs(root, puzz, puzzles[i].charAt(0), 0));\n    }\n    return res;\n}\n```","tags":["LeetCode"],"categories":["算法"]},{"title":"七牛云免费额度开启 HTTPS 代理","url":"/2021/02/22/1fab87bb/","content":"\n## 起因\n最近给自己的博客上了 https，而图床一直用的七牛云的免费额度，但是七牛云的免费额度是不支持 HTTPS 流量的，~~作为资深白嫖怪当然首先是考虑如何白嫖了~~\n\n## 解决方案\n因为要上全站 https，所以我们站点是不允许发送 http 请求的，http 的外链资源都无法加载。其实解决方案也很简单，我们再套一层 https 的代理就行了。\n\n我们七牛云的 cdn 加速域名是 [static.imlgw.top]()，我们再申请一个子域名 [qiniu.imlgw.top]()，然后给这个子域名添加一条 A 记录指向我们的服务器，然后再给这个域名申请一套 ssl 证书上传到服务器上，然后就是对 Nginx 的配置了\n\n```sh\n# 配置 https 代理\nserver {\n    listen        443 ssl;\n    # https 跳板\n    server_name  qiniu.imlgw.top;\n    # 证书\n    ssl_certificate  /usr/local/cert/qiniu.imlgw.top.pem;\n    ssl_certificate_key  /usr/local/cert/qiniu.imlgw.top.key;\n    location / {\n        # 七牛云 CDN 域名\n        proxy_pass http://static.imlgw.top;\n    }\n}\n```\n然后我们就可以通过 [https://qiniu.imlgw.top/abc.jpg](https://qiniu.imlgw.top/abc.jpg)\n 代理访问 [http://static.imlgw.top/abc.jpg](http://static.imlgw.top/abc.jpg)，进而继续白嫖七牛云的免费额度🤣\n\n ## 进阶\n\n实际上这种方案我弄好了后并没有采用，主要原因如下：\n\n1. 这样代理之后图片都会通过我的服务器中转，七牛云 cdn 加速其实就没用了，而我的服务器是个 1Mbps 的小水管，图片的加载速度会变慢\n2. `MPic`上传图片获取链接后还需要手动的去修改链接为 qiniu...，事情变复杂了，没有那么方便了\n3. 这样代理之后，之前所有的文章图片都需要将链接替换成`qiniu.imlgw.top`，虽然文章也不多，写个脚本一下就替换了，但是终归是有点麻烦\n\n其实这种方案有一个更好的用途：可以做到**无缝换源** 。我们可以**同步**我们的多个对象存储源，当我们其中一个发生故障的时候（欠费）我们可以修改 Nginx 的配置，将其代理到另一个源这样我们文章的外链不需要做任何修改依然可以正常访问\n\n## 结语\n最终还是选择了付费，其实本来是打算采用阿里云 OSS 做付费图床的，但是阿里云的计费规则我实在是有点摸不透，空间很便宜 9 元 40G/Year，但是流量的计算有点复杂，而且要做图床替换也是个麻烦事，得写个通用脚本出来，用七牛云的话只要升级了 https，然后开启强制 https，文章中的链接都不需要修改就可以直接访问（我这里最新的 Chrome 会自动把 https 站点的 http 请求替换成 https，但是其他的浏览器就不知道了，所以我们直接开启强制 https 就行了）\n\n七牛云的我大概看了下，计费规则还是很清晰的，免费的额度是：10G 空间，10G 的 CDN-HTTP 流量。使用了 CDN 加速后就不计算外网流出的流量费用。所以我需要做的就是将 http 的 cdn 流量升级成 https，价格如下\n![](https://i.loli.net/2021/02/23/HDhXPIkGSvmRuK4.png) 我充了一点点钱，先按量付费用着看，看看一年能不能把我冲的这点钱花完😂（立个 flag 一年后再来看），毕竟是个人博客，除了自己也没啥人会看，如果流量大了可以考虑卖资源包，有打折，会便宜一点。\n","tags":["Nginx"],"categories":["Web"]},{"title":"AtCoder Beginner Contest 190","url":"/2021/02/04/891c3448/","content":"> 比赛地址： https://atcoder.jp/contests/abc190\n> \n> 完整代码（A-F）：[Github](https://github.com/imlgw/competition-algorithm/tree/master/%E6%AF%94%E8%B5%9B/AtCoder/abc190)\n## [A - Very Very Primitive Game](https://atcoder.jp/contests/abc190/tasks/abc190_a)\n先下手的人 candies 数量 **大于** 另一个人就能赢\n## [B - Magic 3](https://atcoder.jp/contests/abc190/tasks/abc190_b)\n循环判断\n## [C - Bowls and Dishes](https://atcoder.jp/contests/abc190/tasks/abc190_c)\nWe have $N$ dishes numbered $1, 2, \\dots, N$ and $M$ conditions numbered $1, 2, \\dots, M$ .\n\nCondition $i$ is satisfied when both Dish $A_i$ and Dish $B_i$ have (one or more) balls on them.\n\nThere are $K$ people numbered $1, 2, \\dots, K$ . Person $i$ will put a ball on Dish $C_i$ or Dish $D_i$ .\nAt most how many conditions will be satisfied?\n\n**Constraints**\n- All values in input are integers.\n- $2 ≤ N ≤ 100$\n- $1 ≤ M ≤ 100$\n- $1 ≤ A_i < B_i ≤ N$\n- $1 ≤ K ≤ 16$\n- $1 ≤ C_i < D_i ≤ N$\n\n**Sample Input 1**\n```c\n4 4\n1 2\n1 3\n2 4\n3 4\n3\n1 2\n1 3\n2 3\n```\n**Sample Output 1**\n```c\n2\n```\n### 解法一\n题目大意：有 $N$ 个空盘子，然后给定 $M$ 个询问，如果 $Ai$ -th 和 $Bi$ -th 的盘子（从 1 开始）上都有至少一个球，那么这个询问就满足了，然后给了 $K$ 给选择，每个选择可以从两个盘子中选一个盘子然后将一个球放到其中，问最多能满足多少个询问\n\n这个题比赛的时候也卡了一会儿，最后算了下暴力的复杂度，发现直接暴力枚举就行了。枚举所有的放置情况，然后求一个最大值就行了，时间复杂度 $O(2^K*M)$\n```java\n//比赛时的 code，太丑了\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int[] dish;\n    static int[][] w;\n    static int[][] kn;\n    static int K;\n    static int N, M;\n    static int res = 0;\n    //2^16*100 = 1024 * 100 * 100 = 1000 0000\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        N = in[0]; M = in[1];\n        dish = new int[N];\n        w = new int[M][2];\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            w[i][0] = t[0]; w[i][1] = t[1];\n        }\n        K = read(br)[0];\n        kn = new int[K][2];\n        for (int i = 0; i < K; i++) {\n            int[] t = read(br);\n            kn[i][0] = t[0]; kn[i][1] = t[1];\n        }\n        dfs(0);\n        out.println(res);\n        out.flush();\n    }\n\n    public static void dfs(int i) {\n        if (i == K) {\n            res = Math.max(res, check());\n            return;\n        }\n        dish[kn[i][0]-1]++;\n        dfs(i+1);\n        dish[kn[i][0]-1]--;\n\n        dish[kn[i][1]-1]++;\n        dfs(i+1);\n        dish[kn[i][1]-1]--;\n    }\n\n    public static int check() {\n        int cnt = 0;\n        for (int i = 0; i < M; i++) {\n            if (dish[w[i][0]-1] >= 1 && dish[w[i][1]-1] >= 1) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n### 解法二\n二进制枚举，赛后独立写出来的，时间复杂度 $O(2^K(K+M))$\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    //2^16*100 = 1024 * 100 * 100 = 1000 0000\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1];\n        int[][] cond = new int[M][2];\n        //注意输入都是从 1 开始的\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            cond[i] = new int[]{t[0]-1, t[1]-1};\n        }\n        int K = read(br)[0];\n        int[][] kn = new int[K][2];\n        for (int i = 0; i < K; i++) {\n            int[] t = read(br);\n            kn[i] = new int[]{t[0]-1, t[1]-1};\n        }\n        int res = 0;\n        //000 001 011\n        for (int i = 0; i < (1<<K); i++) {\n            int[] dish = new int[N];\n            for (int j = 0; j < K; j++) {\n                //这里不用考虑无符号右移\n                dish[kn[K-1-j][(i>>j)&1]]++;\n            }\n            int cnt = 0;\n            for (int j = 0; j < M; j++) {\n                if (dish[cond[j][0]] >= 1 && dish[cond[j][1]] >= 1) {\n                    cnt++;\n                }\n            }\n            res = Math.max(res, cnt);\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [D - Staircase Sequences](https://atcoder.jp/contests/abc190/tasks/abc190_d)\n\nHow many arithmetic progressions consisting of integers with a common difference of $1$ have a sum of $N$ ?\n\n**Constraints**\n- $1≤N≤10^12$\n- $N$ is an integer.\n\n**Sample Input 1**\n```c\n12\n```\n**Sample Output 1**\n```c\n4\n```\nWe have four such progressions:\n- $[12]$\n- $[3, 4, 5]$\n- $[-2, -1, 0, 1, 2, 3, 4, 5]$\n- $[-11, -10, -9, \\dots, 10, 11, 12]$\n\n### 解法一\n公差是 $1$ 的等差数列前 $n$ 项和： $S= \\frac{(a_0+a_0+n-1)n}{2}$ ，转换一下就变成了 $\\frac{2S}{n}+1-n=2a_0$ ，那么首先 $n$ 肯定是整数，其次题目说了 $a_i$ 也是整数，所以上述式子需要保证这两个条件，那么我们直接枚举 $2N$ 的因子 $f$ ，然后判断 $\\frac{2S}{f}+1-f$ 是否是偶数就行了，时间复杂度 $O(\\sqrt{N})$ （看题目数据范围 $1e12$ 就知道肯定是根号的复杂度）\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        long N = Long.valueOf(br.readLine());\n        // (a+a+n-1)*n/2 = N ==> 2a = 2N/n + 1 - n\n        // 枚举 2N 的所有因子\n        long x = 2*N;\n        HashSet<Long> set = new HashSet<>();\n        //i*i 大于 x 那么 i 之前肯定已经被加入了\n        for (long i = 1; i*i <= x; i++) {\n            if ((x%i) == 0) {\n                set.add(i);\n                set.add(x/i);\n            }\n        }\n        long res = 0;\n        for (Long f : set) {\n            if ((x/f+1-f)%2==0) res++;\n        }\n        out.println(res);\n        out.flush();\n    }\n}\n```\n\n## [E - Magical Ornament](https://atcoder.jp/contests/abc190/tasks/abc190_e)\n\nThere are $N$ kinds of magical gems, numbered $1, 2, \\ldots, N$ , distributed in the AtCoder Kingdom.\n\nTakahashi is trying to make an ornament by arranging gems in a row.\n\nFor some pairs of gems, we can put the two gems next to each other; for other pairs, we cannot. We have $M$ pairs for which the two gems can be adjacent: (Gem $A_1$ , Gem $B_1$ ), (Gem $A_2$ , Gem $B_2$ ), $\\ldots$ , (Gem $A_M$ , Gem $B_M$ ). For the other pairs, the two gems cannot be adjacent. (Order does not matter in these pairs.)\n\nDetermine whether it is possible to form a sequence of gems that has one or more gems of each of the kinds $C_1, C_2, \\dots, C_K$ . If the answer is yes, find the minimum number of stones needed to form such a sequence.\n\n**Constraints**\n\n- All values in input are integers.\n- $1 ≤ N ≤ 10^5$\n- $0 ≤ M ≤ 10^5$\n- $1 ≤ A_i < B_i ≤ N$\n- If $i ≠ j, (A_i, B_i) ≠ (A_j, B_j)$ .\n- $1 ≤ K ≤ 17$\n- $1 ≤ C_1 < C_2 < \\dots < C_K ≤ N$\n\n**Sample Input 1**\n```c\n4 3\n1 4\n2 4\n3 4\n3\n1 2 3\n```\n**Sample Output 1**\n```c\n5\n```\n\n### 解法一\nbfs+状态压缩，因为 $K$ 很小，所以我们可以将给定的输入转换成一个双向图，然后将关键点之间的最短路径求出来，这里直接 BFS 就行了，时间复杂度 $O(K*(N+M))$ ，得到一个 $dist[i][j]$ ，表示第 $i$ -th 关键点和第 $j$ -th 个关键点的最短路径\n\n然后再进行状态压缩，设置状态为： $dp[mask][last]$ ，选取 $mask$ 代表的 **关键宝石**，并且以 $last$ 宝石结尾的最短序列长度（显然 $last$ 一定是关键宝石）\n- 入口： $dp[1 <<  i][i] = 1$ ，只选取一个关键宝石，序列长度为 1\n- 转移： $dp[mask|(1 << j)][j] = \\min(dp[mask][i] + dist[i][j])$ ，枚举所有的选取状态，枚举所有以关键宝石作为结尾的状态，递推求最小值\n- 出口： $\\min_i(dp[(1 << k)-1][i])$ ，选取到所有的关键石头，并且以某个关键石头结尾的最小值\n\n代码实现如下（注意下标统一，给的输入都是从 1 开始的，需要转换，一开始转换掉了一个，找了半天的 bug）：\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0], M = in[1];\n        int INF = 0x3f3f3f3f;\n        List<Integer>[] adj = new ArrayList[N];\n        for (int i = 0; i < M; i++) {\n            int[] t = read(br);\n            int x = t[0]-1, y = t[1]-1;\n            if (adj[x] == null) {\n                adj[x] = new ArrayList<>();\n            }\n            if (adj[y] == null) {\n                adj[y] = new ArrayList<>();\n            }\n            adj[x].add(y); adj[y].add(x);\n        }\n        int K = read(br)[0];\n        int[] C = read(br);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < K; i++) map.put(--C[i], i);\n        //K 个关键点之间的最短距离\n        int[][] dis = new int[K][K];\n        Queue<int[]> queue = new LinkedList<>();\n        for (int i = 0; i < K; i++) {\n            Arrays.fill(dis[i], INF);\n            queue.clear();\n            queue.add(new int[]{C[i], 0});\n            boolean[] vis = new boolean[N];\n            while (!queue.isEmpty()) {\n                int[] cur = queue.poll();\n                if (map.containsKey(cur[0])) {\n                    dis[i][map.get(cur[0])] = cur[1];\n                }\n                if (adj[cur[0]] == null) continue;\n                for (Integer next : adj[cur[0]]) {\n                    if (vis[next]) continue;\n                    queue.add(new int[]{next, cur[1]+1});\n                    vis[next] = true;\n                }\n            }\n        }\n        int[][] dp = new int[1<<K][K];\n        for (int i = 0; i < (1<<K); i++) {\n            Arrays.fill(dp[i], INF);\n        } \n        for (int i = 0; i < K; i++) {\n            dp[1<<i][i] = 1;\n        }\n        //枚举所有状态递推\n        for (int mask = 0; mask < (1<<K); mask++) {\n            for (int i = 0; i < K; i++) {\n                //C[i] 被选取，C[j] 未被选取（因为有 INF 的原因，判断去掉也可 AC，不过最好还是加上）\n                if ((mask&(1<<i))==0) continue;\n                for (int j = 0; j < K; j++) {\n                    if ((mask&(1<<j))==1 || dis[i][j] == INF || dp[mask][i] == INF) continue;\n                    dp[mask|(1<<j)][j] = Math.min(dp[mask|(1<<j)][j], dp[mask][i] + dis[i][j]);\n                }\n            }\n        }\n        int res = INF;\n        for (int i = 0; i < K; i++) {\n            res = Math.min(res, dp[(1<<K)-1][i]);\n        }\n        if (res == INF) out.println(-1);  \n        else out.println(res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n## [F - Shift and Inversions](https://atcoder.jp/contests/abc190/tasks/abc190_f)\nGiven is a sequence $A = [a_0, a_1, a_2, \\dots, a_{N-1}]$ that is a permutation of $0, 1, 2, \\dots, N - 1$ .\n\nFor each $k = 0, 1, 2, \\dots, N - 1$ , find the inversion number of the sequence $B = [b_0, b_1, b_2, \\dots, b_{N-1}]$ defined as $b_i = a_{i+k \\bmod N}$ .\n\n**Constraints**\n- All values in input are integers.\n- $2≤N≤3×10^5$\n- $a_0,a_1,a_2,…,a_{N−1}$ is a permutation of $0,1,2,…,N−1$ .\n\n**Sample Input 1**\n```c\n4\n0 1 2 3\n```\n**Sample Output 1**\n```c\n0\n3\n4\n3\n```\nWe have $A = [0, 1, 2, 3]$ .\n- For $k = 0$ , the inversion number of $B = [0, 1, 2, 3]$ is $0$ .\n- For $k = 1$ , the inversion number of $B = [1, 2, 3, 0]$ is $3$ .\n- For $k = 2$ , the inversion number of $B = [2, 3, 0, 1]$ is $4$ .\n- For $k = 3$ , the inversion number of $B = [3, 0, 1, 2]$ is $3$ .\n\n### 解法一\n首先 $B_{k=i}$ 序列实际上就是 $A$ 数组将开头的 $i$ 个元素移动到后面得到的序列。同时题目说了给定的 $A$ 序列是 $0，1，2 \\ldots N-1$ 的一个排列，所以我们把某个元素从开头移动到结尾的逆序对变化是可以直接计算出来的\n\n![](https://i.loli.net/2021/02/03/TFsGkEvZjxqiVHm.png)\n所以我们只需要求出初始 $A$ 数组的逆序对个数然后按照上面的式子递推就行了，这里我采用树状数组的方法求逆序对，也可以用归并排序的方式\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static int[] tree;\n\n    public static int lowbit(int x) {\n        return x & -x;\n    }\n\n    //q[1001] = t[1001] + t[1000]\n    public static int query(int i) {\n        int res = 0;\n        while (i > 0) {\n            res += tree[i];\n            i -= lowbit(i);\n        }\n        return res;\n    }\n\n    public static void add(int i, int val) {\n        while (i < tree.length) {\n            tree[i] += val;\n            i += lowbit(i);\n        }\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = read(br)[0];\n        int[] A = read(br);\n        tree = new int[N+1];\n        //这题不用离散化，序列值就是 Rank\n        long res = 0;\n        //树状数组或者归并都可\n        for (int i = N-1; i >= 0; i--) {\n            add(A[i]+1, 1);\n            res += query(A[i]);\n        }\n        out.println(res);\n        //-k+(N-1-k) = N-1-2*k\n        for (int i = 0; i < N-1; i++) {\n            res += N-1-2*A[i];\n            out.println(res);\n        }\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n> 一开始写了个假的算法结果 AC 了，主要是离散化写错了（这题本来也不用离散化，写离散化属于我吃饱了撑的，完了还写了个错的，还好，给自己提前暴雷了），幸好我尝试去写了其他的解法，不然这个错误就被混过去了 [错误代码 Gist](https://gist.github.com/imlgw/0d89d211ebd0f032c109daed8566db5a)\n### 解法二\n进一步的解法，序列的值是完全随机的的做法，这个时候归并就不太行了，而对于树状数组只需要稍微稍微改动一下就行了。\n```java\nclass Main {\n\n    static int[] tree;\n\n    public static int lowbit(int x) {\n        return x & -x;\n    }\n\n    //q[1001] = t[1001] + t[1000]\n    public static int query(int i) {\n        int res = 0;\n        while (i > 0) {\n            res += tree[i];\n            i -= lowbit(i);\n        }\n        return res;\n    }\n\n    public static void add(int i, int val) {\n        while (i < tree.length) {\n            tree[i] += val;\n            i += lowbit(i);\n        }\n    }\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = read(br)[0];\n        int[] A = read(br);\n        tree = new int[N+1];\n        //离散化（这题不用离散化，为了更加通用）\n        int[][] temp = new int[N][2];\n        for (int i = 0; i < N; i++) temp[i] = new int[]{A[i], i};\n        Arrays.sort(temp, (t1, t2)->t1[0]-t2[0]);\n        int[] rank = new int[N];\n        for (int i = 0; i < N; i++) {\n            rank[temp[i][1]] = i+1;\n        }\n        long res = 0;\n        //树状数组或者归并都可\n        for (int i = N-1; i >= 0; i--) {\n            add(rank[i], 1);\n            res += query(rank[i]-1);\n        }\n        out.println(res);\n        //改动的地方\n        for (int i = 0; i < N-1; i++) {\n            res -= query(rank[i]-1);\n            res += query(N) - query(rank[i]);\n            out.println(res);\n        }\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"AtCoder Beginner Contest 189","url":"/2021/01/28/e9dbbdad/","content":"> 比赛地址：https://atcoder.jp/contests/abc189\n> \n> 完整代码（A-F）：[Github](https://github.com/imlgw/competition-algorithm/tree/master/%E6%AF%94%E8%B5%9B/AtCoder/abc189)\n## [A - Slot](https://atcoder.jp/contests/abc189/tasks/abc189_a)\n直接判断就行了\n## [B - Alcoholic](https://atcoder.jp/contests/abc189/tasks/abc189_b)\n注意避免用除，转换成乘\n## [C - Mandarin Orange](https://atcoder.jp/contests/abc189/tasks/abc189_c)\n\nThere are $N$ dishes arranged in a row in front of Takahashi. The $i$ -th dish from the left has $A_i$ oranges on it.\n\nTakahashi will choose a triple of integers $(l, r, x)$ satisfying all of the following conditions:\n\n- $1 \\leq l \\leq r \\leq N$\n- $1 \\le x$\n- for every integer $i$ between $l$ and $r$ (inclusive), $x \\le A_i$ .\n\nHe will then pick up and eat $x$ oranges from each of the $l$ -th through $r$ -th dishes from the left.\n\nAt most how many oranges can he eat by choosing the triple $(l, r, x)$ to maximize this number?\n\n**Constraints**\n\n- All values in input are integers.\n- $1 \\leq N \\leq 10^4$\n- $1 \\leq A_i \\leq 10^5$\n\n**Sample Input 1**\n```c\n6\n2 4 4 9 4 9\n```\n**Sample Output 1**\n```c\n20\n```\n### 解法一\n\n暴力 $O(N^2)$ 的方法，枚举所有区间，以及区间最小值，数据范围 $1e4$ ，在 LC 上肯定超时了，但是在这里好像不仅不会超时，速度还很快，180ms\n\n不过这个题放在这个位置正确的解法应该就是下面的暴力，如果放到 D 题，然后数据范围大一点，就没这么简单了，就是下面的解法二了\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = read(br)[0];\n        int[] w = read(br);\n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            if (i > 0 && w[i] == w[i-1]) continue;\n            int min = Integer.MAX_VALUE;\n            for (int j = i; j < N; j++) {\n                min = Math.min(w[j], min);\n                res = Math.max(res, min*(j-i+1));\n            }\n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n### 解法二\n\n单调栈的解法，和 [Lc84. 柱状图中最大的矩形](https://imlgw.top/2020/08/28/leetcode-dan-diao-zhan/#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2) 是一道题，时间复杂度 $O(N)$\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        //2 4 4 9 4 9\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = read(br)[0];\n        int[] w = new int[N+1];\n        System.arraycopy(read(br), 0, w, 0, N);\n        w[N] = -1;\n        //单调递增栈\n        Deque<Integer> stack = new ArrayDeque<>();\n        int res = 0;\n        for (int i = 0; i <= N; i++) {\n            while (!stack.isEmpty() && w[stack.peek()] > w[i]) {\n                int cur = stack.pop();\n                //向左最多扩展到 left+1，向右最多扩展到 i-1 (i-1-left-1+1)\n                int left = stack.isEmpty() ? -1 : stack.peek();\n                res = Math.max(res, (i-1-left)*w[cur]);\n            }\n            stack.push(i);\n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n## [D - Logical Expression](https://atcoder.jp/contests/abc189/tasks/abc189_d)\n\nGiven are $N$ strings $S_1,\\ldots,S_N$ , each of which is `AND` or `OR`.\n\nFind the number of tuples of $N+1$ variables $(x_0,\\ldots,x_N)$ , where each element is $\\text{True}$ or $\\text{False}$ , such that the following computation results in $y_N$ being $\\text{True}$ :\n\n- $y_0=x_0$ ;\n- for $i\\geq 1$ , $y_i=y_{i-1} \\land x_i$ if $S_i$ is `AND`, and $y_i=y_{i-1} \\lor x_i$ if $S_i$ is `OR`.\n\nHere, a $\\land$ b and a $\\lor$ b are logical operators.\n\n**Constraints**\n- $1 \\leq N \\leq 60$\n- $S_i$ is `AND` or `OR`.\n\n**Sample Input 1**\n```c\n2\nAND\nOR\n```\n**Sample Output 1**\n```c\n5\n```\n\n### 解法一\n比赛的时候写了个巨丑的记忆化递归，虽然过了但是并不是很满意，这里实际上很容易直接递推。\n\n$dp[i][j]$ ：前 $i$ 个元素使得 $y_i$ 为 $j$ 的个数（0 为 F，1 为 T）\n\n$$\n\\begin{aligned}\n{S_i=\\text{AND}}： \n\\begin{cases}\n    dp[i][0] = \\underbrace{dp[i-1][0] + dp[i-1][1]}_{x_i=false} + \\underbrace{dp[i-1][0]}_{x_i=true} \\\\\\\\\n    dp[i][1] = \\underbrace{dp[i-1][1]}_{x_i=true}\n\\end{cases}\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n{S_i=\\text{OR}}：\n\\begin{cases}\n    dp[i][0] = \\underbrace{dp[i-1][0]}_{x_i=false} \\\\\\\\\n    dp[i][1] = \\underbrace{dp[i-1][1] + dp[i-1][0]}_{x_i=true} + \\underbrace{dp[i-1][1]}_{x_i=false}\n\\end{cases}\n\\end{aligned}\n$$\n\n代码实现\n```java\n//代码还可以进行空间降维，注意消除前后依赖就行了\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        //前 i 个元素，yi 为 F 和 T\n        long[][] dp = new long[N+1][2];\n        dp[0][0] = dp[0][1] = 1;\n        for (int i = 1; i <= N; i++) {\n            String op = sc.next();\n            if (\"AND\".equals(op)) {\n                dp[i][1] = dp[i-1][1];\n                dp[i][0] = dp[i-1][1] + dp[i-1][0] + dp[i-1][0];\n            } else {\n                dp[i][1] = dp[i-1][0] + dp[i-1][1] + dp[i-1][1];\n                dp[i][0] = dp[i-1][0];\n            }\n        }\n        System.out.println(dp[N][1]);\n    }\n}\n```\n\n## [E - Rotate and Flip](https://atcoder.jp/contests/abc189/tasks/abc189_e)\n\nThere are $N$ pieces on a two-dimensional plane. The coordinates of Piece $i$ are $(X_i,Y_i)$ . There may be multiple pieces at the same coordinates.\n\nWe will do $M$ operations $\\mathrm{op}_1, \\ldots, \\mathrm{op}_M$ , one by one. There are four kinds of operations, described below along with their formats in input.\n\n- `1`：Rotate every piece $90$ degrees clockwise about the origin;\n- `2`：Rotate every piece $90$ degrees counterclockwise about the origin;\n- `3 p`：Move each piece to the point symmetric to it about the line $x=p$ ;\n- `4 p`：Move each piece to the point symmetric to it about the line $y=p$ .\n\nYou are given $Q$ queries. In the $i$ -th query, given two integers $A_i$ and $B_i$ , print the coordinates of Piece $B_i$ just after the $A_i$ -th operation. Here, the moment just before the $1$ -st operation is considered to be the moment just after \"the $0$ -th operation\".\n\n**Constraints**\n\n- All values in input are integers.\n- $1 \\leq N \\leq 2\\times 10^5$\n- $1 \\leq M \\leq 2\\times 10^5$\n- $1 \\leq Q \\leq 2\\times 10^5$\n- $10^9 \\leq X_i,Y_i \\leq 10^9$\n- $\\mathrm{op}_i$ is in the format of one of the four kinds of operations.\n- In an operation with the form `3 p` or `4 p`, $-10^9 \\leq p \\leq 10^9$ .\n- $0 \\leq A_i \\leq M$\n- $1 \\leq B_i \\leq N$\n\n**Sample Input 1**\n```c\n1\n1 2\n4\n1\n3 3\n2\n4 2\n5\n0 1\n1 1\n2 1\n3 1\n4 1\n```\n**Sample Output 1**\n```c\n1 2\n2 -1\n4 -1\n1 4\n1 0\n```\nInitially, the only piece - Piece $1$ - is at $(1, 2)$ . Each operation moves the piece as follows: $(1,2)\\to(2,-1)\\to(4,-1)\\to(1,4)\\to(1,0)$ .\n\n### 解法一\n题目意思就是：给你 $N$ 个点，然后给你 $M$ 个操作（有序），然后给你 $Q$ 个查询，每个查询有两个值 $A_i$ 和 $B_i$ ，返回第 $B_i$ 个点在经过第 $A_i$ 次操作后的坐标\n\n做法就是将所有的操作叠加起来，这里题目说了操作都是有序的，所以我们按顺序叠加 $M$ 个操作，然后针对每个查询我们就可以 $O(1)$ 的求出结果\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = readOne(br);\n        int[] x = new int[N];\n        int[] y = new int[N];\n        for (int i = 0; i < N; i++) {\n            int[] t = read(br);\n            x[i] = t[0]; y[i] = t[1];\n        }\n        int M = readOne(br);\n        //将操作叠加起来\n        //1.(x, y) --> (y, -x)\n        //2.(x, y) --> (-y, x)\n        //3.(x, y) --> (-x+2p, y)\n        //4.(x, y) --> (x, -y+2p)\n        boolean[] swap = new boolean[M+1];\n        long[] addx = new long[M+1];\n        long[] addy = new long[M+1];\n        long[] mulx = new long[M+1];\n        long[] muly = new long[M+1];\n        mulx[0] = muly[0] = 1;\n        for (int i = 1; i <= M; i++) {\n            int[] t = read(br);\n            if (t[0] == 1) {\n                swap[i] = !swap[i-1];\n                mulx[i] = muly[i-1]; muly[i] = -mulx[i-1];\n                addx[i] = addy[i-1]; addy[i] = -addx[i-1];\n            } else if (t[0] == 2) {\n                swap[i] = !swap[i-1];\n                mulx[i] = -muly[i-1]; muly[i] = mulx[i-1];\n                addx[i] = -addy[i-1]; addy[i] = addx[i-1];\n            } else if (t[0] == 3) {\n                swap[i] = swap[i-1];\n                mulx[i] = -mulx[i-1]; muly[i] = muly[i-1];\n                addx[i] = 2l*t[1] - addx[i-1]; addy[i] = addy[i-1];\n            } else if (t[0] == 4) {\n                swap[i] = swap[i-1];\n                mulx[i] = mulx[i-1]; muly[i] = -muly[i-1];\n                addx[i] = addx[i-1]; addy[i] = 2l*t[1] - addy[i-1];\n            }\n        }\n        int Q = readOne(br);\n        for (int i = 0; i < Q; i++) {\n            int[] t = read(br);\n            int a = t[0], b = t[1]-1;\n            if (!swap[a]) {\n                out.println((x[b]*mulx[a] + addx[a]) + \" \" + (y[b]*muly[a] + addy[a]));\n            } else {\n                out.println((y[b]*mulx[a] + addx[a]) + \" \" + (x[b]*muly[a] + addy[a]));\n            }\n        }\n        out.flush();\n        out.close();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n\n    public static int readOne(BufferedReader br) throws Exception {\n        return Integer.parseInt(br.readLine());\n    }\n}\n```\n具体的 addx，addy，mulx... 这些参数的变化最好找一个例子自己代入试一下，空想容易搞错\n> 这里踩了个小坑，Java 的 prinf 效率会比 print 以及 write 慢很多，虽然可以想象到会慢一点，没想到会慢这么多，上面这题一开始用的 printf 打印的结果，然后就 T 了。.. 后面我自己测试了一下，发现确实会慢很多，以后要慎用了\n[TestCode](https://pasteme.cn/104650)\n![](https://i.loli.net/2021/01/29/8vpVZE1tDf4uoJY.png)\n\n这题实际上还有一个利用矩阵的解法，相对来说会比较直接简单，官方题解也是用的矩阵的做法，后面有时间再来补充\n## F - Sugoroku2\n> 暂时还没搞懂，后面再来补","tags":["算法"],"categories":["算法"]},{"title":"AtCoder Beginner Contest 188","url":"/2021/01/21/9edc8d3b/","content":"> 比赛地址：https://atcoder.jp/contests/abc188 第一次打，太菜了只写出了 3/6\n> \n> 完整代码（A-F）: [Github](https://github.com/imlgw/competition-algorithm/tree/master/%E6%AF%94%E8%B5%9B/AtCoder/abc188)\n## [A - Three-Point Shot](https://atcoder.jp/contests/abc188/tasks/abc188_a)\n判断两个数差值是否大于 3，直接判断\n## [B - Orthogonality](https://atcoder.jp/contests/abc188/tasks/abc188_b)\n求两个数组内积，直接求，注意溢出\n## [C - ABC Tournament](https://atcoder.jp/contests/abc188/tasks/abc188_c)\n$2^N$ players, labeled $1$ through $2^N$ , will compete against each other in a single-elimination programming tournament. The rating of Player ${i}$ is $A_i$ . Any two players have different ratings, and a match between two players always results in the victory of the player with the higher rating.\n\nThe tournament looks like a perfect binary tree.Formally, the tournament will proceed as follows:\n- For each integer ${i= 1, 2 , 3 , …,N}$ in this order, the following happens.\n  - For each integer ${j(1 \\leq j  \\leq 2^{N-i})}$ , among the players who have never lost, the player with the $(2j-1)$ -th smallest label and the player with the $2j$ -th smallest label play a match against each other.\n\nFind the label of the player who will take **second place**, that is, lose in the final match.\n\n**Constraints**\n\n- $1 \\leq N \\leq 16$\n- $1 \\leq A_i \\leq 10^9$\n- $A_i$ are pairwise different\n- All values in input are integers.\n\n**Sample Input 1**\n```c\n2\n1 4 2 5\n```\n**Sample Output 1**\n```c\n2\n```\n### 解法一\n题目的意思就是把输入数组当作一颗完全二叉树的最底层元素，相邻的两个 Player 进行淘汰（rating 低的会被淘汰），求最终 battle 中败者的索引（第二）\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n    //2^16 = 65536\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = Integer.valueOf(br.readLine());\n        int[] w = read(br);\n        LinkedList<Player> queue = new LinkedList<>();\n        for (int i = 0; i < (1<<N); i++) {\n            queue.addLast(new Player(i+1, w[i]));\n        }\n        while (queue.size() > 2) {\n            Player p1 = queue.removeFirst();\n            Player p2 = queue.removeFirst();\n            queue.addLast(p1.rank > p2.rank ? p1 : p2);\n        }\n        Player p1 = queue.get(0);\n        Player p2 = queue.get(1);\n        System.out.println(p1.rank > p2.rank ? p2.i : p1.i);\n    }\n\n    static class Player{\n        int i;\n        int rank;\n        public Player (int i, int rank) {\n            this.rank = rank;\n            this.i = i;\n        }\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [D - Snuke Prime](https://atcoder.jp/contests/abc188/tasks/abc188_d)\n\nSnuke Inc. offers various kinds of services.\n\nA payment plan called Snuke Prime is available.In this plan, by paying $C$ yen (the currency of Japan) per day, you can use all services offered by the company without additional fees.\n\nYou can start your subscription to this plan at the beginning of any day and cancel your subscription at the end of any day.\n\nTakahashi is going to use $N$ of the services offered by the company.\n\nHe will use the $i$ -th of those services from the beginning of the $a_i$ -th day until the end of the $b_i$ -th day, where today is the first day. Without a subscription to Snuke Prime, he has to pay $c_i$ yen per day to use the $i$ -th service.\n\nFind the minimum total amount of money Takahashi has to pay to use the services.\n\n**Constraints**\n- $1 \\leq N \\leq 2 \\times 10^5$\n- $1 \\leq C \\leq 10^9$\n- $1 \\leq a_i \\leq b_i \\leq 10^9$\n- $1 \\leq c_i \\leq 10^9$\n- All values in input are integers.\n\n**Sample Input 1**\n```c\n2 6\n1 2 4\n2 2 4\n```\n**Sample Output 1**\n```c\n10\n```\n### 解法一\n这题卡了好久，一开始题目的意思就理解了很久，直到结束也没整明白（英语捉急），最后看别人题解的时候才明白啥意思。Otz\n\n这里大概的意思就是说：高桥要使用给出的所有服务，这些服务从 $a_i$ 天开始到 $b_i$ 天结束，每天需要支付 $c_i$ ，同时该公司有另一项政策，就是订阅`Snuke Prime`，当天支付 $C$ 后就可以使用当天出现的所有服务，不用额外的付钱。比如样例一，第一项服务第一天支付 4，第二天支付 6 同时使用第一项服务和第二项服务，总共 10，这样消费是最小的。\n\n![](https://i.loli.net/2021/01/11/luhbOUCWjTmzVZ7.png)\n\n要求总体最小的消耗，我们就得知道每天的最小花费是多大，这里题目给的是一个区间 $a_i \\sim b_i$ 内所有时间的花费 $c[i]$ ，而这题数据很大，暴力必然是不可行的。解决办法就是构建出差分数组，然后按时间戳排序，计算使用每天出现的各项服务的总花费，和 $C$ 取一个最小值，然后乘以对应的区间的天数，累加起来就是结果\n```java\n//1652ms\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0];\n        int C = in[1];\n        HashMap<Integer, Long> diff = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            int[] abc = read(br);\n            int a = abc[0], b = abc[1], c = abc[2];\n            // Java 的 map 确实蛋疼。..\n            diff.put(a, diff.getOrDefault(a, 0l)+c); diff.put(b+1, diff.getOrDefault(b+1, 0l)-c);\n        }\n        long res = 0;\n        int last = 0; // 上一个时间点\n        long sum = 0; // 差分前缀和\n        Integer[] keys = diff.keySet().toArray(new Integer[0]);\n        // 按照时间排序\n        Arrays.sort(keys);\n        for (Integer key : keys) {\n            long min = Math.min(sum, C);\n            res += min * (key-last);\n            last = key;\n            sum += diff.get(key);\n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n\npublic class D {\n    public static void main(String[] args) throws Exception {\n        new Main().main();\n    }\n}\n```\n\n### 解法二\n扫描线的做法，其实和差分思路一样，但是不需要 hash，相比于上面的解法，会稍微快一点\n```java\n//913ms\nimport java.util.*;\nimport java.io.*;\n\nclass Event {\n    int t, c;\n    public Event(int t, int c) {\n        this.t = t;\n        this.c = c;\n    }\n}\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int[] in = read(br);\n        int N = in[0];\n        int C = in[1];\n        List<Event> events = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int[] abc = read(br);\n            int a = abc[0], b = abc[1], c = abc[2];\n            events.add(new Event(a, c));\n            events.add(new Event(b+1, -c));\n        }\n        long res = 0;\n        int last = 0; // 上一个时间点\n        long sum = 0;\n        // 按照时间排序\n        Collections.sort(events, (e1, e2)->e1.t-e2.t);\n        for (Event event : events) {\n            long min = Math.min(sum, C);\n            res += min * (event.t-last);\n            last = event.t;\n            sum += event.c;\n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [E - Peddler](https://atcoder.jp/contests/abc188/tasks/abc188_e)\n\nIn Takahashi Kingdom, there are $N$ towns, called Town $1$ through Town $N$ .\nThere are also $M$ roads in the kingdom, called Road $1$ through Road $M$ . By traversing Road $i$ , you can travel from Town $X_i$ to Town $Y_i$ , but not vice versa. Here, it is guaranteed that $X_i < Y_i$ .\n\nGold is actively traded in this kingdom. At Town $i$ , you can buy or sell $1$ kilogram of gold for $A_i$ yen (the currency of Japan).\n\nTakahashi, a traveling salesman, plans to buy $1$ kilogram of gold at some town, traverse one or more roads, and sell $1$ kilogram of gold at **another town**.\n\nFind the maximum possible profit (that is, the selling price minus the buying price) in this plan.\n\n**Constraints**\n- $2 \\leq N \\leq 2 \\times 10^5$\n- $1 \\leq M \\leq 2 \\times 10^5$\n- $1 \\leq A_i \\leq 10^9$\n- $1 \\leq X_i < Y_i \\leq N$\n- $(X_i, Y_i) \\neq (X_j, Y_j)(i \\neq j)$\n- All values in input are integers.\n\n**Sample Input 1**\n```c\n4 3\n2 3 1 5\n2 4\n1 2\n1 3\n```\n\n**Sample Output 1**\n```c\n3\n```\nWe can achieve the profit of $3$ yen, as follows:\n- At Town $1$ , buy one kilogram of gold for $2$ yen.\n- Traverse Road $2$ to get to Town $2$ .\n- Traverse Road $1$ to get to Town $4$ .\n- At Town $4$ , sell one kilogram of gold for $5$ yen.\n\n### 解法一\n\n这题其实和买卖股票题是一样的，但是我一开始以为题目是有环的。实际上题目条件中说了 $X_i < Y_i$ 所以这就是一个 DAG，直接 DP 就行了， $dp[i]$ 代表从起点（初始入度为 0 的点）到当前节点 $i$ 最低的买入价格。过程中统计一个最大的 $w[j]-dp[i]$ 就行了， $w[j]$ 为当前节点卖出价格， $dp[i]$ 为源点到当前 $j$ 节点之前的最低买入价格（不包括 $j$ ，题目说了不能就地买卖，收益可以为负）\n\n这里的做法是用 BFS 遍历图，从入度为 0 的节点开始，当某个子节点入度为 0 的时候再把他加入队列，保证递推的正确性，过程中维护各个节点的 $dp$ 值，同时计算最大受益，整个过程需要遍历所有的节点和边，所以时间复杂度 $O(N+M)$\n```java\n//一开始用 hashmap 建图未优化，1000ms+\n//改成 ArrayList 建图 845ms，要不是 Java 的 List 太难用我也不会用 map 建图。..\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int INF = 0x3f3f3f3f;\n        int[] nm = read(br);\n        int N = nm[0], M = nm[1];\n        int[] w = read(br);\n        //节点入度数\n        int[] in = new int[N];\n        List<Integer>[] adj = new ArrayList[N];\n        for (int i = 0; i < M; i++) {\n            int[] xy = read(br);\n            int x = xy[0]-1, y = xy[1]-1;\n            if (adj[x] == null) {\n                adj[x] = new ArrayList<>();\n            }\n            adj[x].add(y);\n            in[y]++;\n        }\n        int[] dp = new int[N];\n        Arrays.fill(dp, INF);\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < N; i++) {\n            if (in[i] == 0) {\n                queue.add(i);\n                dp[i] = w[i];\n            }\n        }\n        int res = -INF;\n        while (!queue.isEmpty()) {\n            int i = queue.poll();\n            if (adj[i]==null) continue;\n            for (Integer j : adj[i]) {\n                res = Math.max(res, w[j] - dp[i]);\n                //这里 WA 了好几发。.. 这里 dp[j] 不只在这里计算一次，前面可能计算过了，所以需要对过往的 dp[j] 取 min\n                dp[j] = Math.min(dp[j], Math.min(w[j], dp[i]));\n                in[j]--;\n                if (in[j] == 0) {\n                    queue.add(j);\n                }\n            }\n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n优化后的直接递推的写法，因为题目说了 $x < y$ 所以实际上只能从前向后，所以我们直接循序遍历就一定能保证之前的节点是计算过的，不需要借助队列\n\n```java\n//时间上和上面差不多\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int INF = 0x3f3f3f3f;\n        int[] nm = read(br);\n        int N = nm[0], M = nm[1];\n        int[] w = read(br);\n        List<Integer>[] adj = new ArrayList[N];\n        for (int i = 0; i < M; i++) {\n            int[] xy = read(br);\n            int x = xy[0]-1, y = xy[1]-1;\n            if (adj[x] == null) {\n                adj[x] = new ArrayList<>();\n            }\n            adj[x].add(y);\n        }\n        int[] dp = new int[N];\n        Arrays.fill(dp, INF);\n        int res = -INF;\n        //题目说了 x<y，其实也就说明了只能从前向后走，所以直接顺序遍历是没问题的\n        for (int i = 0; i < N; i++) {\n            //更新当前节点的 dp[i]\n            dp[i] = Math.min(dp[i], w[i]);\n            if (adj[i]==null) continue;\n            for (Integer j : adj[i]) {\n                res = Math.max(res, w[j] - dp[i]);\n                //这里 WA 了好几发。.. 这里 dp[j] 不只在这里计算一次，前面可能计算过了，所以需要对过往的 dp[j] 取 min\n                dp[j] = Math.min(dp[j], Math.min(w[j], dp[i]));\n            }\n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n### 解法二\n\n这个是参考了 [官方题解](https://atcoder.jp/contests/abc188/editorial/555)，这种解法当图不是 DAG 的时候也适用，也就是不考虑 $xy$ 大小关系，给的图只是一个普通的有向图。\n\n首先对各个城镇的金子价格进行排序，从低到高，然后从价格最低的城镇 $x_1$ 开始 BFS，搜索 $x_1$ 能到达的城镇 $y_i$ ，记录最大的收益，并标记到过的城镇，然后从价格第二低的城镇 $x_2$ 开始同样的操作，但是这一次我们之前已经被标记过的 $x_1$ 能到达的城镇 $y_i$ 便不用再入队了，因为收益一定小于从 $x_1$ 开始的收益。因为需要对点进行排序，所以整体的复杂度 $O(NlogN+M)$\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int INF = 0x3f3f3f3f;\n        int[] nm = read(br);\n        int N = nm[0], M = nm[1];\n        int[] w = read(br);\n        Integer[] tid = new Integer[N];\n        for (int i = 0; i < N; i++) tid[i] = i;\n        //将 id 按照 cost 从小到大排序\n        Arrays.sort(tid, (t1,t2)->w[t1]-w[t2]);\n        List<Integer>[] adj = new ArrayList[N];\n        for (int i = 0; i < M; i++) {\n            int[] xy = read(br);\n            int x = xy[0]-1, y = xy[1]-1;\n            if (adj[x] == null) {\n                adj[x] = new ArrayList<>();\n            }\n            adj[x].add(y);\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visit = new boolean[N];\n        int res = -INF;\n        for (int i = 0; i < N; i++) {\n            if (visit[tid[i]]) continue;\n            queue.add(tid[i]);\n            while (!queue.isEmpty()) {\n                int cur = queue.poll();\n                if (adj[cur]==null) continue;\n                for (Integer j : adj[cur]) {\n                    if (visit[j]) continue;\n                    visit[j] = true;\n                    res = Math.max(res, w[j]-w[tid[i]]);\n                    queue.add(j);\n                }\n            }   \n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [F - +1-1x2](https://atcoder.jp/contests/abc188/tasks/abc188_f) \n\nTakahashi has written an integer $X$ on a blackboard. He can do the following three kinds of operations any number of times in any order:\n\n- increase the value written on the blackboard by $1$ ;\n- decrease the value written on the blackboard by $1$ ;\n- multiply the value written on the blackboard by $2$ .\n\nFind the minimum number of operations required to have $Y$ written on the blackboard.\n\n**Constraints**\n\n- $1 \\le X \\le 10^{18}$\n- $1 \\le Y \\le 10^{18}$\n- $X$ and $Y$ are integers.\n\n**Sample Input 1**\n```c\n3 9\n```\n**Sample Output 1**\n```c\n3\n```\n\n### 解法一\n\n这个 F 其实很简单。.. 甚至我之前也做过类似的题（[吃掉-N-个橘子的最少天数](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#1553-%E5%90%83%E6%8E%89-N-%E4%B8%AA%E6%A9%98%E5%AD%90%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0)），但是比赛的时候题都没看😂\n\n这题如果直接考虑从 $X \\rightarrow Y$ 的话，每层递归都有 3 个分支，很明显会爆栈。我们可以将问题转化从 $Y \\rightarrow X$ 的等价问题，反过来 $Y$ 转化成 $X$ 就有三种选择： $y-1$ , $y+1$ , $y/2$ 。首先 $y/2$ 时 $y$ 必须要是偶数，奇数情况只考虑 $y+1$ 和 $y-1$ ，那么 $y$ 为偶数时能考虑加一和减一分支吗？\n1. $y$ 为偶数（只考虑 $y > x$ ，小于 $x$ 差值就是答案），这时候 $y+1$ 会增大 $y$ 和 $x$ 的差距，那么有没有可能是 $y+2$ 然后再除二使得次数更少呢？也是不可能的， $(y+2)/2 = y/2+1$ ， 转换到同一个值，前者需要 3 次变化，而后者只需要 2 次变化，所以直接除 2 是最优选择\n2. $y-1$ 同理，但是我们也需要考虑 $y$ 和 $x$ 差距很小的时候， $y$ 直接一步步的减到 $x$ 的情况\n\n如此一来，我们再加上记忆化，复杂度直线下降，每个分支都有除 2，时间复杂度降低为对数级别\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static HashMap<Long, Long> dp = new HashMap<>();\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        long[] xy = read(br);\n        long x = xy[0], y = xy[1];\n        if (x >= y) {\n            System.out.println(x-y);\n            return;\n        }\n        System.out.println(dfs(x, y));\n    }\n\n    public static long dfs (long x, long y) {\n        if (x > y) return x-y;\n        if (x == y)  return 0;\n        if (dp.containsKey(y)) {\n            return dp.get(y);\n        }\n        long res = y-x;\n        if (y%2==0) {\n            res = Math.min(dfs(x, y/2)+1, res);\n        } else {\n            res = Math.min(dfs(x, (y-1)/2)+2, res);\n            res = Math.min(dfs(x, (y+1)/2)+2, res);\n        }\n        dp.put(y, res);\n        return res;\n    }\n\n    public static long[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"记两道并查集的题（lc947 & lc803）","url":"/2021/01/18/49a9955/","content":"\n> LeetCode 最近每日一题出了好几道并查集的题，有几道挺有意思的，记录一下\n## [947. 移除最多的同行或同列石头](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/)\n\nDifficulty: **中等**\n\n`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。\n\n如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。\n\n给你一个长度为 `n` 的数组 `stones` ，其中 stones[i] = [x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>] 表示第 `i` 块石头的位置，返回 **可以移除的石子** 的最大数量。\n\n**示例 1：**\n\n```c\n输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n输出：5\n解释：一种移除 5 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,1] 同行。\n2. 移除石头 [2,1] ，因为它和 [0,1] 同列。\n3. 移除石头 [1,2] ，因为它和 [1,0] 同行。\n4. 移除石头 [1,0] ，因为它和 [0,0] 同列。\n5. 移除石头 [0,1] ，因为它和 [0,0] 同行。\n石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。\n```\n\n**示例 2：**\n\n```c\n输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\n输出：3\n解释：一种移除 3 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,0] 同行。\n2. 移除石头 [2,0] ，因为它和 [0,0] 同列。\n3. 移除石头 [0,2] ，因为它和 [0,0] 同行。\n石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。\n```\n\n**示例 3：**\n\n```c\n输入：stones = [[0,0]]\n输出：0\n解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。\n```\n\n**提示：**\n\n- 1 <= stones.length <= 1000\n- 0 <= x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub> <= 10<sup>4</sup>\n- 不会有两块石头放在同一个坐标点上\n\n### 解法一\n\n简单的想法肯定是直接双重循环枚举所有的点对，如果两个点横纵坐标有一样的就合并，最后统计下就行了，但是这样时间复杂度就比较高了。\n\n这里我们换一个思路来合并，因为我们并不关心各个点是如何联通的，只要各个点在同一行或者同一列那么他们就是连通的，所以我们可以直接将每个点的行列坐标进行合并，也就相当于我们将 **该行以及该列的所有元素** 与 **当前的元素** 合并起来，最后用石头数量减去连通分量的个数就行了。需要注意的点就是我们需要区分横纵坐标，避免混淆。比如（1，2）和（2，4）不是同一行列，如果不加区分就会被合并成一个连通分量，这里题目给了行列的范围，我们直接加上一个 10001 就行了\n\n```python\nclass Solution(object):\n    def removeStones(self, stones: List[List[int]]) -> int:\n        n = len(stones)\n        parent = {}\n        count = 0\n\n        def union(a, b):\n            nonlocal count\n            pa = find(a)\n            pb = find(b)\n            if pa == pb:\n                return\n            count -= 1\n            parent[pa] = pb\n\n        def find(a):\n            nonlocal count\n            if a not in parent:\n                count += 1\n                parent[a] = a\n                return a\n            if a == parent[a]:\n                return a\n            parent[a] = find(parent.get(a))\n            return parent.get(a)\n\n        for s in stones:\n            union(s[0]+10001, s[1])\n        return n - count\n```\n\n## [803. 打砖块](https://leetcode-cn.com/problems/bricks-falling-when-hit/)\n\nDifficulty: **困难**\n\n有一个 `m x n` 的二元网格，其中 `1` 表示砖块，`0` 表示空白。砖块 **稳定**（不会掉落）的前提是：\n\n- 一块砖直接连接到网格的顶部，或者\n- 至少有一块相邻（4 个方向之一）砖块 **稳定** 不会掉落时\n\n给你一个数组 `hits` ，这是需要依次消除砖块的位置。每当消除 `hits[i] = (rowi, coli)` 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。\n\n返回一个数组 `result` ，其中 `result[i]` 表示第 `i` 次消除操作对应掉落的砖块数目。\n\n**注意**，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。\n\n**示例 1：**\n\n```c\n输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\n输出：[2]\n解释：\n网格开始为：\n[[1,0,0,0]，\n [1,1,1,0]]\n消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0]\n [0,1,1,0]]\n两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n因此，结果为 [2] 。\n```\n\n**示例 2：**\n\n```c\n输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\n输出：[0,0]\n解释：\n网格开始为：\n[[1,0,0,0],\n [1,1,0,0]]\n消除 (1,1) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [1,0,0,0]]\n剩下的砖都很稳定，所以不会掉落。网格保持不变：\n[[1,0,0,0], \n [1,0,0,0]]\n接下来消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n剩下的砖块仍然是稳定的，所以不会有砖块掉落。\n因此，结果为 [0,0] 。\n```\n\n**提示：**\n\n- m == grid.length\n- n == grid[i].length\n- 1 <= m, n <= 200\n- grid[i][j] 为 `0` 或 `1`\n- 1 <= hits.length <= 4 * 10<sup>4</sup>\n- hits[i].length == 2\n- 0 <= x<sub style=\"display: inline;\">i </sub><= m - 1\n- 0 <= y<sub style=\"display: inline;\">i</sub> <= n - 1\n- 所有 (x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>) 互不相同\n\n### 解法一\n\n也是一道很有意思的并查集的题。常规意义上的并查集只能处理连通块的合并，而这题打掉一个砖块意味着连通分量的拆分，那我们应该如何利用并查集呢？\n\n这里的解法很巧妙的采用了 **逆向思维**，既然打掉砖块无法操作，那么我们可以反过来补砖块，先将原本待打击的地方置为 0，然后逆向的的补上去，而补的操作就代表着连通块的合并，我们就可以通过连通块数量的变化统计掉落的砖块，整体的思路非常巧妙。\n\n具体的算法实现还是有一些细节需要注意，都注释在代码中了\n\n```java\nimport java.util.*;\nimport java.io.*;\n \nclass Solution {\n\n    int[] parent;\n    int[] size;\n\n    public int find(int a) {\n        if (parent[a] == a) return a;\n        return parent[a] = find(parent[a]);\n    }\n\n    public void union(int a, int b) {\n        int pa = find(a);\n        int pb = find(b);\n        if (pa == pb) return;\n        if (size[pa] > size[pb]) {\n            parent[pb] = pa;\n            size[pa] += size[pb]; \n        } else {\n            parent[pa] = pb;\n            size[pb] += size[pa];\n        }\n    }\n\n    public int[] hitBricks(int[][] grid, int[][] hits) {\n        int n = grid.length, m = grid[0].length;\n        int hlen = hits.length;\n        //记录当前 hits 对应的位置有没有砖块\n        int[] exist = new int[hlen];\n        for (int i = 0; i < hlen; i++) {\n            int x = hits[i][0], y = hits[i][1];\n            exist[i] = grid[x][y]&1;\n            grid[x][y] = 0;\n        }\n        parent = new int[m*n+1];\n        size = new int[m*n+1];\n        //抽象的屋顶节点\n        int ROOT = m*n;\n        for (int i = 0; i <= m*n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n        //和屋顶有关联的先合并下\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) {\n                union(ROOT, j);\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j]==1) {\n                    //与左边和上边方块合并\n                    if (j-1 >= 0 && grid[i][j-1] == 1) {\n                        union(m*i+j, m*i+j-1);\n                    }\n                    if (/*i-1 >= 0 &&*/ grid[i-1][j] == 1) {\n                        union(m*i+j, m*(i-1)+j);\n                    }\n                }\n            }\n        }\n        int[] res = new int[hlen];\n        int[] dir = {1, 0, -1, 0, 1};\n        for (int i = hlen-1; i >= 0; i--) {\n            int last = size[find(ROOT)];\n            int x = hits[i][0], y = hits[i][1];\n            //WA_2: 还原错误，hit 原本可能没有砖块，一开始直接还原成 1 了\n            grid[x][y] = exist[i]&1;\n            if (grid[x][y] == 0) continue;\n            //WA_1: 还原后和 ROOT 连接的别忘了合并\n            if (x == 0) union(ROOT, x*m+y);\n            //与周围 4 个方向的方块合并\n            for (int k = 0; k < 4; k++) {\n                int nx = x + dir[k], ny = y + dir[k+1];\n                if (nx < 0 || ny < 0 || nx >= n || ny >= m || grid[nx][ny] != 1) {\n                    continue;\n                }\n                union(x*m+y, nx*m+ny);\n            }\n            res[i] = Math.max(0, size[find(ROOT)]-last-1);\n        }\n        return res;\n    }\n}\n```\n\n## [721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)\n\nDifficulty: **中等**\n\n给定一个列表 `accounts`，每个元素 `accounts[i]` 是一个字符串列表，其中第一个元素 `accounts[i][0]` 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。\n\n现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。\n\n合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按字符 ASCII 顺序排列的邮箱地址。账户本身可以以任意顺序返回。\n\n**示例 1：**\n\n```c\n输入：\naccounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n输出：\n[[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n解释：\n第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 \"johnsmith@mail.com\"。 \n第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。\n可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，\n['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。\n```\n\n**提示：**\n\n*   `accounts`的长度将在`[1，1000]`的范围内。\n*   `accounts[i]`的长度将在`[1，10]`的范围内。\n*   `accounts[i][j]`的长度将在`[1，30]`的范围内。\n\n### 解法一\n\n>没错，这是第二道，上面的是第 0 道和第 1 道😁\n\n本来不想记这道题的，没啥意思，业务题，但是写都写了，还是记一下，难倒是不难，就是要理清楚思路，我感觉很麻烦直接看了题解😂，不过题解也有点小瑕疵，邮件映射姓名的时候可以用邮件的编号直接映射的，题解依然用的字符串。这种题其实只想理清楚先干嘛后干嘛就好做了，别老想着一步都求出来，先分步，后面能合并再合并。\n\n```java\n​import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    \n    int[] parent;\n\n    public void union(int a, int b) {\n        parent[find(a)] = find(b);\n    }\n\n    public int find(int a) {\n        if (parent[a] == a) return a;\n        return parent[a] = find(parent[a]);\n    }\n\n    // 比较繁琐，想清楚了写就很简单，没啥意思\n    public List<List<String>> accountsMerge(List<List<String>> acc) {\n        //email : idx\n        HashMap<String, Integer> e2i = new HashMap<>();\n        //idx : name\n        HashMap<Integer, String> i2n = new HashMap<>();\n        int cnt = 0;\n        for (int i = 0; i < acc.size(); i++) {\n            String name = acc.get(i).get(0);\n            for (int j = 1; j < acc.get(i).size(); j++) {\n                String email = acc.get(i).get(j);\n                if (!e2i.containsKey(email)) {\n                    e2i.put(email, cnt);\n                    i2n.put(cnt++, name);\n                }\n            }\n        }\n        parent = new int[cnt];\n        for (int i = 0; i < cnt; i++) {\n            parent[i] = i;\n        }\n        for (int i = 0; i < acc.size(); i++) {\n            int first = e2i.get(acc.get(i).get(1));\n            for (int j = 2; j < acc.get(i).size(); j++) {\n                union(first, e2i.get(acc.get(i).get(j)));\n            }\n        }\n        // idx : emails\n        HashMap<Integer, List<String>> map = new HashMap<>();\n        for (String email : e2i.keySet()) {\n            map.computeIfAbsent(find(e2i.get(email)), k->new LinkedList<>()).add(email);\n        }\n        List<List<String>> res = new ArrayList<>();\n        for (Integer idx : map.keySet()) {\n            String name = i2n.get(idx);\n            List<String> emails = map.get(idx);\n            Collections.sort(emails);\n            emails.add(0, name);\n            res.add(emails);\n        }\n        return res;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"贪心：绝对值不等式","url":"/2021/01/10/6134a4bc/","content":"\n## [104. 货仓选址](https://www.acwing.com/problem/content/description/106/)\n\n在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1$ ~ $A_N$ 。\n\n现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。\n\n为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。\n\n**输入格式**\n\n第一行输入整数 $N$ 。\n\n第二行 N 个整数 $A_1$ ~ $A_N$ 。\n\n**输出格式**\n\n输出一个整数，表示距离之和的最小值。\n\n**数据范围**： $1 ≤ N ≤ 100000$\n\n**输入样例：**\n```c\n4\n6 2 9 1\n```\n**输出样例：**\n```c\n12\n```\n### 解法一\n\n货仓位置为 $A_i$ ，修建点为 $x$ ，那么货仓到 $x$ 点的距离之和为：\n$$\n\\begin{aligned}\nf(x) &= \\sum_{i=0}^{n-1}|A_i-x| \\\\\\\\ &= |A_0-x|+|A_1-x|+...+|A_{n-2}-x|+|A_{n-1}-x| \\\\\\\\ &= (|A_0-x|+|A_{n-1}-x|) + (|A_1-x|+|A_{n-2}-x|) + ... + (|A_{mid-1}-x|+|A_{mid+1}-x|) \\\\\\\\ &\\geq(A_{n-1}-A_0) + (A_{n-2}-A_1) +...+ (A_{mid+1}-A_{mid-1})\n\\end{aligned}\n$$\n\n当且仅当 $x$ 取在 $A_n$ 和 $A_1$ 中间， $A_{n-2}$ 和 $A_2$ 中间。.. 以及 $A_{mid+1}$ 和 $A_{mid-1}$ 中间时，不等式取得最小值，即 $X$ 为 $A_i$ 中位数时（奇偶同理）\n\n![mark](https://static.imlgw.top/blog/20210223/SQaIvuS0o3Nm.png)\n代码实现如下：\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = Integer.parseInt(br.readLine());\n        int[] A = read(br);\n        Arrays.sort(A);\n        int mid = A[(N-1)/2];  // 下取整\n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            res += Math.abs(A[i]-mid);\n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [462. 最少移动次数使数组元素相等 II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)\n\nDifficulty: **中等**\n\n给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加 1 或减 1。 您可以假设数组的长度最多为 10000。\n\n**例如：**\n\n```c\n输入：\n[1,2,3]\n\n输出：\n2\n\n说明：\n只有两个动作是必要的（记得每一步仅可使其中一个元素加 1 或减 1）： \n\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n```\n\n### 解法一\n同上，不多解释\n```java\n​class Solution {\n    public int minMoves2(int[] nums) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += Math.abs(nums[i]-nums[n>>1]);\n        }\n        return res;\n    }\n}\n```\n\n## [912. 最佳见面地点](https://www.lintcode.com/problem/best-meeting-point/description)\n\n有一群住在不同地方的朋友（两个或以上）想要在某地见面，要求他们去往目的地的路程和最短。现在给一个 0、1 组成的二维数组，1 表示此地有一个人居住。使用曼哈顿距离作为计算总距离，公式为： $(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|$\n\n**样例 1:**\n```c\n输入：\n[[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]\n输出：\n6\n解释：\n点 (0, 2) 是最佳见面地点，最小的路程总和为 2+2+2=6，返回 6。\n```\n\n**样例 2:**\n```c\n输入：\n[[1,1,0,0,1],[1,0,1,0,0],[0,0,1,0,1]]\n输出：\n14\n```\n\n### 解法一\n和前面一样\n$$\nf(n) = \\sum_{i=0}^{n-1}(|x_i-x| + |y_i-y|) = \\sum_{i=0}^{n-1}|x_i-x| + \\sum_{i=0}^{n-1}|y_i-y|\n$$\n所以我们分别取 $x_i$ 和 $y_i$ 中点就行了\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * @param grid: a 2D grid\n     * @return: the minimize travel distance\n     */\n    public int minTotalDistance(int[][] grid) {\n        // Write your code here\n        int n = grid.length;\n        int m = grid[0].length;\n        List<Integer> xlis = new ArrayList<>();\n        List<Integer> ylis = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    xlis.add(i);\n                    ylis.add(j);\n                }\n            }\n        }\n        Collections.sort(xlis);\n        Collections.sort(ylis);\n        int xmid = xlis.get(xlis.size()>>1);\n        int ymid = ylis.get(ylis.size()>>1);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    res += Math.abs(i-xmid) + Math.abs(j-ymid);      \n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n## [1703. 得到连续 K 个 1 的最少相邻交换次数](https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/)\n\nDifficulty: **困难**\n\n给你一个整数数组 `nums` 和一个整数 `k` 。 `nums` 仅包含 `0` 和 `1` 。每一次移动，你可以选择 **相邻** 两个数字并将它们交换。\n\n请你返回使 `nums` 中包含 `k` 个连续 `1` 的最少交换次数。\n\n**示例 1：**\n\n```c\n输入：nums = [1,0,0,1,0,1], k = 2\n输出：1\n解释：在第一次操作时，nums 可以变成 [1,0,0,0,1,1] 得到连续两个 1 。\n```\n\n**示例 2：**\n\n```c\n输入：nums = [1,0,0,0,0,0,1,1], k = 3\n输出：5\n解释：通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,1,1,1] 。\n```\n\n**示例 3：**\n\n```c\n输入：nums = [1,1,0,1], k = 2\n输出：0\n解释：nums 已经有连续 2 个 1 了。\n```\n\n**提示：**\n\n*   1 <= nums.length <= 10<sup>5</sup>\n*   `nums[i]` 要么是 `0` ，要么是 `1` 。\n*   1 <= k <= sum(nums)\n\n### 解法一\n42th 双周赛 T4，相比上面的题就有了一些思维的转换。\n\n我们要把 $k$ 个 1 聚拢在一起，我们设定原始位置为 $A_0$ ~ $A_k-1$ ，聚集后的位置为 $X, X+1, X+2...., X+k-1$ 。推导过程如下：\n\n交换次数为：\n\n$$\nf(k) = \\sum_{i=0}^{k-1}|A_i-(X+i)|\n$$\n\n要求这个式子的最小值，将式子转换一下，设 $A_i=B_i+i$ ，那么我们的式子就变成了\n\n$$\nf(k) = \\sum_{i=0}^{k-1}|B_i-X|\n$$\n\n根据我们 [上面的结论](#104-货仓选址），这个式子当 $X$ 取在 $B_i$ 中位数的时候，取得最小值。此时 $X=B_{mid}$ （奇偶同理)\n\n$$\n\\begin{aligned}\n    f(k) &= \\sum_{i=l}^r|B_i-B_{mid}| \\\\\\\\\n         &= \\sum_{i=l}^{mid}(B_{mid}-B_i) + \\sum_{i = mid+1}^{r}(B_i-B_{mid}) \\\\\\\\\n         &= B_{mid}  (2mid-l-r+1) - \\sum_{i = l}^{mid}B_i  +  \\sum_{i = mid+1}^{r}B_i\n\\end{aligned}\n$$\n\n前半部分可以直接计算得到，后半部分可以通过预处理前缀和快速求得，如此我们就可以在 $O(1)$ 的时间内滑窗求出窗口内 1 需要交换的次数，滑动过程中统计出最小值就 ok 了\n```java\nimport java.util.*;\nimport java.io.*;\n\n/*\n1.    得到连续 K 个 1 的最少相邻交换次数\n给你一个整数数组 nums 和一个整数 k 。 nums 仅包含 0 和 1 。每一次移动你可以选择 相邻 两个数字并将它们交换。\n请你返回使 nums 中包含 k 个 连续 1 的 最少 交换次数。\n */\n\nclass Solution {\n    public int minMoves(int[] nums, int k) {\n        int n = nums.length;\n        // int[] w = new int[k];\n        List<Integer> lis = new ArrayList<>();\n        int x = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i]==1) {\n                lis.add(i-x);\n                x++;\n            }\n        }\n        int[] w = lis.stream().mapToInt(Integer::valueOf).toArray();\n        int m = w.length;\n        int[] sum = new int[m+1];\n        for (int i = 1; i <= m; i++) {\n            sum[i] = sum[i-1] + w[i-1];\n        }\n        //sum[i]: [0,i-1]\n        int res = Integer.MAX_VALUE;\n        int left = 0;\n        for (int right = k-1; right < m; right++) {\n            int mid = left+(right-left)/2; //左中位数\n            res = Math.min(res, w[mid]*(2*mid-left-right+1)-(sum[mid+1]-sum[left])+(sum[right+1]-sum[mid+1]));\n            left++;\n        }\n        return res;\n    }\n}\n```\n这里其实有一个 [小的问题](https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/solution/de-dao-lian-xu-k-ge-1-de-zui-shao-xiang-lpa9i/724362)。比如窗口第一次向右滑动时，从 $[A_0，A_1-1，...，A_{k-1}-{k-1}]$ ，滑动到 $[A_1-1，...，A_{k-1}-{k-1}，A_{k}-k]$ 但是实际上按照我们前面的推导，这里我们需要的应该是 $[A_1，A_2-1，A_3-2，...，A_n-n]$ ，那么我们需要重新计算吗？\n\n显然并不需要，这里两个窗口之间差距仅仅只是在坐标轴上**整体的**移动了一步，而我们求的是窗口内元素和中位数差值的和，对结果的计算并没有影响。\n\n## [LCP 24. 数字游戏](https://leetcode-cn.com/problems/5TxKeK/)\n\n小扣在秋日市集入口处发现了一个数字游戏。主办方共有 N 个计数器，计数器编号为 0 ~ N-1。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组 nums。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。\n\n主办方请小扣回答出一个长度为 N 的数组，第 i 个元素 (0 <= i < N) 表示将 0~i 号计数器 初始 所示数字操作成满足所有条件 nums[a]+1 == nums[a+1],(0 <= a < i) 的最小操作数。回答正确方可进入秋日市集。\n\n由于答案可能很大，请将每个最小操作数对 1,000,000,007 取余。\n\n**示例 1：**\n\n```c\n输入：nums = [3,4,5,1,6,7]\n\n输出：[0,0,0,5,6,7]\n\n解释：\ni = 0，[3] 无需操作\ni = 1，[3,4] 无需操作；\ni = 2，[3,4,5] 无需操作；\ni = 3，将 [3,4,5,1] 操作成 [3,4,5,6], 最少 5 次操作；\ni = 4，将 [3,4,5,1,6] 操作成 [3,4,5,6,7], 最少 6 次操作；\ni = 5，将 [3,4,5,1,6,7] 操作成 [3,4,5,6,7,8]，最少 7 次操作；\n返回 [0,0,0,5,6,7]。\n```\n\n**示例 2：**\n\n```c\n输入：nums = [1,2,3,4,5]\n\n输出：[0,0,0,0,0]\n\n解释：对于任意计数器编号 i 都无需操作。\n```\n**示例 3：**\n```c\n输入：nums = [1,1,1,2,3,4]\n\n输出：[0,1,2,3,3,3]\n\n解释：\ni = 0，无需操作；\ni = 1，将 [1,1] 操作成 [1,2] 或 [0,1] 最少 1 次操作；\ni = 2，将 [1,1,1] 操作成 [1,2,3] 或 [0,1,2]，最少 2 次操作；\ni = 3，将 [1,1,1,2] 操作成 [1,2,3,4] 或 [0,1,2,3]，最少 3 次操作；\ni = 4，将 [1,1,1,2,3] 操作成 [-1,0,1,2,3]，最少 3 次操作；\ni = 5，将 [1,1,1,2,3,4] 操作成 [-1,0,1,2,3,4]，最少 3 次操作；\n返回 [0,1,2,3,3,3]。\n```\n\n**提示：**\n\n- 1 <= nums.length <= 10^5\n- 1 <= nums[i] <= 10^3\n\n### 解法一\n在补上面的题的时候看见有人提到和这题一样，所以顺便一起写一下这题，因为已经知道了和上面哪题差不多，所以这里很快就转换成和上面类似的问题了，设原来的数组为 $A_i$ 数组，转换后新数组以 $X$ 开头，则从 0~n 的转换次数为：\n\n$$\nf(n) = \\sum_{i=0}^{n-1}|A_i-(X+i)|\n$$\n\n我们要求的就是这个式子的最小值，这里我们将式子转换一下，设 $A_i=B_i+i$ ，那么我们的式子就变成了\n\n$$\nf(n) = \\sum_{i=0}^{n-1}|B_i-X|\n$$\n\n根据前面的 [结论](#104-货仓选址），很显然 $X$ 取 $B_i$ 的中位数时该式得到最小值。那么问题就转换成了如何动态的求区间的中位数，[上一题](#1703-得到连续 K 个 1 的最少相邻交换次数） 因为变化的值是下标，窗口内的下标肯定是有序的，所以直接通过左右端点就可以计算得到中位数，但是这题我们变化的是数组的值，并且是无序的，所以我们需要借助一些其他的结构，这里我采用**双堆**的做法动态的维护中位数，详见 [数据流的中位数](https://imlgw.top/2019/05/04/a9999be0/#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0)\n\n有了中位数后，我们还需要滑动的过程中快速的求出上面的式子的值，这里我们再把上面的式子拆分一下就变成\n\n$$\nf(n) = \\sum_{B_i \\leq B_{mid}}(B_{mid}-B_{i}) + \\sum_{B_i > B_{mid}}(B_i-B_{mid})\n$$\n\n左右两部分其实就对应了小于等于 $B_{mid}$ 的元素以及大于 $B_{mid}$ 的元素，我们只需要在维护双堆的同时，维护一下各个堆的元素和以及元素个数就可以快速的求出上面式子的值，时间复杂度大概 $O(NlogN)$ 的样子\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Solution {\n\n    int[] w;\n    //小根堆和大根堆的和\n    long minSum = 0l, maxSum = 0l;\n    //存后 1/2 小的元素\n    PriorityQueue<Integer> max = new PriorityQueue<>((a, b)->w[b]-w[a]);\n    //存前 1/2 大的元素\n    PriorityQueue<Integer> min = new PriorityQueue<>((a, b)->w[a]-w[b]);\n\n    //n = 10^5\n    public int[] numsGame(int[] nums) {\n        int MOD = (int)1e9+7;\n        int n = nums.length;\n        w = new int[n];\n        for (int i = 0; i < n; i++) {\n            w[i] = nums[i]-i;\n        }\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            add(i);\n            int mid = find();\n            //这里取模 WA 了两发。..int 后面没打括号，给强转了\n            //小根堆的个数以及 sum 代表的实际是大于 mid 的元素部分，大根堆同理\n            res[i] = (int)(((long)w[mid]*(max.size()-min.size()) - maxSum + minSum) % MOD);\n        }\n        return res;\n    }\n\n    //维护大根堆以及小根堆\n    public void add(int x) {\n        min.add(x);\n        minSum += w[x];\n        minSum -= w[min.peek()]; maxSum += w[min.peek()];\n        max.add(min.poll());\n        if (min.size() < max.size()) {\n            minSum += w[max.peek()]; maxSum -= w[max.peek()];\n            min.add(max.poll());\n        }\n    }\n\n    public int find() {\n        return min.peek();\n    }\n\n}\n\npublic class LeetCode_LCP24 数字游戏 {\n    public static void main(String[] args) {\n        Arrays.stream(new Solution().numsGame(new int[]{3,4,5,1,6,7})).forEach(System.out::println);\n    }\n}\n```\n\n## [122. 糖果传递](https://www.acwing.com/problem/content/description/124/)\n有 n 个小朋友坐成一圈，每人有 a[i] 个糖果。\n\n每人只能给左右两人传递糖果。\n\n每人每次传递一个糖果代价为 1。\n\n求使所有人获得均等糖果的最小代价。\n\n**输入格式**\n\n第一行输入一个正整数 n，表示小朋友的个数。\n\n接下来 n 行，每行一个整数 a[i]，表示第 i 个小朋友初始得到的糖果的颗数。\n\n**输出格式**\n\n输出一个整数，表示最小代价。\n\n**数据范围**：1≤n≤1000000, 0≤a[i]≤2×109, 数据保证一定有解。\n\n**输入样例：**\n```c\n4\n1\n2\n5\n4\n```\n**输出样例：**\n```c\n4\n```\n\n### 解法一\n老实说，在知道这个题是绝对值不等式的题之后，我还是没有推出了正确的公式，可见我是有多菜了。\n这里直接就不多写了，直接贴我 onenote 的手稿吧\n![mark](https://static.imlgw.top/blog/20210306/1vf8xD2ofBHy.png)\n代码实现如下：\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = read(br)[0];\n        long[] c = new long[N];\n        int[] A = new int[N];\n        long sum = 0;\n        for (int i = 0; i < N; i++) {\n            A[i] = Integer.valueOf(br.readLine());\n            sum += A[i];\n        }\n        long k = sum/N;\n        sum = 0;\n        for (int i = 0; i < N; i++) {\n            sum += A[i];\n            c[i] = (i+1)*k - sum;\n        }\n        Arrays.sort(c);\n        long res = 0;\n        for (int i = 0; i < N; i++) {\n            res += Math.abs(c[i]-c[N>>1]);\n        }\n        out.println(res);\n        out.flush();\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n","tags":["算法"],"categories":["算法"]},{"title":"力扣 42th 双周赛","url":"/2021/01/06/f0b3824b/","content":"\n## [1702. 修改后的最大二进制字符串](https://leetcode-cn.com/problems/maximum-binary-string-after-change/)\n\nDifficulty: **中等**\n\n给你一个二进制字符串 `binary` ，它仅有 `0` 或者 `1` 组成。你可以使用下面的操作任意次对它进行修改：\n\n*   操作 1 ：如果二进制串包含子字符串 \"00\" ，你可以用 \"10\" 将其替换。\n    *   比方说， \"00010\" -> \"10010\"\n*   操作 2 ：如果二进制串包含子字符串 \"10\" ，你可以用 \"01\" 将其替换。\n    *   比方说， \"00010\" -> \"00001\"\n\n请你返回执行上述操作任意次以后能得到的 **最大二进制字符串** 。如果二进制字符串 `x` 对应的十进制数字大于二进制字符串 `y` 对应的十进制数字，那么我们称二进制字符串`x`大于二进制字符串`y`。\n\n**示例 1：**\n\n```c\n输入：binary = \"000110\"\n输出：\"111011\"\n解释：一个可行的转换为：\n\"000110\" -> \"000101\" \n\"000101\" -> \"100101\" \n\"100101\" -> \"110101\" \n\"110101\" -> \"110011\" \n\"110011\" -> \"111011\"\n```\n\n**示例 2：**\n\n```c\n输入：binary = \"01\"\n输出：\"01\"\n解释：\"01\" 没办法进行任何转换。\n```\n\n**提示：**\n\n*   1 <= binary.length <= 10<sup>5</sup>\n*   `binary` 仅包含 '0' 和 '1' 。\n\n### 解法一\n\n因为是补题，之前在群里有看见讨论，大致的提到了一些，所以这里很快就想到了贪心的思路。首先 01 是无法继续变化的，10 是可以变成 01 的，而开头连续的 1 肯定是不需要再变化的，变化只会使得结果变小，所以我们可以将除了开头连续的 1 以外的所有的 1 都转换到最后（一定是可以的，因为 10 可以变成 01），然后再将中间的 00 都转换成 10 最后剩下的就只有中间的一个 0，这样就使得结果最大了。最终的结果就是 1111...0...111 类似的形式\n```java\n​public class MaximumBinaryString {\n    //100101100 --> 100000111 --> 111110111\n1   //1100 --> 1110\n    public String maximumBinaryString(String binary) {\n        int n = binary.length();\n        int cnt = 0;\n        int i = 0;\n        while (i < n && binary.charAt(i) == '1') i++;\n        if (i==n) return binary;\n        while (i < n) {\n            if (binary.charAt(i) == '1') cnt++;\n            i++;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < n-cnt-1; j++) {\n            sb.append(\"1\");\n        }\n        sb.append(\"0\");\n        for (int j = 0; j < cnt; j++) {\n            sb.append(\"1\");\n        }\n        return sb.toString();\n    }\n}\n```\n\n## [1703. 得到连续 K 个 1 的最少相邻交换次数](https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/)\n\nDifficulty: **困难**\n\n给你一个整数数组 `nums` 和一个整数 `k` 。 `nums` 仅包含 `0` 和 `1` 。每一次移动，你可以选择 **相邻** 两个数字并将它们交换。\n\n请你返回使 `nums` 中包含 `k` 个连续 `1` 的最少交换次数。\n\n**示例 1：**\n\n```c\n输入：nums = [1,0,0,1,0,1], k = 2\n输出：1\n解释：在第一次操作时，nums 可以变成 [1,0,0,0,1,1] 得到连续两个 1 。\n```\n\n**示例 2：**\n\n```c\n输入：nums = [1,0,0,0,0,0,1,1], k = 3\n输出：5\n解释：通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,1,1,1] 。\n```\n\n**示例 3：**\n\n```c\n输入：nums = [1,1,0,1], k = 2\n输出：0\n解释：nums 已经有连续 2 个 1 了。\n```\n\n**提示：**\n\n*   1 <= nums.length <= 10<sup>5</sup>\n*   `nums[i]` 要么是 `0` ，要么是 `1` 。\n*   1 <= k <= sum(nums)\n\n### 解法一\n\n单独写了一篇文章整理类似的题，[详见](https://imlgw.top/2021/01/10/6134a4bc/#1703-%E5%BE%97%E5%88%B0%E8%BF%9E%E7%BB%ADK%E4%B8%AA1%E7%9A%84%E6%9C%80%E5%B0%91%E7%9B%B8%E9%82%BB%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0)","tags":["动态规划","LeetCode"],"categories":["算法"]},{"title":"力扣 220th 周赛","url":"/2020/12/29/8e50a4df/","content":"\n> 好久没写 LeetCode 的题了，来补一下 [220 周赛](https://leetcode-cn.com/contest/weekly-contest-220/) 的 T3 和 T4\n## [1696. 跳跃游戏 VI](https://leetcode-cn.com/problems/jump-game-vi/)\n\nDifficulty: **中等**\n\n给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。\n\n一开始你在下标 `0` 处。每一步，你最多可以往前跳 `k` 步，但你不能跳出数组的边界。也就是说，你可以从下标 `i` 跳到 `[i + 1， min(n - 1, i + k)]` **包含** 两个端点的任意位置。\n\n你的目标是到达数组最后一个位置（下标为 `n - 1` ），你的 **得分** 为经过的所有数字之和。\n\n请你返回你能得到的 **最大得分** 。\n\n**示例 1：**\n\n```c\n输入：nums = [1,-1,-2,4,-7,3], k = 2\n输出：7\n解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。\n```\n\n**示例 2：**\n\n```c\n输入：nums = [10,-5,-2,4,0,3], k = 3\n输出：17\n解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。\n```\n\n**示例 3：**\n\n```c\n输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n输出：0\n```\n\n**提示：**\n\n*   1 <= nums.length, k <= 10<sup>5</sup>\n*   -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>\n\n### 解法一\n递推公式很容易得到，先来一发暴力解法，不出意料的 T 了\n```java\n//1 2 3 4 5 k=2\npublic int maxResult(int[] nums, int k) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    dp[0] = nums[0];\n    for (int i = 1; i < n; i++) {\n        dp[i] = -0x3f3f3f3f;\n        for (int j = i-1; i-j <= k && j >= 0; j--) {\n            dp[i] = Math.max(dp[j]+nums[i], dp[i]);\n        }\n    }\n    return dp[n-1];\n}\n```\n\n### 解法二\n其实这题想了挺久的，主要是没想到 T3 会用到单调队列去优化 dp，很巧的是这个单调队列优化这个知识点我刚刚在 yxc 那边学了一点，那个题目相对这题会复杂很多，是多重背包的问题。然后我就感觉这个题好像也可以用单调队列来优化，然后就试了一发，然后就 AC 了😁\n> 这里也可以借助其他的数据结构，比如线段树，st 表，优先队列什么的去维护连续的大小为 k 的区间的最大值，这里我就不写了\n```java\n//1 2 3 4 5 k=2\npublic int maxResult(int[] nums, int k) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    dp[0] = nums[0];\n    //dp[i]   = Max(       dp[i-1], dp[i-2], dp[i-3],... dp[i-k+1], dp[i-k])\n    //dp[i+1] = Max(dp[i], dp[i-1], dp[i-2], dp[i-3],... dp[i-k+1])\n    //dp[i] --> dp[i+1] 滑动窗口最大值\n    LinkedList<int[]> queue = new LinkedList<>();\n    for (int i = 1; i < n; i++) {\n        while (!queue.isEmpty() && dp[i-1] > queue.getLast()[0]) {\n            queue.removeLast();\n        }\n        if (!queue.isEmpty() && i-queue.getFirst()[1] >= k) {\n            queue.removeFirst();\n        }\n        //这里也可以在队列中只存 dp 值的坐标，简化代码\n        queue.addLast(new int[]{dp[i-1], i});\n        dp[i] = queue.getFirst()[0]+nums[i];\n    }\n    return dp[n-1];\n}\n```\n\n## [1697. 检查边长度限制的路径是否存在](https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/)\n\nDifficulty: **困难**\n\n给你一个 `n` 个点组成的无向图边集 `edgeList` ，其中 edgeList[i] = [u<sub style=\"display: inline;\">i</sub>, v<sub style=\"display: inline;\">i</sub>, dis<sub style=\"display: inline;\">i</sub>] 表示点 u<sub style=\"display: inline;\">i</sub>` 和点 `v<sub style=\"display: inline;\">i</sub> 之间有一条长度为 dis<sub style=\"display: inline;\">i</sub> 的边。请注意，两个点之间可能有超过一条边。\n\n给你一个查询数组`queries` ，其中 queries[j] = [p<sub style=\"display: inline;\">j</sub>, q<sub style=\"display: inline;\">j</sub>, limit<sub style=\"display: inline;\">j</sub>] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 p<sub style=\"display: inline;\">j</sub> 到 q<sub style=\"display: inline;\">j</sub>的路径，且这条路径上的每一条边都 **严格小于** limit<sub style=\"display: inline;\">j</sub>。\n\n请你返回一个 **布尔数组**`answer`，其中`answer.length == queries.length` ，当 `queries[j]` 的查询结果为 `true` 时， `answer` 第`j` 个值为`true`，否则为 `false` 。\n\n**示例 1：**\n\n![](https://i.loli.net/2020/12/30/WiZjdPCsFca4JlE.png)\n\n```c\n输入：n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n输出：[false,true]\n解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。\n对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。\n对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。\n```\n\n**示例 2：**\n\n![](https://i.loli.net/2020/12/30/TRQdGcei1S8UX9k.png)\n\n```c\n输入：n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n输出：[true,false]\n解释：上图为给定数据。\n```\n\n**提示：**\n\n*   2 <= n <= 10<sup>5</sup>\n*   1 <= edgeList.length, queries.length <= 10<sup>5</sup>\n*   edgeList[i].length == 3\n*   queries[j].length == 3\n*   0 <= u<sub style=\"display: inline;\">i</sub>, v<sub style=\"display: inline;\">i</sub>, p<sub style=\"display: inline;\">j</sub>, q<sub style=\"display: inline;\">j</sub> <= n - 1\n*   u<sub style=\"display: inline;\">i</sub> != v<sub style=\"display: inline;\">i</sub>\n*   p<sub style=\"display: inline;\">j</sub> != q<sub style=\"display: inline;\">j</sub>\n*   1 <= dis<sub style=\"display: inline;\">i</sub>, limit<sub style=\"display: inline;\">j</sub> <= 10<sup>9</sup>\n*   两个点之间可能有 **多条** 边。\n\n### 解法一\n\n看到了评论区的一句提示然后写出了下面的解法，后来看题解区大佬科普这种类型的题目属于 [离线算法](https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-shi-yao-j-pn1b/)，其实核心的思想就是，对查询的 limit 和边权值进行排序，然后从小 query 的 limit 开始，将 edge 权值不大于 limit 的都丢到并查集里面，然后查询一下就行了\n```java\nint[] parent;\n\npublic int find(int a) {\n    if (parent[a] == a) {\n        return a;\n    }\n    return parent[a] = find(parent[a]);\n}\n\npublic void union(int a,int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) return;\n    parent[pa] = pb; \n}\n\nclass Pair {\n    int p, q;\n    int limit;\n    int idx;\n    public Pair(int p, int q, int limit, int idx) {\n        this.p = p;\n        this.q = q;\n        this.limit = limit;\n        this.idx = idx;\n    }\n}\n\npublic boolean[] distanceLimitedPathsExist(int n, int[][] edge, int[][] q) {\n    parent = new int[n];\n    for (int i = 0; i < n; i++) parent[i] = i;\n    boolean[] res = new boolean[q.length];\n    Pair[] query = new Pair[q.length];\n    for (int i = 0; i < q.length; i++) {\n        query[i] = new Pair(q[i][0], q[i][1], q[i][2], i);\n    }\n    Arrays.sort(edge, (e1, e2)->e1[2]-e2[2]);\n    Arrays.sort(query, (q1, q2)->q1.limit-q2.limit);\n    int j = 0;\n    for (int i = 0; i < query.length; i++) {\n        while (j < edge.length && edge[j][2] < query[i].limit) {\n            union(edge[j][0], edge[j][1]);\n            j++;\n        }\n        res[query[i].idx] = find(query[i].p) == find(query[i].q);\n    }\n    return res;\n}\n```\n看了大佬们的代码后稍微做了下点简化\n```java\nint[] parent;\n\npublic int find(int a) {\n    if (parent[a] == a) return a;\n    return parent[a] = find(parent[a]);\n}\n\npublic void union(int a,int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) return;\n    parent[pa] = pb; \n}\n\npublic boolean[] distanceLimitedPathsExist(int n, int[][] edge, int[][] q) {\n    parent = new int[n];\n    int qlen = q.length;\n    for (int i = 0; i < n; i++) parent[i] = i;\n    boolean[] res = new boolean[qlen];\n    //记录 query 排序后的 id\n    Integer[] qid = new Integer[qlen];\n    for (int i = 0; i < qlen; i++) qid[i] = i;\n    Arrays.sort(edge, (e1, e2)->e1[2]-e2[2]);\n    Arrays.sort(qid, (i1, i2)->q[i1][2]-q[i2][2]);\n    int j = 0;\n    for (int i = 0; i < qlen; i++) {\n        while (j < edge.length && edge[j][2] < q[qid[i]][2]) {\n            union(edge[j][0], edge[j][1]);\n            j++;\n        }\n        res[qid[i]] = find(q[qid[i]][0]) == find(q[qid[i]][1]);\n    }\n    return res;\n}\n```","tags":["动态规划","LeetCode"],"categories":["算法"]},{"title":"Lc1621. 大小为 K 的不重叠线段的数目","url":"/2020/11/24/8f4e877d/","content":"\n## [1621. 大小为 K 的不重叠线段的数目](https://leetcode-cn.com/problems/number-of-sets-of-k-non-overlapping-line-segments/)\n\nDifficulty: **中等**\n\n给你一维空间的 `n` 个点，其中第 `i` 个点（编号从 `0` 到 `n-1`）位于 `x = i` 处，请你找到 **恰好** `k` **个不重叠** 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 **整数坐标** 。这 `k` 个线段不需要全部覆盖全部 `n` 个点，且它们的端点可以重合。\n请你返回 `k` 个不重叠线段的方案数。由于答案可能很大，请将结果对 `1e9+7` **取余** 后返回。\n\n**示例 1：**\n\n![](https://i.loli.net/2020/11/24/CO2b9MBa5WFTNnU.png)\n\n```c\n输入：n = 4, k = 2\n输出：5\n解释：\n如图所示，两个线段分别用红色和蓝色标出。\n上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。\n```\n\n**示例 2：**\n\n```c\n输入：n = 3, k = 1\n输出：3\n解释：总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。\n```\n\n**示例 3：**\n\n```c\n输入：n = 30, k = 7\n输出：796297179\n解释：画 7 条线段的总方案数为 3796297200 种。将这个数对 109 + 7 取余得到 796297179 。\n```\n\n**示例 4：**\n\n```c\n输入：n = 5, k = 3\n输出：7\n```\n\n**示例 5：**\n\n```c\n输入：n = 3, k = 2\n输出：1\n```\n\n**提示：**\n\n*   `2 <= n <= 1000`\n*   `1 <= k <= n-1`\n\n### 解法一\n\n这题题想了好久，最终还是妥协了，看了题解，发现有暴搜+记忆化的解法，试了下，T 了\n```java\nint MOD = (int)1e9+7;\n\n//写个暴搜试试（T 了）\npublic int numberOfSets2(int n, int k) {\n    Long[][] dp = new Long[n+1][k+1];\n    return dfs(n, k, dp);\n}\n\n//n 个点放 k 条线段的方案数\npublic int dfs(int n, int k, Long[][] dp) {\n    if (dp[n][k] != null) {\n        return dp[n][k].intValue();\n    }\n    if (k == 0) {\n        return 1;\n    }\n    if (k == 1) {\n        return (n-1)*n/2;\n    }\n    long res = 0;\n    for (int i = 1; n-i >= k-2; i++) {\n        //前 (i+1) 个点放一条线段有 i 种方案（刨开之前的方案）\n        res += 1l * i * dfs(n-i, k-1, dp);\n        res = (res + MOD) % MOD;\n    }\n    dp[n][k] = res;\n    return (int)res;\n}\n```\n\n### 解法二\n\n其实这里就两个状态，点数 $n$ 和线段条数 $k$ ，所以设计状态的时候肯定是和这两个有关。乍一看这里任意相邻两个点数之间是没有任何关联的，所以我们需要建立联系。这个联系其实就是线段有没有覆盖到 $n$\n\n我们设 $dp[i][j]$ 代表长度为 $i$ 的节点放置 $j$ 条线段有几种方案，状态的转移分两种情况\n1. 最后一条线段不覆盖右端点，那么递推就直接 $dp[i][j] = dp[i-1][j]$\n2. 最后一条线段覆盖右端点，枚举最后一条线段的长度所对应的 $dp[i-len][j-1]$ 累加起来\n\n代码实现如下：\n```java\npublic int numberOfSets(int n, int k) {\n    int MOD = (int)1e9+7;\n    long[][] dp = new long[n+1][k+1];\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= Math.min(i-1, k); j++) {\n            //j 没有覆盖右端点的情况\n            dp[i][j] = dp[i-1][j];\n            //枚举 j 覆盖区间右端点的所有情况，注意从 1 开始\n            for (int s = 1; s < i; s++) {\n                dp[i][j] = (dp[i][j] + dp[s][j-1]) % MOD;\n            }\n        }\n    }\n    return (int) dp[n][k];\n}\n```\n这里数据范围是 $1e3$ ，显然 $O(n^3)$ 是过不了的，所以需要优化。这里发现第三重循环中求的其实是前缀和，所以可以通过前缀和优化成 $O(n^2)$\n```java\npublic int numberOfSets(int n, int k) {\n    int MOD = (int)1e9+7;\n    long[][] dp = new long[n+1][k+1];\n    long[][] sum = new long[n+1][k+1];\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        sum[i][0] = sum[i-1][0] + 1; \n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= Math.min(i-1, k); j++) {\n            //j 没有覆盖右端点的情况\n            dp[i][j] = dp[i-1][j];\n            //枚举 j 覆盖区间右端点的所有情况，注意从 1 开始\n            // for (int s = 1; s < i; s++) {\n            //     dp[i][j] = (dp[i][j] + dp[s][j-1]) % MOD;\n            // }\n            dp[i][j] = (dp[i][j] + sum[i-1][j-1]) % MOD;\n            sum[i][j] = sum[i-1][j] + dp[i][j];\n        }\n    }\n    return (int) dp[n][k];\n}\n```\n\n### 解法三\n\n这种 DP 的方式更好理解\n\n$dp[i][j][0]$ : 前 $i$ 个点放 $j$ 条线段，第 $j$ 条线段没有覆盖右端点，所以显然 $dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1]$\n\n$dp[i][j][1]$ : 前 $i$ 个点放 $j$ 条线段，第 $j$ 条线段覆盖右端点（可以延长），首先 j 位置单独成一条线段 $dp[i-1][j-1][0] + dp[i-1][j-1][1]$ ，然后就是 $j$ 位置和前面的连成一条线段的 $dp[i-1][j]$\n\n```java\npublic int numberOfSets(int n, int k) {\n    int MOD = (int)1e9+7;\n    //dp[i][j][0]: 前 i 个点放 j 条线段，第 j 条线段没有覆盖右端点\n    //dp[i][j][1]: 前 i 个点放 j 条线段，第 j 条线段覆盖右端点（可以延长）\n    long[][][] dp = new long[n+1][k+1][2];\n    for (int i = 0; i <= n; i++) {\n        dp[i][0][0] = 1;\n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= Math.min(i-1, k); j++) {\n            dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1];\n            dp[i][j][1] = dp[i-1][j-1][0] + dp[i-1][j-1][1] + dp[i-1][j][1];\n            dp[i][j][0] = (dp[i][j][0] + MOD) % MOD;\n            dp[i][j][1] = (dp[i][j][1] + MOD) % MOD;\n        }\n    }\n    return (int)(dp[n][k][0] + dp[n][k][1] + MOD) % MOD;\n}\n```\n### 解法四\n\n其实是上面解法的优化递推，省去了前缀和的空间，直接从状态转移方程上进行优化\n![mark](http://static.imlgw.top/blog/20201126/RxHR7Ushje0p.png?imageslim)\n列出递推中的连续两项，然后进行合并优化，直接得到递推公式\n```java\n//有一点技巧性的递推\npublic int numberOfSets(int n, int k) {\n    int MOD = (int)1e9+7;\n    //n 个点，放 k 个线段，不重叠的方案数\n    long[][] dp = new long[n+1][k+1];\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n    }\n    \n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i-1 && j <= k; j++) {\n            //dp[2][1] = 2*dp[1][1] - dp[0][1] + dp[1][0]\n            dp[i][j] = 2*dp[i-1][j] - dp[i-2][j] + dp[i-1][j-1];\n            dp[i][j] = (dp[i][j] + MOD) % MOD;\n        }\n    }\n    return (int)dp[n][k];\n}\n```\n\n### 解法五\n\n数学法，看不懂，求 C(n+k-1, 2k)","tags":["动态规划","LeetCode"],"categories":["算法"]},{"title":"PC 端软件推荐","url":"/2020/11/19/944ca6e0/","content":"\n## 远程桌面软件\n\n### Teamviewer\n个人不是很喜欢这个软件，现在要用这个软件必须要注册了，但是没办法，市面上对个人免费的，速度比较快的也就是它了，其他的要么卡的要死，要么贵的要死（微软自带的有一个远程桌面，但是只有专业版才有，家庭版要用挺麻烦的，而且得有公网 IP，懒得折腾）\n\n平常电脑要是有啥问题，可以直接开这个，然后把账号密码截图给我，我鼓捣鼓捣兴许就给鼓捣好了😁\n> QQ 远程比较卡，而且很多核心的系统设置 QQ 远程无法修改\n\n推荐指数⭐⭐⭐\n\n下载地址 [click](https://www.teamviewer.cn/cn/)\n\n## 安全方面\n推荐就使用**电脑自带**的安全管家，比如**戴尔电脑管家**之类的，如果没有的话建议直接裸奔（win10 自带的有一个 windows defender），只要不乱点奇怪的链接，下载或者启动奇怪的程序就行了，如果实在是不放心可以下载一个 [火绒](https://www.huorong.cn/)，没有广告弹窗什么的，体积也比较小\n\n![](https://i.loli.net/2020/11/18/sy7Z5vQRHemuCBX.png)\n\n> 不推荐装什么 360，腾讯之类的安全管家，装一个就会连带装一些全家桶，挺恶心人的，如果已经装了，可以使用我下面推荐的卸载工具卸载掉\n\n## 卸载 & 清理\n\n### Geek\n\n绿色软件（指不用安装的软件），下载后双击启动就行了，可以用来卸载第三方的一些软件，也可以卸载一些 uwp 应用（微软应用商店安装的软件）。没有广告，体积小，推荐指数⭐⭐⭐⭐⭐\n\n下载地址 [click](https://lanzoux.com/iXFAZiiuq9g)\n\n### CClean\n\n垃圾清理软件，清注册表贼舒服操作比较简单，拒绝辣鸡软件残留（也是绿软）。推荐指数⭐⭐⭐⭐\n> 我这个是破解版，打开后会提示你更新，x 掉就行\n\n下载地址 [click](https://lanzoux.com/i9Zrejswysb)\n\n### Dism++\n\n跟上面的一样也是垃圾清理软件，但是这个不能瞎搞，有些东西不能乱清理\n推荐指数⭐⭐⭐\n\n下载地址 [click](https://www.chuyu.me/zh-Hans/index.html)\n\n## 输入法\n推荐就使用微软自带的输入法，没有弹窗，没有广告，简洁干净，也有很多表情（win + . 触发），搜狗什么的，感觉不太靠谱，之前在微软社区看到有人更新 win10 因为搜狗而崩溃了，[传送门](https://answers.microsoft.com/zh-hans/windows/forum/windows_10-update/systemserviceexception%E8%93%9D%E5%B1%8F/e5c0a131-a155-4cc0-a871-b6089d474313?rtAction=1553553854556)\n\n推荐指数⭐⭐⭐⭐⭐\n## 浏览器\n### Google Chrome\n首先肯定是无脑这个，PC 端最好用的浏览器，没有之一，但是 Chrome 在查看一些老的视频网站，或者一些需要使用 flash 的网页时，会有点麻烦，Chrome 默认会禁用 flash（flash 这项技术不安全，漏洞太多，目前已经被淘汰，但是某些网站仍在使用，比如 4399😁）\n推荐指数⭐⭐⭐⭐⭐\n### 360 极速浏览器\n注意是** 360 极速浏览器**，这个不会有捆绑，我在没换电脑之前也用了很长一段时间的这个浏览器，这个用的是 Chrome 的内核。这个浏览器是可以直接播放 flash 的，不需要设置，但是这个浏览器启动贼慢，冷启动要 6，7 秒，离谱的很\n推荐指数⭐⭐⭐\n\n下载地址 [click](https://browser.360.cn/ee/)\n### Edge\n也就是你现在电脑上自带的哪个，原本自带的是 ie，但是现在新版的 win10 已经都换成这个了，这个用的也是 Chrome 的内核，也挺好用的\n推荐指数⭐⭐⭐⭐\n## 视频播放器\n\n### PotPlayer\n其实 win10 自带的有一个播放器，但是支持的视频格式不是很多，而且功能比较少（不能倍数，不能逐帧。..），这个 PotPlayer 比较好用，没有广告，页面简洁，支持市面上大多数视频格式。推荐指数⭐⭐⭐⭐⭐\n下载地址 [click](https://daumpotplayer.com/wp-content/uploads/2020/10/PotPlayerSetup64.exe)\n\n## PDF 阅读器\n\n### PDFread\n\n平常看一些 pdf 文件（电子书）时可以用这个（浏览器也可以直接打开 pdf 查看，但是不能保存阅读记录，每次要重新打开）\n![](https://i.loli.net/2020/11/18/yhOdHpzFXQTet1W.png)\n也是绿色软件，打开即用，无需安装。\n推荐指数⭐⭐⭐⭐⭐\n\n下载地址 [click](https://lanzoux.com/i8uZ6iivtij)\n\n## 解压 & 压缩\n\n### Bandzip\n简洁好用，最近在免费版本中右下角加入了一点广告，但是只有你主动去启动压缩软件才会出现，正常人应该不会主动去点击压缩软件，平常右键压缩解压是看不见广告的，还算是比较克制，目前还没有影响我使用体验（国内某数字压缩软件一边凉快去吧）。推荐指数⭐⭐⭐⭐\n\n下载地址 [click](https://www.bandisoft.com/bandizip/)\n### 7-zip\n\n这个是完全免费的绿色软件，但是感觉界面比较简陋，有一点学习成本\n推荐指数⭐⭐⭐⭐\n\n下载地址 [click](https://www.7-zip.org/a/7z1900-x64.exe)\n\n## 文件搜索\n\n### Everything\n\n文件检索的工具，第一次初始化会有点慢，后续搜索会非常迅速，体积小，绿色软件，无需安装\n推荐指数⭐⭐⭐⭐⭐\n\n下载地址 [click](https://www.voidtools.com/Everything-1.4.1.992.x64.zip)\n\n## 桌面整理\n### DeskGo\n腾讯桌面整理，tx 难得的良心软件，本来是 QQ 安全管家里面附带的，后来被单独提取出来了，没广告，没捆绑，占用小（几十 M）。用起来大概是这个样子\n![mark](http://static.imlgw.top///20190414/Ch6k6LNP3CU2.png?imageslim)\n可以整理乱糟糟的桌面，把应用程序，文件啥的分类之后摆放的整整齐齐（强迫症必备😂）推荐指数⭐⭐⭐⭐⭐\n\n> 实际上我现在已经不用这个桌面整理的软件了，我桌面上啥都没有（这样就不用整理了🤣）\n> ![](https://i.loli.net/2020/11/18/UFA2gaJ4lxCWbyN.png)\n\n下载地址 [click](https://dl.softmgr.qq.com/original/Office/DeskGo_3_1_1427_127_lite.exe)\n\n## 浏览器插件\n这一块可能会有一点麻烦，需要先把梯子弄好\n浏览器插件有很多挺有用的功能，很多骚操作，可以自己研究研究\n1. 无限制复制粘贴（某度文库不让复制）\n2. 一些影视网站（aiqiyi, tencent...）直接解析到盗版网站在线观看\n3. 广告拦截（ADBlock，非常强力）\n4. B 站 | 知乎 | youtube | ... 视频下载\n5. 划词翻译\n6. lastpass，之前给你介绍的密码管理软件的浏览器插件版本，可以自动填充密码，保存密码，随机密码\n7. ....\n\n## OCR\n### 天若 OCR\n绿色软件，体积很小，无需安装，扫描也很准确（曾经用这个扫描别人手写的作业，然后 copy😁）推荐指数⭐⭐⭐⭐\n\n下载地址 [click](https://lanzoux.com/iF9Wjiiz4af)\n## 在线画流程图网站\n[draw.io](https://app.diagrams.net/)\n在线画图工具，谁用谁知道，现在也有桌面版本的了\n![](https://i.loli.net/2020/11/18/lxbAdeE8knGtQBg.png)\n\n## 梯子\n直接看官方给的教程就 ok 了\n\nhttps://xcat.us/user/tutorial_v2ray\n\n## 常用的网站\n\n- http://imlgw.top/ 不多说，赶快收藏置顶\n- https://www.deepl.com/translator 专业翻译\n- https://www.gaitubao.com/ 在线改图，压图，修改格式，很好用\n- https://wallhaven.cc/ 高清壁纸，图片（很多比较大的图下载后需要手动的改图，改成 1080 才能适配）\n- https://wall.alphacoders.com/ 也是壁纸图片素材网站，这个可以在线的改图的分辨率，改成 1080 就可以直接拿来做壁纸了\n- https://www.lanzou.com/ 这个用来做小文件（小于 100M）分享很好用，免费，不限速，不需要下载客户端，（某度云我基本已经抛弃了，大文件下载限速限到死，小文件下载还得下客户端，我要那么大的空间有毛用，下都下不来）","tags":["软件推荐"],"categories":["杂项"]},{"title":"DP：最长上升子序列模型","url":"/2020/11/14/f00d00a3/","content":"\n> 现在打算写一些短点的文章了，LeetCode 系列不会再 append 了，如果写 lc 题会单独开一篇文章，然后写题解\n\n## 最长上升子序列模型\n\n[300. 最长上升子序列](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97)\n\n[673. 最长递增子序列的个数](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0)\n\n[1016. 使序列递增的最小交换次数（LintCode）](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#1016-%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%EF%BC%88LintCode%EF%BC%89)\n\n[354. 俄罗斯套娃信封问题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98)\n\nLIS 有 N^2 的 DP 解法，也有 NlogN 的贪心的解法，具体用那种取决于数据范围\n\n## [1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/)\n\n怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。\n\n而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。\n\n有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。\n\n不得已，怪盗基德只能操作受损的滑翔翼逃脱。\n\n假设城市中一共有 N 幢建筑排成一条线，每幢建筑的高度各不相同。\n\n初始时，怪盗基德可以在任何一幢建筑的顶端。\n\n他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。\n\n因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。\n\n他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。\n\n请问，他最多可以经过多少幢不同建筑的顶部（包含初始时的建筑）？\n\n**输入格式**\n\n输入数据第一行是一个整数 K，代表有 K 组测试数据。\n\n每组测试数据包含两行：第一行是一个整数 N，代表有 N 幢建筑。第二行包含 N 个不同的整数，每一个对应一幢建筑的高度 h，按照建筑的排列顺序给出。\n\n**输出格式**\n\n对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。\n\n**数据范围**\n\n1≤K≤100, 1≤N≤100, 0<h<10000\n\n**输入样例：**\n```c\n3\n8\n300 207 155 299 298 170 158 65\n8\n65 158 170 298 299 155 207 300\n10\n2 1 3 4 5 6 7 8 9 10\n```\n**输出样例：**\n```c\n6\n9\n```\n\n### 解法一\n\n常规 N^2 动态规划的方式 & NlogN 贪心解法（NlogN 的解法回忆了一会儿才推出来，如果数据范围不是很大还是 N^2 的 dp 好写）\n```java\nimport java.io.*;\nimport java.util.*;\n//AcWing 1017. 怪盗基德的滑翔翼 https://www.acwing.com/problem/content/1019/\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while (T-- > 0) {\n            int n = sc.nextInt();\n            int[] w = new int[n];\n            for (int i = 0; i < n; i++) {\n                w[i] = sc.nextInt(); \n            }\n            System.out.println(Math.max(solve(w, n), solve(reverse(w), n))); \n        }\n    }\n\n    //DP(N^2) 的解法\n    public static int solve(int[] w, int n) {\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        int res = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (w[j] > w[i]) {\n                    dp[i] = Math.max(dp[j]+1, dp[i]);  \n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res; \n    }\n\n    //tail[i]: 长度为 i 的递减子序列最大结尾\n    public static int solve2(int[] w, int n) {\n        int[] tail = new int[n];\n        int len = 0;\n        for (int i = 0; i < n; i++) {\n            int idx = search(tail, len, w[i]);\n            if (idx == -1) {\n                tail[len++] = w[i];\n            } else {\n                tail[idx] = w[i];\n            }\n        }\n        return len;\n    }\n\n    //从左到右找第一个小于 target 的元素下标，替换它，使得结尾更大，长度更长\n    public static int search(int[] tail, int len, int target){\n        int left = 0, right = len-1;\n        int res = -1;\n        while (left <= right) {\n            int mid = left + (right - left)/2;\n            if (tail[mid] <= target) {\n                res = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return res;\n    }\n\n    public static int[] reverse(int[] w) {\n        for (int i = 0, j = w.length-1; i < j; i++, j--) {\n            int temp = w[i];\n            w[i] = w[j];\n            w[j] = temp;\n        }\n        return w;\n    }\n}\n```\n\n## [1014. 登山](https://www.acwing.com/problem/content/1016/)\n\n五一到了，ACM 队组织大家去登山观光，队员们发现山上一个有 N 个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。\n\n同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。\n\n队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？\n\n**输入格式**\n\n第一行包含整数 N，表示景点数量。\n\n第二行包含 N 个整数，表示每个景点的海拔。\n\n**输出格式**\n\n输出一个整数，表示最多能浏览的景点数。\n\n**数据范围**\n2≤N≤1000\n**输入样例：**\n```c\n8\n186 186 150 200 160 130 197 220\n```\n**输出样例：**\n```c\n4\n```\n\n### 解法一\n\nLIS 转换了一下而已，求每个点从**左到右** 和 从**右到左**的最长上升子序列最大和就 ok 了\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] w = new int[N];\n        for (int i = 0; i < N; i++) {\n            w[i] = sc.nextInt();\n        }\n        System.out.println(solve(w, N));\n    }\n\n    //186 186 150 200 160 130 197 220  := 4\n    public static int solve(int[] w, int N) {\n        int[] dp1 = new int[N];\n        int[] dp2 = new int[N];\n        Arrays.fill(dp1, 1);\n        Arrays.fill(dp2, 1);\n        int res = 1;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < i; j++) {\n                if (w[j] < w[i]) {\n                    dp1[i] = Math.max(dp1[j]+1, dp1[i]);          \n                }\n            }\n        }\n        for (int i = N-1; i >= 0; i--) {\n            for (int j = N-1; j > i; j--) {\n                if (w[j] < w[i]) {\n                    dp2[i] = Math.max(dp2[j]+1, dp2[i]);          \n                }\n            }\n            res = Math.max(res, dp1[i]+dp2[i]-1);\n        }\n        return res;\n    }\n}\n```\n> [482. 合唱队形](https://www.acwing.com/problem/content/484/) 和这一题一样，不重复写了\n\n## [1012. 友好城市](https://www.acwing.com/problem/content/1014/)\n\nPalmia 国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 N 个城市。\n\n北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。\n\n每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。\n\n编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。\n\n**输入格式**\n\n第 1 行，一个整数 N，表示城市数。\n\n第 2 行到第 n+1 行，每行两个整数，中间用 1 个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。\n\n**输出格式**\n\n仅一行，输出一个整数，表示政府所能批准的最多申请数。\n\n**数据范围**\n\n1≤N≤5000,\n0≤xi≤10000\n\n**输入样例：**\n```c\n7\n22 4\n2 6\n10 3\n15 12\n9 8\n17 17\n4 2\n```\n**输出样例：**\n```c\n4\n```\n\n### 解法一\n\n和之前的 [354. 俄罗斯套娃信封问题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98) 一样，还简单一点，坐标都是唯一的，不需要考虑坐标重合的问题，具体可以去看看俄罗斯套娃的这个题\n\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[][] w = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            w[i][0] = sc.nextInt();\n            w[i][1] = sc.nextInt();\n        }\n        System.out.println(solve2(w, N));\n    }\n\n    //5000 * 5000 = 2500 0000，能过但是有点慢\n    public static int solve(int[][] w, int N) {\n        Arrays.sort(w, (w1, w2)->w1[0]-w2[0]);\n        int res = 1;\n        int[] dp = new int[N];\n        for (int i = 0; i < N; i++) {\n            dp[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (w[j][0] < w[i][0] && w[j][1] < w[i][1]) {\n                    dp[i] = Math.max(dp[j]+1, dp[i]);\n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n    }\n\n    //NlogN 贪心二分的做法\n    public static int solve2(int[][] w, int N) {\n        Arrays.sort(w, (w1, w2)->w1[0]-w2[0]);\n        int[] tail = new int[N];\n        int len = 0;\n        for (int i = 0; i < N; i++) {\n            int idx = search(tail, len, w[i][1]);\n            if (idx == -1) {\n                tail[len++] = w[i][1];\n            } else {\n                tail[idx] = w[i][1];\n            }\n        }\n        return len;\n    }\n\n    //从左到右找第一个大于 target 的，后面替换它，使得结尾更小\n    public static int search(int[] tail, int len, int target) {\n        int left = 0, right = len-1;\n        int res = -1;\n        while (left <= right) {\n            int mid = left + (right - left)/2;\n            if (tail[mid] > target) {\n                res = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return res;\n    }\n}\n```\n\n## [1016. 最大上升子序列和](https://www.acwing.com/problem/content/1018/)\n\n一个数的序列 bi，当 b1<b2<…<bS 的时候，我们称这个序列是上升的。\n\n对于给定的一个序列 (a1,a2,…,aN)，我们可以得到一些上升的子序列 (ai1,ai2,…,aiK)，这里 1≤i1<i2<…<iK≤N。\n\n比如，对于序列 (1,7,3,5,9,4,8)，有它的一些上升子序列，如 (1,7),(3,4,8) 等等。\n\n这些子序列中和最大为 18，为子序列 (1,3,5,9) 的和。\n\n你的任务，就是对于给定的序列，求出最大上升子序列和。\n\n注意，最长的上升子序列的和不一定是最大的，比如序列 (100,1,2,3) 的最大上升子序列和为 100，而最长上升子序列为 (1,2,3)。\n\n**输入格式**\n\n输入的第一行是序列的长度 N。\n\n第二行给出序列中的 N 个整数，这些整数的取值范围都在 0 到 10000（可能重复）。\n\n**输出格式**\n\n输出一个整数，表示最大上升子序列和。\n\n**数据范围**\n\n1≤N≤1000\n\n**输入样例：**\n```c\n7\n1 7 3 5 9 4 8\n```\n**输出样例：**\n```\n18\n```\n\n### 解法一\n\n没啥好说的，比较简单\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] w = new int[N];\n        for (int i = 0; i < N; i++) {\n            w[i] = sc.nextInt();\n        }\n        System.out.println(solve(w, N));\n    }\n\n    public static int solve(int[] w, int N) {\n        int[] dp = new int[N];\n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            dp[i] = w[i];\n            for (int j = 0; j < i; j++) {\n                if (w[j] < w[i]) {\n                    dp[i] = Math.max(dp[i], dp[j]+w[i]);\n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n    }\n}\n```\n## [1010. 拦截导弹](https://www.acwing.com/problem/content/description/1012/)\n\n某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。\n\n但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。\n\n某天，雷达捕捉到敌国的导弹来袭。\n\n由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n\n输入导弹依次飞来的高度（雷达给出的高度数据是不大于 30000 的正整数，导弹数不超过 1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n\n**输入格式**: \n\n共一行，输入导弹依次飞来的高度。\n\n**输出格式**: \n\n第一行包含一个整数，表示最多能拦截的导弹数。\n\n第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。\n\n**输入样例：**\n```c\n389 207 155 300 299 170 158 65\n```\n**输出样例：**\n```c\n6\n2\n```\n\n### 解法一\n\nDilworth 定理，双 DP 解法\n```java\n//300 250 275 252 200 138 245 := 5,2\n//最多击落多少就不多说了\n//最少需要的系统数量实际上就是最长上升子序列的个数，这里涉及到 Dilworth 定理\npublic static int[] solve(int[] w, int N){\n    int[] down = new int[N];\n    int[] up = new int[N];\n    int max = 0, count = 1;\n    for (int i = 0; i < N; i++) {\n        up[i] = down[i] = 1;\n        for (int j = 0; j < i; j++) {\n            if (w[j] >= w[i]) {\n                down[i] = Math.max(down[j]+1, down[i]);\n            } else {\n                up[i] = Math.max(up[j]+1, up[i]);\n            }\n        }\n        max = Math.max(max, down[i]);\n        count = Math.max(count, up[i]);\n    }\n    return new int[]{max, count};\n}\n```\n\n最多击落多少就不多说了，~~最少需要的系统数其实就是最长上升子序列，因为这个子序列是**必不可能在同一套系统中被击落**，当遇到这个子序列中的元素的时候，就需要增加一套系统，所以最少就是这个子序列的长度~~\n\n最少需要的系统数量（最少的覆盖整个序列的不上升序列个数）就是最长的上升子序列长度，涉及到 Dilworth 定理（[导弹拦截问题与 Dilworth 定理](https://www.cnblogs.com/flipped/p/5009943.html)），感兴趣可以去了解下，定理的定义为：_对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目_ \n\n本题中，最少需要的导弹系统数量就是**最小链划分中链的数量**，其最大反链就是**最长上升子序列长度**，所以直接求最长上升子序列的长度就 ok 了\n\n### 解法二\n\n双贪心解法。\n\n①求 LIS 的贪心做法，`tail[j]`表示长度为`j`的下降序列，每个`w[i]`作为结尾的时候优先选择大于`w[i]`的最小的`tail[j]`（也就是从左到右最第一个大于 w[i] 的），然后接在它后面，这样让长度为 j 的下降序列结尾变小，后面可以接上更多的元素，使得序列可以更长，并且这样不会影响之前已有的序列关系，最终 tail 的长度就是最长上升子序列的长度\n\n②求最少的覆盖全序列的下降子序列个数，`tail[j]`表示目前为止第`j`个系统的最大结尾元素，每个`w[i]`被遍历到的时候都是作为某一个系统的结尾，那么此时就会面临选择，这个时候我们就可以贪心的将其放置到**大于`w[i]`的最小的 tail 后面**，这样避免浪费其他较大的结尾（结尾越大，后面可以接的导弹越多），选择消耗一个最小的结尾，可能有点抽象，举个例子就明白了\n![](https://i.loli.net/2020/11/23/VY6nU9oFuaB3GkO.png)\n\n这里 1 就面临两个选择，要么接在 2 后面，要么接在 4 后面，很明显这里应该接在 2 后面，如果接在 3 后面那么后面的 3 就只能新建一个系统，会增加系统数量\n\n具体的证明可以采用微调法，证明贪心解是小于等于最优解的，这里不再展开\n```java\n//9 8 7 9 8 7 9 8 7 55 66 99 88 77 88 963 365 4561\n//双贪心写法\npublic static int[] solve2(int[] w, int N){\n    int[] res = new int[2];\n    //长度为 i 的最长下降子序列的最小结尾\n    int[] tail = new int[N];\n    int len = 0;\n    //最长下降子序列（不严格）\n    for (int i = 0; i < w.length; i++) {\n        //找 tail 中第一个小于 w[i] 的替换掉，这样后面可以接更多的数\n        //可以二分优化下，这里就不写了\n        int idx;\n        for (idx = 0; idx < len; idx++) {\n            if (tail[idx] < w[i]) {\n                break;\n            }\n        }\n        tail[idx] = w[i];\n        len += (idx == len) ? 1 : 0;\n    }\n    res[0] = len;\n    tail = new int[N];\n    len = 0;\n    //最少覆盖全序列的下降子序列个数\n    for (int i = 0; i < w.length; i++) {\n        //找 tail 中第一个大于等于 w[i] 的替换掉\n        //可以二分优化下，这里就不写了\n        int idx;\n        for (idx = 0; idx < len; idx++) {\n            if (tail[idx] >= w[i]) {\n                break;\n            }\n        }\n        tail[idx] = w[i];\n        len += (idx == len) ? 1 : 0;\n    }\n    res[1] = len;\n    return res;\n}\n```\n\n## [187. 导弹防御系统](https://www.acwing.com/problem/content/189/)\n\n为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。\n\n一套防御系统的导弹拦截高度要么一直 严格单调 上升要么一直 严格单调 下降。\n\n例如，一套系统先后拦截了高度为 3 和高度为 4 的两发导弹，那么接下来该系统就只能拦截高度大于 4 的导弹。\n\n给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。\n\n**输入格式**\n\n输入包含多组测试用例。\n\n对于每个测试用例，第一行包含整数 n，表示来袭导弹数量。\n\n第二行包含 n 个不同的整数，表示每个导弹的高度。\n\n当输入测试用例 n=0 时，表示输入终止，且该用例无需处理。\n\n**输出格式**\n\n对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。\n\n**数据范围**： 1≤n≤50\n\n**输入样例：**\n```java\n5\n3 5 2 4 1\n0 \n```\n**输出样例：**\n\n```java\n2\n样例解释\n对于给出样例，最少需要两套防御系统。\n\n一套击落高度为 3,4 的导弹，另一套击落高度为 5,2,1 的导弹。\n```\n\n### 解法一\n\n搜索 + 贪心剪枝，搜索的复杂度是 O(N*2^N)，每个位置有两种选择，每次选择都需要遍历 up 或者 down，虽然时间复杂度很高，但是整体的结果比较小，所以很多情况都被剪掉了，整体速度还不错\n```java\nimport java.util.*;\nimport java.io.*;\n//1. 考虑每个点是在上升序列中还是下降序列中\n//2. 考虑是否需要新建一个单独的序列\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            int N = sc.nextInt();\n            if (N == 0) return;\n            int[] w = new int[N];\n            up = new int[N];\n            down = new int[N];\n            res = Integer.MAX_VALUE;\n            for (int i = 0; i < N; i++) {\n                w[i] = sc.nextInt();\n            }\n            dfs(w, 0, 0, 0);\n            System.out.println(res);\n        }\n    }\n\n    static int[] up = null;\n    static int[] down = null;\n    static int res;\n\n    public static void dfs(int[] w, int c, int ul, int dl) {\n        //关键的剪枝\n        if (ul+dl >= res) return;\n        if (c == w.length) {\n            res = Math.min(ul+dl, res);\n            return;\n        }\n        //将 c 放在上升序列中\n        boolean flag = false;\n        for (int i = 0; i < ul; i++) {\n            if (up[i] > w[c]) {\n                flag = true;\n                int temp = up[i];\n                up[i] = w[c];\n                dfs(w, c+1, ul, dl);\n                up[i] = temp;\n                break;\n            }\n        }\n        if (!flag) {\n            up[ul] = w[c];\n            dfs(w, c+1, ul+1, dl);\n            up[ul] = 0;\n        }\n        flag = false;\n        for (int i = 0; i < dl; i++) {\n            if (down[i] < w[c]) {\n                flag = true;\n                int temp = down[i];\n                down[i] = w[c];\n                dfs(w, c+1, ul, dl);\n                down[i] = temp;\n                break;\n            }\n        }\n        if (!flag) {\n            down[dl] = w[c];\n            dfs(w, c+1, ul, dl+1);\n            down[dl] = 0;\n        }\n    }\n}\n```\n\n### 解法二\n\n迭代加深搜索，代码简化，在解比较小的时候可以使用这种搜索方式找最小值，结合了 DFS 和 BFS 的优点\n\n```java\npublic static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while (sc.hasNext()) {\n        int N = sc.nextInt();\n        if (N == 0) return;\n        int[] w = new int[N];\n        up = new int[N];\n        down = new int[N];\n        res = Integer.MAX_VALUE;\n        for (int i = 0; i < N; i++) {\n            w[i] = sc.nextInt();\n        }\n        //dfs(w, 0, 0, 0);\n        int depth = 0;\n        while (!dfs(w, depth, 0, 0, 0)) {\n            depth++;\n        }\n        System.out.println(depth);\n    }\n}\n\nstatic int[] up = null;\nstatic int[] down = null;\n//迭代加深，BFS 版的 DFS\npublic static boolean dfs(int[] w, int depth, int c, int ul, int dl) {\n    if (ul+dl > depth) return false;\n    if (c == w.length) {\n        return true;\n    }\n    //将 c 放在上升序列中，那么我们应该找到小于 w[i] 的最大的 tail\n    int i = 0;\n    for (i = 0; i < ul; i++) {\n        if (up[i] < w[c]) break;\n    }\n    int temp = up[i];\n    up[i] = w[c];\n    if (i == ul) {\n        if (dfs(w, depth, c+1, ul+1, dl)) {\n            return true;      \n        }\n    } else if (dfs(w, depth, c+1, ul, dl)) {\n        return true;\n    }\n    up[i] = temp;\n    //将 c 放在下降序列中，那么我们应该找到大于 w[i] 的最小的 tail\n    for (i = 0; i < dl; i++) {\n        if (down[i] > w[c]) break;\n    }\n    temp = down[i];\n    down[i] = w[c];\n    if (i == dl) {\n        if (dfs(w, depth, c+1, ul, dl+1)) {\n            return true;\n        }\n    } else {\n        if (dfs(w, depth, c+1, ul, dl)) {\n            return true;\n        }\n    }\n    down[i] = temp;\n    return false;\n}\n```\n\n## [272. 最长公共上升子序列](https://www.acwing.com/problem/content/description/274/)\n\n熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\n\n小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\n\n小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。\n\n奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\n\n不过，只要告诉奶牛它的长度就可以了。\n\n数列 A 和 B 的长度均不超过 3000。\n\n**输入格式**\n\n第一行包含一个整数 N，表示数列 A，B 的长度。\n\n第二行包含 N 个整数，表示数列 A。\n\n第三行包含 N 个整数，表示数列 B。\n\n**输出格式**\n\n输出一个整数，表示最长公共上升子序列的长度。\n\n**数据范围**\n\n1≤N≤3000, 序列中的数字均不超过 2^31−1\n\n**输入样例：**\n```go\n4\n2 2 1 3\n2 1 2 3\n```\n**输出样例：**\n```go\n2\n```\n\n### 解法一\n\n朴素的解法应该自己想出来的，可惜，没想出来，看了解答才理解，这里`dp[i][j]` 是指** A 序列的前 i 个字符和 B 的前 j 个字符组成的，以`B[j]`结尾的最长公共上升子序列长度**，实际上是 lcs 个 lis 的完美结合，因为状态定义指定了`B[j]`是一定要包含的，所以相比 LCS 的四种情况，这里只有两种情况，包含或者不包含`A[i]`\n- 不包含 A[i] 那么状态就是`dp[i-1][j]`; \n- 如果要包含 A[i]，那么`A[i]`必须等于`B[j]`，否则就没有考虑的意义，然后我们按照 LIS 的方法去找一个最大值就 ok 了\n\n时间复杂度 N^3，这里按道理是会被卡掉的，但是并没有。..\n\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] A = new int[N];\n        int[] B = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n        }\n        for (int i = 0; i < N; i++) {\n            B[i] = sc.nextInt();\n        }\n        System.out.println(solve(A, B, N));\n    }\n\n    public static int solve(int[] A, int[] B, int N){\n        //A 前 i 个字符和 B 前 j 个字符并且以 B[j] 结尾的最长 LCIS\n        int[][] dp = new int[N+1][N+1];\n        int res = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                dp[i][j] = dp[i-1][j];\n                if (A[i-1] == B[j-1]) {\n                    dp[i][j] = Math.max(dp[i][j], 1);\n                    for (int k = 1; k < j; k++) {\n                        if (B[j-1] > B[k-1]) {\n                            dp[i][j] = Math.max(dp[i][k]+1, dp[i][j]);\n                        }\n                    }\n                }\n                res = Math.max(res, dp[i][j]);\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 解法二\n对上面的解法做了等价变形，首先上面解法内循环是找`[1,j-1]`区间内`B[k]<B[j]`的最大值，同时此时的`B[j]==A[i]`，所以我们可以进行一波等价变形，动态的计算这个最大值，从而优化掉一层循环，还是很巧妙的\n\n```java\n//代码等价变形，时间复杂度 N^2\npublic static int solveOpt(int[] A, int[] B, int N){\n    //A 前 i 个字符和 B 前 j 个字符并且以 B[j] 结尾的最长 LCIS\n    int[][] dp = new int[N+1][N+1];\n    int res = 0;\n    for (int i = 1; i <= N; i++) {\n        int maxv = 1;\n        for (int j = 1; j <= N; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (A[i-1] == B[j-1]) {\n                dp[i][j] = Math.max(dp[i][j], maxv);\n            }\n            if (B[j-1] < A[i-1]) {\n                maxv = Math.max(maxv, dp[i][j]+1);\n            }\n            res = Math.max(res, dp[i][j]);\n        }\n    }\n    return res;\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"DP：数字三角形模型","url":"/2020/11/09/22c967e1/","content":"\n> 现在打算写一些短点的文章了，LeetCode 系列不会再 append 了，如果写 lc 题会单独开一篇文章，然后写题解\n\n## 数字三角形模型\n\n[120. 三角形最小路径和](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C)\n\n[64. 最小路径和](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C)\n\n[Path sum: three ways](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#Path-sum-three-ways)\n\n之前写过题解的就不重复写了，还有很多类似的题就不一一列举出来了，详见 [LeetCode 动态规划](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/)\n\n> 后续如果还有类似的题会 append 进来\n## [1027. 方格取数](https://www.acwing.com/problem/content/1029/)\n\n设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字 0。如下图所示：\n\n![](https://files.catbox.moe/hhonhx.png)\n\n某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。\n\n在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0）。\n\n此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。\n\n**输入格式**\n\n第一行为一个整数 N，表示 N×N 的方格图。\n\n接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。\n\n行和列编号从 1 开始。\n\n一行“0 0 0”表示结束。\n\n**输出格式**\n\n输出一个整数，表示两条路径上取得的最大的和。\n\n**数据范围**\n\nN≤10\n\n**输入样例：**\n```c\n8\n2 3 13\n2 6 6\n3 5 7\n4 4 14\n5 2 21\n5 6 4\n6 3 15\n7 2 14\n0 0 0\n```\n**输出样例：**\n```c\n67\n```\n**难度：** 简单\n\n**来源：**《信息学奥赛一本通》 , NOIP2000 提高组\n\n### 解法一\n\n一开始确实没想出来，主要是看着范围好小，然后不确定复杂度，以为可以搜索的，看了 y 总讲解了一点，然后想过来了，自己写了一个 N^4 的解法\n```java\n//input output 省略\n//N^4 dp\npublic static int slove(int[][] w, int N) {\n    int[][][][] dp = new int[N+1][N+1][N+1][N+1];\n    for (int i1 = 1; i1 <= N; i1++) {\n        for (int j1 = 1; j1 <= N; j1++) {\n            for (int i2 = 1; i2 <= N; i2++) {\n                for (int j2 = 1; j2 <= N; j2++) {\n                    int temp = dp[i1][j1][i2][j2];\n                    temp = Math.max(temp, dp[i1-1][j1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1-1][j1][i2][j2-1]);\n                    temp = Math.max(temp, dp[i1][j1-1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1][j1-1][i2][j2-1]);\n                    dp[i1][j1][i2][j2] = temp + ((i1==i2&&j1==j2) ? w[i1-1][j1-1] : (w[i1-1][j1-1] + w[i2-1][j2-1])); \n                }\n            }\n        }\n    }\n    return dp[N][N][N][N];\n}\n```\n其实如果是只有一条路径就很简单，线性 DP 就行了，`dp[i][j] = Max(dp[i-1][j], dp[i][j-1])`，但是这题涉及到了两条路径，所以我们可以将状态定义为`dp[i1][j1][i2][j2]`，含义为从（1，1）到（i1，j1）,(i2，j2) 这两个点的最大和，到每个点有两种走法，2*2 一共 4 种子状态，取 Max 就行了\n\n但是这里会有一个问题，某个点的 val 被取走之后就不能再被取了。也就是说，这两条路径可能会有交点，这种情况需要额外处理，而相交的情况实际上也就是`i1==i2 && j1 == j2`的时候，这种情况交点的值就只能算一次\n\n### 解法二\n\ny 总讲的解法，优化了一维状态，N^3 的解法，非常的巧妙，因为只能向下和向右走，所以从（1，1）到（N-1，N-1），走的总步数一定是`2*N`，那么我们就可以通过步数 K 计算出另一个坐标，从而省去一维状态\n\n```java\n//N^3 优化，根据走的总步数计算另一个坐标位置\npublic static int slove2(int[][] w, int N) {\n    int[][][] dp = new int[2*N+1][N+1][N+1];\n    for (int k = 2; k <= 2*N; k++) {\n        for (int i1 = 1; i1 <= N; i1++) {\n            for (int i2 = 1; i2 <= N; i2++) {\n                int j1 = k-i1, j2 = k-i2;\n                if (1 <= j1 && j1 <= N && 1 <= j2 && j2 <= N) {\n                    int temp = dp[k][i1][i2]; \n                    temp = Math.max(temp, dp[k-1][i1-1][i2-1]);\n                    temp = Math.max(temp, dp[k-1][i1-1][i2]);\n                    temp = Math.max(temp, dp[k-1][i1][i2-1]);\n                    temp = Math.max(temp, dp[k-1][i1][i2]);\n                    dp[k][i1][i2] = temp + ((i1==i2&&j1==j2) ? w[i1-1][j1-1] : (w[i1-1][j1-1] + w[i2-1][j2-1]));     \n                }\n            }\n        }\n    }\n    return dp[2*N][N][N];\n}\n```\n## [275. 传纸条](https://www.acwing.com/problem/content/277/)\n\n小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。\n\n一次素质拓展活动中，班上同学安排坐成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。\n\n幸运的是，他们可以通过传纸条来进行交流。\n\n纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 (1,1)，小轩坐在矩阵的右下角，坐标 (m,n)。\n\n从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 \n\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。\n\n班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 \n\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 0 表示），可以用一个 0-100 的自然数来表示，数越大表示越好心。\n\n小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。\n\n现在，请你帮助小渊和小轩找到这样的两条路径。\n\n**输入格式**\n\n第一行有 2 个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n 列。\n\n接下来的 m 行是一个 m∗n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。\n\n**输出格式**\n\n输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n\n**数据范围：**\n\n1≤n,m≤50\n\n**输入样例：**\n```c\n3 3\n0 3 9\n2 8 5\n5 7 0\n```\n**输出样例：**\n```c\n34\n```\n### 解法一\n\n和上面一题一样，虽然题目说的是一个从左上向右下，一个是从右下到左上，但是实际上依然是要求两条路径连接左上到右下，使得和最大，所以实际上直接照搬上面的代码就 ok 了\n\n```java\n//N^3\npublic static int solve(int[][] w, int m, int n){\n    int[][][] dp = new int[m+n+1][m+1][m+1];\n    for (int k = 2; k <= m+n; k++) {\n        for (int i1 = 1; i1 <= m; i1++) {\n            for (int i2 = 1; i2 <= m; i2++) {\n                int j1 = k - i1, j2 = k - i2;\n                if (j1 < 1 || j1 > n || j2 < 1 || j2 > n) continue;\n                int temp = dp[k][i1][i2]; \n                temp = Math.max(temp, dp[k-1][i1-1][i2]);\n                temp = Math.max(temp, dp[k-1][i1][i2-1]);\n                temp = Math.max(temp, dp[k-1][i1][i2]);\n                temp = Math.max(temp, dp[k-1][i1-1][i2-1]);\n                dp[k][i1][i2] = temp + (i1==i2 ? w[i1-1][j1-1] : (w[i1-1][j1-1] + w[i2-1][j2-1]));\n            }\n        }\n    }\n    return dp[m+n][m][m];\n}\n```\n\n## [1463. 摘樱桃 II](https://leetcode-cn.com/problems/cherry-pickup-ii/)\n\nDifficulty: **困难**\n\n给你一个 `rows x cols` 的矩阵 `grid` 来表示一块樱桃地。 `grid` 中每个格子的数字表示你能获得的樱桃数目。\n\n你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 `(0,0)` 出发，机器人 2 从右上角格子 `(0, cols-1)` 出发。\n\n请你按照如下规则，返回两个机器人能收集的最多樱桃数目：\n\n*   从格子 `(i,j)` 出发，机器人可以移动到格子 `(i+1, j-1)`，`(i+1, j)` 或者 `(i+1, j+1)` 。\n*   当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。\n*   当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。\n*   两个机器人在任意时刻都不能移动到 `grid` 外面。\n*   两个机器人最后都要到达 `grid` 最底下一行。\n\n给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。\n\n你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。\n\n请你按照如下规则，返回两个机器人能收集的最多樱桃数目：\n\n**示例 1：**\n\n![](https://files.catbox.moe/da5rxh.png)\n```java\n输入：grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n输出：24\n解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。\n机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。\n樱桃总数为： 12 + 12 = 24 。\n```\n\n**示例 2：**\n\n![](https://i.loli.net/2020/11/10/aSykAceXPH1snjM.png)\n```java\n输入：grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n输出：28\n解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。\n机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。\n樱桃总数为： 17 + 11 = 28 。\n```\n**示例 3：**\n\n```java\n输入：grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]\n输出：22\n```\n**示例 4：**\n\n```java\n输入：grid = [[1,1],[1,1]]\n输出：4\n```\n\n**提示：**\n\n- rows == grid.length\n- cols == grid[i].length\n- 2 <= rows, cols <= 70\n- 0 <= grid[i][j] <= 100 \n\n### 解法一\n\n本来只写了前两题就打算 push 的，y 总也只讲了这几道题，但是突然想起来很久之前的一道周赛题（27th 双周赛 T4），大概半年前了，没想到居然能想起来😄，看了下，和上面两题是一样的，随手写了下，一开始写的有 bug，调试了好一会儿，最后把状态打出来手推了下，发现有些状态没有初始化好，导致递推的时候使用了非法的状态\n\n先上暴力 N^4 的解法，这题范围不大，N^4 勉强能扛过去\n```java\n//暴力 N^4 解法\npublic int cherryPickup2(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[][][][] dp = new int[m+1][n+2][m+1][n+2];\n    int INF = -0x3f3f3f3f;\n    for (int i1 = 0; i1 <= m; i1++) {\n        for (int j1 = 0; j1 <= n+1; j1++) {\n            for (int i2 = 0; i2 <= m; i2++) {\n                Arrays.fill(dp[i1][j1][i2], INF);\n            }\n        }\n    }\n    dp[1][1][1][n] = grid[0][0]+grid[0][n-1];\n    for (int i1 = 2; i1 <= m; i1++) {\n        for (int j1 = 1; j1 <= n; j1++) {\n            for (int i2 = 2; i2 <= m; i2++) {\n                for (int j2 = 1; j2 <= n; j2++) {\n                    int temp = INF;\n                    temp = Math.max(temp, dp[i1-1][j1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1-1][j1][i2-1][j2+1]);\n                    temp = Math.max(temp, dp[i1-1][j1][i2-1][j2-1]);\n                    \n                    temp = Math.max(temp, dp[i1-1][j1+1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1-1][j1+1][i2-1][j2+1]);\n                    temp = Math.max(temp, dp[i1-1][j1+1][i2-1][j2-1]);   \n                    \n                    temp = Math.max(temp, dp[i1-1][j1-1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1-1][j1-1][i2-1][j2+1]);   \n                    temp = Math.max(temp, dp[i1-1][j1-1][i2-1][j2-1]);\n                    dp[i1][j1][i2][j2] = temp + ((i1==i2&&j1==j2) ? grid[i1-1][j1-1] : (grid[i1-1][j1-1] + grid[i2-1][j2-1]));\n                }\n            }\n        }\n    }\n    int res = 0;\n    for (int j1 = 0; j1 <= n; j1++) {\n        for (int j2 = 0; j2 <= n; j2++) {\n            res = Math.max(res, dp[m][j1][m][j2]);   \n        }\n    }\n    return res;\n}\n```\n\n### 解法二\n\n和上面两题一样，两个机器人走的层数是固定的，都是 m 层，所以可以优化掉一维的状态，同时上面的写法看起来也很 ugly，可以用方向变量简化写法\n\n```java\n//N^3 解法，优化代码写法，简化代码\npublic int cherryPickup(int[][] grid) {\n    int[] dir = {1, -1, 0};\n    int m = grid.length, n = grid[0].length;\n    //这题求最大值，在 dp 数组上边和左右两边各加一行作为边界\n    //这里也可以用滚动数组优化下空间\n    int[][][] dp = new int[m+1][n+2][n+2];\n    int INF = -0x3f3f3f3f;\n    //全部初始化为 INF（实际上初始化两边和最上面的就 ok 了）\n    for (int r = 0; r <= m; r++) {\n        for (int j1 = 0; j1 <= n+1; j1++) {\n            Arrays.fill(dp[r][j1], INF);\n        }\n    }\n    dp[1][1][n] = grid[0][0] + grid[0][n-1];\n    for (int r = 2; r <= m; r++) {\n        for (int j1 = 1; j1 <= n; j1++) {\n            for (int j2 = 1; j2 <= n; j2++) {\n                //方向向量，简化写法\n                for (int d1 = 0; d1 < 3; d1++) {\n                    for (int d2 = 0; d2 < 3; d2++) {\n                        dp[r][j1][j2] = Math.max(dp[r][j1][j2], dp[r-1][j1+dir[d1]][j2+dir[d2]]);\n                    }\n                }\n                dp[r][j1][j2] += (j1==j2 ? grid[r-1][j1-1] : (grid[r-1][j1-1] + grid[r-1][j2-1]));\n            }\n        }\n    }\n    int res = 0;\n    for (int j1 = 0; j1 <= n; j1++) {\n        for (int j2 = 0; j2 <= n; j2++) {\n            res = Math.max(res, dp[m][j1][j2]);   \n        }\n    }\n    return res;\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"LeetCode 单调栈","url":"/2020/08/28/bdc9d1de/","content":"\n> 从 [栈&队列专题](http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/) 中抽取出来\n## [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)\n\n给定两个**没有重复元素**的数组 nums1 和 nums2 ，其中 nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。\n\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。\n\n**示例 1:**\n\n```java\n输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：\n    对于 num1 中的数字 4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。\n    对于 num1 中的数字 1，第二个数组中数字 1 右边的下一个较大数字是 3。\n    对于 num1 中的数字 2，第二个数组中没有下一个更大的数字，因此输出 -1。\n```\n\n**示例 2:**\n\n```java\n输入：nums1 = [2,4], nums2 = [1,2,3,4].\n输出：[3,-1]\n解释：\n    对于 num1 中的数字 2，第二个数组中的下一个较大数字是 3。\n    对于 num1 中的数字 4，第二个数组中没有下一个更大的数字，因此输出 -1。\n```\n\n**注意：**\n\n1. `nums1`和`nums2`中所有元素是唯一的。\n2. `nums1`和`nums2` 的数组大小都不超过 1000。\n\n**解法一**\n\n单调栈，很就之前在链表专题中做过一次 [链表的下一个更大节点](http://imlgw.top/2019/02/27/leetcode-lian-biao/#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9) 但是没想起来，可能当时也没留下影响\n\n这题其实还比原始的题加了一点难度，原始的题就是 num1==nums2 的情况，那样就不需要 HashMap 记录了\n\n```java\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    Stack<Integer> stack=new Stack<>();\n    for (int i=0;i<nums2.length;i++) {\n        while(!stack.isEmpty() && nums2[stack.peek()]<nums2[i]){\n            map.put(nums2[stack.pop()],nums2[i]);\n        }\n        stack.add(i);\n    }\n    int[] res=new int[nums1.length];\n    for (int i=0;i<nums1.length;i++) {\n        res[i]=map.getOrDefault(nums1[i],-1);\n    }\n    return res;\n}\n```\n## [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)\n\n给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n\n**示例 1:**\n\n```java\n输入：[1,2,1]\n输出：[2,-1,2]\n解释：第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n```\n\n**注意：** 输入数组的长度不会超过 10000。\n\n**解法一**\n\n```java\npublic static int[] nextGreaterElements(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return new int[]{};\n    }\n    Stack<Integer> stack=new Stack<>();\n    stack.push(0);\n    int[] res=new int[nums.length];\n    Arrays.fill(res,-1);\n    int index=1;\n    for (int i=1;i<nums.length*2;i++) {\n        index=i>=nums.length?i%nums.length:i;\n        while(!stack.isEmpty()&&nums[stack.peek()]<nums[index]) {\n            res[stack.pop()]=nums[index];\n        }\n        stack.push(index);\n    }\n    return res;\n}\n```\n和上面一样，只不过需要循环遍历一遍，我最开始的做法相当憨憨，copy 了一个两倍的数组。还需要注意的就是 `-1`的处理\n\n## [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)\n\n根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n\n**解法一**\n\n```java\npublic int[] dailyTemperatures(int[] T) {\n    int[] res=new int[T.length];\n    if(T==null || T.length<=0) return res;\n    Stack<Integer> stack=new Stack<>();\n    stack.push(0);\n    for (int i=1;i<T.length;i++) {\n        while(!stack.isEmpty()&&T[stack.peek()]<T[i]){\n            int temp=stack.pop();\n            res[temp]=i-temp;\n        }\n        stack.push(i);\n    }\n    return res;\n}\n```\n和上面两题一样，单调栈的解法，不过这题好像可以不用单调栈，可以从后向前递推\n\n## [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)\n\n编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。\n\n今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。\n\n例如，如果未来 7 天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。\n\n**示例：**\n\n```java\n输入：[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"], [[],[100],[80],[60],[70],[60],[75],[85]]\n输出：[null,1,1,1,2,1,4,6]\n解释：\n首先，初始化 S = StockSpanner()，然后：\nS.next(100) 被调用并返回 1，\nS.next(80) 被调用并返回 1，\nS.next(60) 被调用并返回 1，\nS.next(70) 被调用并返回 2，\nS.next(60) 被调用并返回 1，\nS.next(75) 被调用并返回 4，\nS.next(85) 被调用并返回 6。\n\n注意 （例如） S.next(75) 返回 4，因为截至今天的最后 4 个价格\n（包括今天的价格 75) 小于或等于今天的价格。\n```\n\n**提示：**\n\n- 调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5\n- 每个测试用例最多可以调用  10000 次 StockSpanner.next\n- 在所有测试用例中，最多调用 150000 次 StockSpanner.next\n- 此问题的总时间限制减少了 50%\n\n**解法一**\n\n我起了，一枪秒了，有什么好说的\n\n```java\nclass StockSpanner {\n\n    Deque<int[]> stack=new ArrayDeque<>();\n\n    public StockSpanner() {}\n    \n    public int next(int price) {\n        int res=1;\n        while(!stack.isEmpty() && price>=stack.peek()[0]){\n            res+=stack.pop()[1];\n        }\n        stack.push(new int[]{price,res});\n        return res;\n    }\n}\n```\n\n## [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n![leetCode](https://i.loli.net/2019/12/12/a7pVfNcYuIKFgwA.png)\n\n以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。\n\n![leetCode](https://i.loli.net/2019/12/12/FAvMk3zWf4RheDi.png)\n\n图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。\n\n**示例：**\n\n```java\n输入：[2,1,5,6,2,3]\n输出：10\n```\n\n**解法一**\n\n和上面几道题一样，单调栈的解法，这里是单调递增栈，20ms，87%\n\n```java\npublic int largestRectangleArea(int[] heights) {\n    if (heights==null || heights.length<=0) {\n        return 0;\n    }\n    Stack<Integer> stack=new Stack<>();\n    int maxArea= Integer.MIN_VALUE;\n    for (int i=0;i<heights.length;i++) {\n        while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\n            //当前的柱子小于栈顶，说明当前栈顶最多向右扩展到 i-1\n            int cur=stack.pop();\n            //为空说明向左无法扩展，标为-1 不影响结果（可以提前将-1 压栈）\n            int left=stack.isEmpty()?-1:stack.peek();\n            //这里其实是 (i-1)-(left+1)+1\n            maxArea=Math.max(maxArea,(i-left-1)*heights[cur]);\n        }\n        stack.push(i);\n    }\n    //处理栈中剩下的元素，右边是边界，剩余栈中所有的元素实际上都可以扩展到 heights.length-1\n    //所以为了让所有的元素都能出栈，我们可以再数组的后面想象添加一个 0（也可以直接在原数组中添加一个 0)\n    while(!stack.isEmpty()){ \n        int cur=stack.pop();\n        int left=stack.isEmpty()?-1:stack.peek();\n        //这一步很秀，在数组后面再想象一个 0 出来\n        //让栈中元素向右扩张 (heights.length-1)-(left+1)+1\n        maxArea=Math.max(maxArea,(heights.length-left-1)*heights[cur]);\n    }\n    return maxArea;\n}\n```\n其实就是利用单调栈遍历每一个柱子，**找到每一个柱子左边和右边第一个比它小的元素，比如左边第一个比当前柱子小的是 i，那么很显然 i+1 肯定是大于等于当前柱子的，并且 i+1 是左边连续大于当前柱子的最后一个，也就是当前柱子能想左扩展的边界位置，右边同理，既然是要求左右比当前柱子小的第一个，那么很明显就要用单调递增栈**，然后就可以直接根据这两个数据计算完全包含当前柱子的最大的矩形的面积。\n\n例如：`3 4 5 4 3 6` \n\n首先`3 4 5`都顺利的存入栈中，此时栈中元素为`【0，1，2】` ，当想存入下一个元素`i=3,h[i]=4`的时候，发现 4 比当前栈顶小，所以我们就可以开始计算**完全包含栈中每个柱子**的最大矩形的面积\n\n1. 由于当前`i` 位置的元素是比栈顶小，那么就说明 `i-1` 位置的元素一定比当前栈顶元素大！也就是向右边最多扩展到`i-1`位置\n\n2. 由于单调栈的结构，当前栈顶的下一个栈中元素`left`，其实就是当前栈顶的左边最近的比它小的元素，所以`left+1`位置的元素一定是比当前栈顶元素大（也有可能相等）！，所以向左边最多扩展到 `left+1` 位置\n\n3. 上面其实还分析漏了一种情况，那就是栈顶和`i` 位置元素相等的情况，第一点中提到的其实是 `i` 位置元素小于栈顶的情况，如果相等，那么向右能扩展到的位置还会是`i-1`么？显然不是，至少应该是`i`甚至更大，那我们这里计算的右边界不就是错误的？那我们将 `=` 去掉可以么？去掉之后单调栈就不再是严格单调了，这样的到的右边界确实准确了，但是我们的左边界由于栈中存在相等的元素，就变的不再准确了！\n\n4. 那我们如何处理这种情况呢？其实根本就不用处理，既然栈顶能**向右**扩展到 `i-1` 那么反过来，`i-1` 一样可以**向左**扩展到**栈顶** 位置，进而还可以扩展到`left+1`位置，而向左扩展的`left+1`是准确的，不会有误差，所以我们只需要等待`i-1`位置的元素弹出，然后就可以重新计算得到最大值，这个最大值肯定是包含之前的哪个最大当然这里其实那个 `heights[i]<=heights[stack.peek()]` 中的等号也可以去掉，这样栈就不是严格单调的了，`left+1`也不再准确，但是此时 `i-1` 就准确了，所以我们可以等待`left+1` 弹栈之后再重新计算，总而言之，就是相等的情况是不用做额外的处理\n\n   ![mark](http://static.imlgw.top/blog/20200129/gJPOkfEPDxwg.png?imageslim)\n\n   可以看到按照代码中的逻辑在计算完全包含当前绿色的栈顶元素的最大矩形的时候其实只计算到一部分，当计算到后面的相等的柱子的时候会完全包含之前的柱子的值，这样就不会有问题\n\n​       \n\n经过上面的分析，代码就好写多了，不过这里还有一个地方值得注意，就是处理栈中剩余的元素，其实比较好的方法是在数组的末尾加一个 0，这样确保栈中所有的元素都可以出栈，不用额外的处理，java 中没法直接向数组中 push 元素，所以我们就想象末尾有一个 0，那么所有元素向左能扩展到的最远位置就是 `heights.length-1`\n\n**解法二**\n\n分治，480ms，27%\n\n```java\n//分治 480ms\npublic int largestRectangleArea(int[] heights) {\n    if (heights==null || heights.length<=0) {\n        return 0;\n    }\n    largestRectangleArea(heights,0,heights.length-1);\n    return maxArea;\n}\n\nprivate int maxArea=Integer.MIN_VALUE;\n\npublic void largestRectangleArea(int[] heights,int left,int right) {\n    if (left>right) {\n        return;\n    }\n    int minIndex=left;\n    for (int i=left;i<=right;i++) {\n        minIndex=heights[i]<heights[minIndex]?i:minIndex;\n    }\n    maxArea=Math.max(heights[minIndex]*(right-left+1),maxArea);\n    largestRectangleArea(heights,left,minIndex-1);\n    largestRectangleArea(heights,minIndex+1,right);\n}\n```\n将数组区间以`minIndex`为分界线，分别求左边和右边的最大面积，时间复杂度`O(NlogN)`\n\n**解法三**\n\n优化的分治 1ms，100%，没想到比单调栈还快。\n\n```java\npublic int largestRectangleArea(int[] heights) {\n    if (heights==null || heights.length<=0) {\n        return 0;\n    }\n    return largestRectangleArea(heights,0,heights.length-1);\n}\n\npublic int largestRectangleArea(int[] heights,int left,int right) {\n    if (left>right) {\n        return 0;\n    }\n    int minIndex=left;\n    boolean up=true;\n    boolean down=true;\n    for (int i=left+1;i<=right;i++) {\n        if (heights[i]<heights[i-1]) {\n            up=false;\n        }\n        if (heights[i]>heights[i-1]) {\n            down=false;\n        }\n        minIndex=heights[i]<heights[minIndex]?i:minIndex;\n    }\n    if (up) {\n        int maxArea=-1;\n        for (int i=left;i<=right;i++) {\n            maxArea=Math.max(maxArea,(right-i+1)*heights[i]);\n        }\n        return maxArea;\n    }\n    if (down) {\n        int maxArea=-1;\n        for (int i=right;i>=left;i--) {\n            maxArea=Math.max(maxArea,(i-left+1)*heights[i]);\n        }\n        return maxArea;\n    }\n    return Math.max(heights[minIndex]*(right-left+1),Math.max(largestRectangleArea(heights,minIndex+1,right),largestRectangleArea(heights,left,minIndex-1)));\n}\n```\n其实相比于上面的分治，就是多了一步判断当前区间是否有序，因为有序的话就可以直接遍历得到区间的最大矩形，不用再递归做分治，我这里做了两个有序的判断，不知道是不是有的多余，我看的评论都只有一个\n\n## [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)\n\n给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n**示例：**\n\n```java\n输入：\n[\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\n]\n输出：6\n```\n\n**解法一**\n\n特意在做了上面一题后没有马上做这一题，下面的是第二天下午做的，还行，没忘记😂，就是写的有点难看\n\n```java\n//update: 2020.4.12\npublic int maximalRectangle(char[][] matrix) {\n    if(matrix==null || matrix.length<=0) return 0;\n    int M=matrix.length,N=matrix[0].length;\n    int[][] height=new int[M][N+1]; //每一层多加一个 0, 方便后面出栈\n    int res=0;\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++){\n            if(matrix[i][j]=='1'){\n                height[i][j]=i-1>=0?height[i-1][j]+1:1;\n            }\n        }\n        res=Math.max(maxRectangle(height[i]),res);\n    }\n    return res;\n}\n\npublic int maxRectangle(int[] height){\n    Deque<Integer> stack=new ArrayDeque<>();\n    int max=0;\n    for(int i=0;i<height.length;i++){\n        while(!stack.isEmpty() && height[i]<height[stack.peek()]){\n            int cur=stack.pop();\n            //栈为空的时候说明左边的全部是比当前栈顶大的元素，可以直接扩展到 0, 所以这里应该是-1\n            int left=stack.isEmpty()?-1:stack.peek();\n            //left+1 ~ i-1 = i-1-left\n            max=Math.max((i-1-left)*height[cur],max);\n        }\n        stack.push(i);\n    }\n    return max;\n}\n```\n\n其实计算 height 有一点动态规划的意思，我上面相当于写了个二维的动态规划\n\n> 2020.4.12 重写了一遍，然后更新了代码，之前的代码不够简洁\n\n**解法二**\n\n```java\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix==null || matrix.length<=0) {\n        return 0;\n    }\n    //初始化 height 数组，在末尾添加一个元素（默认 0) 让所有元素可以出栈\n    int[] height=new int[matrix[0].length+1];\n    int max=0;\n    //记录每一层的 height\n    for (int i=0;i<matrix.length;i++) {\n        for (int j=0;j<matrix[0].length;j++) {\n            height[j]=matrix[i][j]=='1'?height[j]+1:0;\n        }\n        max=Math.max(max,maxArea(height));\n    }\n    return max;\n}\n```\n\n`maxArea`可以直接采用上面 84 题的分治\n\n## [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)\n\n给定一个整数数组，你需要寻找一个**连续的子数组**，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。\n\n你找到的子数组应是**最短**的，请输出它的长度。\n\n**示例 1:**\n\n```java\n输入：[2, 6, 4, 8, 10, 9, 15]\n输出：5\n解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n```\n\n**说明 :**\n\n1. 输入的数组长度范围在 [1, 10,000]。\n2. 输入的数组可能包含**重复**元素 ，所以**升序**的意思是**<=。**\n\n**解法一**\n\n~~单调栈的解法明天再写~~\n\n鸽了挺长时间，单调栈的解法还是挺好的\n\n```java\npublic int findUnsortedSubarray(int[] nums) {\n    Stack<Integer> stack=new Stack<>();\n    int left=Integer.MAX_VALUE,right=Integer.MIN_VALUE;\n    for (int i=0;i<nums.length;i++) {\n        while(!stack.isEmpty() && nums[stack.peek()]>nums[i]){\n            left=Math.min(stack.pop(),left); //左边界正确位置（最小值）\n        }\n        stack.push(i);\n    }\n    stack.clear();\n    for (int i=nums.length-1;i>=0;i--) {\n        while(!stack.isEmpty() && nums[stack.peek()]<nums[i]){\n            right=Math.max(stack.pop(),right); //右边界正确位置（最大值）\n        }\n        stack.push(i);\n    }\n    return left>right?0:right-left+1;\n}\n```\n\n第一个单调栈中存的是从左到右递增的序列，当遇到`nums[i]`小于栈顶时，说明这个位置是错位的，正确的位置应该是**栈顶的元素**的位置，我们这里求的就是一个**最小的错位的索引**\n\n第二个单调栈中存的是从右向左递减的序列，当遇到`nums[i]`大于栈顶时，说明这个位置是错位的，正确的位置应该是**栈顶的元素**，这里求的就是一个**最大的错位的索引** ，两者之间的距离其实就是我们最终要求的最短无序子数组长度\n\n**解法二**\n\n其实和上面的单调栈的思路是一样的，都是找第一个（最小）和最后一个（最大）错位的元素，但是这里我们求出错位的元素后还需要再遍历找到原本正确的位置，\n\n```java\n//O(1) 空间的解法\npublic int findUnsortedSubarray(int[] nums) {\n    if (nums[0]>nums[nums.length-1]) {\n        return nums.length;\n    }\n    int max=Integer.MIN_VALUE,min=Integer.MAX_VALUE;\n    for (int i=1;i<nums.length;i++) {\n        if (nums[i]<nums[i-1]) {\n            min=Math.min(min,nums[i]); //无序序列中的最小值\n        }\n    }\n\n    for (int i=nums.length-1;i>0;i--) {\n        if (nums[i]<nums[i-1]) {\n            max=Math.max(max,nums[i-1]); //无序序列中的最大值\n        }\n    }\n    int left=0,right=nums.length-1;\n    while(left<nums.length){\n        if (nums[left]>min) {\n            break;\n        }\n        left++; //左边界正确位置\n    }\n    while(right>=0){\n        if (nums[right]<max) {\n            break;\n        }\n        right--; //右边界正确位置\n    }\n    return right<left?0:right-left+1;\n}\n```\n\n## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![rainwatertrap.png](https://i.loli.net/2019/05/14/5cda71129045d93180.png)\n\n上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n**示例：**\n\n```java\n输入：[0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n```\n\n**解法三**\n\n单调栈解法，双指针的解法放在 [数组专题](http://imlgw.top/2019/05/04/leetcode-shu-zu/#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4) 中，其实我感觉熟悉单调栈的话，单调栈的解法会比其他方法更好理解\n\n```java\npublic static int trap6(int[] height) {\n    if (height == null || height.length == 0) return 0;\n    Deque<Integer> stack = new ArrayDeque<>(); //栈里面维护一个递减序列\n    int res = 0;\n    for (int i = 0; i < height.length; i++){\n        while ( ! stack.isEmpty() && height[stack.peek()] < height[i]) { //当遍历的元素大于栈顶元素\n            int tmp = stack.pop(); //栈顶弹出来\n            if (stack.isEmpty()) break;\n            res += (Math.min(height[i],height[stack.peek()]) - height[tmp]) * (i - stack.peek() - 1);\n        }\n        //维护递减序列\n        stack.push(i);\n    }\n    return res;\n}\n```\n\n单调递减栈，栈中存柱子的索引，当遇到大于栈顶的元素的时候就开始弹栈，计算**栈顶元素和左右首个大于栈顶元素的所能构成的那一层的接水量**，对应下面的图理解就是\n\n**`(Math.min(height[i],height[stack.peek()])-curTop) * (i-stack.peek()-1)`**\n\n![mark](http://static.imlgw.top/blog/20200129/f0b4lo2Xk5Q3.png?imageslim)\n\n依次计算①②③位置的面积，这样的思路感觉会更加的自然\n\n## [面试题 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n\n参考以下这颗二叉搜索树：\n\n```java\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n```\n**示例 1：**\n\n```java\n输入：[1,6,3,2,5]\n输出：false\n```\n\n**示例 2：**\n\n```java\n输入：[1,3,2,6,5]\n输出：true\n```\n\n**提示：**\n\n1. `数组长度 <= 1000`\n\n**解法一**\n\n单调栈的解法\n\n```java\npublic boolean verifyPostorder(int[] postorder) {\n    if(postorder==null || postorder.length<=0) return true;\n    Deque<Integer> stack=new ArrayDeque<>();\n    //1 2 | 4 5 | 3\n    int curRoot=Integer.MAX_VALUE;\n    for(int i=postorder.length-1;i>=0;i--){\n        if(postorder[i]>curRoot){\n            return false;\n        }\n        while(!stack.isEmpty() && postorder[i]<postorder[stack.peek()]){\n            curRoot=postorder[stack.pop()];\n        }\n        stack.push(i);\n    }\n    return true;\n}\n```\n\n逆序遍历这个序列，就是 `root -- root.right -- root.left` ，用一个单调递增栈，当遇到减小的值就说明进入了左子树，我们需要找到这颗树的根节点，也就是不停出栈，直到找到根节点，然后继续向后判断左子树是不是都小于这个根节点的\n\n## [面试题 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)\n\n请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数 max_value、push_back 和 pop_front 的时间复杂度都是 O(1)。\n\n若队列为空，`pop_front` 和 `max_value` 需要返回 -1\n\n**示例 1：**\n\n```java\n输入：\n[\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"]\n[[],[1],[2],[],[],[]]\n输出：[null,null,null,2,1,2]\n```\n\n**示例 2：**\n\n```java\n输入：\n[\"MaxQueue\",\"pop_front\",\"max_value\"]\n[[],[],[]]\n输出：[null,-1,-1]\n```\n\n**限制：**\n\n- `1 <= push_back,pop_front,max_value 的总操作数 <= 10000`\n- `1 <= value <= 10^5`\n\n**解法一**\n\n```java\npublic MaxQueue() {\n\n}\n\nDeque<Integer> queue=new LinkedList<>();\n\nDeque<Integer> maxQueue=new ArrayDeque<>();\n\npublic int max_value() {\n    return maxQueue.isEmpty()?-1:maxQueue.getFirst();\n}\n\npublic void push_back(int value) {\n    queue.addLast(value);\n    while(!maxQueue.isEmpty() && value>maxQueue.getLast()){\n        maxQueue.removeLast();\n    }\n    maxQueue.addLast(value);\n}\n\npublic int pop_front() {\n    if(queue.isEmpty()) return -1;\n    int temp=queue.removeFirst();\n    if(temp==maxQueue.getFirst()){\n        maxQueue.removeFirst();\n    }\n    return temp;\n}\n```\n\n一直以为是和最小栈一样，结果 WA 了两发才意识到搞错了。这里是一个队列，进出方向是不一样的\n\n其实这题和之前的一道 [滑动窗口最大值](http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC) 一样，维护一个单调递减的单调栈然后维护这个单调栈就行了\n\n## [5402. 绝对差不超过限制的最长连续子数组](https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) \n\n给你一个整数数组 `nums` ，和一个表示限制的整数 `limit`，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 `limit` *。*\n\n如果不存在满足条件的子数组，则返回 `0` 。\n\n**示例 1：**\n\n```java\n输入：nums = [8,2,4,7], limit = 4\n输出：2 \n解释：所有子数组如下：\n[8] 最大绝对差 |8-8| = 0 <= 4.\n[8,2] 最大绝对差 |8-2| = 6 > 4. \n[8,2,4] 最大绝对差 |8-2| = 6 > 4.\n[8,2,4,7] 最大绝对差 |8-2| = 6 > 4.\n[2] 最大绝对差 |2-2| = 0 <= 4.\n[2,4] 最大绝对差 |2-4| = 2 <= 4.\n[2,4,7] 最大绝对差 |2-7| = 5 > 4.\n[4] 最大绝对差 |4-4| = 0 <= 4.\n[4,7] 最大绝对差 |4-7| = 3 <= 4.\n[7] 最大绝对差 |7-7| = 0 <= 4. \n因此，满足题意的最长子数组的长度为 2 。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [10,1,2,4,7,2], limit = 5\n输出：4 \n解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。\n```\n\n**示例 3：**\n\n```java\n输入：nums = [4,2,2,2,4,4,2,2], limit = 0\n输出：3\n```\n\n**提示：**\n\n- `1 <= nums.length <= 10^5`\n- `1 <= nums[i] <= 10^9`\n- `0 <= limit <= 10^9`\n\n187th 周赛 t3，时隔这么久又回头打一次周赛，可惜，又只做了两题，前两题 10 分钟不到就写完了，心想这回怎么说也得做个 3 题，结果。\n\n**解法一**\n\n```java\npublic int longestSubarray2(int[] nums, int limit) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int left=0,right=0;\n    int min=0,max=0;\n    int res=1;\n    PriorityQueue<Integer> minpq=new PriorityQueue<>();\n    minpq.add(nums[0]);\n    PriorityQueue<Integer> maxpq=new PriorityQueue<>((a,b)->b-a);\n    maxpq.add(nums[0]);\n    //7 2\n    while(left<=right && right<nums.length){\n        while (right< nums.length && maxpq.peek()-minpq.peek()<=limit) {\n            res=Math.max(right-left+1,res);\n            right++;\n            if (right<nums.length) {\n                maxpq.add(nums[right]);\n                minpq.add(nums[right]);   \n            }\n        }\n        maxpq.remove(nums[left]);\n        minpq.remove(nums[left]);\n        left++;\n    }\n    return res;\n}\n```\n这个是当时比赛调了半天没调出来，结束之后调出来的代码，用两优先队列维护区间最值，然后滑窗就行了，我这里就是调滑窗的时候调了半天，之前写滑窗就是乱写的，没什么章法，边 WA 边改，看来最近得好好总结下滑窗的题了，得搞个板子出来\n\n**解法二**\n\n最优解，O(N) 单调队列\n```java\n//UPDATE: 2020/6/29 改成最近总结的 for-while 滑窗模板\n//上面的解法一的滑窗也写的不好，有时间改改\npublic int longestSubarray(int[] nums, int limit) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int left=0;\n    int min=0,max=0;\n    int res=1;\n    //单调队列记录区间最值索引\n    LinkedList<Integer> maxQue=new LinkedList<>();\n    LinkedList<Integer> minQue=new LinkedList<>();\n    for(int right=0;right<nums.length;right++){\n        while(!maxQue.isEmpty() && nums[maxQue.getLast()]<nums[right]){\n            maxQue.removeLast();\n        }\n        maxQue.addLast(right);\n        while(!minQue.isEmpty() && nums[minQue.getLast()]>nums[right]){\n            minQue.removeLast();\n        }\n        minQue.addLast(right);\n        while(nums[maxQue.getFirst()]-nums[minQue.getFirst()]>limit) {\n            //不符合要求，左边界左移，当左边界是最值的时候 que 弹出\n            if (left==maxQue.getFirst()) maxQue.removeFirst();\n            if (left==minQue.getFirst()) minQue.removeFirst();\n            left++;\n        }\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n其实当时我确实也尝试去用两个单调队列维护最值，但是！！！还是被滑窗的边界给搞得不知道这么写了，然后就没又然后了，上面的代码也是比赛完之后自己写出来的，说到底还是菜啊！😭\n\n## [962. 最大宽度坡](https://leetcode-cn.com/problems/maximum-width-ramp/) \n\n给定一个整数数组 `A`，*坡*是元组 `(i, j)`，其中  `i < j` 且 `A[i] <= A[j]`。这样的坡的宽度为 `j - i`。\n\n找出 `A` 中的坡的最大宽度，如果不存在，返回 0 。\n\n**示例 1：**\n\n```java\n输入：[6,0,8,2,1,5]\n输出：4\n解释：\n最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.\n```\n\n**示例 2：**\n\n```java\n输入：[9,8,1,0,1,9,4,0,4,1]\n输出：7\n解释：\n最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.\n```\n\n**提示：**\n\n1. `2 <= A.length <= 50000`\n2. `0 <= A[i] <= 50000`\n\n**解法一**\n\n想不到，着实想不到，这个单调栈的用法确实没见过\n\n```java\npublic int maxWidthRamp(int[] A) {\n    Deque<Integer> stack=new ArrayDeque<>();\n    int res=0;\n    for(int i=0;i<A.length;i++){\n        if(stack.isEmpty() || A[stack.peek()]>A[i]){\n            stack.push(i);\n        }\n    }\n    for(int i=A.length-1;i>=0;i--){\n        while(!stack.isEmpty() && A[stack.peek()]<=A[i]){\n            int cur=stack.pop();\n            res=Math.max(res,i-cur);\n        }\n    }\n    return res;\n}\n```\n\n首先把 A 数组中的以`A[0]`开头的递减序列抽取出来，我们最后要求的最大的宽度坡一定是以这个序列中的某一个`i`为**坡底**的，我们反证一下\n\n假设存在某个元素位置`k`不存在于上面的递减序列中，且有最大宽度`j-k`，这也就说明`k`位置的元素**一定是小于等于 k 前面所有的元素的**，否则就会有更长的宽度，但是既然`k`小于等于前面所有的元素，那么 k 就一定会被加入到序列中，与假设矛盾，所以不存在 k，解一定存在递减序列中\n\n这样的话我们可以逆向遍历数组，每次遇到元素大于栈顶的就可以计算宽度，然后将栈顶弹出，因为是逆序遍历的，所以这个宽度一定是栈顶这个**坡底 i **能形成的最大宽度了， 逆序遍历再往前的话即使大于这个栈顶，形成的宽度也只会减小，所以这个栈顶是可以直接`pop`出去的，我们遍历所有的坡底求最大值就行了，时间复杂度`O(N)`\n\n**解法二**\n\n二分的思路，和上面一样，先构建一个以`A[0]`开头的递减序列，这里面就是我们所有的坡底，然后我们可以遍历所有的元素，然后在这个单调序列中寻找第一个小于等于当前元素的`index`，这两个构成的宽度就是**当前元素**所能形成的最大宽度，我们求出所有的最大宽度取一个最值就可以了，时间复杂度`O(NlogN)`\n\n```go\nfunc maxWidthRamp(A []int) int {\n    var order [][]int\n    order = append(order, []int{0, A[0]})\n    //构建递减序列\n    for i := 1; i < len(A); i++ {\n        if A[i] < order[len(order)-1][1] {\n            order = append(order, []int{i, A[i]})\n        }\n    }\n    res := 0\n    for j, target := range A {\n        i := binarySearch(order, target)\n        res = Max(res, j-i)\n    }\n    return res\n}\n\n//找第一个小于等于 target 的值\nfunc binarySearch(num [][]int, target int) int {\n    left := 0\n    right := len(num) - 1\n    for left < right {\n        mid := left + (right-left)/2\n        if num[mid][1] > target {\n            left = mid + 1 //注意是递减序列\n        } else {\n            right = mid\n        }\n    }\n    return num[left][0]\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n> 在 lc 写的 [题解](https://leetcode-cn.com/problems/maximum-width-ramp/solution/java-dan-diao-zhan-er-fen-jie-fa-chang-shi-jie-shi/) 欢迎前来纠错\n\n## [1124. 表现良好的最长时间段](https://leetcode-cn.com/problems/longest-well-performing-interval/)\n\n给你一份工作时间表 `hours`，上面记录着某一位员工每天的工作小时数。\n\n我们认为当员工一天中的工作小时数大于 `8` 小时的时候，那么这一天就是「**劳累的一天**」。\n\n所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 **大于**「不劳累的天数」。\n\n请你返回「表现良好时间段」的最大长度。\n\n**示例 1：**\n\n```java\n输入：hours = [9,9,6,0,6,6,9]\n输出：3\n解释：最长的表现良好时间段是 [9,9,6]。\n```\n\n**提示：**\n\n- `1 <= hours.length <= 10000`\n- `0 <= hours[i] <= 16`\n\n**解法一**\n\n惭愧，这题还是看的题解，这题还是挺巧妙的，我们把大于 8 小时的时间段看作`+1`，小于 8 小时的看作`-1`，这样问题就转换成了求**区间和大于 0 的最长长度**，而区间和我们又可以联想到用前缀和，这样我们将题目的例子转换一下就变成了\n\n```java\nhours:    9 9  6  0  6  6  9\nhours:  0 1 1 -1 -1 -1 -1  1\n  pre:  0 1 2  1  0 -1 -2 -1\n```\n\n只要`pre`中两点的前缀`pre[j]-pre[i]>0`就说明区间`[i+1，j]`是满足条件的，我们要求的就是满足条件的最长宽度，这样一来问题其实就转换成了和上面 [962. 最大宽度坡](#962-最大宽度坡)一样了，我们按照上面的步骤求解就 ok 了\n\n```java\npublic int longestWPI(int[] hours) {\n    int[] pre=new int[hours.length+1];\n    for(int i=1;i<=hours.length;i++){\n        pre[i]=pre[i-1]+(hours[i-1]>8?1:-1);\n    }\n    Deque<Integer> stack=new ArrayDeque<>();\n    for(int i=0;i<pre.length;i++){\n        if(stack.isEmpty() || pre[i]<pre[stack.peek()]){\n            stack.push(i);\n        }\n    }\n    int res=0;\n    for(int i=pre.length-1;i>=0;i--){\n        while(!stack.isEmpty() && pre[i]-pre[stack.peek()]>0){\n            res=Math.max(res,i-stack.pop()); //不用+1\n        }\n    }\n    return res;\n}\n```\n\n## [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)\n\n给定一个整数数组 `A`，找到 `min(B)` 的总和，其中 `B` 的范围为 `A` 的每个（连续）子数组。\n\n由于答案可能很大，因此**返回答案模 10^9 + 7**。\n\n**示例：**\n\n```java\n输入：[3,1,2,4]\n输出：17\n解释：\n子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 \n最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。\n```\n\n**提示：**\n\n1. `1 <= A <= 30000`\n2. `1 <= A[i] <= 30000`\n\n**解法一**\n\n虽然花了挺长时间好歹还是自己做出来了，开心😁\n\n```java\npublic int sumSubarrayMins(int[] A) {\n    Deque<Integer> stack=new ArrayDeque<>();\n    int N=A.length;\n    int mod=(int)1e9+7;\n    int res=0;\n    int[] temp=new int[N+1];\n    System.arraycopy(A,0,temp,0,N);\n    //末尾加 0 使所有元素都可以出栈\n    temp[N]=0;A=temp; \n    for(int i=0;i<N+1;i++){\n        while(!stack.isEmpty() && A[stack.peek()]>A[i]){\n            int cur=stack.pop();\n            int left=stack.isEmpty()?-1:stack.peek();\n            //右边大于 cur 的个数 (i 之前）： i-cur-1      \n            //左边大于 cur 的个数 (left 之后）： cur-(left+1) \n            //res=(res+A[cur]*((i-cur-1)*(cur-left-1)+i-1-left))%mod;\n            //(a+1)*(b+1)=ab+a+b+1\n            res=(res+A[cur]*(i-cur)*(cur-left))%mod;\n        }\n        stack.push(i);\n    }\n    return res;\n}\n```\n\n核心思想就是维护单调递增栈，在每个元素出栈的时候考虑如何计算**以该元素为区间最小值**的区间个数\n\n 比如`[9,8,7,6,1,5,3,4,2]`这个区间，我们要求以`1`为区间最小值的区间个数。\n\n我们分开来求，先求左右两边的，很明显仅包含`1`左边或右边元素的子区间个数是 4+4=8 个，也就是 [6,1] , [7,6,1] ... 和 [1,5], [1,5,3].... 这些区间\n\n然后再看同时包含`1`左右两边的元素的子区间，一边选一个区间和另一边都会有 4 种组合，所以就是 4*4=16 种\n\n最后再加上`1`本身就行了，所以以`1`为区间最小值的区间个数就是 8+16+1=25\n\n> 在看了大佬的做法后发现上面的是可以化简的：`a*b+a+b+1=(a+1)*(b+1)`\n\n## [5454. 统计全 1 子矩形](https://leetcode-cn.com/problems/count-submatrices-with-all-ones/)\n\nDifficulty: **中等**\n\n给你一个只包含 0 和 1 的 `rows * columns` 矩阵 `mat` ，请你返回有多少个 **子矩形** 的元素全部都是 1 。\n\n**示例 1：**\n\n```\n输入：mat = [[1,0,1],\n            [1,1,0],\n            [1,1,0]]\n输出：13\n解释：\n有 6 个 1x1 的矩形。\n有 2 个 1x2 的矩形。\n有 3 个 2x1 的矩形。\n有 1 个 2x2 的矩形。\n有 1 个 3x1 的矩形。\n矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。\n```\n\n**示例 2：**\n\n```\n输入：mat = [[0,1,1,0],\n            [0,1,1,1],\n            [1,1,1,0]]\n输出：24\n解释：\n有 8 个 1x1 的子矩形。\n有 5 个 1x2 的子矩形。\n有 2 个 1x3 的子矩形。\n有 4 个 2x1 的子矩形。\n有 2 个 2x2 的子矩形。\n有 2 个 3x1 的子矩形。\n有 1 个 3x2 的子矩形。\n矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。\n```\n\n**示例 3：**\n\n```go\n输入：mat = [[1,1,1,1,1,1]]\n输出：21\n```\n\n**示例 4：**\n\n```go\n输入：mat = [[1,0,1],[0,1,0],[1,0,1]]\n输出：5\n```\n\n**提示：**\n\n*   `1 <= rows <= 150`\n*   `1 <= columns <= 150`\n*   `0 <= mat[i][j] <= 1`\n\n**解法一**\n\n196 周赛 T3，感觉还是挺难的，不过数据量比较小，只有 150，所以暴力其实就可以\n\n```java\n//解法一：N3\npublic int numSubmat(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    //预处理 mat[i][j] 上边有多少个连续的 1\n    int[][] upCnt= new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if(mat[i][j] == 1){\n                upCnt[i][j] = i==0 ? mat[i][j]&1 : upCnt[i-1][j]+1;\n            }\n        }\n    }\n    int res = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if(mat[i][j] == 1){\n                int k = j;\n                int rowCnt = upCnt[i][j];\n                while(k>=0){\n                    rowCnt = Math.min(rowCnt, upCnt[i][k]);\n                    res += rowCnt;\n                    k--;\n                }\n            }\n        }\n    }\n    return res;\n}\n```\n\n**解法二**\n\n单调栈，参考了网上的题解，虽然自己搞懂了，但是想写题解的时候感觉有点不好描述啊，要写好多东西，有点抽象，但是思路还是非常好的，也是个很经典的题了\n```java\npublic int numSubmat(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    //预处理 mat[i][j] 上边有多少个连续的 1\n    int[][] upCnt= new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if(mat[i][j] == 1){\n                upCnt[i][j] = i==0 ? mat[i][j]&1 : upCnt[i-1][j]+1;\n            }\n        }\n    }\n    //单调递增栈维护列的长度\n    Deque<Integer> stack = new ArrayDeque<>();\n    int res = 0;\n    for (int i = 0; i < m; i++) {\n        stack.clear();\n        int ijCnt = 0; //以 i,j 为右下角的矩形的 cnt\n        for (int j = 0; j < n; j++) {\n            ijCnt += upCnt[i][j];\n            while(!stack.isEmpty() && upCnt[i][stack.peek()] > upCnt[i][j]){\n                int cur = stack.pop();\n                //栈中的索引是从 0 开始的，所以这里如果栈为空，left 应该为-1\n                int left = stack.isEmpty() ? -1 : stack.peek();\n                //减去多的部分\n                ijCnt -= (cur-left) * (upCnt[i][cur] - upCnt[i][j]);\n            }\n            stack.push(j);\n            res += ijCnt;\n        }\n    }\n    return res;\n}\n```\n为了方便回顾，简单的画了个图\n![mark](http://static.imlgw.top/blog/20200705/BDIQmVW7vEuT.png?imageslim)\n> 这题好像是个很经典的题，我在网上搜索的的时候发现和 [ICPC 的一道题](https://blog.csdn.net/qq_40774175/article/details/82354072) 一样\n\n**解法三**\n\n在刷了几遍评论区，看见了大佬们写的比较好解法，发现了一个比较容易理解的单调栈的思路\n\n（1）第一步预处理和上面是一样的，统计每个元素向上延申的最大值\n（2）然后我们同样使用单调递增栈维护这个高度，但是同时我们额外的维护另一个值：**以当前`mat[i][j]`为右下角所形成的矩形个数也存入单调栈** ，然后我们在每个元素进栈的时候统计个数，统计一共分为两部分：\n\n![mark](http://static.imlgw.top/blog/20200828/x8M127uqudmS.png?imageslim)\n（2020.8.28 更新了一下，之前的图有点抽象）\n\n```java\npublic int numSubmat(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    //预处理 mat[i][j] 上边有多少个连续的 1\n    int[][] upCnt= new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if(mat[i][j] == 1){\n                upCnt[i][j] = i==0 ? mat[i][j]&1 : upCnt[i-1][j]+1;\n            }\n        }\n    }\n    //单调递增栈维护列的长度\n    Deque<int[]> stack = new ArrayDeque<>();\n    int res = 0;\n    for(int i = 0;i < m; i++){\n        stack.clear();\n        for (int j = 0; j < n; j++) {\n            while(!stack.isEmpty() && upCnt[i][stack.peek()[0]] > upCnt[i][j]){\n                stack.pop();\n            }\n            int[] pair = stack.isEmpty() ? new int[]{-1,0} : stack.peek();\n            //以当前栈顶元素 mat[i][pair[0]] 为右下角能形成矩形个数\n            int cur = (j-pair[0]) * upCnt[i][j] + pair[1];\n            res += cur;\n            //将 mat[i][j] 的索引 j 和以其为右下角形成的矩阵个数 cur 也存入单调栈\n            stack.push(new int[]{j, cur});\n        }\n    }\n    return res;\n}\n```\n这个思路比上面要容易理解多了\n\n## [面试题 03.05. 栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)\n\nDifficulty: **中等**\n\n栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：`push`、`pop`、`peek` 和 `isEmpty`。当栈为空时，`peek` 返回 -1。\n\n**示例 1:**\n\n```go\n 输入：\n[\"SortedStack\", \"push\", \"push\", \"peek\", \"pop\", \"peek\"]\n[[], [1], [2], [], [], []]\n 输出：\n[null,null,null,1,null,2]\n```\n\n**示例 2:**\n\n```go\n 输入： \n[\"SortedStack\", \"pop\", \"pop\", \"push\", \"pop\", \"isEmpty\"]\n[[], [], [], [1], [], []]\n 输出：\n[null,null,null,null,null,true]\n```\n\n**说明：**\n\n1.  栈中的元素数目在 [0, 5000] 范围内。\n\n**解法一**\n\n之前在书上看到过这一题，但是时间久了忘了咋做了，只记得是单调栈，思考了下还是写出来了\n\n单调栈，主栈单调递减（自顶向下），当遇到大于栈顶的元素就弹栈，并将弹出的元素用辅助栈接收，完事了再将元素 push 进去，最后将辅助栈中的元素再倒回去就 ok 了，时间复杂度 N^2\n```java\nclass SortedStack {\n    \n    Deque<Integer> stack = null;\n    \n    Deque<Integer> help = null;\n    //单调栈排序\n    //4 3 2 1 3 4 2\n    public SortedStack() {\n        stack = new ArrayDeque<>();\n        help = new ArrayDeque<>();\n    }\n    \n    public void push(int val) {\n        //一开始写成 pop 了找半天的错\n        while(!stack.isEmpty() && stack.peek() < val) {\n            help.push(stack.pop());\n        }\n        stack.push(val);\n        //再装回去\n        while(!help.isEmpty()) {\n            stack.push(help.pop());\n        }\n    }\n    \n    public void pop() {\n        if (!stack.isEmpty()) {\n            stack.pop();\n        }\n    }\n    \n    public int peek() {\n        if (stack.isEmpty()) {\n            return -1;\n        }\n        return stack.peek();\n    }\n    \n    public boolean isEmpty() {\n        return stack.isEmpty();\n    }\n}\n```\n## [NC580. 抢打出头鸟](https://www.nowcoder.com/practice/1504075c856248748ca444c8c093d638)\n现在有 n 个人站成一列，第 i 个人的身高为`a[i]`他们人手一把玩具枪，并且他们喜欢把枪举在头顶上。\n每一次练习射击，他们都会朝正前方发射一发水弹。\n这个时候，第 i 个人射击的水弹，就会击中在他前面第一个比他高的人。\n牛牛认为这样的练习十分的荒唐，完全就是对长得高的人的伤害。\n于是它定义了一个荒唐度，初始为 0。\n对于第 i 个人，如中他击中了第 j 个人，则荒唐度加 j，如果没有击中任何人，则荒唐度加 0.\n牛牛想问你，你能计算出荒唐度是多少吗？\n\n**输入**\n\n一个整数 n（1 ≤ n ≤ 10^7），一个数组 a (1 ≤ a[i] ≤ 10^7)\na 下标从 0 开始，`a[i]` 代表第 i 个人身高\n\n**示例 1**\n```go\n输入：5,[1,2,3,4,5]\n输出：0\n说明：没有一个人击中任何一个人\n```\n**示例 2**\n```go\n输入：5,[5,4,3,2,1]\n输出：10\n说明：第二个人击中第一个人，第三个人击中第二个人，第四个人击中第三个人，第五个人击中第四个人； 1+2+3+4=10\n```\n\n**解法一**\n\n很直白的单调栈，但是一开始被题目的 case 误导了下，搞了一个单调递增栈，这里很很明显应该是递减栈，递增栈会把原本大的值给 pop 出去\n```java\n//5 4 3 4 1\n//一开始被例子给误导了，搞了一手单调递增栈。...\npublic long solve (int n, int[] a) {\n    Deque<Integer> stack = new ArrayDeque<>();\n    long res = 0l;\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && a[stack.peek()] <= a[i]) {\n            stack.pop();\n        }\n        if (!stack.isEmpty()) {\n            res += stack.peek()+1;\n        }\n        stack.push(i);\n    }\n    return res;\n}\n```","tags":["LeetCode"],"categories":["算法"]},{"title":"Golang 踩坑：exec 取消后不退出","url":"/2020/08/25/4d00b309/","content":"\n## 背景\n在做 [Scheduler 项目](https://github.com/imlgw/scheduler) 的过程中利用 os/exec 包执行一些 shell 脚本，调试过程中发现我取消了 context 后 go 进程仍然阻塞不退出\n## 分析\n> go version go1.13.6 linux/amd64\n\n在实现 kill 强杀功能时候发现的问题，无法杀死任务，即使 kill 了还是会等到任务执行完才会返回，在查资料的过程中发现这应该也算是 golang 本身的一个坑了，参考 [issue23019](https://github.com/golang/go/issues/23019)\n\n一开始是在 Windows 平台上运行测试的，以为是平台的原因但是在切换了 Linux 后问题依然存在，如下 poc 既可复现\n\n```golang\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os/exec\"\n    \"time\"\n)\n\nfunc main() {\n    ctx, cancelFn := context.WithTimeout(context.Background(), time.Second*5)\n    defer cancelFn()\n    cmd := exec.CommandContext(ctx, \"/bin/bash\", \"-c\", \"sleep 120; echo hello\")\n    output, err := cmd.CombinedOutput()\n    fmt.Printf(\"output：【%s】err:【%s】\", string(output), err)\n}\n```\n在 linux 平台上通过 go run 执行上面的代码，然后`pstree -p`查看进程树\n```golang\n//由于进程树比较庞大，所以省略了一些无关的部分\nsystemd(1)─┬─...\n           ├─sshd(17395)─┬─sshd(18450)───sftp-server(18453)\n           │             ├─sshd(28684)───zsh(28687)───go(2661)─┬─demo3_cmdPit(2680)─┬─bash(2683)───sleep(2684)\n           │             │                                     │                    ├─{demo3_cmdPit}(2681)\n           │             │                                     │                    ├─{demo3_cmdPit}(2682)\n           │             │                                     │                    └─{demo3_cmdPit}(2686)\n           │             │                                     ├─{go}(2662)\n           │             │                                     ├─{go}(2663)\n           │             │                                     ├─{go}(2664)\n           │             │                                     ├─{go}(2665)\n           │             │                                     ├─{go}(2672)\n           │             │                                     ├─{go}(2679)\n           │             │                                     └─{go}(2685)\n           │             └─sshd(29042)───zsh(29044)───pstree(2688)\n```\n可以看到这里我们的 go 进程`demo3_cmdPit(2680)`创建了`bash(2683)`进程去执行具体的 shell 指令，但是这里由于我们执行的命令是【`sleep 50; echo hello`】属于一组多条命令，所以这里 shell 会 fork 出子进程去执行这些命令，所以上面显示`sleep(2684)`是`bash(2683)`的子进程\n>补充：除了多条命令会产生子进程外，还有一些情况会产生子进程，比如`&`后台运行，`pipe`管道，外部 shell 脚本等等，具体可以参考这篇文章 [子 shell 以及什么时候进入子 shell](https://www.cnblogs.com/f-ck-need-u/p/7446194.html)\n\n然后再 5s 后 ctx 到期 cancel 后我们再次查看进程树\n```golang\nsystemd(1)─┬─...\n           ├─sleep(2684)\n           ├─sshd(17395)─┬─sshd(18450)───sftp-server(18453)\n           │             ├─sshd(28684)───zsh(28687)───go(2661)─┬─demo3_cmdPit(2680)─┬─{demo3_cmdPit}(2681)\n           │             │                                     │                    ├─{demo3_cmdPit}(2682)\n           │             │                                     │                    └─{demo3_cmdPit}(2686)\n           │             │                                     ├─{go}(2662)\n           │             │                                     ├─{go}(2663)\n           │             │                                     ├─{go}(2664)\n           │             │                                     ├─{go}(2665)\n           │             │                                     ├─{go}(2672)\n           │             │                                     ├─{go}(2679)\n           │             │                                     └─{go}(2685)\n           │             └─sshd(29042)───zsh(29044)───pstree(2708)\n```\n可以看到`bash(2683)`进程确实被 kill 了，但是它的子进程确并没有结束，而是变成了**孤儿进程**，被`init 1(systemd)`收养，但是我们看到这时进程`demo3_cmdPit(2680)`还没有退出，符合之前的预测，这里该进程仍然还有 3 条线程（协程）没有退出，直到 sleep 命令执行完才会返回，这里通过 pstack 是无法查看这几条线程的堆栈的，因为操作系统并不认识协程，而且 G 会在 P 上切换，所以我们暂时也不知道这几条线程在干嘛\n\n>孤儿进程：父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1) 所收养，并由 init 进程对它们完成状态收集工作。\n>\n>僵尸进程：父进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用`wait`或`waitpid`获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。\n\n当 sleep 执行完成后，程序会正常返回如下信息\n```go\noutput：【】err:【signal: killed】#\n```\n因为是在 Linux 环境下没有 IDE 而且不太熟悉`gdb`所以这里我们用`pprof`查看了一下堆栈\n```golang\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n    _ \"net/http/pprof\"\n    \"os/exec\"\n    \"time\"\n)\n\nfunc main() {\n    go func() {\n        err := http.ListenAndServe(\":6060\", nil)\n        if err != nil {\n            fmt.Printf(\"failed to start pprof monitor:%s\", err)\n        }\n    }()\n    ctx, cancelFn := context.WithTimeout(context.Background(), time.Second*5)\n    defer cancelFn()\n    cmd := exec.CommandContext(ctx, \"/bin/bash\", \"-c\", \"sleep 50; echo hello\")\n    output, err := cmd.CombinedOutput()\n    fmt.Printf(\"output：【%s】err:【%s】\", string(output), err)\n}\n```\n> 后面了解到其实直接发送`SIGQUIT`信号也可以看到堆栈，如 `kill -SIGQUIT <pid>`，go 的工具链还是非常完善的，除了这些还有很多方法看堆栈\n\n```go\ncurl http://127.0.0.1:6060/debug/pprof/goroutine\\?debug\\=2\n...\ngoroutine 1 [chan receive]:\nos/exec.(*Cmd).Wait(0xc000098580, 0x0, 0x0)\n        /usr/lib/golang/src/os/exec/exec.go:509 +0x125\nos/exec.(*Cmd).Run(0xc000098580, 0xc00006d710, 0xc000098580)\n        /usr/lib/golang/src/os/exec/exec.go:341 +0x5c\nos/exec.(*Cmd).CombinedOutput(0xc000098580, 0x9, 0xc0000bff30, 0x2, 0x2, 0xc000098580)\n        /usr/lib/golang/src/os/exec/exec.go:561 +0x91\nmain.main()\n\t\t/usr/local/gotest/cmd/demo3_cmdPit/main.go:22 +0x176\n...\ngoroutine 9 [IO wait]:\ninternal/poll.runtime_pollWait(0x7fa96a0f5f08, 0x72, 0xffffffffffffffff)\n        /usr/lib/golang/src/runtime/netpoll.go:184 +0x55\ninternal/poll.(*pollDesc).wait(0xc000058678, 0x72, 0x201, 0x200, 0xffffffffffffffff)\n        /usr/lib/golang/src/internal/poll/fd_poll_runtime.go:87 +0x45\ninternal/poll.(*pollDesc).waitRead(...)\n        /usr/lib/golang/src/internal/poll/fd_poll_runtime.go:92\ninternal/poll.(*FD).Read(0xc000058660, 0xc0000e2000, 0x200, 0x200, 0x0, 0x0, 0x0)\n        /usr/lib/golang/src/internal/poll/fd_unix.go:169 +0x1cf\nos.(*File).read(...)\n        /usr/lib/golang/src/os/file_unix.go:259\nos.(*File).Read(0xc000010088, 0xc0000e2000, 0x200, 0x200, 0x7fa96a0f5ff8, 0x0, 0xc000039ea0)\n        /usr/lib/golang/src/os/file.go:116 +0x71\nbytes.(*Buffer).ReadFrom(0xc00006d710, 0x8b6120, 0xc000010088, 0x7fa96a0f5ff8, 0xc00006d710, 0x1)\n        /usr/lib/golang/src/bytes/buffer.go:204 +0xb4\nio.copyBuffer(0x8b5a20, 0xc00006d710, 0x8b6120, 0xc000010088, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)\n        /usr/lib/golang/src/io/io.go:388 +0x2ed\nio.Copy(...)\n        /usr/lib/golang/src/io/io.go:364\nos/exec.(*Cmd).writerDescriptor.func1(0x0, 0x0)\n        /usr/lib/golang/src/os/exec/exec.go:311 +0x63\nos/exec.(*Cmd).Start.func1(0xc000098580, 0xc00000e3a0)\n        /usr/lib/golang/src/os/exec/exec.go:435 +0x27\ncreated by os/exec.(*Cmd).Start\n        /usr/lib/golang/src/os/exec/exec.go:434 +0x608\n```\n这里我忽略了一些无关的协程，留下了这两条的堆栈信息\n\n首先我们看一下第一条的堆栈信息，很明显这条就是我们的主`goroutine`，可以看到它正处于`[chan receive]`状态，也就是在等待某个 chan 传递信息，根据堆栈信息可以看到问题出在\n\n `/usr/lib/golang/src/os/exec/exec.go:509`\n\n我们去看一下这里发生了什么\n\n![mark](http://static.imlgw.top/blog/20200821/l2wEHHBXyTTh.png?imageslim)\n果然这里在等待`c.errch`，那么这个 errch 是谁负责推送的呢？\n\n我们再来看看另一条`goroutine`，这条`goroutine`处于`【IO wait】`状态，说明 IO 发生阻塞了，我们从下往上看堆栈，首先看一下是在哪里启动了这个协程\n```go\ncreated by os/exec.(*Cmd).Start\n        /usr/lib/golang/src/os/exec/exec.go:434 +0x608\n```\n![mark](http://static.imlgw.top/blog/20200822/sh8qmlcDeD64.png?imageslim)\n可以看到这个协程的作用就是向我们上面的主`goroutine`在等待的`c.errch`推送消息，那么这里`fn()`为什么没有返回呢？这个 fn 是在干嘛？继续翻一翻源码，发现这些函数`fn()`是在 cmd.Start 的时候创建的，用于处理 shell 的标准输入，输出和错误输出，而我们的程序就是卡在了这里，继续跟进上面的堆栈信息\n```go\nos/exec.(*Cmd).writerDescriptor.func1(0x0, 0x0)\n        /usr/lib/golang/src/os/exec/exec.go:311 +0x63\n```\n![mark](http://static.imlgw.top/blog/20200826/Boqz6oWej6HA.png?imageslim)\n可以看到这里就是具体协程执行的任务，这里有一个 IO 操作，可想而知程序就是阻塞在了这里，再往下分析就是内部 epoll 的代码了，就不往下了，我们分析下这段代码的意义，首先创建了管道`Pipe`，然后在协程中将读端`pr`的数据 copy 到`w`中，很明显这里就是`goroutine`通过 pipe 读取子进程的输出，但是由于某些原因`Pipe`阻塞了，无法从读端获取数据\n\n我们用`lsof -p`看一下该进程打开的资源\n```go\n$ lsof -p 27301\nCOMMAND   PID USER   FD      TYPE    DEVICE SIZE/OFF      NODE NAME\nmain    27301 root  cwd       DIR     253,1     4096   1323417 /usr/local/gotest/cmd/demo3_cmdPit\nmain    27301 root  rtd       DIR     253,1     4096         2 /\nmain    27301 root  txt       REG     253,1  7647232    401334 /tmp/go-build043247660/b001/exe/main\nmain    27301 root  mem       REG     253,1  2151672   1050229 /usr/lib64/libc-2.17.so\nmain    27301 root  mem       REG     253,1   141968   1050255 /usr/lib64/libpthread-2.17.so\nmain    27301 root  mem       REG     253,1   163400   1050214 /usr/lib64/ld-2.17.so\nmain    27301 root    0u      CHR     136,0      0t0         3 /dev/pts/0\nmain    27301 root    1u      CHR     136,0      0t0         3 /dev/pts/0\nmain    27301 root    2u      CHR     136,0      0t0         3 /dev/pts/0\nmain    27301 root    3u     IPv6 170355813      0t0       TCP *:6060 (LISTEN)\nmain    27301 root    4u  a_inode      0,10        0      5074 [eventpoll]\nmain    27301 root    5r     FIFO       0,9      0t0 170355794 pipe\n```\n可以看到确实打开了一个 inode 为 170355794 的管道，结合前面的分析，我们的 shell 在执行的时候`fork()`创建了子进程，但是 kill 的时候只 kill 了 shell 进程，而在`fork()`的时候会同时将当前进程的`pipe`的`fd[2]`描述符也复制过去，这就造成了`pipe`的写入端`fd[1]`被子进程继续持有（文件表引用计数不为 0），而`goroutine`也会继续等待 pipe 写入端写入或者关闭，直到`sleep 50`执行完后才返回\n## 原因总结\n`golang`的`os/exec`包在和 shell 做交互的时候会和 shell 之间建立 pipe，用于输入输出，获取 shell 返回值，但是在某些情况下，我们的 shell 会 fork 出子进程去执行命令，比如多条语句，&后台执行，sh 脚本等，然而这里 ctx 过期后，仅仅 kill 了 shell 进程，并没有 kill 它所创建的子进程，这就导致了 pipe 的 fd 仍然被子进程持有无法关闭，而在`os/exec`的实现中`goroutine`会一直等待 pipe 关闭后才返回，进而导致了该问题的产生\n## 解决方案\n问题搞清楚了，就好解决了。在 go 的实现中只 kill 了 shell 进程，并不会 kill 子进程，进而引发了上面的问题\n```golang\n// Kill causes the Process to exit immediately. Kill does not wait until\n// the Process has actually exited. This only kills the Process itself,\n// not any other processes it may have started.\nfunc (p *Process) Kill() error {\n\treturn p.kill()\n}\n```\n这里我们可以通过 kill`进程组`的方式来解决，所谓进程组也就是父进程和其创建的子进程的集合，`PGID`就是进程组的 ID，每个进程组都有进程组 ID，这里我们可以通过`ps -axjf`命令查看一下\n```go\nPPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND\n17395 20937 20937 20937 ?           -1 Ss       0   0:00  \\_ sshd: root@pts/0\n20937 20939 20939 20939 pts/0    25879 Ss       0   0:00  |   \\_ -zsh\n20939 25879 25879 20939 pts/0    25879 Sl+      0   0:00  |       \\_ go run main.go\n25879 25902 25879 20939 pts/0    25879 Sl+      0   0:00  |           \\_ /tmp/go-build486839449/b001/exe/main\n25902 25906 25879 20939 pts/0    25879 S+       0   0:00  |               \\_ /bin/bash -c sleep 50; echo hello\n25906 25907 25879 20939 pts/0    25879 S+       0   0:00  |                   \\_ sleep 50\n```\n在知道`PGID`后可以根据这个 ID 直接 Kill 掉所有相关的进程，但是这里注意看上面，我们的`Shell`进程和它的子进程，以及我们`go 进程`都是在一个进程组内的，直接 kill 会把我们的 go 进程也杀死，所以这里我们要让`Shell`进程和它的子进程额外开辟一个新的进程组，然后再 kill\n\n> 下面的代码中使用到了一些`syscall`包的方法，这个包的实现平台之间是有差异的，下面的代码只适用于 Linux 环境下\n\n```golang\nfunc RunCmd(ctx context.Context, cmd *exec.Cmd) ([]byte, error) {\n    var (\n        b   bytes.Buffer\n        err error\n    )\n    //开辟新的线程组（Linux 平台特有的属性）\n    cmd.SysProcAttr = &syscall.SysProcAttr{\n        Setpgid: true, //使得 Shell 进程开辟新的 PGID, 即 Shell 进程的 PID, 它后面创建的所有子进程都属于该进程组\n    }\n    cmd.Stdout = &b\n    cmd.Stderr = &b\n    if err = cmd.Start(); err != nil {\n        return nil, err\n    }\n    var finish = make(chan struct{})\n    defer close(finish)\n    go func() {\n        select {\n        case <-ctx.Done(): //超时/被 cancel 结束\n            //kill -(-PGID) 杀死整个进程组\n            syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)\n        case <-finish: //正常结束\n        }\n    }()\n    //wait 等待 goroutine 执行完，然后释放 FD 资源\n    //这个时候再 kill 掉 shell 进程就不会再等待了，会直接返回\n    if err = cmd.Wait(); err != nil {\n        return nil, err\n    }\n    return b.Bytes(), err\n}\n```\n**效果演示**\n![mark](http://static.imlgw.top/blog/20200825/gfz2xQ7nnKKg.gif)","tags":["开源项目","Golang"],"categories":["踩坑记录"]},{"title":"LeetCode 位运算","url":"/2020/07/03/a9fb61a5/","content":"\n> 从 [数组专题](http://imlgw.top/2019/05/04/leetcode-shu-zu/) 抽离出来的，时间就不做矫正了，我也不知道啥时候开始做的\n\n##  _LeetCode 二进制_\n\n## [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n给定一个**非空整数**数组，除了某个元素只出现一次以外，**其余每个元素均出现两次**。找出那个只出现了一次的元素。\n\n**说明：**\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**示例 1:**\n\n```java\n输入：[2,2,1]\n输出：1\n```\n\n**示例 2:**\n\n```java\n输入：[4,1,2,1,2]\n输出：4\n```\n\n**解法一**\n\n很可惜，想到了位运算，但是没试，瞄了一眼评论区，看见异或两个字马上就滚回来写了这个😂\n\n```java\npublic int singleNumber(int[] nums) {\n    for(int i=1;i<nums.length;i++){\n        nums[i]^=nums[i-1];\n    }\n    return nums[nums.length-1];\n}\n```\n## [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)\n\n给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。\n\n**示例 :**\n\n```java\n输入：[1,2,1,3,2,5]\n输出：[3,5]\n```\n\n**注意：**\n\n1. 结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。\n2. 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？\n\n**解法一**\n\n根据异或的结果`xor`，讲整个数组划分为两组，分别包含 a，b 这两个唯一的元素\n\n```java\npublic int[] singleNumber(int[] nums) {\n    if(nums==null || nums.length<=0) return new int[0];\n    int xor=nums[0];\n    for (int i=1;i<nums.length;i++) {\n        xor^=nums[i];\n    }\n    int index=0; //ab 二进制不同的 index\n    while((xor&1)==0){\n        xor>>>=1;\n        index++;\n    }\n    //a,b 在 index 位置的二进制位不同，异或结果为 1，然后我们就可以根据这个不同点，将整个数组按照这个划分为两部分\n    //这样相同的数肯定会被分配到同一组，问题就转换成了 136，这样我们再分别异或就能得到最终的 a,b\n    int a=0,b=0;\n    for (int i=0;i<nums.length;i++) {\n        if(((nums[i]>>>index)&1)==1){ //根据 index 位置的元素 0，1 来划分为两个数组\n            a^=nums[i];\n        }else{\n            b^=nums[i];\n        }\n    }\n    return new int[]{a,b};\n}\n```\n> 为啥没有 只出现一次的数字Ⅱ？ 别问，问就是不会🤣\n>\n\n## [268. 缺失数字](https://leetcode-cn.com/problems/missing-number/)\n\n给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。\n\n**示例 1:**\n\n```java\n输入：[3,0,1]\n输出：2\n```\n\n**示例 2:**\n\n```java\n输入：[9,6,4,2,3,5,7,0,1]\n输出：8\n```\n\n**说明：**\n你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现？\n\n**解法一**\n\n比较直接的思路，求全序列的和然后相减就 ok\n\n```java\npublic int missingNumber(int[] nums) {\n    int N=nums.length;\n    int sum=0;\n    for (int i=0;i<N;i++) {\n        sum+=nums[i];\n    }\n    return N*(N+1)/2-sum; //可能会溢出\n}\n```\n**解法二**\n\n位运算，异或，和上面一样的思路\n\n```java\npublic int missingNumber(int[] nums) {\n    int res=0;\n    //3 0 1 \n    for (int i=0;i<nums.length;i++) {\n        res^=nums[i];\n        res^=i;\n    }\n    //3^0^1^0^1^2^3=2\n    return res^nums.length;\n}\n```\n异或每个数和下标索引，结果就是缺失的数，因为缺失的只有一个，这样就和上面那一题一样了\n\n## [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)\n\n两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n\n**注意：**\n`0 ≤ x, y < 2^31.`\n\n**示例：**\n\n```java\n输入：x = 1, y = 4\n\n输出：2\n\n解释：\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n```\n\n**解法一**\n\n```java\npublic int hammingDistance(int x, int y) {\n    int i=x^y;\n    int count=0;\n    while(i!=0){\n        if ((i&1)==1) { //括号不能掉\n            count++;\n        }\n        i=i>>1;\n    }\n    return count;\n}\n```\n\n一行`Integer.bitCount(x^y)`\n\n## [191. 位 1 的个数](https://leetcode-cn.com/problems/number-of-1-bits/)\n\n编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）\n\n**示例 1：**\n\n```java\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n```\n\n**示例 2：**\n\n```java\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n```\n\n**示例 3：**\n\n```java\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n```\n\n**提示：**\n\n- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n**进阶：**\n如果多次调用这个函数，你将如何优化你的算法？ \n\n**解法一**\n\n比较精妙的解法，`n&(n-1)` 就是将二进制最右边的 1 变为 0，这样逐步的&最后数组就会变为 0，我们统计下次数就是 1 的数量\n\n```java\npublic int hammingWeight(int n) {\n    int count=0;\n    while(n!=0){\n        //while(n>0){\n        n&=(n-1);\n        count++;\n    }\n    return count;\n}\n```\n\n**解法二**\n\n移位操作，相比上面会慢一些，没有那么精妙\n\n```java\npublic int hammingWeight(int n) {\n    int count=0;\n    while(n!=0){\n        if((n&1)==1)//判断末位是不是 1\n            count++;\n        n>>>=1; //无符号右移，避免添高位添 1 死循环\n    }\n    return count;\n}\n```\n\n> 注意右移的操作，都需要使用无符号右移，不然负数右移高位补 1 后就错了\n\n## [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)\n\n给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n\n**示例 1:**\n\n```java\n输入：2\n输出：[0,1,1]\n```\n\n**示例 2:**\n\n```java\n输入：5\n输出：[0,1,1,2,1,2]\n```\n\n**进阶：**\n\n- 给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？\n- 要求算法的空间复杂度为 O(n)。\n- 你能进一步完善解法吗？要求在 C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 \n\n**解法一**\n\n这样的题肯定是直接上进阶的啦，有动态规划的意思\n\n```java\npublic int[] countBits(int num) {\n    int[] res=new int[num+1];\n    for (int i=1;i<=num;i++) {\n        //如果 i 二进制以 0 结尾，那么 i>>1 的 countBit 和 i 一样，i&1=0（>>1 就是/2）\n        //反之，那么 i>>1 的比 i 会少 1 个，i&1=1\n        res[i]=res[i>>1]+(i&1); //注意括号\n    }\n    return res;\n}\n```\n\n**解法二**\n\n和上面类似，不过手法有点不一样\n\n```java\npublic int[] countBits(int num) {\n    int[] res=new int[num+1];\n    for (int i=1;i<=num;i++) {\n        //i&(i-1) 会去掉最右边的 1\n        res[i]=res[i&(i-1)]+1;\n    }\n    return res;\n}\n```\n\n## [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)\n\n给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n\n**示例 1:**\n\n```java\n输入：1\n输出：true\n解释：20 = 1\n```\n\n**示例 2:**\n\n```java\n输入：16\n输出：true\n解释：24 = 16\n```\n\n**示例 3:**\n\n```java\n输入：218\n输出：false\n```\n\n**解法一**\n\n应该是最快 AC 的题吧 hahaha\n\n```java\npublic boolean isPowerOfTwo(int n) {\n    return n>0 && (n&(n-1))==0;\n}\n```\n\n## [458. 可怜的小猪](https://leetcode-cn.com/problems/poor-pigs/)\n\n有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。\n\n问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？\n\n回答这个问题，并为下列的进阶问题编写一个通用算法。\n\n**进阶：**\n\n假设有 `n` 只水桶，猪饮水中毒后会在 `m` 分钟内死亡，你需要多少猪（`x`）就能在 `p` 分钟内找出 “**有毒**” 水桶？这 `n` 只水桶里有且仅有一只有毒的桶。\n\n**提示：**\n\n1. 可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。\n2. 小猪喝完水后，必须有 *m* 分钟的**冷却时间**。在这段时间里，只允许观察，而不允许继续饮水。\n3. 任何给定的桶都可以无限次采样（无限数量的猪）。\n\n**解法一**\n\n[参考题解区](https://leetcode-cn.com/problems/poor-pigs/solution/hua-jie-suan-fa-458-ke-lian-de-xiao-zhu-by-guanpen/) 我就不搬运了，简单来说就是看每个小猪能表示几进制的状态，比如题目中说的是 15 分钟死亡，一个小时时间，那么每只小猪可以吃 4 次药，可以检测出 5 瓶药，所以`x`只猪就能检测`state^x`个桶\n\n```java\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int state=minutesToTest/minutesToDie+1;\n    return (int)Math.ceil(Math.log(buckets)/Math.log(state));\n}\n```\n\n具体的做法：x 只🐖，每只🐖都和对应。.....\n\n> 两只猪二维的表格可以解决，三只猪三维的坐标可以解决，如果是 4 只猪，5 只猪呢？具体的如何测量，这里我还没有点没想清楚😐\n\n## [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)\n\n**不使用**运算符 `+` 和 `-` ，计算两整数 `a` 、`b` 之和。\n\n**示例 1:**\n\n```java\n输入：a = 1, b = 2\n输出：3\n```\n\n**示例 2:**\n\n```java\n输入：a = -2, b = 3\n输出：1\n```\n\n**解法一**\n\n两数之和 = 两数不进位和+两数进位和 ，一开始也没搞懂这个式子，后来在 10 进制上想了下就明白了\n\n比如 998 + 99 = 987+110 = 97 + 1000 = 1097 ，其实就是把加法拆开来看，把进位的数和对应的数位和分开计算，而进位的数和两数的不进位和都可以通过位运算算出来，进而不使用`+/-`计算两数之和\n\n```go\nfunc getSum(a int, b int) int {\n    if b==0{\n        return a\n    }\n    //a^b: 不进位和 a&b<<1: 进位数和（进位是进到前一位，所以需要左移，类比十进制就清楚了）\n    return getSum(a^b,(a&b)<<1) \n}\n```\n\n## [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)\n\nDifficulty: **简单**\n\n颠倒给定的 32 位无符号整数的二进制位。\n\n**示例 1：**\n\n```\n输入：00000010100101000001111010011100\n输出：00111001011110000010100101000000\n解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n```\n\n**示例 2：**\n\n```\n输入：11111111111111111111111111111101\n输出：10111111111111111111111111111111\n解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。\n```\n\n**提示：**\n\n*   请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n*   在 Java 中，编译器使用记法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。\n\n**进阶**:  \n如果多次调用这个函数，你将如何优化你的算法？\n\n**解法一**\n\n利用移位运算从后往前计算二进制的值就可以了\n```java\npublic int reverseBits(int n) {\n    int res = 0;\n    int count = 32;\n    while(n != 0){ //Java 中没有无符号数，所以这里不能写大于 0\n        //Java 移位运算优先级低于+-\n        res = (res << 1) + (n & 1);\n        n >>>= 1; //无符号右移，避免高位补 1\n        count--;\n    }\n    while(count > 0){\n        res <<= 1;\n        count--;\n    }\n    return res;\n}\n```\n上面的解法还是不够简洁，第二个循环没有必要，不过中间有几个小知识点挺有意思的，回顾了下\n\n**解法二**\n\n简洁的解法\n```golang\nfunc reverseBits(num uint32) uint32 {\n    var res uint32 = 0\n    for i := 32; i > 0; i-- {\n        //go 中移位运算符优先级高于于+-\n        res = (res << 1) + (num & 1)\n        num >>= 1\n    }\n    return res\n}\n```\n> golang 和 java 的位运算优先级居然不一样，一开始写的 go，该成 java 的时候发现不对，调试了下才发现😂，所以任何时候能加括号的尽量加括号，即使你知道不加也可以，最好还是要加上括号！！！\n\n## [201. 数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)\n\nDifficulty: **中等**\n\n给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。\n\n**示例 1:**\n\n```golang\n输入：[5,7]\n输出：4\n```\n\n**示例 2:**\n\n```golang\n输入：[0,1]\n输出：0\n```\n\n**解法一**\n最长公共前缀\n```golang\n//最长公共前缀\n//1011 011 m\n//1011 100\n//1011 101\n//1011 110 n\nfunc rangeBitwiseAnd(m int, n int) int {\n    var tlen = 0\n    for m != n {\n        m >>= 1\n        n >>= 1\n        tlen++\n    }\n    return m << tlen\n}\n```\n**解法二**\n```golang\nfunc rangeBitwiseAnd(m int, n int) int {\n    for n > m {\n        n &= (n-1)\n    }\n    return n\n}\n```\n\n## [1018. 可被 5 整除的二进制前缀](https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/)\n\nDifficulty: **简单**\n\n给定由若干 `0` 和 `1` 组成的数组 `A`。我们定义 `N_i`：从 `A[0]` 到 `A[i]` 的第 `i` 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。\n\n返回布尔值列表 `answer`，只有当 `N_i` 可以被 `5` 整除时，答案 `answer[i]` 为 `true`，否则为 `false`。\n\n**示例 1：**\n\n```c\n输入：[0,1,1]\n输出：[true,false,false]\n解释：\n输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。\n```\n\n**示例 2：**\n\n```c\n输入：[1,1,1]\n输出：[false,false,false]\n```\n\n**示例 3：**\n\n```c\n输入：[0,1,1,1,1,1]\n输出：[true,false,false,false,true,false]\n```\n\n**示例 4：**\n\n```c\n输入：[1,1,1,0,1]\n输出：[false,false,false,false,false]\n```\n\n**提示：**\n\n1.  1 <= A.length <= 30000\n2.  `A[i]` 为 `0` 或 `1`\n\n**解法一**\n\n一开始没考虑溢出的问题，用的是 py 所以也没报错，看了评论区才意识到会有溢出的问题，不过这里也很好处理，因为我们每次都只需要知道这个值模 5 的值就行了，所以我们只需要保留当前值模 5 的余数就行了\n$$\n(a * b+c) \\bmod \\ p=((\\underbrace{(a \\bmod \\ p)} * (b \\bmod \\ p))+(c \\bmod p))\\bmod p\n$$\n这里的$a$就是上次计算的结果，根据取模运算的性质，我们只需要保存上次计算的结果模 5 后的值就行了，这样就能避免溢出的问题\n```python\n​class Solution:\n    def prefixesDivBy5(self, A: List[int]) -> List[bool]:\n        res = []\n        v = 0\n        # 1110(14) --> 11101 (29)\n        for i in range(0, len(A)):\n            v = (v*2 + A[i]) % 5\n            res.append(v==0)\n        return res\n```","tags":["LeetCode","位运算"],"categories":["算法"]},{"title":"Rabin-Karp 算法","url":"/2020/07/01/194514a9/","content":" > 见到好几次了，感觉不是很难，学一手，本来想详细的写一下完整的 Rabin-Karp 解析的，但是目前确实时间有点紧，加上自己也没做几题，理解的可能还不到位，等后面有时间再来补吧\n ## [1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)\n\nDifficulty: **困难**\n\n给出一个字符串 `S`，考虑其所有**重复子串**（`S` 的连续子串，出现两次或多次，可能会有重叠）。\n\n返回**任何**具有最长可能长度的重复子串。（如果 `S` 不含重复子串，那么答案为 `\"\"`。）\n\n**示例 1：**\n\n```\n输入：\"banana\"\n输出：\"ana\"\n```\n\n**示例 2：**\n\n```\n输入：\"abcd\"\n输出：\"\"\n```\n\n**提示：**\n\n1.  `2 <= S.length <= 10^5`\n2.  `S` 由小写英文字母组成。\n\n**解法一**\n\n看题解区学习了一下，整体的思路倒是不难，主要就是一个`rolling hash`的过程，然后就是关于 MOD 的选取，到现在也不是很清楚怎么选 MOD。\n```java\npublic String longestDupSubstring(String S) {\n    int n = S.length();\n    int [] nums =new int[n];\n    for (int i = 0; i < S.length(); i++) {\n        nums[i] =  S.charAt(i) - 'a';\n    }\n    long MOD =  1L<<32;\n    int B = 26; \n    int left = 1;\n    int right = n - 1;\n    int start = -1, mlen = 0;\n    while (left <= right){\n        int mid = left + (right - left)/2;\n        int temp = RabinKarp(mid, B, nums, MOD);\n        if (temp != -1){\n            if (mid > mlen){\n                mlen = mid;\n                start = temp;\n            }\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return start == -1 ? \"\" : S.substring(start, start + mlen);\n}\n\npublic int RabinKarp(int len, int B, int[] nums, long MOD){\n    //hash(S) = s[0] * B^(len-1) + s[1] * B^(len-2) + ... + s[n-1] *1\n    //B^(len-1) （移除左端点时需要的值）\n    long BL = 1;\n    for (int i = 0; i < len - 1; i++){\n        BL = (BL * B) % MOD;\n    }\n    //[0,len-1] 的 hash 值\n    long h = 0;\n    for (int i = 0; i < len; i++){\n        h = (h * B + nums[i]) % MOD;\n    }\n    HashSet<Long> set = new HashSet<>();\n    set.add(h);\n    //rolling hash\n    for (int i = 1; i <= nums.length - len; i++){\n        //+MOD 是为了负数取模\n        h = (h - nums[i - 1] * BL % MOD + MOD) % MOD;\n        h = (h * B + nums[i + len - 1]) % MOD;\n        if (set.contains(h)){\n            return i;\n        }\n        set.add(h);\n    }\n    return -1;\n}\n```\n\n**解法二**\n\n补充一下冲突检测，猜 mod 也太玄学了😂\n> 这个冲突检测的方法有问题，留下做个印证，正确的检测请直接看 解法三\n\n```java\n//写一波检测冲突的\npublic String longestDupSubstring(String S) {\n    int n = S.length();\n    long MOD = (long) 1e9+7;\n    int B = 26; \n    int left = 1;\n    int right = n - 1;\n    int start = -1, mlen = 0;\n    while (left <= right){\n        int mid = left + (right - left)/2;\n        int temp = RabinKarp(mid, B, S, MOD);\n        if (temp != -1){\n            if (mid > mlen){\n                mlen = mid;\n                start = temp;\n            }\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return start == -1 ? \"\" : S.substring(start, start + mlen);\n}\n\npublic int RabinKarp(int len, int B, String S, long MOD){\n    //hash(S) = s[0] * B^(len-1) + s[1] * B^(len-2) + ... + s[n-1] *1\n    //B^(len-1) （移除左端点时需要的值）\n    long BL = 1;\n    for (int i = 0; i < len - 1; i++){\n        BL = (BL * B) % MOD;\n    }\n    //[0,len-1] 的 hash 值\n    long h = 0;\n    for (int i = 0; i < len; i++){\n        h = (h * B + S.charAt(i) - 'a') % MOD;\n    }\n    //这里肯定不能直接存字符串做冲突检测，太大了会 MLE\n    //存一个起始地址就可以了 len 已知\n    HashMap<Long,Integer> map = new HashMap<>();\n    map.put(h, 0);\n    //rolling hash\n    for (int i = 1; i <= S.length() - len; i++){\n        //+MOD 是为了负数取模\n        h = (h - (S.charAt(i-1) - 'a') * BL % MOD + MOD) % MOD;\n        h = (h * B + (S.charAt(len + i -1) - 'a')) % MOD;\n        Integer start = map.get(h);\n        if (start != null && S.substring(start, start + len).equals(S.substring(i, i + len))){\n            return i;\n        }\n        map.put(h, i);\n    }\n    return -1;\n}\n```\n\n> 关于这个冲突检测有一个小问题，我尝试减小了`MOD`的大小，比如 101，这样计算出来的结果在数据量较大的就不对了，得到的字符虽然确实是重复了，但是并不是最长的，按道理写了冲突检测后即使我 MOD 取 1 应该都是可以找出来的啊？======>\n> 在写上面这段话的时候突然想明白了，因为`MOD`取的太小，导致冲突的概率大大增加，而这里我做冲突检测的时候只保存了一个值，也就是说会有很多值被舍弃掉，也许你舍弃的值可能恰好就是最后的答案，字符越长，发生这种情况的概率就越高，所以说我这里冲突检测做的并不完全，能过也纯属运气，正确的冲突检测应该保存一个`List`链表，然后在发生冲突的时候在 List 中找有没有和当前字符相等的，这样一来，时间复杂度就会上去（其实这个过程就是设计 Hash 表的过程，链地址法解决冲突）\n\n**解法三**\n\n下面的应该就没什么问题了，链地址法，时间复杂度会增大，耗时增加到了 500ms+，但是确保了 100%的正确率，这是值得的，这次把 mod 调小也不会出错了（但是可能会 TLE，冲突变大了），总体来说，这几番折腾收获还是挺大的，好事还是要多磨啊\n```java\n//再写一波检测冲突。\n//上面的写的有问题，检测不完全\npublic String longestDupSubstring(String S) {\n    int n = S.length();\n    long MOD = (long) 1e9+7;\n    int B = 26; \n    int left = 1;\n    int right = n - 1;\n    int start = -1, mlen = 0;\n    while (left <= right){\n        int mid = left + (right - left)/2;\n        int temp = RabinKarp(mid, B, S, MOD);\n        if (temp != -1){\n            if (mid > mlen){\n                mlen = mid;\n                start = temp;\n            }\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return start == -1 ? \"\" : S.substring(start, start + mlen);\n}\n\npublic int RabinKarp(int len, int B, String S, long MOD){\n    //hash(S) = s[0] * B^(len-1) + s[1] * B^(len-2) + ... + s[n-1] *1\n    //B^(len-1) （移除左端点时需要的值）\n    long BL = 1;\n    for (int i = 0; i < len - 1; i++){\n        BL = (BL * B) % MOD;\n    }\n    //[0,len-1] 的 hash 值\n    long h = 0;\n    for (int i = 0; i < len; i++){\n        h = (h * B + S.charAt(i) - 'a') % MOD;\n    }\n    //这里肯定不能直接存字符串做冲突检测，太大了会 MLE\n    //存一个起始地址就可以了 len 已知\n    HashMap<Long,List<Integer>> map = new HashMap<>();\n    map.put(h, new ArrayList(){{add(0);}});\n    //rolling hash\n    for (int i = 1; i <= S.length() - len; i++){\n        //+MOD 是为了负数取模\n        h = (h - (S.charAt(i-1) - 'a') * BL % MOD + MOD) % MOD;\n        h = (h * B + (S.charAt(len + i -1) - 'a')) % MOD;\n        List<Integer> starts = map.get(h);\n        if (check(starts, i, S, len)){\n            return i;\n        }\n        if (starts == null){\n            List<Integer> lis = new ArrayList<>();\n            lis.add(i);\n            map.put(h, lis);\n        }else{\n            starts.add(i);\n        }\n    }\n    return -1;\n}\n\npublic boolean check(List<Integer> starts, int i, String s, int len){\n    if(starts == null || starts.size() <= 0){\n        return false;\n    }\n    for (int left : starts) {\n        if(s.substring(left, left + len).equals(s.substring(i, i + len))){\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n**示例 1:**\n\n```java\n输入：\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n输出：3\n解释：\n长度最长的公共子数组是 [3, 2, 1]。\n```\n\n**说明：**\n\n1. 1 <= len(A), len(B) <= 1000\n2. 0 <= A[i], B[i] < 100\n\n**解法一**\n\ndp 的解法是 O(N^2) 的，略显暴力，动态规划的解法放在 [dp 专题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84) 中，这里要介绍的是二分+字符串 Hash 的`O(NlogN)`的解法\n\n这里直接莽过了，且效率极高（16ms），就不写冲突检测了\n```java\npublic int findLength(int[] A, int[] B) {\n    int lenA = A.length, lenB = B.length;\n    int left = 1;\n    int right = Math.min(lenA, lenB);\n    int res = 0;\n    while (left <= right){\n        int mid = left +(right - left) / 2;\n        if(RabinKarp(A, B, mid)){\n            res = Math.max(res, mid);\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n\npublic boolean RabinKarp(int[] A,int[] B, int L){\n    int MOD = (int) 1e9+7, BASE = 101;\n    long BL = 1;\n    for(int i = 0; i < L-1; i++){\n        BL = (BL * BASE) % MOD;\n    }\n    //hash(A[0,L-1]),hash(B[0,L-1])\n    long hA = 0, hB = 0;\n    for(int i = 0; i < L; i++){\n        hA = (hA * BASE + A[i]) % MOD;\n        hB = (hB * BASE + B[i]) % MOD;\n    }\n    HashSet<Long> set =new HashSet<>();\n    set.add(hA);\n    //rolling hash A\n    for(int i = 1; i <= A.length - L; i++){\n        hA = (hA - A[i-1] * BL % MOD + MOD) % MOD;\n        hA = (hA * BASE + A[L + i -1]) % MOD;\n        set.add(hA);\n    }\n    if(set.contains(hB)) return true;\n    //rolling hash B\n    for(int i = 1; i <= B.length - L; i++){\n        hB = (hB - B[i-1] * BL % MOD + MOD) % MOD;\n        hB = (hB * BASE + B[L + i -1]) % MOD;\n        //这里还可以做一下冲突检测，set 中需要多存一些信息\n        if(set.contains(hB)){\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## [面试题 17.13. 恢复空格](https://leetcode-cn.com/problems/re-space-lcci/)\n\nDifficulty: **中等**\n\n哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子`\"I reset the computer. It still didn’t boot!\"`已经变成了`\"iresetthecomputeritstilldidntboot\"`。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典`dictionary`，不过，有些词没在词典里。假设文章用`sentence`表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\n\n**注意：** 本题相对原题稍作改动，只需返回未识别的字符数\n\n**示例：**\n\n```go\n输入：\ndictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]\nsentence = \"jesslookedjustliketimherbrother\"\n输出： 7\n解释： 断句后为\"jess looked just like tim her brother\"，共 7 个未识别字符。\n```\n\n**提示：**\n\n*   `0 <= len(sentence) <= 1000`\n*   `dictionary`中总字符数不超过 150000。\n*   你可以认为`dictionary`和`sentence`中只包含小写字母。\n\n**解法一**\n\n动态规划和 Trie 的解法左转 [动态规划](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/) 专题，这里记录下字符串 Hash 的做法，其实字符串 Hash 的做法相比字典树的做法会慢一点点，不过思路还是很值得学习的\n\n这里看官方题解又学到了一点东西，这里在计算 hash 的时候加了一个 1，这样我猜测就是为了避免 0 的出现，使得后面的 base 失效，使得冲突的概率变大，比如`aba`和`ba`可能就会被判成一样的字符，我下面的做法没有做减`a`的操作，而是取了更大的 BASE，这里就不写冲突检测了，可以直接莽过，上面的第一题确实太离谱了，不按照官方题解的数据来就过不了\n```java\npublic int respace(String[] dictionary, String s) {\n    int BASE = 131;\n    long MOD = Integer.MAX_VALUE;\n    HashSet<Long> set = new HashSet<>();\n    for (String word : dictionary ) {\n        set.add(hash(word, BASE, MOD));\n    }\n    int n = s.length();\n    int[] dp = new int[n+1];\n    for (int i = 1; i <=n ; i++) {\n        dp[i] = dp[i-1] + 1;\n        long rollhash = 0;\n        for (int j = i; j >= 1; j--) {\n            rollhash = (rollhash * BASE + s.charAt(j-1)) % MOD;\n            if(set.contains(rollhash)){\n                //注意这里是 dp[j-1]，对应 s.charAt(j-1) 的前一个字符\n                dp[i] = Math.min(dp[i], dp[j-1]);\n            }\n            if(dp[i] == 0){\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\n//注意需要逆向 hash，上面计算的时候是 j--，是逆向的\npublic long hash(String s, int BASE, long MOD){\n    long h = 0;\n    for (int i = s.length()-1; i >=0 ; i--) {\n        h = (h * BASE + s.charAt(i)) % MOD;\n    }\n    return h;\n}\n```\n> 这个解法也用到了 Hash 表，但是相比用 Hash 表存字符，存数字的时间复杂度会低很多，其实字符串 Hash 也就是为了避免在 Hash 表中存大量的字符，一来空间占用会非常大，二来对于字符串来说计算字符的`hashCode()`的时间复杂度也是 O(N) 不可忽略的，而数字长度固定，`hashCode()`直接返回值就行了\n\n## [1316. 不同的循环子字符串](https://leetcode-cn.com/problems/distinct-echo-substrings/)\n\nDifficulty: **困难**\n\n给你一个字符串 `text` ，请你返回满足下述条件的 **不同** 非空子字符串的数目：\n\n*   可以写成某个字符串与其自身相连接的形式（即，可以写为 `a + a`，其中 `a` 是某个字符串）。\n\n例如，`abcabc` 就是 `abc` 和它自身连接形成的。\n\n**示例 1：**\n\n```go\n输入：text = \"abcabcabc\"\n输出：3\n解释：3 个子字符串分别为 \"abcabc\"，\"bcabca\" 和 \"cabcab\" 。\n```\n\n**示例 2：**\n\n```go\n输入：text = \"leetcodeleetcode\"\n输出：2\n解释：2 个子字符串为 \"ee\" 和 \"leetcodeleetcode\" 。\n```\n\n**提示：**\n\n*   `1 <= text.length <= 2000`\n*   `text` 只包含小写英文字母。\n\n**解法一**\n\n哭了，看着 KMP 的 tag 进来的，结果发现 KMP 的不太会写，学习了题解的前缀和 Hash 的思路，还是有点收获\n```java\nint BASE = 131;\n\nlong MOD = (long)1e9+7;\n\npublic int distinctEchoSubstrings(String s) {\n    int n = s.length();\n    //前缀 hash 和（前 i 个元素的 hash 值）\n    long[] hashSum = new long[n+1];\n    //BASE 的所有幂乘\n    long[] pow = new long[n+1];\n    pow[0] = 1;\n    hashSum[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        hashSum[i] = (hashSum[i-1]*BASE + s.charAt(i-1)) % MOD;\n        pow[i] = (pow[i-1]*BASE) % MOD;\n    }\n    HashSet<Long> set = new HashSet<>();\n    //枚举所有偶数长度的子串\n    for (int len = 2; len <= n; len+=2) {\n        for (int i = 0 ; i+len-1 < n; i++) {\n            int j = i + len - 1; //右边界\n            int mid = i + (j-i)/2; //中点\n            //0,3\n            long hleft = getHash(hashSum, pow, s, i, mid);\n            long hright = getHash(hashSum, pow, s, mid+1, j);\n            if(hleft == hright && !set.contains(hleft)){\n                set.add(hleft);\n            }\n        }\n    }\n    return set.size();\n}\n\n// 求 s[i,j] 区间的哈希值：s[i]*B^j-i + s[i+1]*B^j-i-1 + ... + s[j]\n// \n// hashSum[i] = s[0]*B^i-1 + s[1]*B^i-2 +...+ s[i-1]\n// hashSum[j+1] = s[0]*B^j + s[1]*B^j-1 +...+ s[j]\n// hashSum[i]*B^j-i+1 = s[0]*B^j + s[1]*B^j-1 +...+ s[i-1]*B^j-i+1\n// hash[i,j] = hashSum[j+1] - hashSum[i] * B^j-i+1\n//           = s[i]*B^j-i + s[i+1]*B^j-i-1 +...+s[j]\npublic long getHash(long[] hashSum, long[] pow, String s, int i, int j){\n    //j-i+1 是 [i,j] 区间的长度，包含 i 和 j，而 hashSum[k] 是不包含 k 的\n    //所以这里需要转换下，j 需要+1 使得 hashSum 包含 j\n    return (hashSum[j+1] - (hashSum[i] * pow[j-i+1]) % MOD + MOD) % MOD;\n}\n```\n\n**解法二**\n\nKMP 的做法肯定就是参考 KMP 的 [459. 重复的子字符串](http://imlgw.top/2020/05/13/kmp-suan-fa/#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2) 的做法，我看了外网的 discuss，只看见了一个这样写的，而且看不太懂，我自己尝试了下，感觉好多地方都会有坑，主要就是去重很麻烦，代码如下\n\n下面为错误解法，无法通过 OJ，懒得改了，感觉不是个很好的做法\n```java\n//KMP 的做法\npublic int distinctEchoSubstrings(String s) {\n    for (int i = 0; i < s.length(); i++) {\n        getNext(s.substring(i));\n    }\n    return set.size();\n}\n\nHashSet<String> set = new HashSet<>();\n\npublic void getNext(String s){\n    if(s.length() < 2){\n        return;\n    }\n    int n = s.length();\n    int[] next = new int[n+1];\n    next[0] = -1;\n    next[1] = 0;\n    int left = 0, right = 2;\n    while(right <= n){\n        if(s.charAt(left) == s.charAt(right-1)){\n            left++;\n            next[right] = left;\n            int replen = right-next[right];\n            String rs = s.substring(0,replen);\n            if (right%2==0 && replen!=right && right%replen==0 && !set.contains(rs)) {\n                set.add(rs);\n            }\n            right++;\n        }else if(next[left] == -1){\n            right++;\n        }else{\n            left = next[left];\n        }\n    }\n}\n```","tags":["算法","数据结构"],"categories":["算法"]},{"title":"Linux 磁盘与文件系统","url":"/2020/06/20/96e38ff1/","content":"\n> 要点摘抄，全文摘抄自《鸟叔的 Linux 私房菜》，对小部分词语进行转换，对部分内容进行批注，方便以后查阅\n\n## Linux 磁盘与文件系统\n- 一个可以被挂载的数据通常称为 “ 文件系统 , filesystem” 而不是分区 （ partition ） \n- 基本上 `Linux` 的传统文件系统为 Ext2 ，该文件系统内的信息主要有：\n  - `superblock` ：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；\n  - `inode` ：记录文件的属性，一个文件占用一个 inode ，同时记录此文件的数据所在的 block 号码；\n  - `block` ：实际记录文件的内容，若文件太大时，会占用多个 block 。\n- `Ext2` 文件系统的数据存取为**索引式文件系统**（ `indexed allocation` ）每个文件由一个 inode 和多个 block 组成，与之对应的是 FAT，FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中，是一种链表的结构，磁盘重组也主要是针对的这种文件系统\n- 需要**磁盘重组**的原因就是文件写入的 block 太过于离散了，我们的磁头将无法在磁盘转一圈就读到所有的数据，因此磁盘就会多转好几圈才能完整的读取到这个文件的内容此时文件读取的性能将会变的很差所致。 这个时候可以通过磁盘重组将同一个文件所属的 blocks 汇整在一起。\n- Ext2 文件系统主要有： boot sector, superblock, `inode bitmap`, `block bitmap`, `inode table`,`data block `等六大部分。\n- data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已\n- inode 记录文件的属性 / 权限等数据，其他重要项目为： 每个 inode 大小均为固定，有 128/256Bytes 两种基本容量。每个文件都仅会占用\n  一个 inode 而已； 因此文件系统能够创建的文件数量与 inode 的数量有关；\n  ![NMhIY9.png](https://s1.ax1x.com/2020/06/20/NMhIY9.png)\n  > inode 要记录的数据非常多，但偏偏又只有 128Bytes 而已， 而 inode 记录一个 block 号码要花掉 4Byte ，假设我一个文件有 400MB 且每个 block 为 4K 时， 那么至少也要十万笔 block 号码的记录 inode 哪有这么多可记录的信息？为此我们的系统很聪明的将 inode 记录 block 号码的区域定义为 12 个直接，一个间接 , 一个双间接与一个三间接记录区。（双间接，三间接其实就是多级指针，inode 指向 block，block 又指向另一个 block）\n- 文件的 block 在记录文件的实际数据，目录的 block 则在记录该目录下面文件名与其 inode 号码的对照表；\n- 日志式文件系统 （ `journal` ） 会多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；（ext2 之后的 ext3,4 支持）\n    1. 预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；\n    2. 实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；\n    3. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。\n  > 这种方式在很多的应用软件中也有类似的体现，比如`mysql`的`redo log`，`redis`的`aof`\n- Linux 文件系统为增加性能，会让内存作为大量的磁盘高速缓存；（这里看了原文也不是很懂，这里意思应该是让内存作为磁盘的缓存，也就是数据不直接写入磁盘，先写入内存，再同步到磁盘）\n  - 系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读 / 写；\n  - 承上，因此 Linux 的实体内存最后都会被用光！这是正常的情况！可加速系统性能；\n  - 你可以手动使用 `sync` 来强迫内存中设置为 Dirty 的文件回写到磁盘中；\n  - 若正常关机时，关机指令会主动调用 `sync` 来将内存的数据回写入磁盘内；\n  - 但若不正常关机（如跳电、死机或其他不明原因），由于数据尚未回写到磁盘内， 因此重新开机后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁（非磁盘损毁）。\n- 实体链接只是多了一个文件名对该 `inode` 号码的链接而已 (ln)\n  ![UTOOLS1592753917172.png](https://upload.cc/i1/2020/06/21/xuFwlq.png)\n- 符号链接就类似 Windows 的捷径功能。(ln -s)\n  ![UTOOLS1592753775172.png](https://upload.cc/i1/2020/06/21/qmB46s.png)\n- 磁盘的使用必需要经过：分区、格式化与挂载，分别惯用的指令为： gdisk, mkfs, mount 三个指令\n- 分区时，应使用 parted 检查分区表格式，再判断使用 fdisk/gdisk 来分区，或直接使用 parted 分区\n- 为了考虑性能， XFS 文件系统格式化时，可以考虑加上 agcount/su/sw/extsize 等参数较佳\n- 如果磁盘已无未分区的容量，可以考虑使用大型文件取代磁盘设备的处理方式，通过 dd 与格式化功能。\n- 挂载点的意义：每个 filesystem 都有独立的 inode / block / superblock 等信息，这个文件系统要能够链接到目录树才能被我们使用。 将文件系统与目录树结合的动作我们称为 “ 挂载 ” 。 重点是：挂载点一定是目录，该目录为进入该文件系统的入口。因此并不是你有任何文件系统都能使用，必须要 “ 挂载 ” 到目录树的某个目录后，才能够使用该文件系统的。\n  - 单一文件系统不应该被重复挂载在不同的挂载点（目录）中；\n  - 单一目录不应该重复挂载多个文件系统；\n  - 要作为挂载点的目录，理论上应该都是空目录才是。\n  - 挂载了文件系统之后，原目录下的东西就会暂时的消失\n- 开机自动挂载可参考 /etc/fstab 之设置，设置完毕务必使用 mount -a 测试语法正确否；","tags":["Linux","操作系统","读书笔记"],"categories":["Linux"]},{"title":"Gacache 分布式缓存","url":"/2020/06/02/1f88320a/","content":"\n## TOC\n\n- [TOC](#toc)\n- [简介](#简介)\n- [整体流程](#整体流程)\n- [LRU 队列](#lru-队列)\n- [并发控制](#并发控制)\n- [一致性 Hash](#一致性-hash)\n  - [实现](#实现)\n- [分布式节点通信](#分布式节点通信)\n  - [Client 端](#client-端)\n  - [Server 端](#server-端)\n- [缓存击穿](#缓存击穿)\n  - [复现](#复现)\n  - [解决方案](#解决方案)\n  - [测试](#测试)\n- [热点互备](#热点互备)\n  - [思路](#思路)\n  - [测试](#测试-1)\n- [缓存穿透](#缓存穿透)\n  - [复现](#复现-1)\n  - [解决方案](#解决方案-1)\n- [TODO](#todo)\n\n## 简介\n\n本项目是模仿 [groupcache](https://github.com/golang/groupcache) 实现的一个分布式缓存库，其可以作为单独服务部署，亦可以作为一个`lib`来用，使用一致性 Hash 进行节点的选取和数据的分片，节点之间采用 http 协议进行通信，使用 [Protobuf](https://github.com/protocolbuffers/protobuf) 序列化数据进行传输，提高传输效率，节点之间支持热点数据互备，减少网络开销，同时还实现了并发访问控制机制，防止缓存击穿，相比于原项目，对热点互备的功能进行了增强\n\n> 本项目为练手项目，不可用于生产\n\n## 整体流程\n\n![mark](http://static.imlgw.top/blog/20200602/Glc7aMrySiqF.png?imageslim)\n\n## LRU 队列\n\n因为缓存的数据都是在内存中的，内存资源是有限的，所以我们需要选择一种合适的策略，在内存快要满的时候剔除部分数据，这里选择了较为平衡且实现简单的方案 LRU（最近最少使用）可以参考我之前的一篇博文 [LRU 队列的实现（Java）](http://imlgw.top/2019/11/16/lrucache/) 这里为了方便，以及避免重复造轮子，直接使用`container` 包中的`List`双向链表和`map`来实现，具体代码见 [gacache/lru/lru.go](https://github.com/imlgw/gacache/blob/master/gacache/lru/lru.go)\n\n## 并发控制\n\ngolang 中的 map 并不是并发安全的容器，并发的访问可能会出现错误，所以我们需要加锁来控制并发的读写\n\n```go\ntype cache struct {\n    mu         sync.Mutex //互斥锁\n    lru        *lru.Cache\n    cacheBytes int64\n}\n\nfunc (c *cache) put(key string, value ByteView) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    if c.lru == nil { //尚未初始化，lazyinit\n        c.lru = lru.New(c.cacheBytes, nil)\n    }\n    c.lru.Put(key, value)\n}\n\nfunc (c *cache) get(key string) (value ByteView, ok bool) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    if c.lru == nil {\n        return\n    }\n    if v, ok := c.lru.Get(key); ok {\n        return v.(ByteView), ok\n    }\n    return\n}\n```\n\n## 一致性 Hash\n\n对于一个**分布式缓存**来讲，客户端在向某一个节点请求数据的时候，该节点应该如何去获取数据呢？是自己拿，还是去其他节点拿？如果这里不做处理，让当前节点自己去数据源取数据，那么最终可能每个节点都会缓存一份数据源的数据，这样不仅效率低下（需要和 DB 交互），而且浪费了很多空间，严格来说这就称不上是**分布式缓存**了，只能称之为**缓存集群**\n\n所以我们需要一个方案能够将`key`和节点对应起来，有一种比较简单的方案就是将`key`哈希后对节点数量取余，这样每次请求都会打到同一个节点，但是这样的方案扩展性和容错性比较差，如果节点的数量发生变化可能会导致大量缓存的迁移，一瞬间大量缓存都失效了，这就可能导致缓存雪崩，所以这里我采用**一致性 Hash 算法**\n\n### 实现\n\n- 构造一个 `0 ~ 2^32-1` 大小的环\n- 服务节点经过 hash 之后将定位到环中\n- 将`key`哈希之后也定位到这个环中\n- 顺时针找到离`hash(key)`最近的一个节点，也就是最终选择的缓存节点\n- 考虑到服务节点的个数以及 hash 算法的问题导致环中的数据分布不均匀时引入了虚拟节点\n\n**一致性 Hash 的 Map**\n\n```go\ntype Map struct {\n    hash     Hash           //hash 函数\n    replicas int            //虚拟节点倍数\n    keys     []int          //节点的地址，完整的协议/ip/port [eg. http://localhost:8001]\n    hashMap  map[int]string //虚拟节点和真实节点映射关系\n}\n```\n\n**添加机器/节点的方法**\n\n```go\n//添加机器/节点\nfunc (m *Map) Add(keys ...string) {\n    //hashMap := make(map[string][]int, len(keys))\n    for _, key := range keys {\n        //每台机器 copy 指定倍数的虚拟节点\n        for i := 0; i < m.replicas; i++ {\n            //计算虚拟节点的 hash 值\n            hash := int(m.hash([]byte(strconv.Itoa(i) + key)))\n            //添加到环上\n            m.keys = append(m.keys, hash)\n            //hashMap[key] = append(hashMap[key], hash)\n            //记录映射关系\n            m.hashMap[hash] = key\n        }\n    }\n    //fmt.Println(hashMap)\n    //环上 hash 值进行排序\n    sort.Ints(m.keys)\n}\n```\n\n**Get 获取节点**\n\n因为整个环是有序的，所以可以直接通过二分去找第一个大于等于`hash(key)`的节点\n\n```go\nfunc (m *Map) Get(key string) string {\n    if len(m.keys) == 0 {\n        return \"\"\n    }\n    hash := int(m.hash([]byte(key)))\n    //二分找第一个大于等于 hash 的节点 idx\n    idx := sort.Search(len(m.keys), func(i int) bool {\n        return m.keys[i] >= hash\n    })\n    return m.hashMap[m.keys[idx%len(m.keys)]]\n}\n```\n\n## 分布式节点通信\n\n集群之间的通信通过 Http 协议，同时采用 [Protobuf](https://github.com/protocolbuffers/protobuf) 序列化数据提高传输效率\n\n### Client 端\n\n通过节点地址和`groupName`以及`key`构成的地址请求数据，通过`protobuf`解码数据\n\n```go\nfunc (h *httpGetter) Get(in *pb.Request, out *pb.Response) error {\n    u := fmt.Sprintf(\n        \"%v%v/%v\",\n        h.baseURL,\n        url.QueryEscape(in.GetGroup()),\n        url.QueryEscape(in.GetKey()),\n    )\n    //通过 http 请求远程节点的数据\n    res, err := http.Get(u)\n    if err != nil {\n        return err\n    }\n    defer res.Body.Close()\n    if res.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"server returned: %v\", res.Status)\n    }\n    //转换成 []byte\n    bytes, err := ioutil.ReadAll(res.Body)\n    if err != nil {\n        return fmt.Errorf(\"reading response body: %v\", err)\n    }\n    //解码 proto 并将结果存到 out 中\n    if err != proto.Unmarshal(bytes, out) {\n        return fmt.Errorf(\"decoding response body : %v\", err)\n    }\n    return nil\n}\n```\n\n### Server 端\n\n实现`http.Handler`接口，对缓存中其他节点暴露地址，提供服务\n\n```go\nfunc (p *HTTPPool) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    if !strings.HasPrefix(req.URL.Path, p.basePath) {\n        panic(\"HTTPPool serving unexpect path\")\n    }\n    p.Log(\"%s %s\", req.Method, req.URL.Path)\n    // basePath/groupName/key\n    // 以‘/’为界限将 groupName 和 key 划分为 2 个 part\n    parts := strings.SplitN(req.URL.Path[len(p.basePath):], \"/\", 2)\n    if len(parts) != 2 {\n        http.Error(w, \"bad request\", http.StatusBadRequest)\n        return\n    }\n    groupName := parts[0]\n    key := parts[1]\n    group := GetGroup(groupName)\n    if group == nil {\n        http.Error(w, \"no such group: \"+groupName, http.StatusNotFound)\n        return\n    }\n    view, err := group.Get(key)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    //使用 proto 编码 Http 响应\n    body, err := proto.Marshal(&pb.Response{Value: view.ByteSlice()})\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.Header().Set(\"Content-Type\", \"application/octet-stream\")\n    w.Write(body)\n}\n```\n\n## 缓存击穿\n\n一个存在的`key`突然失效，在失效的同时有大量的请求来请求这个`key`，这个时候大量请求就会直接打到 DB，导致 DB 压力变大，甚至宕机\n\n### 复现\n\n这里简单的演示缓存击穿的效果，我们用下面的脚本启动 4 个`cache server` 并且在端口号为`8004`的`server`上启动一个前端服务，用于和客户端交互\n\n```bash\nstart go run .  -port=8001\nstart go run .  -port=8002\nstart go run .  -port=8003\nstart go run .  -port=8004 -api=1\n```\n\n(windows 平台的 bat，其他平台可以用这个 [test.sh](https://github.com/imlgw/gacache/blob/master/test.sh))\n\n尝试了用 window 的批处理写并发访问的脚本，但是效果不是很好，所以直接用`go`写了个小脚本测试并发请求\n\n```go\nfunc main() {\n    for i := 0; i < 5; i++ {\n        wg.Add(1)\n        go curl(\"resolmi\")\n    }\n    wg.Wait()\n    fmt.Println(\"Done!\")\n}\n\nfunc curl(key string) {\n    res, _ := http.Get(\"http://localhost:9999/api?key=\" + key)\n    bytes, _ := ioutil.ReadAll(res.Body)\n    fmt.Println(string(bytes))\n    wg.Done()\n}\n```\n\n开启 5 个`goroutine`，并发的去请求`resolmi`，此时`cache`肯定是没有这个 key 的，所以需要到 DB 中去取\n\n然后就可以看到如下的情况：\n\n![mark](http://static.imlgw.top/blog/20200529/pU2omvLdDqyQ.png?imageslim)\n\n前台`Server`收到了 Get \"resolmi\"请求，通过一致性 Hash 选择了远程节点`port:8003`\n\n![mark](http://static.imlgw.top/blog/20200529/uovtpKufQME4.png?imageslim)\n\n可以看到，5 次请求全部打到了`SlowDB`中！！这就说明发生了缓存穿透！请求穿过了缓存层，打到 DB\n\n> 这里如果效果不明显可以尝试在`load`函数执行前加上一个`time.Sleep`，这样并发缓存击穿效果会更明显\n\n### 解决方案\n\n其实常见的方案就两种：\n\n**1. 缓存永不过期**\n\n缓存值不设置`ttl`，而是在`value`中添加一个逻辑的过期时间，这样请求就不会直接穿透到 DB，同时我们可以通过当前时间判断该 key 是否过期，如果过期了就启动一个异步线程去更新缓存，这种方式用户延迟是最低的，但是可能会造成缓存的不一致\n\n**2. 互斥锁**\n\n在第一个请求获取数据的时候设置一个`mutex`互斥锁，让其他请求阻塞，当前第一个请求请求到数据返回之后释放`mutex`锁，其他请求停止阻塞，然后直接从缓存中获取数据\n\n因为我们的项目本身是不支持`ttl`和删除操作的，所以第一种方案不太适合，所以采用第二种互斥锁的方案，实现了一个`singleflight`结构来处理缓存击穿\n\n**封装请求 call**\n\n```go\n//封装每个请求/调用\ntype call struct {\n    wg  sync.WaitGroup\n    val interface{} //请求的值\n    err error       //err\n}\n\n//singleflight 核心结构\ntype Group struct {\n    mu sync.Mutex\n    m  map[string]*call //key 与 call 的映射\n}\n```\n\n**并发控制核心代码**\n\n```go\n//并发请求控制\nfunc (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {\n    g.mu.Lock()\n    if g.m == nil {\n        g.m = make(map[string]*call)\n    }\n    if c, ok := g.m[key]; ok {\n        g.mu.Unlock() //释放锁，按顺序进来\n        c.wg.Wait()   //等着，等第一个请求完成\n        return c.val, c.err\n    }\n    c := new(call)\n    c.wg.Add(1)\n    g.m[key] = c\n    g.mu.Unlock()       //这里释放锁，让其他请求进入上面的分支中 wait（其实只有并发量大的时候才会进入上面的分支）\n    c.val, c.err = fn() //请求数据\n    c.wg.Done()         //获取到值，第一个请求结束，其他请求可以获取到值了\n    //删除 m 中的 key, 避免 key 发生变化，而取到的还是旧值\n    g.mu.Lock()\n    delete(g.m, key)\n    g.mu.Unlock()\n    return c.val, c.err\n}\n```\n\n当多个并发的请求来请求同一个`key`的时候，只有**第一个请求**能拿到锁去 DB 中取数据，其他的请求就只能在方法外阻塞，当第一个请求构造好`call`就释放锁，这个时候其他并发的请求获取锁，进入阻塞的分支释放锁，然后再次阻塞，等待**第一个请求**获取到数据并封装进与`key`对应的`call`中，然后直接返回，不再向数据库请求，从而避免了缓存击穿\n\n### 测试\n用`singleFlight`包装一下我们的`load`方法\n\n```go\nview, err := g.loader.Do(key, func() (interface{}, error) {\n    if g.peers != nil {\n        //根据一致性 Hash 选择节点 Peer\n        if peer, ok := g.peers.PickPeer(key); ok {\n            //从上面的 Peer 中获取数据\n            if value, err = g.getFromPeer(peer, key); err == nil {\n                return value, nil\n            }\n            log.Println(\"[Gacache] Fail to get from remote peer!!!\", err)\n        }\n    }\n    return g.getLocally(key)\n})\n```\n\n再次使用上面同样的脚本进行测试\n\n![mark](http://static.imlgw.top/blog/20200530/OThgxtFJrFIG.png?imageslim)\n\n可以看到 5 个请求都成功了，我们再看看`log`\n\n![mark](http://static.imlgw.top/blog/20200530/fsgxPPXNeVoo.png?imageslim)\n\n可以看到，我请求了 5 次，但是实际上`getFromPeer`从远程节点取数据只执行了一次\n\n![mark](http://static.imlgw.top/blog/20200530/ChE0FxjwlYbl.png?imageslim)\n\n从`SlowDB`的查询也只执行了一次，说明我们的`singleFlight`并发控制生效了！\n\n## 热点互备\n\n热点互备也是`groupcache`的特点之一，在源码注释中写到\n\n> hotCache contains keys/values for which this peer is not authoritative (otherwise they would be in **mainCache**), but are popular enough to warrant mirroring in this process to avoid going over the network to fetch from a peer.  Having a hotCache avoids network hotspotting, where a peer's network card could become the bottleneck on a popular key. This cache is used sparingly to maximize the total number of key/value pairs that can be stored globally.\n\n大致意思就是，`hotCache`中存储的主要是该节点没有的键值对（否则就在`mainCache`中了），但是这些键值对请求的非常频繁，所以需要保证在此过程中进行热点备份，避免通过网络从远程节点去获取，`hotCache`避免了网络热点，使节点的网卡成为热点`key`的瓶颈\n\n但是在`groupcache`中对`hotCache`的处理只是随机的存储，每次从远程节点获取数据的时候有 1/10 的概率存储到`hotCache`中（[code](https://github.com/golang/groupcache/blob/master/groupcache.go#L318)）\n\n![mark](http://static.imlgw.top/blog/20200601/A0oPStJGqht3.png?imageslim)\n\n可以看到这是一个 TODO，注释中也提到了可以使用 QPS 来判断是否是热点`key`，所以我按照这个想法写了一个简单的统计\n\n### 思路\n\n首先我们需要添加一个`hotCache`的结构，这个 cache 和`mainCache`一样，都是并发安全的`lru`队列，然后我们在向某个节点请求数据的时候就可以先从`mainCache`中请求如果没有就从`hotCache`中请求 ，如下\n\n```go\nfunc (g *Group) Get(key string) (ByteView, error) {\n    if key == \"\" {\n        return ByteView{}, fmt.Errorf(\"key nil\")\n    }\n    if v, ok := g.mainCache.get(key); ok {\n        log.Printf(\"[GaCache (mainCache)] hit\")\n        return v, nil\n    }\n    //add: hotCache\n    if v, ok := g.hotCache.get(key); ok {\n        log.Printf(\"[GaCache (hotCache)] hit\")\n        return v, nil\n    }\n    //当前节点没有数据，去其他地方加载\n    return g.load(key)\n}\n```\n\n然后封装了一个`KeyStats`的结构，用于统计`key`的请求信息\n\n```go\n//Key 的统计信息\ntype KeyStats struct {\n    firstGetTime time.Time //第一次请求的时间\n    remoteCnt    AtomicInt //请求的次数（利用 atomic 包封装的原子类）\n}\n```\n\n除此之外，还需要将`key`和`KeyStats`对应，所以需要在 cache 的核心结构`Group`中加入映射关系\n\n```go\ntype Group struct {\n    //...\n    keys map[string]*KeyStats\n}\n```\n\n然后在节点请求远程节点的时候统计请求的信息，也就是`getFromPeer`函数中\n\n```go\n//从远程节点获取数据\nfunc (g *Group) getFromPeer(peer PeerGetter, key string) (ByteView, error) {\n    //构建 proto 的 message\n    req := &pb.Request{\n        Group: g.name,\n        Key:   key,\n    }\n    res := &pb.Response{}\n    err := peer.Get(req, res)\n\n    fmt.Println(\"getFromPeer\", key)\n    if err != nil {\n        return ByteView{}, err\n    }\n    //远程获取 cnt++\n    if stat, ok := g.keys[key]; ok {\n        stat.remoteCnt.Add(1)\n        //计算 QPS\n        interval := float64(time.Now().Unix()-stat.firstGetTime.Unix()) / 60\n        qps := stat.remoteCnt.Get() / int64(math.Max(1, math.Round(interval)))\n        if qps >= maxMinuteRemoteQPS {\n            //存入 hotCache\n            g.populateCache(key, ByteView{b: res.Value}, &g.hotCache)\n            //删除映射关系，节省内存\n            mu.Lock()\n            delete(g.keys, key)\n            mu.Unlock()\n        }\n    } else {\n        //第一次获取\n        g.keys[key] = &KeyStats{\n            firstGetTime: time.Now(),\n            remoteCnt:    1,\n        }\n    }\n    return ByteView{b: res.Value}, nil\n}\n```\n\n`maxMinuteRemoteQPS`是一个常量，每个 key 每分钟远程请求最大的 QPS，每次向远程节点请求数据的时候计算当前`key`第一次获取的时间到目前为止的 QPS，如果大于阈值`maxMinuteRemoteQPS`，就会将其存入`hotCache`中，之后就可以直接从`hotCache`中获取数据，而不用在通过网络去获取\n\n### 测试\n\n同样使用前面的 go 脚本来测试\n\n```go\nfunc main() {\n    for i := 0; i < 20; i++ {\n        wg.Add(1)\n        //go curl(\"resolmi\")\n        //i not exist\n        //go curl(strconv.Itoa(i))\n        time.Sleep(500 * time.Millisecond)\n        curl(\"resolmi\")\n    }\n    wg.Wait()\n    fmt.Println(\"Done!\")\n}\n\nfunc curl(key string) {\n    res, _ := http.Get(\"http://localhost:9999/api?key=\" + key)\n    bytes, _ := ioutil.ReadAll(res.Body)\n    fmt.Println(string(bytes))\n    wg.Done()\n}\n```\n\n> 注意这里请求不要请求太快，如果一个 key 请求的太快会被`singleFlight`并发控制组件拦截，多数请求不会走网络（这个组件作用还是挺大的），所以并没有使用`goroutine`，而是正常的调用，并且中间停顿 0.5s\n\n这里为了方便模拟，我设置了 `maxMinuteRemoteQPS = 10` ，上面的脚本一分钟之内会请求`“resolmi”` 20 次，这个`key`的分片已知是远程节点（8003）的，所以会在第 10 次的时候触发`hotCache`，将数据存入当前节点（8004）的`hotCache`中，后续的请求就会直接从`hotCache`中取，如下图所演示\n\n![mark](http://static.imlgw.top/blog/20200602/hKH8u6E1gpcA.gif)\n\n可以看到效果确实达到了，但是这样做有一个比较大的缺点就是内存耗费会比原来大，需要额外维护一个 map，不过这部分信息并不大，仅仅需要存储`key`和对应`keyStats` ，key 的长度一般不会很长，`keyStats` 的长度是固定的，一个`time`和一个`int64`，所以一定程度上还是可行的。\n\n> 这种方案只是我能想到的一种比较简单的处理方法，肯定会有更好的处理方式。但是截至目前（2020.6.2）`groupcache`中没有对这里进行改进，如果以后有更新可以再学习下\n\n## 缓存穿透\n\n查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB 就会导致宕机\n\n### 复现\n\n使用上面的脚本再次启动`Cache Server`，然后用下面的 go 代码测试\n\n```go\nfunc main() {\n    for i := 0; i < 5; i++ {\n        wg.Add(1)\n        //go curl(\"resolmi\")\n        //i not exist\n        go  curl(strconv.Itoa(i))\n    }\n    wg.Wait()\n    fmt.Println(\"Done!\")\n}\n\nfunc curl(key string) {\n    res, _ := http.Get(\"http://localhost:9999/api?key=\" + key)\n    bytes, _ := ioutil.ReadAll(res.Body)\n    fmt.Println(string(bytes))\n    wg.Done()\n}\n```\n\n> 注意这里需要构造不同的 key，相同的 key 会被前面的`singleFlight`组件拦截\n\n结果如下：\n\n```go\n[ `go run .` | done: 1.8734423s ]\n  1 not exist\n  2 not exist\n  0 not exist\n  4 not exist\n  3 not exist\n  Done!\n```\n\n然后我们看看`Server`的情况\n\n![mark](http://static.imlgw.top/blog/20200531/kV5ojfIeddm4.png?imageslim)\n\n可以看到，5 个`key`通过一致性 Hash 分散到不同的节点，但是由于`DB`中根本就没有这些数据，所以这些数据并不会缓存，每次查询都会到`DB`中去重新查询，如果短时间内有大量请求查询这些根本不存在的数据，那么这些请求都会直接打到 DB 层，将 DB 层压垮！\n\n### 解决方案\n\n**1. 缓存空对象**\n\n之所以发生缓存穿透，是因为缓存中没有存储这些空数据的 key，导致这些请求全都打到数据库上。那么，我们可以稍微修改一下业务层的代码，将数据库查询结果为空的 key 也存储在缓存中。当后续又出现该 key 的查询请求时，缓存直接返回 null，而无需查询数据库。\n\n**2. 布隆过滤器**\n\n当业务层有查询请求的时候，首先去`BloomFilter`中查询该 key 是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回 null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。\n\n这里第一个种方案可以直接排除，一方面因为我们这个 cache 是不能删除数据的，只能被动的淘汰数据，缓存大量的空对象且得不到及时的删除会浪费大量内存，另一方面，缓存空对象的做法，如果每次查询的不存在的`key`都不一样，那么这种方案也就起不到作用了\n\n至于第二种方案，可行，但是不应该在缓存层来做，应该在业务层处理，也就是在上层处理，因为这是一个分布式的缓存组件，每个节点的数据都是不一样的，用布隆过滤器你只能判断在**当前节点**有没有，无法判断**远程节点**有没有，所以一开始就要将所有数据预热到布隆过滤器中，但是这样每一个节点都会需要一个布隆过滤器，这样做没有任何意义，所以缓存穿透的问题应该放到应用层去处理\n\n## TODO\n\n- [x] 分布式节点通信\n- [x] 一致性 Hash\n- [x] 缓存击穿\n- [x] 热点互备\n- [ ] 配置解耦\n- [ ] 集群管理\n","tags":["开源项目","Gacache"],"categories":["Web"]},{"title":"Linux 文件权限和目录配置","url":"/2020/05/27/91d3cf25/","content":"\n> 本文全文摘抄自《鸟叔的 LInux 私房菜》，对部分用词做了转换，仅保留了我感兴趣的部分，便于以后查找\n\n## Linux 文件属性\n\n`ls -al：` ls 是 “list” 的意思，重点在显示文件的文件名与相关属性。而选项 “-al” 则表示列出所有的文件详细的权限与属性 （包含隐藏文件，就是文件名第一个字符为 “ . ” 的文件）\n\n![YIhreU.png](https://s1.ax1x.com/2020/05/19/YIhreU.png)\n\n- 第一栏代表这个文件的类型与权限（ permission ）\n    - 第一个字符代表这个文件是 “ 目录、文件或链接文件等等 ” ：\n      - 当为 `[ d ]` 则是目录，例如上表文件名为 “boot” 的那一行；\n      - 当为 `[ - ]` 则是文件，例如上表文件名为 “.autorelabel” 那一行；\n      - 若是 `[ l ]` 则表示为链接文件（ link file ）；\n      - 若是 `[ b ]` 则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；\n      - 若是 `[ c ]` 则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。\n\n    - 接下来的字符中，以三个为一组，且均为 “`rwx`” 的三个参数的组合。其中， [ r ] 代表可读（ read ）、 [ w ] 代表可写（ write ）、 [ x ] 代表可执行（ execute ）。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 [ - ] 而已。\n\n      - 第一组为 “ 文件拥有者可具备的权限 ” ，以 “.autorelabel” 那个文件为例， 该文件的拥有者可以读-\n\n        写，但不可执行；\n\n      - 第二组为 “ 加入此群组之后帐号的权限 ” ；\n\n      - 第三组为 “ 非本人且没有加入本群组之其他帐号的权限 ” 。\n\n- 第二栏表示有多少文件名链接到此节点（ i-node ）\n\n- 第三栏表示这个文件（或目录）的 “ 拥有者帐号 ”\n\n- 第四栏表示这个文件的所属群组\n\n- 第五栏为这个文件的容量大小，默认单位为 Bytes \n\n- 第六栏为这个文件的创建日期或者是最近的修改日期：\n\n    > 有的年代过于久远的可能只会显示年份，如果想要显示完整的时间格式，可以利用 ls 的选项，亦即： “ls -l --full-time” 就能够显示出完整的时间格式了！包括年、月、日、时间\n\n- 第七栏为这个文件的文件名\n\n  这个字段就是文件名了。比较特殊的是：如果文件名之前多一个 “ . ” ，则代表这个文件为 “ 隐藏文件 ” ，例如上表中的 .autorelabel 那一行，该文件就是隐藏文件，使用 `-a`可以查看到\n\n### 改变文件属性\n\n#### 改变所属群组 , chgrp\n\n改变一个文件的群组真是很简单的，直接以 chgrp 来改变即可，咦！这个指令就是 change group 的缩写嘛！这样就很好记了吧！ ^_^ 。不过，请记得，要被改变的群组名称必须要在 /etc/group 文件内存在才行，否则就会显示错误， -R 可以递归更改权限\n\n#### 改变文件拥有者 , chown\n\n如何改变一个文件的拥有者呢？很简单呀！既然改变群组是 change group ，那么改变拥有者就是 change owner 啰！ BINGO ！那就是 chown 这个指令的用途，要注意的是， 使用者必须是已经存在系统中的帐号，也就是在 /etc/passwd 这个文件中有纪录的使用者名称才能改变。-R 可以递归更改权限\n\nchown 还可以顺便直接修改群组的名称 ：“ `chown user.group file`”，亦即在拥有者与群组间加上小数点\n\n> 知道如何改变文件的群组与拥有者了，那么什么时候要使用 chown 或 chgrp 呢？或许你会觉得奇怪吧？ 是的，确实有时候需要变更文件的拥有者的，最常见的例子就是在复制文件给你之外的其他人时，cp 复制了文件但是属性并没有变，这个时候别人仍然看不见，所以需要修改文件属性\n\n#### 改变权限 , chmod\n\n- 数字类型改变文件权限\n\n  Linux 文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己的 read/write/execute 权限， 先复习一下刚刚上面提到的数据：文件的权限字符为： “-rwxrwxrwx” ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\n\n  | r    | 4    |\n  | ---- | ---- |\n  | w    | 2    |\n  | x    | 1    |\n\n  每种身份（ owner/group/others ）各自的三个权限（ r/w/x ）分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：\n  owner = rwx = 4+2+1 = 7\n  group = rwx = 4+2+1 = 7\n  others= --- = 0+0+0 = 0\n  所以等一下我们设置权限的变更时，该文件的权限数字就是 770 啦\n\n  命令：`chmod [-R] xyz 文件或目录`\n\n- 符号类型改变文件权限\n\n  还有一个改变权限的方法呦！从之前的介绍中我们可以发现，基本上就九个权限分别是（ 1 ） user （ 2 ） group （ 3 ） others 三种身份啦！那么我们就可以借由 u, g, o 来代表三种身份的权限！此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成 r, w, x 啰！+ （加入），-（除去） ，=（设置）\n\n  > '+'与'–'的状态下，只要是没有指定到的项目，则该权限 “ 不会被变动 ” ，而=是直接设置\n\n  命令：`chmod u+x file` ，`chmod u=x,g=rw file`\n\n#### 权限的意义\n\n**文件的权限**\n\n- r （ read ）：可读取此一文件的实际内容，如读取文本文件的文字内容等\n- w （ write ）：可以编辑、新增或者是修改该文件的内容（**但不含删除该文件**）\n- x （ execute ）：该文件具有可以被系统执行的权限\n\n**目录的权限**\n\n- r （ read contents in directory ）：表示具有读取目录结构清单的权限，所以当你具有读取（ r ）一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来\n\n- w （ modify contents of directory ）：这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有改变该目录结构的权限，也就是下面这些权限：创建新的文件与目录；**删除已经存在的文件与目录**（不论该文件的权限为何！）将已存在的文件或目录进行更名；搬移该目录内的文件、目录位置。总之，目录的 w 权限就与该目录下面的文件名改变有关就对了啦！\n\n  > 自己测试了一下，开了 w 还是不能删也不能加也不能改，实际上这里书上没有介绍清楚，这个 w 权限只有在 x 权限打开之后才有用（其实想一下就知道了，如果 w 有这么多权限，那还要 x 干嘛）\n\n- x （ access directory ）：能否进入目录（cd）\n\n## FHS\n\n### 根目录 （ / ） 的意义与内容：\n\n因此 FHS 定义出根目录（ / ）下面应该要有下面这些次目录的存在才好，即使没有实体目录， FHS 也希望至少有链接文件存在才好\n**FHS 要求必须要存在的目录**\n\n- `/bin:` 系统有很多放置可执行文件的目录，但 /bin 比较特殊。因为 /bin 放置的是在单人维护模式下还能够被操作的指令。 在 /bin 下面的指令可以被 root 与一般帐号所使用，主要有： cat, chmod, chown, date, mv, mkdir, cp, bash 等等常用的指令。\n- `/boot:` 这个目录主要在放置开机会使用到的文件，包括 Linux 核心文件以及开机菜单与开机所需配置文件等等。 Linux kernel 常用的文件名为： vmlinuz ，如果使用的是 grub2 这个开机管理程序， 则还会存在 /boot/grub2/ 这个目录\n- `/dev:` 在 Linux 系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。 你只要通过存取这个目录下面的某个文件，就等于存取某个设备啰～ 比要重要的文件有 /dev/null, /dev/zero, /dev/tty, /dev/loop, /dev/sd 等等\n- `/etc:` 系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码、 各种服务的配置等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有 root 有权力修改。 FHS 建议不要放置可可执行文件（ binary ）在这个目录中喔。比较重要的文件有： /etc/modprobe.d/, /etc/passwd, /etc/fstab 等等\n- `/lib:`系统的函数库非常的多，而 /lib 放置的则是在开机时会用到的函数库， 以及在 /bin 或 /sbin 下面的指令会调用的函数库而已。什么是函数库呢？你可以将他想成是 “ 外挂 ” ，某些指令必须要有这些 “ 外挂 ” 才能够顺利完成程序的执行之意。 另外 FSH 还要求下面的目录必须要存在：/lib/modules/ ：这个目录主要放置可抽换式的核心相关模块（驱动程序）喔！\n- `/media: `media 是 “ 媒体 ” 的英文，顾名思义，这个 /media 下面放置的就是可移除的设备啦！ 包括软盘、光盘、 DVD 等等设备都暂时挂载于此。常见的文件名有： /media/floppy, /media/cdrom 等等。\n- `/mnt:` 如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与 /media 相同，只是有了 /media 之后，这个目录就用来暂时挂载用了\n- `/opt:` 这个是给第三方软件放置的目录。什么是第三方软件啊？ 举例来说， KDE 这个桌面管理系统是一个独立的软件，不过他可以安装到 Linux 系统中，因此 KDE 的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的 distribution 提供的），那么也能够将你的软件安装到这里来。 不过，以前的 Linux 系统中，我们还是习惯放置在 /usr/local 目录下\n- `/run:`早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！\n- `/sbin:` Linux 有非常多指令是用来设置系统环境的，这些指令只有 root 才能够利用来 “ 设置 ” 系统，其他使用者最多只能用来 “ 查询 ” 而已。 放在 /sbin 下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到 /usr/sbin/ 当中。至于本机自行安装的软件所产生的系统可执行文件（ system binary ）， 则放置到 /usr/local/sbin/ 当中了。常见的指令包括： fdisk, fsck, ifconfig, mkfs 等等。\n- `/srv:` srv 可以视为 “service” 的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如 WWW, FTP 等等。举例来说， WWW 服务器需要的网页数据就可以放置在 /srv/www/ 里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。\n- `/tmp:` 这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为 FHS 甚至建议在开机时，应该要将 /tmp 下的数据都删除\n\n**FHS 建议可以存在的目录**\n\n- `/home:`这是系统默认的使用者主文件夹（ home directory ）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来。比较重要的是，主文件夹有两种代号喔：\n  ~ ：代表目前这个使用者的主文件夹\n  ~dmtsai ：则代表 dmtsai 的主文件夹！\n- `/root:`系统管理员（ root ）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有 root 的主文件夹，所以我们会希望 root 的主文件夹与根目录放置在同一个分区中。\n  事实上 FHS 针对根目录所定义的标准就仅有上面的，不过我们的 Linux 下面还有许多目录你也需要了解一下\n- `/lost+found:` 这个目录是使用标准的 ext2/ext3/ext4 文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！\n- `/proc:` 这个目录本身是一个 “ 虚拟文件系统（ virtual filesystem ） ” 喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（ process ）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！\n  比较重要的文件例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。\n- `/sys:` 这个目录其实跟 /proc 非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！\n\n早期 Linux 在设计的时候，若发生问题时，救援模式通常仅挂载根目录而已，因此有五个重要的目录被要求一定要与根目录放置在一起， 那就是 `/etc`, `/bin`, `/dev`, `/lib`, `/sbin` 这五个重要目录。现在许多的 Linux distributions 由于已经将许多非必要的文件移出 /usr 之外了， 所以 /usr 也是越来越精简，同时因为 /usr 被建议为 “ 即使挂载成为只读，系统还是可以正常运行 ” 的模样，所以救援模式也能同时挂载 /usr 喔！ 例如，我们的这个 CentOS 7.x 版本在救援模式的情况下就是这样。因此那个五大目录的限制已经被打破了呦！例如 CentOS 7.x 就已经将 /sbin, /bin,  /lib 通通移动到 /usr 下面了\n\n### /usr 的意义与内容：\n\n​\t依据 FHS 的基本定义， /usr 里面放置的数据属于可分享的与不可变动的（ shareable, static ）， 如果你知道如何通过网络进行分区的挂载（例如在服务器篇会谈到的 NFS 服务器），那么 /usr 确实可以分享给区域网络内的其他主机来使用\n​\t很多读者都会误会 /usr 为 user 的缩写，其实 usr 是 Unix Software Resource 的缩写， 也就是 “Unix 操作系统软件资源 ” 所放置的目录，而不是使用者的数据，这点要注意。 FHS 建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。\n因为是所有系统默认的软件（ distribution 发布者提供的软件）都会放置到 /usr 下面，因此这个目录有点类似 Windows 系统的 “C:\\Windows\\ （当中的一部份） + C:\\Program files\\” 这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说， /usr 的次目录建议有下面这些：\n\n **FHS 要求必须要存在的目录**\n\n- `/usr/bin/:`所有一般用户能够使用的指令都放在这里！目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用链接文件的方式将 /bin 链接至此！ 也就是说， /usr/bin 与 /bin 是一模一样了！另外， FHS 要求在此目录下不应该有子目录！\n- `/usr/lib/:`  基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！/usr/local/\n  系统管理员在本机自行安装自己下载的软件（非 distribution 默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的 distribution 提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于 /usr/local/ 目录下，可与原先的旧版软件有分别啦！ 你可以自行到 /usr/local 去看看，该目录下也是具有 bin, etc, include,lib... 的次目录喔！\n- `/usr/sbin/:` 非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（ daemon ）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。\n- `/usr/share/:`主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据，因为几乎都是文字文件\n\n**FHS 建议可以存在的目录**\n\n- `/usr/games/:` 与游戏比较相关的数据放置处\n- `/usr/include/:` c/c++ 等程序语言的文件开始（ header ）与包含档（ include ）放置处，当我们以 tarball 方式 （ *.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！\n- `/usr/libexec/:` 某些不被一般使用者惯用的可执行文件或脚本（ script ）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。\n- `/usr/lib<qual>/` 与 `/lib<qual>/` 功能相同，因此目前 `/lib<qual>` 就是链接到此目录中\n- `/usr/src/:`  一般源代码建议放置到这里， src 有 source 的意思。至于核心源代码则建议放置到 /usr/src/linux/ 目录下\n\n### /var 的意义与内容：\n\n如果 /usr 是安装时会占用较大硬盘容量的目录，那么 /var 就是在系统运行后才会渐渐占用硬盘容量的目录。 因为 /var 目录主要针对常态性变动的文件，包括高速缓存（ cache ）、登录文件（ log file ）以及某些软件运行所产生的文件， 包括程序文件（ lock file, run file ），或者例如 MySQL 数据库的文件等等。常见的次目录有：\n\n **FHS 要求必须要存在的目录**\n\n- `/var/cache/:` 应用程序本身运行过程中会产生的一些暂存盘；\n- `/var/lib/:` 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说， MySQL 的数据库放置到 /var/lib/mysql/ 而 rpm 的数据库则放到 /var/lib/rpm 去！\n- `/var/lock/:` 某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（ lock ），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在\n  烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中！\n- `/var/log/:` 重要到不行！这是登录文件放置的目录！里面比较重要的文件如 /var/log/messages, /var/log/wtmp （记录登陆者的信息）等。\n- `/var/mail/:` 放置个人电子邮件信箱的目录，不过这个目录也被放置到 /var/spool/mail/ 目录中！ 通常这两个目录是互为链接文件啦！\n- `/var/run/:`某些程序或者是服务启动后，会将他们的 PID 放置在这个目录下喔！至于 PID 的意义我们会在后续章节提到的。 与 /run 相同，这个目录链接到 /run 去了！\n- `/var/spool/:` 这个目录通常放置一些队列数据，所谓的 “ 队列 ” 就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到 /var/spool/mail/ 中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到 /var/spool/mqueue/ 中， 等到被送出后就被删除。如果是工作调度数据（ crontab ），就会被放置\n  到 /var/spool/cron/ 目录中！\n\n## 参考\n\n[FHS3.0](https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf)\n","tags":["Linux"],"categories":["Linux"]},{"title":"KMP 算法","url":"/2020/05/13/2da0528d/","content":"\n## 前言\n\n之前大一的时候写过一篇关于 KMP 的博客，写的也是乱七八糟的，自己看着都费劲，最近看左神的书《程序员代码面试指南》有讲，重新学了一遍，感觉写的还是挺好的，这篇就不从 0 开始讲解`KMP`了，简单说一些要点，方便以后回顾\n\n> 我记得大一为了搞懂 kmp 好像花了挺长时间的，网上翻各种博客，搞了大半天吧，结果还是没咋搞清楚，前几天看书大概只花了一个小时左右就都搞清楚了，可能是左神写的比较好吧😂\n\n## next 数组是什么？\n\n`kmp`最关键的地方就是这个`next`数组了，`next`数组就是各个子串的前缀后缀最大匹配（相等）长度，具体一点就是`next[i]`代表的就是子串`i`位置前字符（不包括`i`位置）的前后缀最大匹配长度\n\n举个例子： 子串`abababc`  \n\nnext[3] = \"aba\" 的前后缀最大匹配长度 = 1 （开头的 a 和结尾的 a 匹配）\n\nnext[6]= \"ababab\" 的前后缀最大匹配长度 = 4 （开头的 abab 和结尾的 abab 匹配）\n\n## next 数组的作用？\n\n他的作用其实就是在两个字符串比较失配的时候避免目标串回溯，常规的暴力匹配在字符失配的时候就会回退到首字符重新匹配，整体时间复杂度就是`O(m*n)`，而 next 数组就是为了避免回退，简单举一个例子\n\n![mark](http://static.imlgw.top/blog/20200513/ugvgLhmyaeBr.png?imageslim)\n\n用 PPT 简单的画了个图（PPT 真好用），当匹配到**母串和子串**`index=6`的位置时，发现两者的字符不相同，按照暴力匹配，下一步就是母串回溯到`index=1`也就是 b 字符位置，子串回溯到首字符，重新开始匹配，直到匹配到子串，或者匹配完母串所有子串，但是当我们有了`next`数组，我们的母串就不必再回退了，而子串也不必再回退到首字符了，图中的黄色下划线和绿色下划线代表的就是**子串 index=6 **位置前的最长前后缀匹配长度，也就是`ababab`的**最长前后缀匹配字符**，当子串 index=6 位置的字符匹配不上的时候我们我们就可以直接将`index`跳到`next[6]`，也就是将子串索引移动到 index=4 的位置，就变成下面这样\n\n![mark](http://static.imlgw.top/blog/20200513/6sBvml0hXrr6.png?imageslim)\n\n母串并没有回退，继续匹配`母串 index=6`和子串`index=4`位置的元素，然后重复上面的过程\n\n## 为什么子串可以直接滑动 next[i] 步？\n\n前面我们知道了如何使用`next`数组，但是为什么子串可以一下子从滑动到`next[i]`位置呢？万一中间有能匹配的字符不就滑过了么？\n\n我们假设在母串中间存在某一个位置能匹配出子串，且该位置在**子串最长匹配后缀之前**，也就是说这部分**比当前的最长前后缀匹配长度还要长**对应到下图就是黑色虚线框框出来的部分\n\n![mark](http://static.imlgw.top/blog/20200513/EbC0E1JvbkHh.png?imageslim)\n\n既然能从这个位置匹配出子串，那么说明我的**子串的前缀**和这一部分相等，同时，由于失配前子串和母串是完全匹配的，所以我**子串的后缀**和这一部分肯定也是相等的，诶？我子串前后缀都和这部分相等，那它肯定是我的匹配前后缀啊，但是这部分又比我的最长前后缀长度要长，是不是矛盾了？所以原假设是不成立的，不存在这样的位置！所以子串可以放心的滑到`next[i]`位置\n\n## next 数组如何求？\n\n说了这么多 next 数组，那么 next 数组究竟怎么求呢？其实整个的求解过程有点像动态规划，有一些细节需要注意下\n\n> 想起来了再写\n\n## 时间复杂度为什么是线性的？\n\n> 想起来了再写\n\n## 例题\n\n### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)\n\n实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 （从 0 开始）。如果不存在，则返回  **-1**。\n\n**示例 1:**\n\n```java\n输入：haystack = \"hello\", needle = \"ll\"\n输出：2\n```\n\n**示例 2:**\n\n```java\n输入：haystack = \"aaaaa\", needle = \"bba\"\n输出：-1\n```\n\n**说明：**\n\n当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n\n对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与 C 语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java 的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。\n\n**解法一**\n\n标注的是简单，很多人都是直接调的 API，但是我感觉没啥意义，所以这题应该直接上 kmp\n\n```java\npublic int strStr(String haystack, String needle) {\n    if(needle==null || needle.length()<=0) return 0;\n    if(haystack==null ||haystack.length()<=0) return -1;\n    int[] next=getNext(needle);\n    int tidx=0,sidx=0;\n    while (sidx<haystack.length() && tidx<needle.length()) {\n        if(needle.charAt(tidx) == haystack.charAt(sidx)){\n            tidx++;sidx++;\n            if(tidx==needle.length()){\n                return sidx-tidx;\n            }\n        }else if(next[tidx]==-1){\n            //完全失配 sidx 需要后移\n            sidx++;\n        }else{\n            tidx=next[tidx];\n        }\n    }\n    return -1;\n}\n\n//求 t 的 next\n//abadabac\n//ac\npublic int[] getNext(String t){\n    int[] next= new int[t.length()];\n    next[0]=-1;\n    if(t.length()<=1) return next;\n    next[1]=0;\n    int left=0,right=2;\n    while(right<t.length()){\n        if(t.charAt(left)==t.charAt(right-1)){\n            left++;\n            next[right++]=left;\n        }else if(next[left]==-1){ //无法匹配了\n            right++; //next[right]=0\n        }else{\n            left=next[left];\n        }\n    }\n    return next;\n}\n```\n没啥好说的，裸 kmp\n\n### [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)\n\n给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过 10000。\n\n**示例 1:**\n\n```java\n输入：\"abab\"\n\n输出：True\n\n解释：可由子字符串 \"ab\" 重复两次构成。\n```\n\n**示例 2:**\n\n```java\n输入：\"aba\"\n\n输出：False\n```\n\n**示例 3:**\n\n```java\n输入：\"abcabcabcabc\"\n\n输出：True\n\n解释：可由子字符串 \"abc\" 重复四次构成。 （或者子字符串 \"abcabc\" 重复两次构成。)\n```\n\n**解法一**\n\n这题标注的也是简单，确实暴力的解法不难想到，但是复杂度比较高，所以就直接上 kmp\n\n```java\n//20ms，做复杂了，构造了一个 s+s 然后去掉头，再在里面 kmp 找\npublic boolean repeatedSubstringPattern(String s) {\n    if(s==null || s.length()<=0) return false;\n    String t=s+s;\n    int[] next=getNext(s);\n    int i=0,j=1; //去掉头\n    while(i<s.length() && j<t.length()){\n        if(s.charAt(i)==t.charAt(j)){\n            i++;j++;\n        }else if(next[i]==-1){\n            j++;\n        }else{\n            i=next[i];\n        }\n    }\n    return j-i!=s.length();\n}\n\npublic int[] getNext(String s){\n    if(s.length()==1){\n        return new int[]{-1};\n    }\n    int[] next=new int[s.length()];\n    next[0]=-1;\n    next[1]=0;\n    int left=0,right=2; \n    while(right<s.length()){\n        if(s.charAt(left)==s.charAt(right-1)){\n            next[right++]=++left;\n        }else if(next[left]==-1){\n            next[right++]=0;\n        }else{\n            left=next[left];\n        }\n    }\n    return next;\n}\n```\n这个解法其实构造了一个`s+s`的字符`t`，然后去掉头，在`t[1:]`中找原`s`，最后找到的位置只要不是`s+s`连接处，也就是`s.length()`位置，那么就肯定是重复的有循环的，其实这个结论在写的时候并没有证明，完全是猜的😂，简单证明下，一图胜前言\n\n![mark](http://static.imlgw.top/blog/20200513/O4Nmz343e9Li.png?imageslim)\n\n**解法二**\n\n其实只需要构造 next 数组，根据 next 数组就可以判断是不是重复的，我们看几组数据\n\n```java\n   s:  a b c a b c a b c a b c \\0\nnext: -1 0 0 0 1 2 3 4 5 6 7 8  9\n   s:  a a b a b d \\0\nnext: -1 0 1 0 1 0  0\n   s:  a b c d a b \\0\nnext: -1 0 0 0 0 1 2 \n```\n\n相比常规的 KMP 算法，我们在字符最后最后也加了`next`位，其实是为了区别下面的情况\n\n```\n   s:  a b a b \\0\nnext: -1 0 0 1 2\n   s:  a b a c \\0\nnext: -1 0 0 1 0\n```\n\n然后我们就可以发现，next 数组在过了一定的范围后就开始逐渐递增了，而这个递增的拐点就是在第一个循环节结束的时候，至于为什么我就不详细证明了，其实也很好想因为过了循环节，后面的都是和前面重复的，所以每多一个字符`next[i]=next[i-1]+1`，所以我们用字符的长度减去`next[slen]`就可以得到循环结的长度，我们只需要验证这个循环节能否被`s`字符串长度整除就可以了，同时需要防止循环节长度等于字符串长度的情况\n\n```java\npublic boolean repeatedSubstringPattern(String s) {\n    if(s==null || s.length()<=1) return false;\n    int[] next=getNext(s);\n    int replen=s.length()-next[s.length()];\n    //循环结长度等于字符长度\n    return replen!=s.length() && s.length()%replen==0;\n}\n\npublic int[] getNext(String s){\n    if(s.length()==1){\n        return new int[]{-1};\n    }\n    int[] next=new int[s.length()+1];\n    next[0]=-1;\n    next[1]=0;\n    int left=0,right=2; \n    while(right<=s.length()){\n        if(s.charAt(left)==s.charAt(right-1)){\n            next[right++]=++left;\n        }else if(next[left]==-1){\n            next[right++]=0;\n        }else{\n            left=next[left];\n        }\n    }\n    return next;\n}\n```\n\n实在不行把这个记住就行了，反正我是记住了😂（过几天就忘了\n\n### [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)\n\n给定一个字符串 ***s***，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\n\n**示例 1:**\n\n```java\n输入：\"aacecaaa\"\n输出：\"aaacecaaa\"\n```\n\n**示例 2:**\n\n```java\n输入：\"abcd\"\n输出：\"dcbabcd\"\n```\n\n**解法一**\n\n这题很关键的一个点就是最短回文串其实就是原字符`s`，减去`s[0]`开头的最长回文串，剩下的部分再放到`s`前，这就是最短回文串\n\n所以问题就变成了如何求`s[0]`开头的最长回文串，朴素的思路可以使用中心扩散法，枚举所有的字符和间隙，或者使用\"马拉车\"，等高效算法，这里不多介绍，主要介绍 kmp 的做法\n\n我们把`s`串翻转变成`rs`，然后将两部分拼接起来变为`s+rs`，这个时候我们要求`s[0]`开头的最长回文子串，实际上就变成了求`s+rs`的最长公共前后缀\n\n![mark](http://static.imlgw.top/blog/20200518/CtFIYht31mIL.png?imageslim)\n\n这里还有一点需要注意，就是`s+rs`的中间应该加分隔符，这是为了避免公共前后缀过长，甚至比原字符`s`还要长，这肯定是不对的，就比如`aaaaaaa`这样的 case，加了分割符之后最长的前后缀就不会超过`s`了，\n\n```java\npublic String shortestPalindrome(String s) {\n    String rs=new StringBuilder(s).reverse().toString();\n    //#是为了避免前后缀过长超过原字符 s 的长度，比如 aaaaaaa 这种\n    String t=s+\"#\"+rs; \n    int[] next=new int[t.length()+1];\n    next[0]=-1;\n    next[1]=0;\n    int left=0;\n    int i=2;\n    while(i<=t.length()){\n        if(t.charAt(i-1)==t.charAt(left)){\n            next[i++]=++left;\n        }else if(next[left]==-1){\n            next[i++]=0;\n        }else{\n            left=next[left];\n        }\n    }\n    //System.out.println(next[t.length()]);\n    return rs.substring(0,s.length()-next[t.length()])+s;\n}\n```\n\n### [1392. 最长快乐前缀](https://leetcode-cn.com/problems/longest-happy-prefix/)\n\n「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。\n\n给你一个字符串 s，请你返回它的**最长快乐前缀**。\n\n如果不存在满足题意的前缀，则返回一个空字符串。\n\n**示例 1：**\n\n```java\n输入：s = \"level\"\n输出：\"l\"\n解释：不包括 s 自己，一共有 4 个前缀（\"l\", \"le\", \"lev\", \"leve\"）和 4 个后缀（\"l\", \"el\", \"vel\", \"evel\"）。最长的既是前缀也是后缀的字符串是 \"l\" 。\n\n```\n**示例 2：**\n\n```java\n输入：s = \"ababab\"\n输出：\"abab\"\n解释：\"abab\" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。\n```\n**示例 3：**\n\n```java\n输入：s = \"leetcodeleet\"\n输出：\"leet\"\n```\n**示例 4：**\n\n```java\n输入：s = \"a\"\n输出：\"\"\n```\n\n**提示：**\n- 1 <= s.length <= 10^5\n- s 只含有小写英文字母\n\n**解法一**\n\n最近某次周赛的 T4，没参加，今天看见群里有人提到了，看了下发现是裸 KMP... 正好复习下，结果写出 bug 了。\n\n```golang\nfunc longestPrefix(s string) string {\n    if len(s) == 1 {\n        return \"\"\n    }\n    //裸 KMP\n    next := make([]int, len(s)+1)\n    next[0] = -1\n    next[1] = 0\n    var left = 0\n    var i = 2\n    for i <= len(s) {\n        if s[i-1] == s[left] {\n            left++\n            next[i] = left\n            i++\n        } else if next[left] == -1 {\n            i++\n        } else {\n            left = next[left]\n        }\n    }\n    return s[0:next[len(s)]]\n}\n```\n确实也长时间没有复习 kmp 了，kmp 的细节几乎都忘了，上面的都是凭借着一点理解和记忆写的\n> 检查了前面 kmp 的写法，稍微改进了一下，目前统一了写法\n\n### [796. 旋转字符串](https://leetcode-cn.com/problems/rotate-string/)\n\n给定两个字符串，`A` 和 `B`。\n\n`A` 的旋转操作就是将 `A` 最左边的字符移动到最右边。 例如，若 `A = 'abcde'`，在移动一次之后结果就是`'bcdea'` 。如果在若干次旋转操作之后，`A` 能变成`B`，那么返回`True`。\n\n```java\n示例 1:\n输入：A = 'abcde', B = 'cdeab'\n输出：true\n```\n```java\n示例 2:\n输入：A = 'abcde', B = 'abced'\n输出：false\n```\n\n**注意：**\n\n*   `A` 和 `B` 长度不超过 `100`。\n\n**解法一**\n\n经典 easy 题当 hard 做，这个题数据量很小，直接暴力就行了，但是我们还是要追求更好的解法\n\n一开始是在一篇文章中看到了这个题，里面说了这个题是 kmp，我看了下没想到什么好的思路，只想到了一个 NlogN 的做法，二分+kmp 找旋转点，然后 kmp 判断旋转点后时候也存在于 A 字符中（类似二分答案）\n```golang\n//不够聪明的做法：二分+KMP 时间复杂度 O(NlogN)\nfunc rotateString(A string, B string) bool {\n    if len(A) != len(B) {\n        return false\n    }\n    if A == B {\n        return true\n    }\n    var left = 0\n    var right = len(B) - 1\n    var rotate = -1\n    //二分找旋转点\n    for left <= right {\n        mid := left + (right-left)/2\n        if kmp(A, B[:mid+1]) != -1 {\n            rotate = mid\n            left++\n        } else {\n            right--\n        }\n    }\n    if rotate == -1 {\n        return false\n    }\n    return kmp(A, B[rotate+1:]) != -1\n}\n\nfunc kmp(A string, t string) int {\n    var next = getNext(t)\n    var Ai = 0\n    var ti = 0\n    for Ai < len(A) && ti < len(t) {\n        if A[Ai] == t[ti] {\n            Ai++\n            ti++\n        } else if next[ti] == -1 {\n            Ai++\n        } else {\n            ti = next[ti]\n        }\n    }\n    if ti == len(t) {\n        return Ai - 1\n    }\n    return -1\n}\n\nfunc getNext(t string) []int {\n    if len(t) < 2 {\n        return []int{-1}\n    }\n    var next = make([]int, len(t))\n    var left = 0\n    next[0] = -1\n    next[1] = 0\n    var i = 2\n    for i < len(t) {\n        if t[left] == t[i-1] {\n            left++\n            next[i] = left\n            i++\n        } else if next[left] == -1 {\n            i++\n        } else {\n            left = next[left]\n        }\n    }\n    return next\n}\n```\n\n**解法二**\n\n看了评论区的大佬的做法，实际上`A+A`就包含了所有的旋转`A`的结果子串，`A+A`就相当于首位相连，所以我们可以直接在`A+A`中 kmp 找`B`就可以了，时间复杂度`O(N)`\n\n```golang\n//聪明的解法：A+A 包含了所有可能的旋转情况，直接对 A+A 和 B 做 kmp 就行了\n//abcdeabcde\nfunc rotateString(A string, B string) bool {\n    if len(A) != len(B) {\n        return false\n    }\n    if A == B {\n        return true\n    }\n    return kmp(A+A, B) != -1\n}\n```","tags":["算法","数据结构"],"categories":["算法"]},{"title":"并查集","url":"/2020/02/02/c517589e/","content":"\n## 并查集\n\n在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：\n\n### UF 接口\n\n```java\npublic interface UF{\n    int getSize(); //获取并查集的大小\n    boolean isConnected(int p,int q); //是否连接\n    void unionElement(int p,int q); //合并两个集合\n}\n```\n\n### UnionFind1-QuickFind\n\n按照朴素的思路写出的并查集\n\n```java\npublic class UnionFind1 implements UF{\n\n    private int[] id; //集合 ids\n\n    public UnionFind1(int size){\n        id=new int[size];\n        for (int i=0;i<size;i++) {\n            id[i]=i;\n        }\n    }\n\n    public int getSize(){\n        return id.length;\n    }\n\n    //p 所属的集合 ID\n    private int find(int p){\n        if (p<0 && p>=id.length) {\n            throw new IllegalArgumentException(\"p is out....\");\n        }\n        return id[p];\n    }\n    \n    //判断集合 ID 是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        for (int i=0;i<id.length;i++) {\n            if (id[i]==qID) {\n                id[i]=pID;\n            }\n        }\n    }\n}\n```\n\n初始化的时候每个元素都是不同的集合 ID\n\n`find`操作会返回他们所属集合 ID，时间复杂度`O(1)`\n\n`isConnected`会判断两个元素的集合 ID 是不是相同的，时间复杂度也是`O(1)`\n\n而`unionElement` 合并操作就是遍历整个集合，将集合 ID 等于其中一个的改成另一个，时间复杂度`O(N)`\n\n> 这种方式属于快速查找，但是合并的效率太低了，我们还可以继续优化下\n\n### UnionFind2-QuickUnion\n\n这一次我们不记录每个元素所属的集合 ID，我们记录每个元素的父元素的 ID，根节点一样的元素就是一个集合，这样就形成了一颗奇怪的树，由子节点指向父节点的树（森林）\n\n```java\npublic class UnionFind2 implements UF{\n\n    private int[] parent; //父 ID\n\n    public UnionFind2(int size){\n        parent=new int[size];\n        for (int i=0;i<size;i++) {\n            parent[i]=i;\n        }\n    }\n\n    public int getSize(){\n        return parent.length;\n    }\n\n    //p 所属的集合 ID\n    private int find(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        while(parent[index]!=index){\n            index=parent[index];\n        }\n        return index;\n    }\n    \n    //判断集合 ID 是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        parent[pID]=qID;\n    }\n}\n```\n\n初始化的时候每个元素的父节点都指向自己\n\n`find`操作的时候就不停的向上爬，找到每个元素的根节点，就是它的集合 ID，时间复杂度就是`O(h)` h 是树的高度，注意这里并不是`logN`，因为这课树并一定是一棵二叉树\n\n`isConnected` 和上面一样，判断两个元素的根节点时候一样就 ok\n\n`unionElement` 合并两个元素的集合，我们只需要将其中一个`parentID`变为另一个的`parentID`就 Ok 了，时间复杂度`O(hq)+O(hp)` (hp，hq 代表 p 和 q 形成的树的高度）\n\n> 相比上面的`UnionFInd1`我们牺牲了一点查找的效率获得了更高的合并效率，但是仍然还有可以优化的点，我们这里在合并两个集合的时候，并没有考虑两颗树的形状，直接将一颗树加在了另一颗的后面，而这样很有可能会增加合并后的树的高度，甚至可能会形成一个链表的结构，这将极大的影响我们的时间复杂度，所以我们可以考虑更好的合并方式\n>\n> ![mark](http://static.imlgw.top/blog/20200101/ifSkJmMWNB2U.png?imageslim)\n\n### UnionFind3-size 优化\n\n这里我们添加一个 sz 数组用来记录每个集合的元素个数\n\n```java\npublic class UnionFind3 implements UF{\n\n    private int[] parent; //父 ID\n\n    private int[] sz; //记录每颗树的节点数量\n\n    public UnionFind3(int size){\n        parent=new int[size];\n        sz=new int[size];\n        for (int i=0;i<size;i++) {\n            parent[i]=i;\n            sz[i]=1;\n        }\n    }\n\n    public int getSize(){\n        return parent.length;\n    }\n\n    //p 所属的集合 ID\n    private int find(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        while(parent[index]!=index){\n            index=parent[index];\n        }\n        return index;\n    }\n    \n    //判断集合 ID 是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        if (sz[pID]>sz[qID]) {\n            parent[qID]=pID;\n            sz[pID]+=sz[qID];    \n        }else{\n            parent[pID]=qID;\n            sz[qID]+=sz[pID];\n        }\n    }\n}\n```\n\n初始化的时候额外的将每个元素的 sz 置为 1\n\n`find`操作和`isConnected`没有变化\n\n`unionElement` 的时候我们不在是盲目的随意合并，而是将 size 小的集合加在 size 大的集合下\n\n![mark](http://static.imlgw.top/blog/20200101/ifSkJmMWNB2U.png?imageslim)\n\n类似这样的情况下就不会将 1 接在 5 下面，而是将 5 接在 1 下面，这样合并后的集合的高度就不会增大\n\n> 但是根据 size 判断一定能准确判断么？很显然是不行的\n\n![mark](http://static.imlgw.top/blog/20200101/SdfeawuEf9Qz.png?imageslim)\n\n类似这样的，如果按照之前的按照 size 合并的方案可能反而会导致树的高度增加，所以更加合理的方案应该是根据树的高度来合并\n\n### UnionFind4-hight 优化\n\n```java\npublic class UnionFind4 implements UF{\n\n    private int[] parent; //父 ID\n\n    private int[] hight; //每个集合形成的树的高度\n\n    public UnionFind4(int size){\n        parent=new int[size];\n        hight=new int[size];\n        for (int i=0;i<size;i++) {\n            parent[i]=i;\n            hight[i]=1;\n        }\n    }\n\n    public int getSize(){\n        return parent.length;\n    }\n\n    //p 所属的集合 ID\n    private int find(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        while(parent[index]!=index){\n            index=parent[index];\n        }\n        return index;\n    }\n    \n    //判断集合 ID 是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        if (hight[pID]>hight[qID]) {\n            parent[qID]=pID;    \n        }else if(hight[pID]<hight[qID]){\n            parent[pID]=qID;\n        }else{ //高度相等情况，才会增大树的高度\n            parent[pID]=qID; \n            hight[qID]++;\n        }\n    }\n}\n```\n\n初始化的时候仍然将每个元素的高度设置为 1\n\n合并的时候我们根据树的高度来合并，将高度小的集合添加到高度大的集合上，这样整体的高度并不会变化，仍然是高度较大的集合的高度，只有在两颗树的高度相同的时候才会使集合高度增加，这个时候就无所谓谁添加到谁上了\n\n> 回头想一想，其实我们查找或者合并的时候并不会去关系每个元素的父节点又或者爷节点是啥，我们只关心的是这个元素的祖宗节点是啥，也就是根节点是啥，也就是我们希望每个集合的高度越小越好\n\n![mark](http://static.imlgw.top/blog/20200101/D84lWwYGlVag.png?imageslim)\n\n### UnionFind5-路径压缩\n\n在 find 过程中增加了路径压缩的功能\n\n```java\npublic class UnionFind5 implements UF{\n\n    private int[] parent; //父 ID\n\n    private int[] rank;\n\n    public UnionFind5(int size){\n        parent=new int[size];\n        rank=new int[size];\n        for (int i=0;i<size;i++) {\n            parent[i]=i;\n            rank[i]=1;\n        }\n    }\n\n    public int getSize(){\n        return parent.length;\n    }\n\n    //p 所属的集合 ID\n    private int find(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        while(parent[index]!=index){\n            parent[index]=parent[parent[index]]; //路径压缩\n            index=parent[index];\n        }\n        return index;\n    }\n\t\n    //递归的方式进行路径压缩，可以压得更低\n    private int find2(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        if(parent[index]!=index){\n            parent[index]=find2(parent[index]);\n        }\n        return parent[index];\n    }\n    \n    //判断集合 ID 是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        if (rank[pID]>rank[qID]) {\n            parent[qID]=pID;    \n        }else if(rank[pID]<rank[qID]){\n            parent[pID]=qID;\n        }else{ //高度相等情况，才会增大树的 Rank\n            parent[pID]=qID; \n            rank[qID]++;\n        }\n    }\n}\n```\n\nfind 操作本身就是一个向上遍历的过程，所以我们可以直接再 find 得过程中去进行路径的压缩\n\n核心的语句就是 `parent[index]=parent[parent[index]];`\n\n如果父节点不是要找的根节点就将父节点设置为父节点的父节点\n\n当然这里还有一种压缩的方式，可以将树压缩的更短，也就是上面的`find2`，核心语句就是\n\n `parent[index]=find2(parent[index])` \n\n![mark](http://static.imlgw.top/blog/20200101/D84lWwYGlVag.png?imageslim)\n\n如果是这样的树执行 `find2(5)` 可以直接将树压缩成左边的样子，而`find1(5)` 并不能一次就压缩成这样，两者各有优缺点，这里不过多阐述\n\n> 细心的朋友肯定发现了，我这里将`hight`改成了`rank`，为什么要改成 rank?\n>\n> 其实原因很简单，在加入了路径压缩后，这里的 hight 不再能表示高度的含义，所以我们改成了 Rank\n>\n> 那我们为什么不继续维护这个高度了？这样不是就无法准确的判断如何合并了嘛？\n>\n> 其实这里如果想要继续维护这个树的高度是一种不太明智的选择，成本太大了，难以维护，并不是简单的`--` 就可以完成的，会有很多的情况，所以我们索性直接将其改成 Rank 作为一个参考量，表示这个集合的排名，其实仔细想一想，我们进行路径压缩带来的优化明显会大于维护 hight 带来的优化\n\n### 时间复杂度\n\n这里经过科学家们的计算证明得到最终的时间复杂度是 `O(log*N)`我也是第一次听说这个复杂度，\n\n![mark](http://static.imlgw.top/blog/20200101/iXPijTwciz0b.png?imageslim)\n\n**迭代对数**\n\n| n                | lg* n |\n| ---------------- | ----- |\n| (−∞, 1]          | 0     |\n| (1, 2]           | 1     |\n| (2, 4]           | 2     |\n| (4, 16]          | 3     |\n| (16, 65536]      | 4     |\n| (65536, 2^65536] | 5     |\n\n可以看到，时间复杂度是相当低，可以近似的认为就是一个`O(1)` 常数的复杂度\n\n## 练手例题\n\n### [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)\n\n班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。\n\n给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果`M[i][j] = 1`，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。\n\n**示例 1:**\n\n```java\n输入：\n[[1,1,0],\n [1,1,0],\n [0,0,1]]\n输出：2 \n说明：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。\n第 2 个学生自己在一个朋友圈。所以返回 2。\n```\n\n**示例 2:**\n\n```java\n输入：\n[[1,1,0],\n [1,1,1],\n [0,1,1]]\n输出：1\n说明：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1。\n```\n\n**注意：**\n\n1. N 在`[1,200]`的范围内。\n2. 对于所有学生，有`M[i][i] = 1`。\n3. 如果有`M[i][j] = 1`，则有`M[j][i] = 1`。\n\n**解法二**\n\n这题很久之前做过 [LeetCode 回溯&递归](http://imlgw.top/2019/10/10/leetcode-hui-su/#547-%E6%9C%8B%E5%8F%8B%E5%9C%88) 当时 DFS 做的，其实这题应该属于最经典的并查集的题目了\n\n```java\nprivate int[] parent; //父 ID\n\nprivate int[] rank;\n\n//p 所属的集合 ID\nprivate int find(int index){\n    if (index<0 && index>=parent.length) {\n        throw new IllegalArgumentException(\"index is out....\");\n    }\n    while(parent[index]!=index){\n        parent[index]=parent[parent[index]];\n        index=parent[index];\n    }\n    return index;\n}\n\npublic void unionElement(int p,int q){\n    int pID=find(p);\n    int qID=find(q);\n    if (qID==pID) {\n        return;\n    }\n    if (rank[pID]>rank[qID]) {\n        parent[qID]=pID;    \n    }else if(rank[pID]<rank[qID]){\n        parent[pID]=qID;\n    }else{ //高度相等情况，才会增大树的高度\n        parent[pID]=qID; \n        rank[qID]++;\n    }\n}\n\npublic int findCircleNum(int[][] M) {\n    parent=new int[M.length];\n    rank=new int[M.length];\n    //初始化\n    for (int i=0;i<M.length;i++) {\n        parent[i]=i;\n        rank[i]=1;\n    }\n    //union\n    for (int i=0;i<M.length;i++) {\n        for (int j=0;j<M.length;j++) {\n            if (M[i][j]==1) {\n                unionElement(i,j);\n            }\n        }\n    }\n    int res=0;\n    for (int i=0;i<parent.length;i++) {\n        if (parent[i]==i) {\n            res++;\n        }\n    }\n    return res;\n}\n```\n\n代码还是很简单的，合并之后统计一下数量就 ok 了\n\n### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n给定一个未排序的整数数组，找出最长连续序列的长度。\n\n要求算法的时间复杂度为 `O(n)`。\n\n**示例：**\n\n```java\n输入：[100, 4, 200, 1, 3, 2]\n输出：4\n解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。\n```\n\n**并查集解法**\n\n```java\n//并查集\nHashMap<Integer,Integer> parent;\n\nHashMap<Integer,Integer> size;\n\nint max=1;\n\npublic int find(int index){\n    while(parent.get(index)!=index){\n        //parent[index]=parent[parent[index]];\n        parent.put(index,parent.get(index));\n        index=parent.get(index);\n    }\n    return index;\n}\n\npublic void union(int p,int q){\n    int pID=find(p);\n    int qID=find(q);\n    if (pID==qID) {\n        return;\n    }\n    int pSize=size.get(pID);\n    int qSize=size.get(qID);\n    if (pSize > qSize) {\n        //parent[qID]=pID;\n        parent.put(qID,pID);\n        //size[pID]+=size[qID];\n        size.put(pID,pSize+qSize);\n    }else{\n        //parent[pID]=qID;\n        parent.put(pID,qID);\n        //size[qID]+=size[pID];\n        size.put(qID,pSize+qSize);\n    }\n    max=Math.max(max,pSize+qSize); //统计最大值\n}\n\npublic void initUnionFind(int[]nums){\n    parent=new HashMap<>();\n    size=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        parent.put(nums[i],nums[i]);\n        size.put(nums[i],1);\n    }\n}\n\npublic int longestConsecutive(int[] nums) {\n    if (nums ==null || nums.length<=0) {\n        return 0;\n    }\n    HashSet<Integer> set=new HashSet();\n    for (int i=0;i<nums.length;i++) {\n        set.add(nums[i]);\n    }\n    initUnionFind(nums);\n    for (int i=0;i<nums.length;i++) {\n        if (set.contains(nums[i]-1)) { //判断-1 或者+1 都可以\n            union(nums[i],nums[i]-1);\n        }\n    }\n    return max;\n}\n```\n\n这里用并查集其实并不是最优解，直接循环用 HashSet 感觉会更好更简洁  [详见 LeetCode 查找](http://imlgw.top/2019/09/15/leetcode-cha-zhao/) 不过熟悉一下并查集还是不错的，这里因为是根据 num 的数值判断的，code 所以用数组索引合并是行不通的，需要改成 Hash 表\n\n### [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)\n\n用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。\n\n网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。\n\n给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 \n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/01/4HfDievqKpbswNh.png)\n\n```java\n输入：n = 4, connections = [[0,1],[0,2],[1,2]]\n输出：1\n解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上\n```\n\n**示例 2：**\n\n![image.png](https://i.loli.net/2020/02/01/mDjJCSHwOrZoa9g.png)\n\n```java\n输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n输出：2\n```\n\n**示例 3：**\n\n```java\n输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\n输出：-1\n解释：线缆数量不足。\n```\n\n**示例 4：**\n\n```java\n输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]\n输出：0\n```\n\n**提示：**\n\n- 1 <= n <= 10^5\n- 1 <= connections.length <= min(n*(n-1)/2, 10^5)\n- connections[i].length == 2\n- 0 <= connections[i][0], connections[i][1] < n\n- connections[i][0] != connections[i][1]\n- 没有重复的连接。\n- 两台计算机不会通过多条线缆连接。\n\n**解法一**\n\n1.12 周赛的第三题，挺有意思的，当时想了一会儿，然后就直接想到了并查集\n\n```java\nprivate int[] parent; //父 ID\n\nprivate int[] rank;\n\n//p 所属的集合 ID\nprivate int find(int index){\n    if (index<0 && index>=parent.length) {\n        throw new IllegalArgumentException(\"index is out....\");\n    }\n    while(parent[index]!=index){\n        parent[index]=parent[parent[index]];\n        index=parent[index];\n    }\n    return index;\n}\n\npublic void union(int p,int q){\n    int pID=find(p);\n    int qID=find(q);\n    if (qID==pID) {\n        return;\n    }\n    if (rank[pID]>rank[qID]) {\n        parent[qID]=pID;    \n    }else if(rank[pID]<rank[qID]){\n        parent[pID]=qID;\n    }else{ //高度相等情况，才会增大树的高度\n        parent[pID]=qID; \n        rank[qID]++;\n    }\n}\n\n//判断集合 ID 是不是一样的\npublic boolean isConnected(int p,int q){\n    return find(q)==find(p);\n}\n\npublic void initUF(int n){\n    parent=new int[n];\n    rank=new int[n];\n    for (int i=0;i<n;i++) {\n        parent[i]=i;\n        rank[i]=1;\n    }\n}\n\npublic int makeConnected(int n, int[][] connections) {\n    initUF(n);\n    int more=0;\n    for (int i=0;i<connections.length;i++) {\n        if (isConnected(connections[i][0],connections[i][1])) {\n            more++; //多出来的边个数\n        }else{\n            union(connections[i][0],connections[i][1]);\n        }\n    }\n    int count=0;\n    for (int i=0;i<n;i++) {\n        if (parent[i]==i) {\n            count++; //集合个数\n        }\n    }\n    return count-1<=more?count-1:-1;\n}\n```\n\n核心思路就是将元素合并，然后中间求出多出的边，最后判断多出来的边能不能将所有的集合聚合成一个大集合，也就是`count-1<=more`的时候才可以联通，否则就无法联通\n\n### [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)\n\n给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。\n\n示例 :\n\n```java\n给定 a / b = 2.0, b / c = 3.0\n问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \n返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]\n```\n\n输入为：`vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries（方程式，方程式结果，问题方程式）`， 其中 `equations.size() == values.size()`，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回`vector<double>`类型。\n\n基于上述例子，输入如下：\n\n```java\nequations（方程式） = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\nvalues（方程式结果） = [2.0, 3.0],\nqueries（问题方程式） = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \n```\n\n输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。\n\n**解法一**\n\n首先弄清楚题目的意思，这题 LeetCode 上只是 mid，其实我感觉如果用并查集做的话就不是 mid 题了，今天搞了好长时间并查集的解法\n\n首先来一版不带路径压缩的\n\n```java\nprivate HashMap<String,String> parent=new HashMap<>();\n\nprivate HashMap<String,Double> quotient=new HashMap<>();\n\n//不带路径压缩\npublic String find(String p){\n    while (parent.get(p)!=p) {\n        p=parent.get(p);\n    }\n    return p;\n}\n\npublic void init(String s){\n    if (!parent.containsKey(s)) {\n        parent.put(s,s);\n        quotient.put(s,1.0);   \n    }\n}\n\npublic void merge(String a,String b,Double value){\n    init(a);init(b);\n    String fa=find(a); // a/fa=val[a], b/fb=val[b]\n    String fb=find(b);\n    if (fa.equals(fb)) {\n        return;\n    }\n    parent.put(fa,fb);\n    quotient.put(fa,value*(cal(b)/cal(a))); //cal(a) 和 cal(b) 代表 a 和 b 到根节点的总值\n}\n\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n    for (int i=0;i<equations.size();i++) {\n        List<String> equation=equations.get(i);\n        merge(equation.get(0),equation.get(1),values[i]);\n    }\n    double[] res=new double[queries.size()];\n    int index=0;\n    for (List<String> query:queries) {\n        String a=find(query.get(0));\n        String b=find(query.get(1));\n        System.out.println(a+\" \"+b);\n        if (!parent.containsKey(query.get(0)) || !parent.containsKey(query.get(1)) || !a.equals(b)) {\n            res[index++]=-1;\n        }else{\n            //没有路劲压缩，需要遍历整个路劲求积\n            res[index++]=cal(query.get(0))/cal(query.get(1));\n        }\n    }\n    return res;\n}\n\n//计算当前节点到根节点的路径乘积\npublic double cal(String index){\n    double res=quotient.get(index);\n    while(parent.get(index)!=index){\n        index=parent.get(index);\n        res*=quotient.get(index);\n    }\n    return res;\n}\n```\n\n其实这题我开始想到就是建图然后 BFS，并查集我是真没想到，看来还是不够敏锐，不过有一说一并查集的方法确实比较麻烦，特别是带了路径压缩的。\n\n这里我的并查集的方向是\n\n```java\na/b=2 , b/c=3\n    \n        c  1\n        ^\n        |\n        b  3\n        ^\n        |\n        a  2\n```\n\n`quotient`代表的是**当前节点**是**直接父节点**的多少倍，也就是 `A/fatherA`  ，重点就是合并两个集合的时候需要注意：\n\n```java\n已知\na / fa = val[a]\nb / fb = val[b]\n现在我们要合并 a，b 且 a / b=value\n所以我们需要设置 parent[fa]=fb\n由于 fa 父节点发生了变化所以它的值也需要变化，也就是要求 fa/fb 的值\nval[fa] = fa/fb = a/b * b/fb * fa/a = value * (val[b] / val[a])\n```\n\n**解法二**\n\n```java\nprivate HashMap<String,String> parent=new HashMap<>();\n\nprivate HashMap<String,Double> quotient=new HashMap<>();\n\n//带路径压缩的\npublic String find(String p){\n    if (parent.get(p)!=p) {\n        //需要先保存父亲的值，因为后面压缩后树只有两层，后面*的就是根节点的权值 1, 是不对的\n        //这里可以看看上面的并茶几的方向和值来判断\n        String f=parent.get(p); \n        parent.put(p,find(f));\n        //这样压缩后的子节点才是正确的\n        quotient.put(p,quotient.get(p)*quotient.get(f));\n    }\n    return parent.get(p);\n}\n\npublic void init(String s){\n    if (!parent.containsKey(s)) {\n        parent.put(s,s);\n        quotient.put(s,1.0);   \n    }\n}\n\npublic void merge(String a,String b,Double value){\n    init(a);init(b);\n    String fa=find(a); // fa/a=val[a], fb/b=val[b]\n    String fb=find(b);\n    if (fa.equals(fb)) {\n        return;\n    }\n    parent.put(fa,fb);\n    quotient.put(fa,value*(quotient.get(b)/quotient.get(a))); \n}\n\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n    for (int i=0;i<equations.size();i++) {\n        List<String> equation=equations.get(i);\n        merge(equation.get(0),equation.get(1),values[i]);\n    }\n    double[] res=new double[queries.size()];\n    int index=0;\n    for (List<String> query:queries) {\n        String a=query.get(0);\n        String b=query.get(1);\n        if (!parent.containsKey(a) || !parent.containsKey(b)) {\n            res[index++]=-1;\n        }else{\n            //先做路径压缩\n            res[index++]=find(a).equals(find(b))?quotient.get(a)/quotient.get(b):-1;\n        }\n    }\n    return res;\n}\n```\n\n这里可以看到已经省略了`cal` 函数计算从当前节点到根节点的总权值积，因为这里路径压缩已经将树压缩到只有两层了，所以并不需要了，既然要压缩到只有两层，这里就只能使用递归来压缩，循环的版本没办法压到只有两层，这里需要注意压缩中值的变化。\n\n**解法三**\n\n图的解法放到了 [栈和队列专题](http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/) 中了\n\n### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)\n\n给定一个包含了一些 0 和 1 的非空二维数组 grid , 一个 岛屿 是由四个方向 （水平或垂直） 的 1 （代表土地） 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。\n\n找到给定的二维数组中最大的岛屿面积。（如果没有岛屿，则返回面积为 0。)\n\n**示例 1:**\n\n```java\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n```\n\n对于上面这个给定矩阵应返回 6。注意答案不应该是 11，因为岛屿只能包含水平或垂直的四个方向的‘1’。\n\n**示例 2:**\n\n```java\n[[0,0,0,0,0,0,0,0]]\n```\n\n对于上面这个给定的矩阵，返回 0。\n\n**注意：** 给定的矩阵 grid 的长度和宽度都不超过 50\n\n**解法一**\n\nlc 打卡题选了这题，之前用的 dfs，这次用并查集实现下\n\n```java\n//补充一个并查集的解法\nint[] parent=null;\n\nint[] size=null;\n\nint max=0;\n\npublic void merge(int a,int b){\n    int fa=find(a);\n    int fb=find(b);\n    if(fa==fb) return;\n    if(size[fa]>size[fb]){\n        parent[fb]=fa;\n        size[fa]+=size[fb];\n        max=Math.max(max,size[fa]);\n    }else{\n        parent[fa]=fb;\n        size[fb]+=size[fa];\n        max=Math.max(max,size[fb]);\n    }\n}\n\npublic int find(int p){\n    if(parent[p]==p) return p;\n    parent[p]=find(parent[p]);\n    return parent[p];\n}\n\npublic int maxAreaOfIsland(int[][] grid) {\n    int m=grid.length;\n    int n=grid[0].length;\n    //init\n    parent=new int[m*n];\n    size=new int[m*n];\n    for (int i=0;i<m*n;i++){\n        parent[i]=i;\n        size[i]=1;\n    }\n    //1 1 1 1 \n    //1 1 1 1\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(grid[i][j]==1){\n                //特判一下 hahaha~ 感觉如果不是 lc 有 wacase 我还挺难发现这个\n                max=Math.max(max,1);\n                //和前面，上面的合并\n                if(i>0 && grid[i-1][j]==1) merge(i*n+j,(i-1)*n+j);\n                if(j>0 && grid[i][j-1]==1) merge(i*n+j,i*n+j-1);  \n            }\n        }\n    }\n    return max;\n}\n```\n\n### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)\n\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n**示例 1:**\n\n```java\n输入：\n11110\n11010\n11000\n00000\n输出：1\n```\n\n**示例 2:**\n\n```java\n输入：\n11000\n00100\n00011\n输出：3\n解释：每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。\n```\n\n**解法一**\n\n补充一个并查集的写法，手写出来了，但是逻辑出了一点小问题，卡了一会儿\n\n```java\n//复习下并查集\nint[] rank=null;\n\nint[] parent=null;\n\npublic int find(int a){\n    if(parent[a]==a) return a;\n    return parent[a]=find(parent[a]);\n}\n\npublic void merge(int a,int b){\n    int fa=find(a);\n    int fb=find(b);\n    if(fa==fb) return;\n    if(rank[fa]>rank[fb]){\n        parent[fb]=fa;\n        rank[fa]+=rank[fb];\n    }else{\n        parent[fa]=fb;\n        rank[fb]+=rank[fa];\n    }\n}\n\npublic int numIslands2(char[][] grid) {\n    if(grid==null || grid.length<=0) return 0;\n    int m=grid.length,n=grid[0].length;\n    rank=new int[m*n];\n    parent=new int[m*n];\n    //init\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(grid[i][j]=='1'){\n                parent[i*n+j]=i*n+j;\n                rank[i*n+j]=1;\n            }\n        }\n    }\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(grid[i][j]=='1'){\n                //和上/左合并\n                if(i>0 && grid[i-1][j]=='1') merge(i*n+j,(i-1)*n+j);\n                if(j>0 && grid[i][j-1]=='1') merge(i*n+j,i*n+(j-1));\n            }\n        }\n    }\n    int res=0;\n    //直接循环 parent 会有问题，还是老老实实遍历矩阵\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(grid[i][j]=='1' && parent[i*n+j]==i*n+j){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)\n\n给出一个二维数组 `A`，每个单元格为 0（代表海）或 1（代表陆地）。\n\n移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。\n\n返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。\n\n**示例 1：**\n\n```java\n输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n输出：3\n解释： \n有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。\n```\n\n**示例 2：**\n\n```java\n输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n输出：0\n解释：\n所有 1 都在边界上或可以到达边界。\n```\n\n**提示：**\n\n1. `1 <= A.length <= 500`\n2. `1 <= A[i].length <= 500`\n3. `0 <= A[i][j] <= 1`\n4. 所有行的大小都相同\n\n**解法一**\n\n```java\n//并查集\nint[] rank=null;\n\nint[] parent=null;\n\npublic int find(int a){\n    if(parent[a]==a) return a;\n    return parent[a]=find(parent[a]); //路径压缩\n}\n\npublic void merge(int a,int b){\n    int fa=find(a);\n    int fb=find(b);\n    if(fa==fb) return;\n    if(rank[fa]>rank[fb]){\n        parent[fb]=fa;\n        rank[fa]+=rank[fb];\n    }else{\n        parent[fa]=fb;\n        rank[fb]+=rank[fa];\n    }\n}\n\npublic int numEnclaves2(int[][] A) {\n    if(A==null || A.length<=0) return 0;\n    int m=A.length,n=A[0].length;\n    rank=new int[m*n+1];\n    parent=new int[m*n+1];\n    //init\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(A[i][j]==1){\n                parent[i*n+j]=i*n+j;\n                rank[i*n+j]=1;\n            }\n        }\n    }\n    //将边界和虚拟节点合并\n    int dummyNode=m*n;\n    parent[dummyNode]=dummyNode;\n    rank[dummyNode]=1;\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(A[i][j]==1){\n                if(i==0 || j==0 || i==m-1 || j==n-1){\n                    merge(dummyNode,i*n+j);\n                }else{ \n                    //和周围节点合并（一开始复制的上面的，只和左上的合并，结果出 bug 了 hahaha\n                    if(A[i][j-1]==1) merge(i*n+j,i*n+j-1);\n                    if(A[i-1][j]==1) merge(i*n+j,(i-1)*n+j);\n                    if(A[i][j+1]==1) merge(i*n+j,i*n+j+1);\n                    if(A[i+1][j]==1) merge(i*n+j,(i+1)*n+j);\n                }\n            }\n        }\n    }\n    int res=0;\n    int dump=find(dummyNode);\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            //判断和虚节点是否连接\n            if(A[i][j]==1 && find(i*n+j)!=dump){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\n### [990. 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)\n\n给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 `equations[i]` 的长度为 `4`，并采用两种不同的形式之一：`\"a==b\"` 或 `\"a!=b\"`。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。\n\n只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 `true`，否则返回 `false`。 \n\n**示例 1：**\n\n```java\n输入：[\"a==b\",\"b!=a\"]\n输出：false\n解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。\n```\n\n**示例 2：**\n\n```java\n输出：[\"b==a\",\"a==b\"]\n输入：true\n解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。\n```\n\n**示例 3：**\n\n```java\n输入：[\"a==b\",\"b==c\",\"a==c\"]\n输出：true\n```\n\n**示例 4：**\n\n```java\n输入：[\"a==b\",\"b!=c\",\"c==a\"]\n输出：false\n```\n\n**示例 5：**\n\n```java\n输入：[\"c==c\",\"b==d\",\"x!=z\"]\n输出：true\n```\n\n**提示：**\n\n1. `1 <= equations.length <= 500`\n2. `equations[i].length == 4`\n3. `equations[i][0]` 和 `equations[i][3]` 是小写字母\n4. `equations[i][1]` 要么是 `'='`，要么是 `'!'`\n5. `equations[i][2]` 是 `'='`\n\n**解法一**\n\n2020.6.8 打卡题，在群里看见了讨论说并查集，所以直接就想到了并查集的做法，自己想的话 emmm，感觉也能想到，也不是很复杂的并查集\n\n```java\n//路径压缩+按秩合并\nint[] parent;\n\nint[] rank;\n\npublic int find(int p){\n    if(parent[p]==p) return p;\n    return parent[p]=find(parent[p]);\n}\n\npublic void merge(int a,int b){\n    int af=find(a);\n    int bf=find(b);\n    if(af==bf) return;\n    if(rank[af]>rank[bf]){\n        parent[bf]=af;\n    }else if(rank[af]<rank[bf]){\n        parent[af]=bf;\n    }else{\n        parent[af]=bf;\n        rank[bf]++;\n    }\n}\n\npublic boolean equationsPossible(String[] equations) {\n    parent=new int[128]; //-'a'减来减去太麻烦了，直接设个 128 完事\n    rank=new int[128];\n    //排序后先合并==, 再判断！= 偷懒的做法\n    //Arrays.sort(equations,(s1,s2)->s2.charAt(1)-s1.charAt(1));\n    for (String eq:equations) {\n        parent[eq.charAt(0)]=eq.charAt(0);\n        rank[eq.charAt(0)]=1;\n        parent[eq.charAt(3)]=eq.charAt(3);\n        rank[eq.charAt(3)]=1;\n    }\n    for (String eq:equations) {\n        if(eq.charAt(1)=='='){\n            merge(eq.charAt(0),eq.charAt(3));\n        }\n    }\n    for (String eq:equations) {\n        if(eq.charAt(1)=='!' && find(eq.charAt(0))==find(eq.charAt(3))){\n            return false;\n        }\n    }\n    return true;\n}\n```\n### [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)\n\nDifficulty: **中等**\n\n在本问题中，树指的是一个连通且无环的**无向**图。\n\n输入一个图，该图由一个有着 N 个节点 （节点值不重复 1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在 1 到 N 中间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以`边`组成的二维数组。每一个`边`的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。\n\n返回一条可以删去的边，使得结果图是一个有着 N 个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。\n\n**示例 1：**\n\n```\n输入：[[1,2], [1,3], [2,3]]\n输出：[2,3]\n解释：给定的无向图为：\n  1\n / \\\n2 - 3\n```\n\n**示例 2：**\n\n```\n输入：[[1,2], [2,3], [3,4], [1,4], [1,5]]\n输出：[1,4]\n解释：给定的无向图为：\n5 - 1 - 2\n    |   |\n    4 - 3\n```\n\n**注意：**\n\n*   输入的二维数组大小在 3 到 1000。\n*   二维数组中的整数在 1 到 N 之间，其中 N 是输入数组的大小。\n\n**更新 (2017-09-26):**  \n我们已经重新检查了问题描述及测试用例，明确图是_**无向 **_图。对于有向图详见**。**对于造成任何不便，我们深感歉意。\n\n**解法一**\n\n没啥好说的，题目意思读懂就行了\n```golang\nvar parent []int\n​\nfunc union(a int, b int) bool {\n    pa := find(a)\n    pb := find(b)\n    if pa == pb {\n        return false\n    }\n    parent[pa] = pb\n    return true\n}\n​\nfunc find(a int) int {\n    if parent[a] == a {\n        return a\n    }\n    parent[a] = find(parent[a])\n    return parent[a]\n}\n​\nfunc findRedundantConnection(edges [][]int) []int {\n    var n = len(edges)\n    parent = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        parent[i] = i\n    }\n    for i := 0; i < n; i++ {\n        if !union(edges[i][0], edges[i][1]) {\n            return edges[i]\n        }\n    }\n    return []int{}\n}\n```\n\n### [685. 冗余连接 II](https://leetcode-cn.com/problems/redundant-connection-ii/)\n\nDifficulty: **困难**\n\n在本问题中，有根树指满足以下条件的**有向**图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。\n\n输入一个有向图，该图由一个有着 N 个节点 （节点值不重复 1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在 1 到 N 中间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以`边`组成的二维数组。 每一个`边` 的元素是一对 `[u, v]`，用以表示**有向**图中连接顶点 `u` 和顶点 `v` 的边，其中 `u` 是 `v` 的一个父节点。\n\n返回一条能删除的边，使得剩下的图是有 N 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。\n\n**示例 1:**\n\n```go\n输入：[[1,2], [1,3], [2,3]]\n输出：[2,3]\n解释：给定的有向图如下：\n  1\n / \\\nv   v\n2-->3\n```\n\n**示例 2:**\n\n```go\n输入：[[1,2], [2,3], [3,4], [4,1], [1,5]]\n输出：[4,1]\n解释：给定的有向图如下：\n5 <- 1 -> 2\n     ^    |\n     |    v\n     4 <- 3\n```\n\n**注意：**\n\n*   二维数组大小的在 3 到 1000 范围内。\n*   二维数组中的每个整数在 1 到 N 之间，其中 N 是二维数组的大小。\n\n**解法一**\n\n没做出来，看的题解，感觉怪怪的\n\n```golang\nvar parent []int\n\nfunc union(a int, b int) bool {\n    pa := find(a)\n    pb := find(b)\n    if pa == pb {\n        return false\n    }\n    parent[pa] = pb\n    return true\n}\n\nfunc find(a int) int {\n    if parent[a] == a {\n        return a\n    }\n    parent[a] = find(parent[a])\n    return parent[a]\n}\n\nfunc judge(edges [][]int, k int) bool {\n    parent = make([]int, len(edges)+1)\n    for i := 1; i <= len(edges); i++ {\n        parent[i] = i\n    }\n    for i := 0; i < len(edges); i++ {\n        if i == k {\n            continue\n        }\n        if !union(edges[i][0], edges[i][1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc findRedundantDirectedConnection(edges [][]int) []int {\n    var n = len(edges)\n    var indegree = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        indegree[edges[i-1][1]]++\n    }\n    for i := n-1; i >= 0; i-- {\n        if indegree[edges[i][1]] == 2 {\n            //删除该边\n            if judge(edges, i) {\n                return edges[i]\n            }\n        }\n    }\n    for i := n-1; i >= 0; i-- {\n        if indegree[edges[i][1]] == 1 {\n            if judge(edges, i) {\n                return edges[i]\n            }\n        }\n    }\n    return []int{}\n}\n```\n\n###  未完待续\n\n其实之前做的一些题都可以用并查集做，像 [岛屿数量]()，[岛屿最大面积]() 啥的，这里就不多写了，都差不多","tags":["算法","数据结构"],"categories":["数据结构"]},{"title":"LeetCode 贪心","url":"/2020/01/21/a91acf16/","content":"\n## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n**注意：**\n\n你可以假设胃口值为正。\n一个小朋友最多只能拥有一块饼干\n\n**示例 1:**\n\n```java\n输入：[1,2,3], [1,1]\n\n输出：1\n\n解释：\n你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。\n所以你应该输出 1。\n```\n\n**示例 2:**\n\n```java\n输入：[1,2], [1,2,3]\n\n输出：2\n\n解释：\n你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\n所以你应该输出 2.\n```\n\n**解法一**\n\n贪就完事儿了\n\n```java\npublic int findContentChildren(int[] g, int[] s) {\n    if (g==null || s==null) {\n        return 0;\n    }\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int res=0,index=0;\n    for (int i=0;i<g.length;i++) {\n        while(index<s.length){\n            if (g[i]<=s[index]) {\n                res++;\n                index++;\n                break;\n            }\n            index++;\n        }\n    }\n    return res;\n}\n```\n\n## [274. H 指数](https://leetcode-cn.com/problems/h-index/)\n\n给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。\n\nh 指数的定义：“h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）~~至多~~有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”\n\n**示例：**\n\n```java\n输入：citations = [3,0,6,1,5]\n输出：3 \n解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。\n     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。\n```\n\n**说明：** 如果 h 有多种可能的值，h 指数是其中最大的那个。\n\n**解法一**\n\n题目意思搞懂就 ok\n\n```java\npublic int hIndex(int[] citations) {\n    int len=citations.length;\n    Arrays.sort(citations);\n    int count=0;\n    for (int i=len-1;i>=0;i--) {\n        if (citations[i]<=len-(i+1)) {\n            return len-(i+1);\n        }\n    }\n    return len;\n}\n```\n\n## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`\"ace\"`是`\"abcde\"`的一个子序列，而`\"aec\"`不是）。\n\n**示例 1:**\n\n```java\ns = \"abc\", t = \"ahbgdc\"\n返回 true.\n```\n\n**示例 2:**\n\n```java\ns = \"axc\", t = \"ahbgdc\"\n返回 false.\n```\n\n**后续挑战 :**\n\n如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n**解法一**\n\n```java\npublic boolean isSubsequence(String s, String t) {\n    if (s==null || t==null) {\n        return false;\n    }\n    int sindex=0,tindex=0;\n    while(sindex<s.length()) {\n        while(tindex<t.length() && sindex<s.length()){\n            if (s.charAt(sindex)==t.charAt(tindex)) {\n                sindex++;\n            }\n            tindex++;\n        }\n        if (tindex==t.length()) {\n            break; \n        }\n    }\n    return sindex==s.length();\n}\n```\n可以改成递归（多练习递归）\n\n```java\npublic boolean isSubsequence(String s,String t){\n    return subsequence(s,t,0,0);\n}\n\npublic boolean subsequence(String s,String t,int sindex,int tindex){\n    if (sindex == s.length()) {\n        return true;\n    }\n    //上下 if 不能交换，可能最后一个才相等\n    if (tindex == t.length()) {\n        return false;\n    }\n    return s.charAt(sindex)==t.charAt(tindex)?subsequence(s,t,sindex+1,tindex+1):subsequence(s,t,sindex,tindex+1);\n}\n```\n**解法二**\n\n```java\n//大量的 s 字符串 处理\npublic boolean isSubsequence3(String s, String t) {\n    //预处理\n    ArrayList<ArrayList<Integer>> hash=new ArrayList<>();\n    for (int i=0;i<26;i++) {\n        hash.add(new ArrayList());\n    }\n    for (int i=0;i<t.length();i++) {\n        hash.get(t.charAt(i)-'a').add(i);\n    }\n    //经过上面的预处理，后面的处理就会很快，不用再遍历 t 字符串\n    int lastIndex=-1;\n    for (int i=0;i<s.length();i++) {\n        List<Integer> indexList=hash.get(s.charAt(i)-'a');\n        int temp=binarySearch(indexList,lastIndex);\n        if (temp==indexList.size()) {\n            return false;\n        }\n        lastIndex=indexList.get(temp);\n    }\n    return true;\n}\n\n//找到第一个比 target 大的元素\npublic int binarySearch(List<Integer> list,int target){\n    int left=0,right=list.size()-1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if (list.get(mid)>target) {\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return left;\n}\n```\n\n## [621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)\n\n给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的 26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。\n\n然而，两个**相同种类**的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。\n\n你需要计算完成所有任务所需要的**最短时间**\n\n**示例 1：**\n\n```java\n输入：tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n输出：8\n执行顺序：A -> B -> （待命） -> A -> B -> （待命） -> A -> B.\n```\n\n**注：**\n\n- 任务的总个数为 `[1, 10000]`\n- n 的取值范围为 `[0, 100]`\n\n**解法一**\n\n```java\npublic int leastInterval(char[] tasks, int n) {\n    int[] map=new int[26];\n    for (int i=0;i<tasks.length;i++) {\n        map[tasks[i]-'A']++;\n    }\n    //找最大值\n    int max=-1;\n    for (int i=0;i<map.length;i++) {\n        max=Math.max(map[i],max);\n    }\n    int maxCount=0;\n    for (int i=0;i<map.length;i++) {\n        if (map[i]==max) {\n            maxCount++;\n        }\n    }\n    //比如 a b c d e f g,n=1\n    return Math.max((n+1)*(max-1)+maxCount,tasks.length);\n}\n```\n核心思想就是将出现次数最多的任务优先执行并且尽可能的分散，比如  `A A A B B C n=2` 最短的时间就是`A X X A X X A` ，最终的时间就是`(n+1)*(max-1)+1` 也就是 `(2+1) *(3-1)+1=7`， 但是可能会有多个最多次数的任务，所以我们还需要加上最多的相同的个数，最后就是 `(n+1)*(max-1)+maxCount` ，但是还不够，还是有可能会出现代码中的例子，也就是最后得到的结果比我们的任务列表还有短，所以我们需要取一个最大值\n\n## [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个位置。\n\n**示例 1:**\n\n```java\n输入：[2,3,1,1,4]\n输出：true\n解释：我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n```\n\n**示例 2:**\n\n```java\n输入：[3,2,1,0,4]\n输出：false\n解释：无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n```\n\n**解法一**\n\n回溯，勉强能过。太蠢了，为啥想不到简单的方法，就非得往复杂了想？就这么傻么？\n\n```java\nBoolean[] cache=null;\n\npublic boolean canJump(int[] nums) {\n    if (nums==null || nums.length<=0) return false;\n    cache=new Boolean[nums.length];\n    return jump(nums,0);\n}\n\npublic boolean jump(int[] nums,int index) {\n    if (nums[index] >= nums.length-1 -index) {\n        return true;\n    }\n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    for (int i=nums[index];i>=1;i--) {\n        if (index+i<nums.length && jump(nums,index+i)) {\n            return cache[index]=true;\n        }\n    }\n    return cache[index]=false;\n}\n```\n**解法二**\n\n不用多说了，遍历数组，不断更新能到达的最远距离，如果**某个位置的 index 大于当前能到达的最远距离就直接返回 false**\n\n```java\n//MDZZ\npublic boolean canJump(int[] nums) {\n    int maxIndex=nums[0];\n    for (int i=1;i<nums.length-1;i++) {\n        if(maxIndex >= nums.length-1) return true;\n        if (i>maxIndex) {\n            return false;\n        }\n        maxIndex=Math.max(maxIndex,i+nums[i]);\n    }\n    return true;\n}\n```\n\n## [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n**示例：**\n\n```java\n输入：[2,3,1,1,4]\n输出：2\n解释：跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n```\n\n**说明：**\n\n假设你总是可以到达数组的最后一个位置。\n\n**解法一**\n\n兴致勃勃写了个 dp\n\n```java\npublic int jump(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[nums.length];\n    for (int i=1;i<nums.length;i++) {\n        dp[i]=Integer.MAX_VALUE;\n        for (int j=0;j<i;j++) {\n            if (nums[j]>=i-j) {\n                dp[i]=Math.min(dp[j]+1,dp[i]);    \n            }\n        }\n    }\n    return dp[nums.length-1];\n}\n```\n\n如果这就过了那你也太小瞧这题了😂人家可是 hard 题，那能这么容易就让你过了？\n\n没错，这里直接 TLE 了，最后一个 CASE 过不去\n\n**解法二**\n\n贪心，核心思想不是每次都跳到最远的地方，**而是跳到当前位置能跳到的最远的位置**\n\n```java\n//每次选能跳的位置中跳的最远的\npublic int jump(int[] nums){\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int max=0;//最大边界\n    int step=0,curMaxIndex=0;\n    for (int i=0;i<nums.length-1;i++) {\n        curMaxIndex=Math.max(curMaxIndex,nums[i]+i); //i 能跳的位置中，跳的最远的\n        if (i==max) {//走到边界就++\n            step++;\n            max=curMaxIndex;\n        }\n    }\n    return step;\n}\n```\n\n代码需要细细品，一下可能看不太明白\n\n**解法三**\n\n回顾的时候这道题始终是没搞清楚，[看了一个大佬的题解](https://leetcode-cn.com/problems/jump-game-ii/solution/xun-huan-bu-bian-shi-fen-xi-cban-by-huai-an-2/) （这个大佬好像是个初中的妹子）后明白了\n\n```java\n//参考了一个大佬循环不变表达式的分析\npublic int jump(int[] nums){\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    //当前这一跳能选择的最远距离\n    int left=0;\n    //目前能达到的最远距离\n    int right=0;\n    int ptr=0,step=0;\n    while (right<nums.length-1) {\n        left=right;\n        while(ptr<nums.length && ptr<=left) {\n            right=Math.max(right,nums[ptr]+ptr);\n            ptr++;\n        }\n        step++;\n    }\n    return step;\n}\n```\n## [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)\n\n给出一个区间的集合，请合并所有重叠的区间。\n\n**示例 1:**\n\n```java\n输入：[[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠，将它们合并为 [1,6].\n```\n\n**示例 2:**\n\n```java\n输入：[[1,4],[4,5]]\n输出：[[1,5]]\n解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n```\n\n**解法一**\n\n思路也没啥好说的，类似贪心吧\n\n```java\npublic int[][] merge(int[][] intervals) {\n    if (intervals ==null || intervals.length<=0) {\n        return new int[][]{};\n    }\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    LinkedList<int[]> list=new LinkedList<>();\n    for (int i=1;i<intervals.length;i++) {\n        if (intervals[i][0]<=intervals[i-1][1]) {\n            if (intervals[i][1]>intervals[i-1][1]) {\n                intervals[i][0]=intervals[i-1][0];   \n            }else{\n                intervals[i][0]=intervals[i-1][0];\n                intervals[i][1]=intervals[i-1][1];\n            }\n        }else{\n            list.add(intervals[i-1]);\n        }\n    }\n    list.add(intervals[intervals.length-1]);\n    /*  int[][] res=new int[list.size()][2];\n        for (int i=0;i<list.size();i++) {\n            res[i][0]=list.get(i)[0];\n            res[i][1]=list.get(i)[1];\n        }*/\n    return list.toArray(new int[0][0]); //题解哪里学到一招\n}\n```\n\n最大的收获就是学到了一招 list 转 array 的方法😁\n\n偶然看到，简化下代码\n\n```java\n//update：2020.4.16\n//偶然看到，简化下代码\npublic int[][] merge(int[][] intervals) {\n    if (intervals ==null || intervals.length<=0) {\n        return new int[][]{};\n    }\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    LinkedList<int[]> list=new LinkedList<>();\n    for (int i=1;i<intervals.length;i++) {\n        if (intervals[i][0]<=intervals[i-1][1]) {\n            intervals[i][0]=intervals[i-1][0];\n            intervals[i][1]=Math.max(intervals[i-1][1],intervals[i][1]);\n        }else{\n            list.add(intervals[i-1]);\n        }\n    }\n    list.add(intervals[intervals.length-1]);\n    return list.toArray(new int[0][0]);\n}\n```\n一开始还没注意这个解法，现在回头看看这个方法挺妙的，当无法覆盖的时候将`intervals[i-1]` 入栈，当可以覆盖的时候修改当前元素值，在下一轮继续添加或覆盖，其实还是有一点点不好理解，刚刚又重写了一个，思路很直白\n\n```java\npublic int[][] merge(int[][] intervals) {\n    if(intervals==null || intervals.length<=0) return intervals;\n    Arrays.sort(intervals,(a,b)->a[0]!=b[0]?a[0]-b[0]:a[1]-b[1]);\n    List<int[]> res=new ArrayList<>();\n    res.add(intervals[0]);\n    for(int i=1;i<intervals.length;i++){\n        int[] pre=res.get(res.size()-1);\n        if(intervals[i][0]<=pre[1]){\n            if(intervals[i][1]>=pre[1]){\n                pre[1]=intervals[i][1];\n            }\n        }else{\n            res.add(intervals[i]);\n        }\n    }\n    return res.toArray(new int[0][0]);\n}\n```\n## [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)\n\nDifficulty: **中等**\n\n字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。\n\n**示例 1：**\n\n```go\n输入：S = \"ababcbacadefegdehijhklij\"\n输出：[9,7,8]\n解释：\n划分结果为 \"ababcbaca\", \"defegde\", \"hijhklij\"。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 的划分是错误的，因为划分的片段数较少。\n```\n\n**提示：**\n\n*   `S`的长度在`[1, 500]`之间。\n*   `S`只包含小写字母 `'a'` 到 `'z'` 。\n\n**解法一**\n\n我一开始的想法就是先统计出所有 26 个字母出现的首位置和末位置，然后题目就变成了 [合并区间](#56-合并区间)，但是其实不需要真正的合并，这里只需要求长度就行了\n```golang\nfunc partitionLabels(S string) []int {\n    var m = make(map[byte]int)\n    var Max = func(a, b int) int {if a>b{return a};return b}\n    for i := 0; i < len(S); i++ {\n        m[S[i]] = i\n    }\n    var start, end = 0, 0\n    var res []int\n    for i := 0; i < len(S); i++ {\n        //更新当前区间结尾最大值\n        end = Max(end, m[S[i]])\n        //走到当前区间结尾，当前区间结束\n        if i==end {\n            res = append(res, end-start+1)\n            start = i+1\n        }\n    }\n    return res\n}\n```\n代码意思很明确，多看看就明白了\n\n## [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)\n\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n注意：\n\n- 可以认为区间的终点总是大于它的起点。\n- 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n**示例 1:**\n\n```java\n输入：[ [1,2], [2,3], [3,4], [1,3] ]\n\n输出：1\n\n解释：移除 [1,3] 后，剩下的区间没有重叠。\n```\n\n**示例 2:**\n\n```java\n输入：[ [1,2], [1,2], [1,2] ]\n\n输出：2\n\n解释：你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n```\n\n**示例 3:**\n\n```java\n输入：[ [1,2], [2,3] ]\n\n输出：0\n\n解释：你不需要移除任何区间，因为它们已经是无重叠的了。\n```\n\n**解法一**\n\n动态规划，其实和最长递增子序列是一样的\n\n> 和 [最长数对链](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE) 一摸一样\n\n```java\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals==null || intervals.length<=0) {\n        return 0;\n    }\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    int[]dp=new int[intervals.length];\n    int max=-1;\n    for (int i=0;i<intervals.length;i++) {\n        dp[i]=1;\n        for (int j=0;j<i;j++) {\n            if(intervals[i][0]>=intervals[j][1]){\n                dp[i]=Math.max(dp[j]+1,dp[i]);\n            }\n        }\n        max=Math.max(max,dp[i]);\n    }\n    return intervals.length-max;\n}\n```\n先根据左边界排个序，保证后面的不会覆盖前面的，然后反手求一下最长的无重叠区间长度，和最长递增子序列一样，最后用总长度减去这个最长的区间长度结果就是答案\n\n171ms，8%，感觉快要过不了了。本来是是写的记忆化递归的，结果过不了。卡在倒数第二个 case 上\n\n**记忆化递归写法**\n\n```java\nHashMap<Pair,Integer> cache=new HashMap<>();//TLE\n\npublic int eraseOverlapIntervals2(int[][] intervals) {\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    return intervals.length-dfs(intervals,0,Integer.MIN_VALUE);\n}\n\n//背包问题，返回最多可以留下的区间\npublic int dfs(int[][] intervals,int index,int prev) {\n    if (index==intervals.length) {\n        return 0;\n    }\n    Pair key=new Pair(index,prev);\n    if (cache.containsKey(key)) {\n        return cache.get(key);\n    }\n    int res=dfs(intervals,index+1,prev);\n    if (intervals[index][0]>=prev) {\n        res=Math.max(res,dfs(intervals,index+1,intervals[index][1])+1);\n    }\n    cache.put(key,res);\n    return res;\n}\n```\n**解法二**\n\n贪心，时间复杂度降低为线性\n\n```java\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals==null || intervals.length<=0) {\n        return 0;\n    }\n    //按照起点排序，重叠的时候选择保留结尾小的那一个\n    //Arrays.sort(intervals,(a,b)->a[0]-b[0]); lambda 初始化效率会低一点\n    Arrays.sort(intervals,new Comparator<int[]>(){\n        @Override\n        public int compare(int[] a,int[] b){\n            return a[0]-b[0];\n        }\n    });\n    int res=1;\n    int prev=0;\n    for (int i=1;i<intervals.length;i++) {\n        if (intervals[i][0]>=intervals[prev][1]) {\n            res++;\n            prev=i;\n        }else if(intervals[i][1]<intervals[prev][1]){\n            prev=i; //选择结尾小的那一个\n        }\n    }\n    return intervals.length-res;\n}\n```\n按照起点排序，在重叠的时候优先选择结尾小的哪一个，这样就可能得到更多的区间组合\n\n## [1288. 删除被覆盖区间](https://leetcode-cn.com/problems/remove-covered-intervals/)\n\nDifficulty: **中等**\n\n给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。\n\n只有当 `c <= a` 且 `b <= d` 时，我们才认为区间 `[a,b)` 被区间 `[c,d)` 覆盖。\n\n在完成所有删除操作后，请你返回列表中剩余区间的数目。\n\n**示例：**\n\n```go\n输入：intervals = [[1,4],[3,6],[2,8]]\n输出：2\n解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。\n```\n\n**提示：**​​​​​​\n\n*   `1 <= intervals.length <= 1000`\n*   `0 <= intervals[i][0] < intervals[i][1] <= 10^5`\n*   对于所有的 `i != j`：`intervals[i] != intervals[j]`\n\n**解法一**\n\n思路比较直白\n```golang\nfunc removeCoveredIntervals(intervals [][]int) int {\n    sort.Slice(intervals, func (i int, j int) bool {\n        if intervals[i][0] == intervals[j][0] {\n            return intervals[i][1] > intervals[j][1]\n        }\n        return intervals[i][0] < intervals[j][0]\n    })\n    var Max = func(a, b int) int {if a>b {return a};return b}\n    var count = 0\n    var maxRight = intervals[0][1]\n    for i := 1; i < len(intervals); i++ {\n        if intervals[i][1] <= maxRight {\n            count++\n        }\n        maxRight = Max(maxRight, intervals[i][1])\n    }\n    return len(intervals)-count\n}\n```\n\n## [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)\n\nDifficulty: **中等**\n\n在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以 y 坐标并不重要，因此只要知道开始和结束的 x 坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在 10<sup>4</sup>个气球。\n\n一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x<sub style=\"display: inline;\">start，</sub>x<sub style=\"display: inline;\">end，</sub> 且满足  x<sub style=\"display: inline;\">start</sub> ≤ x ≤ x<sub style=\"display: inline;\">end，</sub>则该气球会被引爆<sub style=\"display: inline;\">。</sub>可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。\n\n**Example:**\n\n```go\n输入：\n[[10,16], [2,8], [1,6], [7,12]]\n\n输出：\n2\n\n解释：\n对于该样例，我们可以在 x = 6（射爆 [2,8],[1,6] 两个气球）和 x = 11（射爆另外两个气球）。\n```\n\n**解法一**\n\n和前面几题一样，按照起点排序，发生重叠时记录小的 Xend，实际上 end 的含义就是当前这一箭能射穿前面所有气球的最远距离，后面的气球如果大于这个距离就需要加一箭，否则就可以一并射穿\n```golang\nfunc findMinArrowShots(points [][]int) int {\n    if len(points) <= 0 {\n        return 0\n    }\n    sort.Slice(points, func(i int, j int) bool {\n        return points[i][0] < points[j][0]\n    })\n    var end = points[0][1]\n    var res = 1\n    for i := 1; i < len(points); i++ {\n        if points[i][0] > end {\n            res++\n            end = points[i][1]\n        }else{\n            end = Min(end, points[i][1])\n        }\n    }\n    return res\n}\n​\nfunc Min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n**解法二**\n\n按照终点排序\n```golang\nfunc findMinArrowShots(points [][]int) int {\n    if len(points) <= 0 {\n        return 0\n    }\n    sort.Slice(points, func(i int, j int) bool {\n        return points[i][1] < points[j][1]\n    })\n    var end = points[0][1]\n    var res = 1\n    for i := 1; i < len(points); i++ {\n        if points[i][0] > end {\n            res++\n            end = points[i][1]\n        }\n    }\n    return res\n}\n\nfunc Min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n## [1024. 视频拼接](https://leetcode-cn.com/problems/video-stitching/)\n\n你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。\n\n视频片段 `clips[i]` 都用区间进行表示：开始于 `clips[i][0]` 并于 `clips[i][1]` 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 `[0, 1] + [1, 3] + [3, 7]` 三部分。\n\n我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。\n\n**示例 1：**\n\n```java\n输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10\n输出：3\n解释：\n我们选中 [0,2], [8,10], [1,9] 这三个片段。\n然后，按下面的方案重制比赛片段：\n将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。\n现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。\n```\n\n**示例 2：**\n\n```java\n输入：clips = [[0,1],[1,2]], T = 5\n输出：-1\n解释：\n我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。\n```\n\n**示例 3：**\n\n```java\n输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9\n输出：3\n解释： \n我们选取片段 [0,4], [4,7] 和 [6,9] 。\n```\n\n**示例 4：**\n\n```java\n输入：clips = [[0,4],[2,8]], T = 5\n输出：2\n解释：\n注意，你可能录制超过比赛结束时间的视频。\n```\n\n**提示：**\n\n- `1 <= clips.length <= 100`\n- `0 <= clips[i][0], clips[i][1] <= 100`\n- `0 <= T <= 100`\n\n**解法一**\n\n感觉这个贪心还是很经典的，很多题都是这个思路，上面的 跳跃游戏 2，包括 172 周赛的最后一题，都是这个类似的区间覆盖问题\n\n```java\npublic int videoStitching(int[][] clips, int T) {\n    Arrays.sort(clips,(a,b)->a[0]-b[0]);\n    int i=0,res=0,last=0;\n    while(i<clips.length) {\n        int temp=last;\n        while(i<clips.length&&clips[i][0]<=temp) {\n            last=Math.max(last,clips[i][1]);\n            i++;\n        }\n        if (last==temp) { //没有找到能覆盖的\n            return -1;\n        }\n        res++;\n        if (last>=T) {\n            return res;\n        }\n    }\n    return -1;\n}\n```\n\n首先按照左边界排序，然后找的时候**每次都在序列中找能覆盖`overlap`上一次右边界的最长区间** ，第一次覆盖其实就是找的左边界能覆盖 0 的最长的区间，然后下一次就要找能覆盖这个区间右边界的最长的区间。最终的结果就是最少的区间数目，正确性这里其实思考一下就知道了，每次都选择最优区间，对后面的选择没有负面影响，具体如何证明还是留给大佬们吧\n\n## [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)\n\n假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对` (h, k) `表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。 编写一个算法来重建这个队列。\n\n注意：\n总人数少于 1100 人。\n\n**示例**\n\n```java\n输入：\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\n输出：\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n```\n\n**解法一**\n\n贪心，没想出来\n\n```java\npublic int[][] reconstructQueue(int[][] people) {\n    if (people==null ||people.length<=0) {\n        return new int[0][0];\n    }\n    List<int[]> res=new LinkedList<>();\n    Arrays.sort(people,(p1,p2)->p1[0]!=p2[0]?p2[0]-p1[0]:p1[1]-p2[1]);\n    for (int i=0;i<people.length;i++) {\n        res.add(people[i][1],people[i]);\n    }\n    return res.toArray(new int[0][0]);\n}\n```\n\n首先对身高 h 降序，k 升序进行排列得到，然后将元素`（h，k）`插入前面比它大的元素中的第 k 个位置，保证该元素前面有 k 个比当前元素大的，使之合法，**后面的比它矮的元素的移动对前面其实的没有任何影响**，这个算法的正确性很容易想到，身高高的人是看不到身高矮的人的~，也就是身高矮的人在身高高的人前或后对身高高的人是没有任何影响的\n\n```java\n[7,0] [7,1] [6,1] [5,0] [5,2] [4,4]\n\n[]                (7,0) -> []\n0                 (7,1) -> [7,0]\n0 1               (6,1) -> [7,0] [7,1]\n0 1 2             (5,0) -> [7,0] [6,1] [7,1]\n0 1 2 3           (5,2) -> [5,0] [7,0] [6,1] [7,1]\n0 1 2 3 4         (4,4) -> [5,0] [7,0] [5,2] [6,1] [7,1]\n0 1 2 3 4 5                [5,0] [7,0] [5,2] [6,1] [4,4] [7,1]\n```\n\n## [1262. 可被三整除的最大和](https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/)\n\n给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。\n\n**示例 1：**\n\n```java\n输入：nums = [3,6,5,1,8]\n输出：18\n解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [4]\n输出：0\n解释：4 不能被 3 整除，所以无法选出数字，返回 0。\n```\n\n**示例 3：**\n\n```java\n输入：nums = [1,2,3,4,4]\n输出：12\n解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。\n```\n\n**提示：**\n\n- `1 <= nums.length <= 4 * 10^4`\n- `1 <= nums[i] <= 10^4`\n\n**解法三**\n\nO(NlogN) 贪心，最优解法应该是 dp，放在 dp[专题中](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/)\n\n```java\npublic int maxSumDivThree3(int[] nums) {\n    int sum=0;\n    List<Integer> one=new ArrayList<>();\n    List<Integer> two=new ArrayList<>();\n    for (int n:nums) {\n        sum+=n;\n        if (n%3==1) one.add(n);\n        if (n%3==2) two.add(n);\n    }\n    Collections.sort(one);\n    Collections.sort(two);\n    if (sum%3==1) { //移除一个余数为 1 的 或者两个余数为 2 的\n        return Math.max(one.size()>=1?sum-one.get(0):0,two.size()>=2?sum-two.get(0)-two.get(1):0);\n    }\n    if (sum%3==2) { //移除一个余数为 2 或者两个余数为 1 的\n        return Math.max(two.size()>=1?sum-two.get(0):0,one.size()>=2?sum-one.get(0)-one.get(1):0);   \n    }\n    return sum;\n}\n```\n\n如果总和%3=1 我们就可以移除数组中%3=1 的最小那个或者移除两个%3=2 的最小的，同理，总和%3=2，我们可以移除一个最小的%2=0 的元素，或者移除两个%2=1 的最小元素\n\n这里我们需要记录的仅仅是数组中%3=1 和%3=2 的最小的 4 个值就 ok，其实不用排序就可以，直接 O(N) 遍历就行，嫌麻烦没改，后面有时间来改改\n\n**解法二**\n\n履行上面的承诺，改好了一版 O(N) 的贪心解法\n\n```java\npublic int maxSumDivThree(int[] nums) {\n    int M=0x3f3f3f3f;\n    //余 1 最小值\n    int min1_0=M,min1_1=M;\n    //余 2 最小值\n    int min2_0=M,min2_1=M;\n    int sum=0;\n    for(int i=0;i<nums.length;i++){\n        sum+=nums[i];\n        if(nums[i]%3==1){\n            if(nums[i]<=min1_0){\n                min1_1=min1_0; //更新次小值\n                min1_0=nums[i]; //更新最小值\n            }else if(nums[i]<=min1_1){\n                min1_1=nums[i]; //更新次小值\n            }\n        }\n        if(nums[i]%3==2){\n            if(nums[i]<=min2_0){\n                min2_1=min2_0;\n                min2_0=nums[i];\n            }else if(nums[i]<=min2_1){\n                min2_1=nums[i];\n            }\n        }\n    }\n    if(sum%3==1) return sum-Math.min(min2_0+min2_1,min1_0);\n    if(sum%3==2) return sum-Math.min(min1_0+min1_1,min2_0);\n    return sum;\n}\n```\n\n## [5172. 形成三的最大倍数](https://leetcode-cn.com/problems/largest-multiple-of-three/)\n\n给你一个整数数组 `digits`，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。\n\n由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。\n\n如果无法得到答案，请返回一个空字符串。\n\n**示例 1：**\n\n```java\n输入：digits = [8,1,9]\n输出：\"981\"\n```\n\n**示例 2：**\n\n```java\n输入：digits = [8,6,7,1,0]\n输出：\"8760\"\n```\n\n**示例 3：**\n\n```java\n输入：digits = [1]\n输出：\"\"\n```\n\n**示例 4：**\n\n```java\n输入：digits = [0,0,0,0,0,0]\n输出：\"0\"\n```\n\n**提示：**\n\n- 1 <= digits.length <= 10^4\n- 0 <= digits[i] <= 9\n- 返回的结果不应包含不必要的前导零。\n\n**解法一**\n\n177 周赛的 T4，时隔多日，周赛又出了这一题，和上面一样，思路差不多的，需要优先考虑只删除一个的情况\n\n```java\npublic String largestMultipleOfThree(int[] digits) {\n    int sum=0;\n    int[] freq=new int[10];\n    for(int i=0;i<digits.length;i++) {\n        sum+=digits[i];\n        freq[digits[i]]++;\n    }\n    if(sum==0) return \"0\";\n    //删除一个余 1 的或者两个余 2 的，优先删除一个余 1 的\n    //删除 1 个得到的结果肯定比删除 2 个大\n    if(sum%3==1){ \n        if(!deleteMin(freq,1)){ \n            deleteMin(freq,2);\n        }\n    }\n    if(sum%3==2){ //删除一个余 2 的或者两个余 1 的\n        if(!deleteMin(freq,2)){\n            deleteMin(freq,1);\n        }   \n    }\n    StringBuilder res=new StringBuilder();\n    //逆序构建结果\n    for(int i=9;i>=0;i--){\n        int count=freq[i];\n        while(count-- >0){\n            res.append(i);\n        }\n    }\n    return res.toString();\n}\n\npublic boolean deleteMin(int[] freq,int y){\n    for (int i=y;i<9;i+=3) {\n        if (freq[i]!=0) {\n            freq[i]--;\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## [1111. 有效括号的嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)\n\n迷惑题，不想粘题目了\n\n**解法一**\n\n按照深度的奇偶划分两个子串。\n\n```java\npublic int[] maxDepthAfterSplit(String seq) {\n    //Deque<Character> stack=new ArrayDeque<>();\n    int depth=0;\n    int[] res=new int[seq.length()];\n    for (int i=0;i<seq.length();i++) {\n        if(seq.charAt(i)=='('){\n            res[i]=depth++%2;\n        }else{\n            //根据左括号奇偶判断\n            res[i]=--depth%2;\n        }\n    }\n    return res;\n}\n```\n\n## [1353. 最多可以参加的会议数目](https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/) \n\n给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。\n\n你可以在满足 startDayi <= d <= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。\n\n请你返回你可以参加的 最大 会议数目。\n\n**示例 1：**\n\n![JELWN9.png](https://s1.ax1x.com/2020/04/17/JELWN9.png)\n\n```java\n输入：events = [[1,2],[2,3],[3,4]]\n输出：3\n解释：你可以参加所有的三个会议。\n安排会议的一种方案如上图。\n第 1 天参加第一个会议。\n第 2 天参加第二个会议。\n第 3 天参加第三个会议。\n```\n\n**示例 2：**\n\n```java\n输入：events= [[1,2],[2,3],[3,4],[1,2]]\n输出：4\n```\n\n**示例 3：**\n\n```java\n输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]]\n输出：4\n```\n\n**示例 4：**\n\n```java\n输入：events = [[1,100000]]\n输出：1\n```\n\n**示例 5：**\n\n```java\n输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]\n输出：7\n```\n\n**提示：**\n\n- `1 <= events.length <= 10^5`\n- `events[i].length == 2`\n- `1 <= events[i][0] <= events[i][1] <= 10^5`\n\n**解法一**\n\n暴力贪心\n\n```java\n//[[1,4],[4,4],[2,2],[3,4],[1,1]]\n// 1,1  2,2  1,4  3,4  4,4\n// 暴力贪心，按结束时间排序，优先安排结束时间短的，O(N^2)\npublic int maxEvents(int[][] events) {\n    if(events==null || events.length<=0) return 0;\n    Arrays.sort(events,(e1,e2)->e1[1]-e2[1]);\n    //当天有没有安排会议\n    HashSet<Integer> set=new HashSet<>();\n    int count=0;\n    for(int i=0;i<events.length;i++){\n        int start=events[i][0];\n        int end=events[i][1];\n        for(int j=start;j<=end;j++){ //在对应时间段内进行安排\n            if(!set.contains(j)){\n                set.add(j);\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n**解法二**\n\n```java\n//优先队列优化，NlogN\npublic int maxEvents(int[][] events) {\n    if(events==null || events.length<=0) return 0;\n    Arrays.sort(events,(e1,e2)->e1[0]-e2[0]);\n    //结束时间构建小根堆\n    PriorityQueue<Integer> pq=new PriorityQueue<>();\n    int index=0,res=0,n=events.length;\n    int curDay=1;\n    while(index<n || !pq.isEmpty()){\n        //将当天开始的会议的结束时间加入小根堆\n        while(index<n && curDay==events[index][0]){\n            pq.add(events[index++][1]);\n        }\n        //将过期会议的移除\n        while(!pq.isEmpty() && pq.peek()<curDay){\n            pq.poll();\n        }\n        //优先选择结束时间最短的\n        if(!pq.isEmpty()){\n            pq.poll();\n            res++;\n        }\n        curDay++; //安排下一天\n    }\n    return res;\n}\n```\n\n## [134. 加油站](https://leetcode-cn.com/problems/gas-station/)\n\n在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n\n如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。\n\n**说明：** \n\n- 如果题目有解，该答案即为唯一答案。\n- 输入数组均为非空数组，且长度相同。\n- 输入数组中的元素均为非负数。\n\n**示例 1:**\n\n```java\n输入：\ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\n输出：3\n\n解释：\n从 3 号加油站（索引为 3 处）出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。\n```\n\n**示例 2:**\n\n```java\n输入：\ngas  = [2,3,4]\ncost = [3,4,3]\n\n输出：-1\n\n解释：\n你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。\n```\n\n**解法一**\n\n```go\nfunc canCompleteCircuit(gas []int, cost []int) int {\n    n:=len(gas)\n    curGas:=0 //当前油量\n    start:=0 //起点\n    total:=0 //gas 和 cost 之差，小于 0 的话肯定无法绕圈\n    for i:=start;i<n;i++{\n        curGas+=(gas[i]-cost[i])\n        total+=(gas[i]-cost[i])\n        //油量不够，i 无法继续前进到 i+1, 说明从 start~i 无法绕环\n        if curGas<0{ \n            start=i+1\n            curGas=0\n        }\n    }\n    if total<0{\n        return -1\n    }\n    return start\n}\n```\n\n## [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n- 如果 `x == y`，那么两块石头都会被完全粉碎；\n- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n\n最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。\n\n**示例：**\n\n```java\n输入：[2,7,4,1,8,1]\n输出：1\n解释：\n先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，\n再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，\n接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，\n最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。\n```\n\n**提示：**\n\n1. `1 <= stones.length <= 30`\n2. `1 <= stones[i] <= 1000`\n\n**解法一**\n\n虽然 tag 有贪心，但是并不是贪心。直接模拟就行了，反而是这题的 [进阶版本](https://leetcode-cn.com/problems/last-stone-weight-ii/)，我以为可以这样贪心过，结果发现不对\n\n```java\npublic int lastStoneWeight(int[] stones) {\n    if(stones==null ||stones.length<=0){\n        return 0;\n    }\n    PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->b-a);\n    for(int i=0;i<stones.length;i++){\n        pq.add(stones[i]);\n    }\n    //NlogN\n    while(pq.size()>1){\n        int y=pq.poll();\n        int x=pq.poll();\n        pq.add(y-x);\n    }\n    return pq.poll();\n}\n```\n## [920. 会议室 (LintCode)](https://www.lintcode.com/problem/meeting-rooms/description)\n\n给定一系列的会议时间间隔，包括起始和结束时间 [[s1,e1]，[s2,e2]，…(si < ei)，确定一个人是否可以参加所有会议。\n- (0,8),(8,10) 在 8 这这一时刻不冲突\n\n**样例 1**\n\n```go\n输入：intervals = [(0,30),(5,10),(15,20)]\n输出：false\n解释：\n(0,30), (5,10) 和 (0,30),(15,20) 这两对会议会冲突\n```\n**样例 2**\n```go\n输入：intervals = [(5,8),(9,15)]\n输出：true\n解释：\n这两个时间段不会冲突\n```\n\n**解法一**\n\n这个比较简单，排序后判断相邻的区间是否会覆盖就行了\n```golang\nimport \"sort\"\n\nfunc canAttendMeetings (intervals []*Interval) bool {\n    // Write your code here\n    sort.Slice(intervals, func(i int, j int) bool {\n        return intervals[i].Start < intervals[j].Start\n    })\n    for i := 1; i < len(intervals); i++ {\n        if intervals[i].Start < intervals[i-1].End {\n            return false\n        }\n    }\n    return true\n}\n```\n\n## [919. 会议室 II(LintCode)](https://www.lintcode.com/problem/meeting-rooms-ii/description)\n\n给定一系列的会议时间间隔 intervals，包括起始和结束时间 [[s1,e1],[s2,e2],...] (si < ei)，找到所需的最小的会议室数量。\n\n**样例 1**\n```go\n输入：intervals = [(0,30),(5,10),(15,20)]\n输出：2\n解释：\n需要两个会议室\n会议室 1:(0,30)\n会议室 2:(5,10),(15,20)\n```\n\n**样例 2**\n```go\n输入：intervals = [(2,7)]\n输出：1\n解释：\n只需要 1 个会议室就够了\n```\n\n**解法一**\n\n扫描线的做法，感觉比较简单，也比较好理解（这应该属于最简单的扫描线吧，我看了其他的一些扫描线啥的都是 acm 里面的内容）\n![mark](http://static.imlgw.top/blog/20200810/nQveo3X6eKxI.png?imageslim)\n类似就是上图样子，求一个最大的有重合的区间数量，先将起点终点打散后排序，扫描的时候就按照排序后的节点来一个个扫描，然后根据节点的属性来判断是应该+1 还是-1，如果是起点就+1，如果遇到终点就-1，整个过程就像是一条线从左往右扫描过去一样\n```golang\n/**\n * Definition of Interval:\n * type Interval struct {\n *     Start, End int\n * }\n */\n\n/**\n * @param intervals: an array of meeting time intervals\n * @return: the minimum number of conference rooms required\n */\nimport \"sort\"\n\ntype Pair struct{\n    time int\n    isEnd bool\n}\n\nfunc minMeetingRooms (intervals []*Interval) int {\n    var n = len(intervals)\n    var list []*Pair\n    var Max = func (a,b int) int {if a>b {return a};return b}\n    for i := 0; i < n; i++ {\n        list = append(list, &Pair{intervals[i].Start,false})\n        list = append(list, &Pair{intervals[i].End,true})\n    }\n    sort.Slice(list, func (i int, j int) bool {\n        return list[i].time < list[j].time\n    })\n    var res = 0\n    var count = 0\n    for _, p := range list {\n        if p.isEnd{\n            count--\n        }else{\n            count++\n        }\n        res = Max(count, res)\n    }\n    return res\n}\n```\n**解法二**\n\n排序+小根堆，按起点排序，然后遍历所有区间，如果某个区间的 start 大于堆顶的结束时间，说明这两个会议可以公用一个会议室，所以将堆顶弹出，然后将当前会议加入堆中，所以最后堆的大小就是会议室的数量\n```java\n//小根堆的思路\npublic int minMeetingRooms(List<Interval> intervals) {\n    // Write your code here\n    Collections.sort(intervals,(i1,i2)->i1.start-i2.start);\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n    pq.add(intervals.get(0).end);\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals.get(i).start > pq.peek()) {\n            pq.poll();\n        }\n        pq.add(intervals.get(i).end);\n    }\n    return pq.size();\n}\n```\n个人感觉这个思路还是没有上面扫描线简单好理解\n\n## [391. 数飞机 (LintCode)](https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/description)\n\n给出飞机的起飞和降落时间的列表，用序列 interval 表示。请计算出天上同时最多有多少架飞机？\n\n**样例 1:**\n```go\n输入：[(1, 10), (2, 3), (5, 8), (4, 7)]\n输出：3\n解释：\n第一架飞机在 1 时刻起飞，10 时刻降落。\n第二架飞机在 2 时刻起飞，3 时刻降落。\n第三架飞机在 5 时刻起飞，8 时刻降落。\n第四架飞机在 4 时刻起飞，7 时刻降落。\n在 5 时刻到 6 时刻之间，天空中有三架飞机。\n```\n**样例 2:**\n```go\n输入：[(1, 2), (2, 3), (3, 4)]\n输出：1\n解释：降落优先于起飞。\n```\n\n**解法一**\n\n和会议室一摸一样，代码稍微改动一点，排序规则需要遵循降落有限\n```golang\n/**\n * Definition of Interval:\n * type Interval struct {\n *     Start, End int\n * }\n */\n\n/**\n * @param airplanes: An interval array\n * @return: Count of airplanes are in the sky.\n */\nimport \"sort\"\n\ntype Pair struct {\n    time  int\n    isEnd bool\n}\n\nfunc countOfAirplanes(airplanes []*Interval) int {\n    var n = len(airplanes)\n    var list []*Pair\n    var Max = func(a, b int) int {\n        if a > b {\n            return a\n        }\n        return b\n    }\n    for i := 0; i < n; i++ {\n        list = append(list, &Pair{airplanes[i].Start, false})\n        list = append(list, &Pair{airplanes[i].End, true})\n    }\n    //[(1, 2), (2, 3), (3, 4)]\n    //随意排序： 1 2start 2end 3start 3end 4 这样最大值就是 2，不对\n    //所以应该降落优先，将降落时间点的排在前面\n    sort.Slice(list, func(i int, j int) bool {\n        if list[i].time == list[j].time {\n            //将 end 放在前面\n            return list[i].isEnd\n        }\n        return list[i].time < list[j].time\n    })\n    var res = 0\n    var count = 0\n    for _, p := range list {\n        if p.isEnd {\n            count--\n        } else {\n            count++\n        }\n        res = Max(count, res)\n    }\n    return res\n}\n```\n当然同样可以使用堆，这里就不多写了\n\n## [NC531. 递增数组](https://www.nowcoder.com/practice/d0907f3982874b489edde5071c96754a)\n\n牛牛有一个数组 array，牛牛可以每次选择一个连续的区间，让区间的数都加 1，他想知道把这个数组变为严格单调递增，最少需要操作多少次？\n- 1 <= array.size <= 2*10^5\n- 1 <= array[i] <= 1*10^9\n\n**示例 1**\n```go\n输入：[1,2,1]\n输出：2\n说明：把第三个数字+2 可以构成 1，2，3\n```\n**解法一**\n\n```java\npublic long IncreasingArray (int[] array) {\n    // write code here\n    long res = 0;\n    for (int i = 1; i < array.length; i++){\n        if (array[i] <= array[i-1]) {\n            res += array[i-1]-array[i]+1;\n        }\n    }\n    return res;\n}\n```\n虽然是 easy，还是想了一会儿，我的想法就是当增加一个数的时候就连同**后面的所有数**一起增加，而增加一个数肯定是增加到前一个数+1 的次数是最少的（当然我们也不用真的去加，因为后面的区间是整体++，而我们要求的操作次数只是个差值）\n其实很详细的证明我也给不出来，我只考虑了几种情况\n1. `i`后面的部分是单调递增的 3 1(i)  2  3，那么很明显这里和后面一起增加是最优选择\n2. `i`后面是部分是单调递减的 3 3(i)  2  1，那么同样，和后面的一起增加是最优选择，单独选择某一个区间都会导致整体的落差变大，使得后面没增加的部分需要增加的次数增加\n3. `i`后面先递增后递减 3 1(i)  2  1 同上 相当于 递增+递减 看做两部分，（1 2）同增，那么（2，1）也应该随之同增\n4. `i`后面先递减后递增 5 4(i) 3 5  递减+递增 也分成两部分\n\n## [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)\n\nDifficulty: **中等**\n\n给定一个非负整数&amp;nbsp;<code>N</code>，找出小于或等于&amp;nbsp;<code>N</code>&amp;nbsp; 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>\n\n<p>（当且仅当每个相邻位数上的数字&amp;nbsp;<code>x</code>&amp;nbsp; 和&amp;nbsp;<code>y</code>&amp;nbsp; 满足&amp;nbsp;<code>x &amp;lt;= y</code>&amp;nbsp; 时，我们称这个整数是单调递增的。）</p>\n\n<p>\n\n给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。\n\n（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）\n\n**示例 1:**\n\n```go\n输入：N = 10\n输出：9\n```\n\n**示例 2:**\n\n```go\n输入：N = 1234\n输出：1234\n```\n\n**示例 3:**\n\n```go\n输入：N = 332\n输出：299\n```\n\n**说明：** `N` 是在 `[0, 10^9]` 范围内的一个整数。\n\n<strong>示例 1:</strong></p>\n\n```go\n输入：N = 10\n输出：9\n```\n\n<p><strong>示例 2:</strong></p>\n\n```go\n输入：N = 1234\n输出：1234\n```\n\n<p><strong>示例 3:</strong></p>\n\n```go\n输入：N = 332\n输出：299\n```\n\n<p><strong>说明：</strong> N 是在<code>[0, 10^9]</code>范围内的一个整数。</p>\n\n**解法一**\n\n这题写了好几版，总感觉很简单，但是总是有 case 能把我卡住，最终的思路就是，**逆向遍历**这个数，如果某个数小于前面（左边）的数，那么将前面的数减一，然后记录下当前的下标，最终这个下标后面的数都要变成 9\n```golang\n//322 -> 299\n//243 -> 239\n//3524 -> 499\n//332 -> 299\n//235854 235799\nfunc monotoneIncreasingDigits(N int) int {\n    var nums []int\n    //123\n    for N > 0 {\n        nums = append(nums, N%10)\n        N /= 10\n    }\n    var res = 0\n    var idx = -1\n    //213\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] < nums[i+1] {\n            idx = i\n            nums[i+1]--\n        }\n    }\n    for i := len(nums) - 1; i >= 0; i-- {\n        if i <= idx {\n            res = res*10 + 9\n        } else {\n            res = res*10 + nums[i]\n        }\n    }\n    return res\n}\n```","tags":["LeetCode","贪心"],"categories":["算法"]},{"title":"字典树初探","url":"/2019/12/17/21e3bd45/","content":"\n## 字典树\n\n在计算机科学中，**trie**，又称**前缀树**或**字典树**，字典树设计的核心思想是空间换时间，所以数据结构本身比较消耗空间。但它利用了字符串的**共同前缀（Common Prefix）**作为存储依据，以此来节省存储空间，并加速搜索时间。Trie 的字符串搜索时间复杂度为 **O(m)**，m 为最长的字符串的长度，其查询性能与集合中的字符串的数量无关。其在搜索字符串时表现出的高效，使得特别适用于构建文本搜索和词频统计等应用\n\n### 性质\n\n与二分搜索树不同，**键不是直接保存在节点中，而是由节点在树中的位置决定**。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有**叶子节点**和部分内部节点所对应的键才有相关的值\n\n## 实现\n\n### 使用 TreeMap 实现\n\n```java\nimport java.util.*;\npublic class Trie{\n    private class Node{\n        public boolean isWord; //是否是一个完整单词\n        public TreeMap<Character,Node> next;\n\n        public Node(boolean isWord){\n            this.isWord = isWord;\n            next = new TreeMap<>();\n        }\n\n        public Node(){\n            this(false);\n        }\n    }\n\n    private Node root;\n\n    private int size;\n\n    public Trie(){\n        root=new Node();\n        size=0;\n    }\n\n    public int getSize(){\n        return size;\n    }\n\n    //向 Trie 中添加 word\n    public void addLoop(String word){\n        Node cur=root;\n        for (int i=0;i<word.length();i++) {\n            char c=word.charAt(i);\n            if (cur.next.get(c)==null) {\n                cur.next.put(c,new Node());\n            }\n            cur=cur.next.get(c);\n        }\n        if (!cur.isWord) {\n            size++;\n            cur.isWord=true;\n        }\n    }\n\n    //递归的添加\n    public void add(String word){\n        add(root,word,0);\n    }\n\n    public void add(Node cur,String word,int index){\n        if (index==word.length()) {\n            if (!cur.isWord) {\n                size++;\n                cur.isWord=true;\n            }\n            return;\n        }\n        char c=word.charAt(index);\n        if (cur.next.get(c)==null) {\n            cur.next.put(c,new Node());\n        }\n        add(cur.next.get(c),word,index+1); //尾递归\n    }\n\n    //查询 word 是否在 Trie 中\n    public boolean contains(String word){\n        return contains(root,word,0);\n    }\n\n    public boolean contains(Node cur,String word,int index){\n        if (index==word.length()) {\n            return cur.isWord;\n        }\n        char c=word.charAt(index);\n        return cur.next.containsKey(c) && contains(cur.next.get(c),word,index+1);\n    }\n\n    //循环\n    public boolean containsLoop(String word){\n        Node cur=root;\n        for (int i=0;i<word.length();i++) {\n            Character c=word.charAt(i);\n            if (!cur.next.containsKey(c)) {\n                return false;   \n            }\n            cur=cur.next.get(c);\n        }\n        return cur.isWord;\n    }\n\n    //是否有某个前缀\n    public boolean hasPerfix(String perfix){\n        return hasPerfix(root,perfix,0);\n    }\n\n    public boolean hasPerfix(Node cur,String perfix,int index){\n        if (index==perfix.length()) {\n            return true;\n        }\n        char c=perfix.charAt(index);\n        return cur.next.containsKey(c) && hasPerfix(cur.next.get(c),perfix,index+1);\n    }\n\n    //懒得写循环了。\n}\n```\n\n整体上来说其实很简单，这里用的是 TreeMap 来存储当前节点的下一层节点，可以看到，在 Node 中并没有直接存储某个字符，而是对应了 TreeMap 的 Key，但是由于 TreeMap 底层是红黑树，其实在数据量比较小的时候并没有优势，所以在某些情况下，我们也可以直接使用数组来存储节点，比如下面这道题\n\n## LeetCode 练手例题\n\n### [208. 实现 Trie （前缀树）](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n\n实现一个 Trie （前缀树），包含 insert, search, 和 startsWith 这三个操作。\n\n**示例：**\n\n```java\nTrie trie = new Trie();\n\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 true\ntrie.search(\"app\");     // 返回 false\ntrie.startsWith(\"app\"); // 返回 true\ntrie.insert(\"app\");   \ntrie.search(\"app\");     // 返回 true\n```\n\n**说明：**\n\n- 你可以假设所有的输入都是由小写字母 a-z 构成的。\n- 保证所有输入均为非空字符串\n\n**解法一**\n\n```java\nclass Trie {\n    private class Node{\n        public boolean isWord; //是否是一个完整单词\n        public Node[] next;\n\n        public Node(boolean isWord){\n            this.isWord = isWord;\n            next = new Node[26];\n        }\n\n        public Node(){\n            this(false);\n        }\n    }\n\n    private Node root;\n\n    /** Initialize your data structure here. */\n    public Trie() {\n        root=new Node();\n    }\n    \n    /** Inserts a word into the trie. */\n    public void insert(String word) {\n        insert(root,word,0);\n    }\n    \n    public void insert(Node cur,String word,int index){\n        if (index==word.length()) {\n            if (!cur.isWord) {\n                cur.isWord=true;\n            }\n            return;\n        }\n        char c=word.charAt(index);\n        if (cur.next[c-'a']==null) {\n            cur.next[c-'a']=new Node();\n        }\n        insert(cur.next[c-'a'],word,index+1); //尾递归\n    }\n\n    /** Returns if the word is in the trie. */\n    public boolean search(String word) {\n        return search(root,word,0);\n    }\n    \n    public boolean search(Node cur,String word,int index){\n        if (index==word.length()) {\n            return cur.isWord;\n        }\n        char c=word.charAt(index);\n        return cur.next[c-'a']!=null&& search(cur.next[c-'a'],word,index+1);\n    }\n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    public boolean startsWith(String prefix) {\n        return startsWith(root,prefix,0);\n    }\n    \n    public boolean startsWith(Node cur,String prefix,int index){\n        if (index==prefix.length()) {\n            return true;\n        }\n        char c=prefix.charAt(index);\n        return cur.next[c-'a']!=null && startsWith(cur.next[c-'a'],prefix,index+1);\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n```\n\n这里题目说明了所有的输入都是小写字符，所以可以直接使用固定大小的 Node 数组来实现，相比于上面的 TreeMap 时间空间上都会有很大的提升\n\n### [211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/)\n\n设计一个支持以下两种操作的数据结构：\n\n```java\nvoid addWord(word)\nbool search(word)\n```\n\n`search(word)` 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 `.` 可以表示任何一个字母。\n\n**示例：**\n\n```java\naddWord(\"bad\")\naddWord(\"dad\")\naddWord(\"mad\")\nsearch(\"pad\") -> false\nsearch(\"bad\") -> true\nsearch(\".ad\") -> true\nsearch(\"b..\") -> true\n```\n\n**说明：**\n\n你可以假设所有单词都是由小写字母 `a-z` 组成的。\n\n**解法一**\n\n```java\nprivate class Node{\n    public boolean isWord; //是否找到了一个单词\n    public Node[] next;\n\n    public Node(boolean isWord){\n        this.isWord = isWord;\n        next = new Node[26];\n    }\n\n    public Node(){\n        this(false);\n    }\n}\n\nprivate Node root;\n\n/** Initialize your data structure here. */\npublic WordDictionary() {\n    root=new Node();\n}\n\n/** Adds a word into the data structure. */\npublic void addWord(String word) {\n    addWord(root,word,0);\n}\n\npublic void addWord(Node cur,String word,int index) {\n    if (index == word.length()) {\n        cur.isWord=true;\n        return;\n    }\n    char c=word.charAt(index);\n    if (cur.next[c-'a']==null) {\n        cur.next[c-'a']= new Node();\n    }\n    addWord(cur.next[c-'a'],word,index+1);\n}\n\n/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */\npublic boolean search(String word) {\n    return search(root,word,0);\n}\n\npublic boolean search(Node cur,String word,int index) {\n    if (index == word.length()) {\n        return cur.isWord;\n    }\n    char c=word.charAt(index);\n    if (c=='.') {\n        for (int i=0;i<cur.next.length;i++) {\n            if(cur.next[i]!=null && search(cur.next[i],word,index+1)){\n                return true;\n            }\n        }\n        return false;\n    }\n    return cur.next[c-'a']!=null && search(cur.next[c-'a'],word,index+1);\n}\n```\n没啥好说的，遇到点就循环判断每个子节点就 ok\n\n### [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)\n\n实现一个 MapSum 类里的两个方法，`insert` 和 `sum`。\n\n对于方法 `insert`，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。\n\n对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。\n\n**示例 1:**\n\n```java\n输入：insert(\"apple\", 3), 输出：Null\n输入：sum(\"ap\"), 输出：3\n输入：insert(\"app\", 2), 输出：Null\n输入：sum(\"ap\"), 输出：5\n```\n\n**解法一**\n\n有了前面的铺垫，其实这个也很简单\n\n```java\nclass MapSum {\n\n    private class Node{\n        public boolean isWord; //是否找到了一个单词\n        public Node[] next;\n        public int value;\n\n        public Node(boolean isWord,int value){\n            this.isWord = isWord;\n            this.value=value;\n            next = new Node[26];\n        }\n\n        public Node(int value){\n            this(false,value);\n        }\n    }\n    \n    private Node root;\n\n    public MapSum() {\n        root=new Node(0);\n    }\n    \n    public void insert(String key, int val) {\n        insert(root,key,val,0);\n    }\n\n    //a p p l e\n    public void insert(Node cur,String key, int val,int index) {\n        if (index==key.length()) {\n            cur.isWord=true;\n            cur.value=val;\n            return;\n        }\n        char c=key.charAt(index);\n        if (cur.next[c-'a']==null) {\n            cur.next[c-'a']=new Node(0);\n        }\n        insert(cur.next[c-'a'],key,val,index+1);\n    }\n    \n    public int sum(String prefix) {\n        return sum(root,prefix,0);\n    }\n\n    public int sum(Node cur,String prefix,int index) {\n        if (index == prefix.length()) {\n            return tireSum(cur);\n        }\n        char c=prefix.charAt(index);\n        if (cur.next[c-'a']==null) {\n        \treturn 0;\n        }\n        return sum(cur.next[c-'a'],prefix,index+1);\n    }\n\n    public int tireSum(Node cur){\n    \tint sum=0;\n    \tif (cur.isWord) {\n    \t\tsum+=cur.value;\n    \t}\n    \tfor (int i=0;i<26;i++) {\n    \t\tsum+=cur.next[i]!=null?tireSum(cur.next[i]):0;\n    \t}\n    \treturn sum;\n    }\n}\n```\n\n还是和上面一样，利用前缀树，不过要在上面的基础上做一些改动添加一个 value 字段用来保存值，先在树中找到要求的前缀的最后一个单词所在的节点，然后就直接求这个节点所有的子节点中 isWord 的单词的 value 累加和就 ok 了，我上面的实现并不好，都是写的递归，而且是尾递归，很鸡肋其实\n\n### [820. 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words/)\n\n给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。\n\n例如，如果这个列表是 `[\"time\", \"me\", \"bell\"]`，我们就可以将其表示为 S = `\"time#bell#\"` 和 `indexes = [0, 2, 5]`。\n\n对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 \"#\" 结束，来恢复我们之前的单词列表。\n\n那么成功对给定单词列表进行编码的最小字符串长度是多少呢？\n\n**示例：**\n\n```java\n输入：words = [\"time\", \"me\", \"bell\"]\n输出：10\n说明：S = \"time#bell#\" ， indexes = [0, 2, 5] 。\n```\n\n**提示：**\n\n- `1 <= words.length <= 2000`\n- `1 <= words[i].length <= 7`\n- 每个单词都是小写字母 。\n\n**解法一**\n\n`2020.3.28` 打卡题，简单写了个 Trie，纠结了半天要不要排序\n\n```java\npublic int res=0;\n\nprivate Node root;\n\npublic int minimumLengthEncoding(String[] words) {\n    root=new Node();\n    //纠结了半天要不要排序\n    Arrays.sort(words,(a,b)->b.length()-a.length());\n    for (int i=0;i<words.length;i++) {\n        if(!hasPrefix(words[i])){\n            add(words[i]);\n            res+=(words[i].length()+1);\n        }\n    }\n    return res;\n}\n\nprivate class Node{\n    \n    public Node[] next;\n    \n    public Node(){\n        next = new Node[26];\n    }\n}\n\n//递归的添加\npublic void add(String word){\n    //后缀树\n    add(root,word,word.length()-1);\n}\n\npublic void add(Node cur,String word,int index){\n    if (index==-1) {\n        return;\n    }\n    char c=word.charAt(index);\n    if (cur.next[c-'a']==null) {\n        cur.next[c-'a']=new Node();\n    }\n    add(cur.next[c-'a'],word,index-1); //尾递归\n}\n\npublic boolean hasPrefix(String word){\n    return hasPrefix(root,word,word.length()-1);\n}\n\npublic boolean hasPrefix(Node cur,String word,int index){\n    if(index==-1){\n        return true;\n    }\n    char c=word.charAt(index);\n    return cur.next[c-'a']!=null && hasPrefix(cur.next[c-'a'],word,index-1);\n}\n```\n\n**解法二**\n\n直接**逆序**后按**字典序**排序，这样单词的前缀包含关系就排好了，比如 time , me, bell, 最后就会变为 em emit lleb\n\n然后遍历所有单词，如果前面的单词是后面的前缀，就把前面的单词丢掉，否则就需要加上当前字符长度，代码后面有时间再补","tags":["数据结构","树"],"categories":["数据结构"]},{"title":"线段树初探","url":"/2019/12/09/44ba5333/","content":"\n## 前言\n\n线段树其实属于比较高级的数据结构了，本人并不是竞赛选手，这里的代码也是借鉴的 bobo 老师的视频课来实现的，面试什么的一般是不会考的，这里主要是出于兴趣练练手\n\n## 问题引入\n\n[307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)\n\n给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。\n\nupdate(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。\n\n**示例：**\n\n```java\nGiven nums = [1, 3, 5]\n\nsumRange(0, 2) -> 9\nupdate(1, 2)\nsumRange(0, 2) -> 8\n```\n\n**说明：**\n\n1. 数组仅可以在 update 函数下进行修改。\n2. 你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。\n\n> 这题如果数组不能修改的话就好说了，可以直接利用数组的前缀和，但是这里数组是会变化的，难道没更新一次都要重新遍历么？那也太慢了吧，有没有一种结构能高效的插入同时也能高效的查询？\n\n## 线段树\n\n线段树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性（它是一颗平衡二叉树），它基本能保持每个操作的复杂度为`O(logN)`\n\n线段树的每个节点表示一个区间，父区间为`[a,b]` 则左子区间为`[a,(a+b)/2]`右子区间为`[(a+b)/2+1,b]` 最底层的叶子节点就是对应的一个个具体的元素值，这里我们采用数组来实现线段树\n\n```java\nimport java.util.function.*;\npublic class SegmentTree<E>{\n    \n    private E[] data;\n\n    private E[] tree;\n\n    private BiFunction<E,E,E> function;\n\n    public SegmentTree(E[] arr,BiFunction<E,E,E> function){\n        data = (E[]) new Object[arr.length];\n        this.function=function;\n        System.arraycopy(arr,0,data,0,arr.length);\n        //值得思考为什么是 4n\n        tree = (E[]) new Object[4*arr.length];\n        buildSegmentTree(0,0,arr.length-1);\n    }\n\n    //根据传入的 BiFuction 构建线段树\n    private void buildSegmentTree(int index,int left,int right){\n        if (left==right) {\n            tree[index] =data[right];\n            return;\n        }\n        int leftIndex=leftChild(index);\n        int rightIndex=rightChild(index);\n        int mid=left+(right-left)/2;\n        buildSegmentTree(leftIndex,left,mid);\n        buildSegmentTree(rightIndex,mid+1,right);\n        //根据业务需求传入 BiFunction\n        tree[index]=function.apply(tree[leftIndex],tree[rightIndex]);\n    }\n\n    //范围搜索\n    public E searchRange(int left,int right){\n        return searchRange(0,0,data.length-1,left,right);\n    }\n\n    private E searchRange(int rootIndex,int left,int right,int targetLeft,int targetRight){\n        if (targetLeft == left && targetRight == right) {\n            return tree[rootIndex];\n        }\n        int mid=left+(right-left)/2;\n        if (targetLeft>mid) {\n            return searchRange(rightChild(rootIndex),mid+1,right,targetLeft,targetRight);\n        }\n        if (targetRight<=mid) {\n            return searchRange(leftChild(rootIndex),left,mid,targetLeft,targetRight);\n        }\n        return function.apply(searchRange(leftChild(rootIndex),left,mid,targetLeft,mid),searchRange(rightChild(rootIndex),mid+1,right,mid+1,targetRight));\n    }\n\n    public void update(int index,E e){\n        if (index<0 || index>=data.length) {\n            throw new IllegalArgumentException(\"index illegal\");\n        }\n        update(0,0,data.length-1,index,e);\n    }\n\n    public void update(int rootIndex,int left,int right,int targetIndex,E e){\n        if (left == right) {\n            tree[rootIndex]=e;\n            return;\n        }\n        int mid=left+(right-left)/2;\n        if (targetIndex<=mid) {\n            update(leftChild(rootIndex),left,mid,targetIndex,e);\n        }else{\n            update(rightChild(rootIndex),mid+1,right,targetIndex,e);\n        }\n        tree[rootIndex]=function.apply(tree[leftChild(rootIndex)],tree[rightChild(rootIndex)]);\n    }\n\n    public int getSize(){\n        return data.length;\n    }\n\n    public E get(int index){\n        if (index<0 || index>=data.length) {\n            throw new IllegalArgumentException(\"index is illegal!\");\n        }\n        return data[index];\n    }\n\n    //左孩子\n    private int leftChild(int index){\n        return index*2+1;\n    }\n\n    //右孩子\n    private int rightChild(int index){\n        return index*2+2;\n    }\n}\n```\n\n没啥好说的，整体还是挺简单的，代码中用到了 Java8 的函数式接口，确实挺方便的\n\n其实我觉得有一个比较关键的点就是线段树需要多大的数组空间？\n\n首先一颗 H 层（H 从 1 开始）的满二叉树一共有 `2^H-1`  个节点，我们忽略那一个节点，约为`2^H`个节点，而最后一层（h-1 层）有 `2^(h-1)`个节点，也就是说最后一层的节点树大致等于前面所有层节点的和，所以我们可以得出一个结论，在线段树中如果需要表示的区间大小为 n，并且 n 刚好等于 2 的 k 次幂的话（也就是放好构成一颗满二叉树），那么就只需要 2n 的节点个数，但是如果是`n=2^k+c` 那么当前层就存不下这 n 个元素，需要存到下一层，也就是空间还需要* 2，所以最后我们就需要 4n 的空间去存储这颗线段树。\n\n这个时候再回头去做上面的题就会很简单了😁\n\n> 线段树其实还有很多的扩展，上面的是最最最基本的最简单的线段树结构，我还根本就没摸到线段树的门😂，只是知道了有这么个结构\n>\n> 由于我实在是太菜了，也没有时间去了解那些结构了\n>\n> 当然面试的时候并不会考线段树这些玩意儿，我也只是为了练练手，真正的竞赛的题目也不会像上面那么简单，了解即可😅\n","tags":["数据结构","树"],"categories":["数据结构"]},{"title":"由于 cmd 引发的血案","url":"/2019/12/08/6ff78e85/","content":"\n## 前言\n\n给教务处做一个工作量审核的 web 项目，前几天完成后部署在机房电脑上进行测试，但是测试的时候出现了 Bug，会存在一个用户登录的时候，整个应用卡死，所有人都无法登陆，因为登陆模块是我写的，我当时就慌了（并不），然后赶紧去机房看看到底是啥情况\n\n## FixBug\n\n其实我首先想到的就是网络或者数据库的问题，但是看了我控制台的输出，发现代码其实根本就还没到数据库层！所以先排除了数据库的问题\n\n然后我就想会不会是 GC 的问题，然后我打开了 `jvisualvm`，准备查看当前的堆占用和 GC 情况，但是他们之前重启了服务，现在是正常的，看不出来什么，所以我们需要复现这个 Bug，结果我们几个人在哪里搞了半天死活复现不了😂\n\n> 在经过我们一个小时多小时坚持不懈的尝试下，终于复现了！\n\n页面 hang 住，所有人都无法登陆，后台也并没有任何的错误信息，然后我赶紧去看了下 `jvisualvm` 发现堆并没有任何变化，GC 也并没有发生！而且更诡异的是其他的已经登陆的人是可以正常的操作的！只是卡住了登陆的人，所以 GC 的问题也排除了\n\n在 dump 出线程快照后终于发现了问题所在\n\n![mark](http://static.imlgw.top/blog/20191208/XKUriuCE9nTb.png?imageslim)\n\n图中的这条线程卡在了 `PrintStream.println()` 上，而这个是我在 Service 打印的 log 信息，为什么会在这里卡住？？？这不科学啊，然后我看了 其他 tomcat 的工作线程，发现还有好几个都是`BLOCK` 状态，都在等 `[0x0000004df8afd000]`这把锁，这个锁被另一个 tomcat 的工作线程 `http-bio-80-exec[2]` 所持有，而且它并不是`BLOCK`状态，而是 `RUNNABLE` 状态，这个线程正在执行 `java.io.FileOutputStream.writeBytes()` 方法，我们去看看`println`的源码\n\n```java\n/**\n * Prints a String and then terminate the line.  This method behaves as\n * though it invokes <code>{@link #print(String)}</code> and then\n * <code>{@link #println()}</code>.\n *\n * @param x  The <code>String</code> to be printed.\n */\npublic void println(String x) {\n    synchronized (this) {\n        print(x);\n        newLine();\n    }\n}\n```\n\n可以看出在 println 方法确实是加了锁的，锁的对象就是当前的 PrintStream 实例对象，而占用这个锁的对象的线程则正在执行下面这个方法，是个本地方法我们看不到底层的细节\n\n```java\n/**\n * Writes a sub array as a sequence of bytes.\n * @param b the data to be written\n * @param off the start offset in the data\n * @param len the number of bytes that are written\n * @param append {@code true} to first advance the position to the\n *     end of file\n * @exception IOException If an I/O error has occurred.\n */\nprivate native void writeBytes(byte b[], int off, int len, boolean append)\n    throws IOException;\n```\n\n无奈，借助搜索引擎，果然查到了同样的问题 \n\n[一个 RUNNABLE 状态的线程 hang 在了 java.io.FileOutputStream.writeBytes 方法上](https://my.oschina.net/u/1030459/blog/908007)\n\n当然原问题是来自 [StackOverflow](https://stackoverflow.com/questions/634102/log4j-is-hanging-my-application-what-am-i-doing-wrong) \n\n问题的根本原因：在 CMD 窗口点击了黑框之后，控制台就会被暂停！[mark](http://static.imlgw.top/blog/20191208/1em5YGsoGyxT.png?imageslim)\n\n，进入编辑模式，之后向控制台的输入缓冲区会被很快填满，然后正在输出的线程就会 hang 住，但是正在输出的线程也并不会`BLOCK`，状态仍然是`RUNNABLE`所以就很诡异，也就是上面所描述的情况，当你这个时候在 CMD 状态下按一下回车或者其他的键释放 console，退出编辑模式！[mark](http://static.imlgw.top/blog/20191208/4RXkNizHfNsP.png?imageslim)\n\n这个线程又会继续往下执行，要解决这个问题可以调整 cmd 的设置，我这里其实无所谓，因为后面并不会在 win 上运行\n\n至此问题就基本解决了（其实都不算问题），没想到还会被 cmd 给坑一把，不过增长了一点排查问题的能力也还是不错的😁\n\n## 总结\n\n最大的收获就是： 遇到 bug 不要先急着重启逃避问题，得面对它，因为有些 bug 完全就是偶然性的，一旦放过，要想复现可能会极其困难，这次还算运气好，最终复现了，不过当时如果他们保护了现场后面就不会花几个小时去复现问题（确实大家也都经验不太足），也算是吃一堑长一智了 hahaha ~~","tags":["Bug"],"categories":["踩坑记录"]},{"title":"LeetCode 二分查找","url":"/2019/12/06/ac033e1a/","content":"\n>  从 [数组专题](http://imlgw.top/2019/05/04/leetcode-shu-zu/) 中抽取出来的 \n\n## _二分搜索_\n\n## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n**示例 1:**\n\n```java\n输入：nums = [-1,0,3,5,9,12], target = 9\n输出：4\n解释：9 出现在 nums 中并且下标为 4\n```\n\n**示例 2:**\n\n```java\n输入：nums = [-1,0,3,5,9,12], target = 2\n输出：-1\n解释：2 不存在 nums 中因此返回 -1\n```\n\n**提示：**\n\n- 你可以假设 nums 中的所有元素是不重复的\n- n 将在 [1, 10000] 之间\n- nums 的每个元素都将在 [-9999, 9999] 之间\n\n**解法一**\n\n比较经典的二分\n\n```java\npublic int search(int[] nums, int target) {\n    int left=0,right=nums.length;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]<target){\n            left=mid+1;\n        }else if(nums[mid] > target){\n            right=mid;\n        }else{\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n**解法二**\n\n按照板子来的二分，最后需要后处理一下不存在的情况\n\n```java\n//模板二分\npublic int search(int[] nums, int target) {\n    int left=0,right=nums.length;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]<target){ //排除 mid\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left!=nums.length&&nums[left]==target?left:-1;\n}\n```\n## [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)\n\n实现 `int sqrt(int x)` 函数。\n\n计算并返回 *x* 的平方根，其中 *x* 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n**示例 1:**\n\n```java\n输入：4\n输出：2\n```\n\n**示例 2:**\n\n```java\n输入：8\n输出：2\n说明：8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n```\n\n**解法一**\n\n二分解法\n\n```go\nfunc mySqrt(x int) int {\n    lx := int64(x)\n    var left int64 = 0\n    var right int64 = lx/2 + 1\n    for left < right {\n        mid := left + (right-left)/2\n        if mid*mid < lx {\n            left = mid + 1\n            //向下取整的，所以需要额外判断或者取右中位数\n            if left*left > lx {\n                return int(mid)\n            }\n        } else {\n            right = mid\n        }\n    }\n    return int(left)\n}\n```\n\n还有一种比较好的解法，更加贴合模板\n\n```go\n//这个其实更能体现模板的好处\nfunc mySqrt(x int) int {\n    lx := int64(x)\n    var left int64 = 0\n    var right int64 = lx/2 + 1\n    for left < right {\n        mid := left + (right-left)/2 + 1\n        //大于 lx 的一定不是 res 可以排除，但是小于的不一定不是，题目是向下取整的\n        if mid*mid > lx { \n            right = mid - 1\n        } else {\n            left = mid\n        }\n    }\n    return int(left)\n}\n```\n\n**解法二**\n\n> 牛顿迭代法，还没时间仔细去研究，后面有时间再看看\n\n## [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n**示例 1:**\n\n```java\n输入：[1,3,5,6], 5\n输出：2\n```\n\n**示例 2:**\n\n```java\n输入：[1,3,5,6], 2\n输出：1\n```\n\n**示例 3:**\n\n```java\n输入：[1,3,5,6], 7\n输出：4\n```\n\n**示例 4:**\n\n```java\n输入：[1,3,5,6], 0\n输出：0\n```\n\n**解法一**\n\n跟谁学笔试现场写的，上面的都是 dd（删除了之前的解法）\n\n```java\npublic int searchInsert(int[] nums, int target) {\n    int len=nums.length;\n    int lo=0,hi=len; //和模板不一样，因为这里是搜索插入位置是可以到达 right 的\n    while(lo< hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]<target){\n            lo=mid+1;\n        }else {\n            hi=mid;\n        }\n    }\n    return lo;\n}\n```\n**解法二**\n\n```java\n//update: 2020.5.18\npublic int searchInsert(int[] nums, int target) {\n    int len=nums.length;\n    int lo=0,hi=len-1;\n    int res=hi;\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]>=target){\n            res=mid;\n            hi=mid-1;\n        }else {\n            lo=mid+1;\n        }\n    }\n    return nums[res]<target?len:res;\n}\n```\n\n## [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。\n\n请找出其中最小的元素。\n\n你可以假设数组中不存在重复元素。\n\n**示例 1:**\n\n```java\n输入：[3,4,5,1,2]\n输出：1\n```\n\n**示例 2:**\n\n```java\n输入：[4,5,6,7,0,1,2]\n输出：0\n```\n\n**解法一**\n\n把最开始写的拉跨解法也放上来吧\n\n```java\npublic int findMin(int[] nums) {\n    if (nums==null||nums.length<=0) {\n        return 0;\n    }\n    if (nums.length==1||nums[0]<nums[nums.length-1]) {\n        return nums[0];\n    }\n    int left=1,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2+1;\n        if (nums[mid]>nums[mid-1]) {\n            if (nums[mid]>nums[0]) {\n                left=mid;\n            }else{\n                right=mid-1;\n            }\n        }else{\n            return nums[mid];\n        }\n    }\n    return nums[left];\n}\n```\n说实话，我都不知道咋对的。\n\n**解法二**\n\n模板解法，还是模板写起来清晰舒服\n> 建议直接看 UPDATE\n```java\npublic int findMin(int[] nums) {\n    if (nums==null||nums.length<=0) {\n        return 0;\n    }\n    int left=0,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if (nums[mid]>nums[right]) { //排除 mid 的分支\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return nums[left];\n}\n```\n需要注意要和右边界比较，和左边界比较不一定正确\n\n比如 `1 2 3 4 5` 和`2 3 4 5 1` 两个的中点都大于左边界，但是你无法确定此时应该如果缩短区间，除非做特判，但是那样就麻烦了\n\n**UPDATE: 2020.7.22**\n\n最小值的特点就是肯定是小于等于 nums 的最后一个元素，这里没有重复的元素，所以最小值肯定是小于最后一个元素的，除非最后一个就是最小的元素，这种情况我们设置为 res 的初始值，这样我重写后我感觉更好理解了，进阶版的只需要在这个的基础上稍加改动就行了\n```golang\nfunc findMin(nums []int) int {\n    var n = len(nums)\n    var left, right = 0, n - 1\n    var res = right//对 nums[n-1] 就是最小值做兜底\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] < nums[n-1] {\n            res = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return nums[res]\n}\n```\n同理也可以和左边界比较，最小值一定是小于等于 nums[0] 的\n```golang\nfunc findMin(nums []int) int {\n    var n = len(nums)\n    var left, right = 0, n - 1\n    var res = left //对 nums[0] 就是最小值做兜底\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] < nums[0] {\n            res = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return nums[res]\n}\n```\n\n## [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/) \n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。\n\n请找出其中最小的元素。\n\n注意数组中可能存在重复的元素。\n\n**示例 1：**\n\n```java\n输入：[1,3,5]\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：[2,2,2,0,1]\n输出：0\n```\n\n**说明：**\n\n- 这道题是 寻找旋转排序数组中的最小值 的延伸题目。\n- 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？  \n\n**解法一**\n> 建议直接参考解法 2\n\n相比上一题有了重复的元素，在跳转的时候需要分清楚情况，在 mid 和中点相等的时候只排除右边界一个元素\n\n```java\npublic int findMin(int[] nums) {\n    int left=0,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid] > nums[right]){\n            left=mid+1;\n        }else if(nums[mid] < nums[right]){\n            right=mid;\n        }else{\n            right--; //和右边界相等，无法判断，只缩减一步\n        }\n    }\n    return nums[left];\n}\n```\n\n**解法二**\n\n(UPDATE: 2020.7.22)\n\n相比 [寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)，仅仅只是加了一个尾部去重的操作，去重后就和上面的情况一样了，这样就比前面的解法更加清晰了，时间复杂度也还是一样的\n```python\n# update: 2020/4/8\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left, right = 0, len(nums)-1\n        res = 0\n        while right >= 0 and nums[right] == nums[0]:\n            right -= 1\n        nr = right\n        while left <= right:\n            mid = left + (right - left)//2\n            # 和 nr 比，不能和 0 比，可能会有 0 1 2 这样的\n            if nums[mid] > nums[nr]:\n                left = mid + 1\n            else:\n                res = mid\n                right = mid - 1\n        return nums[res]\n```\n\n## [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。\n\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。\n\n你可以假设数组中不存在重复的元素。\n\n你的算法时间复杂度必须是 *O*(log *n*) 级别。\n\n**示例 1:**\n\n```java\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n```\n\n**示例 2:**\n\n```java\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n```\n\n**解法一**\n\n题目明确要求了时间复杂度 O(logn)，所以肯定还是要二分，先上代码吧\n\n```java\npublic static int search2(int[] nums, int target) {\n    int len = nums.length;\n\n    if ((nums == null) || (len <= 0)) {\n        return -1;\n    }\n\n    int lo = 0;\n    int hi = len - 1;\n\n    while (lo <= hi) {\n        int mid = lo + ((hi - lo) / 2);\n        // 左，右 指的是旋转点左右\n        if (nums[mid] > target) { //首先是大于 target 的情况\n\n            if (target < nums[lo]) {\n                //target 在右边\n                //mid 未知还需要判断下 画一个折线图就很清楚了\n                if (nums[mid] <= nums[hi]) { //mid 也在右边\n                    hi = mid - 1;\n                } else {\n                    //mid 在左边\n                    lo = mid + 1;\n                }\n            } else if (target > nums[lo]) {\n                //说明 mid 在左边，target 也在左边\n                hi = mid - 1;\n            } else {\n                return lo;\n            }\n        } else if (nums[mid] < target) { //小于 target 的情况\n\n            if (target < nums[hi]) {\n                //mid 在右边，target 在右边\n                lo = mid + 1;\n            } else if (target > nums[hi]) {\n                //target 在左边\n                //mid 未知还需要判断下\n                if (nums[mid] > nums[hi]) { //mid 在左边\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            } else {\n                return hi;\n            }\n        } else {\n            return mid;\n        }\n\n        /*if(hi>=0&&lo<len&&nums[lo]<nums[hi]){\n                   //切换成有序的二分\n                   while(lo<=hi){\n                         mid=lo+(hi-lo)/2;\n                         if(nums[mid]>target){\n                                    hi=mid-1;\n                         }else if(nums[mid]<target){\n                                    lo=mid+1;\n                       }else return mid;\n                   }\n            }*/\n    }\n    return -1;\n}\n\n```\n\n1ms，99% 纯 if 判断** target **和** mid **的位置，然后选择移动** lo **还是** hi**，一开始我随便找了几组数然后就开始写，写到后面发现都是 bug😂，这里画个图很方便\n\n![mark](http://static.imlgw.top///20190507/vQgFb8yle0FH.png?imageslim)\n\n在里面找点会很清晰\n\n**解法二**\n\n当然还有一种更加简单也不用这么复杂的方法\n\n```java\npublic static int search(int[] nums, int target) {\n    int lo=0,hi=nums.length-1;\n    if(nums==null||nums.length<=0){\n        return  -1;\n    }\n    int index=-1;\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]>=nums[lo]){\n            //左半部分有序\n            index=binarySearch(nums,target,lo,mid);\n            //对右半部分二分\n            if(index==-1){\n                lo=mid+1;\n                //lo-->mid 没找到就对右半部分继续划分\n            } else return index;\n        } else if(nums[mid]<nums[lo]){\n            //右半部分有序\n            index=binarySearch(nums,target,mid,hi);\n            if(index==-1){\n                hi=mid-1;\n            } else return index;\n        }\n    }\n    return  index;\n}\n\npublic static int binarySearch(int []nums,int target,int lo,int hi){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]>target){\n            hi=mid-1;\n        } else if(nums[mid]<target){\n            lo=mid+1;\n        } else return mid;\n    }\n    return -1;\n}\n```\n\n这个应该比上一个慢一点，最好情况下是`O(logN)`直接将** target **划分到有序的那一边，如果没划分到有序的那一边就会花费时间去二分尝试切割数组，时间复杂度应该是`logN+log(N/2)+log(N/4)+...log(N/N)` 最后整体复杂度应该是`O(logN*logN)` ，虽然比 `logN` 好很多，但是并不是我们想要的算法\n\n**解法三**\n\n相当巧妙的解法！参考 [lcus](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple)，通过判断 `target`和`mid`的位置，如果`target`和`mid`不在同一段就将 `【4，5，6，7，0，1，2】 `转换成 `【4，5，6，7，INT_MAX，INT_MAX，INT_MAX】`或者`【INT_MIN，INT_MIN，INT_MIN，INT_MIN，0，1，2】` 然后再进行二分\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if(nums==null || nums.length<=0) return -1;\n        int left=0,right=nums.length-1;\n        while(left<right){\n            int mid=left+(right-left)/2;\n            //这一步 (nums[mid]>=nums[0])==(target>=nums[0]) 很巧秒，其实用异或也可以\n            int midNum=(nums[mid]>=nums[0])==(target>=nums[0])?nums[mid]:\n                        nums[mid]>=nums[0]?Integer.MIN_VALUE:Integer.MAX_VALUE;\n            if(midNum<target){\n                left=mid+1;\n            }else{\n                right=mid;\n            }\n        }\n        return nums[left]!=target?-1:left;\n    }\n}\n```\n\n`(nums[mid]>=nums[0])==(target>=nums[0])` 这一步很巧妙，满足这个关系就说明 mid 和 target 在同一段，不用变化，可以直接求，否则就根据 mid 的位置考虑如何变化\n\n## [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,0,1,2,2,5,6]` 可能变为 `[2,5,6,0,0,1,2]` )。\n\n编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 `true`，否则返回 `false`。\n\n**示例 1:**\n\n```go\n输入：nums = [2,5,6,0,0,1,2], target = 0\n输出：true\n```\n\n**示例 2:**\n\n```go\n输入：nums = [2,5,6,0,0,1,2], target = 3\n输出：false\n```\n\n**进阶：**\n\n- 这是 [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/) 的延伸题目，本题中的 `nums`  可能包含重复元素。\n- 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？\n\n**解法一**\n\nWA 哭了，好难搞，要是在工程上我肯定直接遍历了，太细节了这波\n\n```go\nfunc search(nums []int, target int) bool {\n    n:=len(nums)\n    if n==0{\n        return false\n    }\n    left:=0\n    right:=n-1\n    for left<right {\n        mid:=left+(right-left)/2+1\n        if nums[mid]>nums[right] { //左半边\n            //target 在 [left,mid) 的有序区间内\n            if nums[left]<=target && target<nums[mid]{\n                right=mid-1\n            }else{\n                left=mid\n            }\n        }else if nums[mid]<nums[right]{\n            //target 在 [mid,right]\n            if nums[mid]<=target && target<=nums[right]{\n                left=mid\n            }else{\n                right=mid-1\n            }\n        }else{\n            //mid==right 看 right 是不是 target\n            if nums[right]==target{\n                return true\n            }\n            right--\n        }\n    }\n    return nums[left]==target\n}\n```\n\n看着别人的题解写都 WA 了 5，6 次。这个其实就不能按照上一题的思路来了，因为有重复的，不好判断 mid 和 target 是不是在同一边\n\n**解法二**\n\n（update：2020/4/8）和上面的搜索最小值一样，如果只是中间重复没有任何影响，但是如果是头尾重复，那么问题就大了，我们就没办法通过头或者尾的值，判断 target 和 mid 所在的区间，所以我们可以开始先对头尾去重，这样就可以方便判断 target 和 mid 所在区间，比如 1 0 1 1 1 就可以变成 1 0，然后再进行二分就很简单了\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left, right = 0, len(nums)-1\n        res = 0\n        # 尾部去重，方便确定 target 和 mid 所在区间\n        while right >= 0 and nums[right] == nums[0]:\n            right -= 1\n        while left <= right:\n            mid = left + (right-left)//2\n            v = nums[mid] if (nums[mid] < nums[0]) == (target < nums[0]) else float(\"inf\") if nums[mid] < nums[0] else float(\"-inf\")\n            if v <= target:\n                res = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        return True if nums[res] == target else False\n```\n\n## [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)\n\n给你一个排序后的字符列表 `letters` ，列表中只包含小写英文字母。另给出一个目标字母 `target`，请你寻找在这一有序列表里比目标字母大的最小字母。\n\n在比较时，字母是依序循环出现的。举个例子：\n\n- 如果目标字母 `target = 'z'` 并且字符列表为 `letters = ['a', 'b']`，则答案返回 `'a'`\n\n**示例：**\n\n```java\n输入：\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\n输出：\"c\"\n\n输入：\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\n输出：\"f\"\n\n输入：\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\n输出：\"f\"\n\n输入：\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"g\"\n输出：\"j\"\n\n输入：\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"j\"\n输出：\"c\"\n\n输入：\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"k\"\n输出：\"c\"\n```\n\n**提示：**\n\n1. `letters`长度范围在`[2, 10000]`区间内。\n2. `letters` 仅由小写字母组成，最少包含两个不同的字母。\n3. 目标字母`target` 是一个小写字母。\n\n**解法一**\n\n按照新模板写的，题解区很多人讨论`['z'，'a'，'b']`这样的 case，其实我觉得没必要，纠结这没啥意义，可能还是题目描述有点问题，我们就直接当普通二分写就行了\n\n```java\npublic char nextGreatestLetter(char[] letters, char target) {\n    int left=0,right=letters.length-1;\n    int res=0; //注意找不到的情况\n    while(left<=right){\n        int mid=(left+right)/2;\n        if(letters[mid]>target){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return letters[res];\n}\n```\n\n## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 *O*(log *n*) 级别。\n\n如果数组中不存在目标值，返回 `[-1, -1]`。\n\n**示例 1:**\n\n```java\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n```\n\n**示例 2:**\n\n```java\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n```\n\n**解法一**\n\n时间复杂度 O(logN)，肯定还是要二分\n\n```java\n//两次二分\npublic int[] searchRange(int[] nums, int target) {\n    if(nums.length<=0){\n        return new int[]{-1,-1};\n    }\n    return new int[]{left(nums,target,0,nums.length-1),right(nums,target,0,nums.length-1)};\n}\n\n//5,7,7,8,8,8,8,10,10\npublic int left(int []nums,int target,int lo,int hi){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        //System.out.println(\"lo: \"+nums[lo]+\"mid: \"+nums[mid] +\"hi: \"+nums[hi]);\n        if(nums[mid]<target){\n            lo=mid+1;\n        }else if(nums[mid]>target){\n            hi=mid-1;\n        }else if(mid>0){ //nums[mid]=target\n            if(nums[mid-1]!=target){\n                return mid;\n            }else{\n                //控制向左找\n                hi=mid-1;\n            }\n        }else{\n            return mid; //0\n        }\n    }\n    return -1;\n}\n\npublic int right(int []nums,int target,int lo,int hi){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]<target){\n            lo=mid+1;\n        }else if(nums[mid]>target){\n            hi=mid-1;\n        }else if(mid<nums.length-1){\n            if(nums[mid+1]!=target){\n                return mid;\n            }else{\n                //控制向右找\n                lo=mid+1;\n            }\n        }else{\n            return mid; //nums.length\n        }\n    }\n    return -1;\n}\n```\n\n1ms ，99% 核心就是两次二分，分别向左和向后二分整个数组， 在相等的时候并不返回，多判断一下，左边的就控制 hi 向左边继续找，右边就控制 lo 向右边继续找，直到下一个不等于 target 就返回，和上面一题一样都是二分的变种\n\n**解法二**\n\n统一的解法，上面的做法虽然直白，但是没有通用性，这里借鉴评论区大佬 [liweiwei1419](https://www.liwei.party/) 的 [讲解](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/) 写一个通用的解法，之前写二分一直都是凭感觉，不注意细节，有错误就 debug，东改一改，西改一改，然后就过了。毫无章法，以后要统一写法了\n\n```java\n//两次二分\npublic int[] searchRange(int[] nums, int target) {\n    if(nums.length<=0){\n        return new int[]{-1,-1};\n    }\n    return new int[]{left(nums,target,0,nums.length-1),right(nums,target,0,nums.length-1)};\n}\n\n//找大于等于 target 的第一个元素，小于肯定不符合\npublic int left(int []nums,int target,int lo,int hi){\n    while(lo<hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]<target){ //排除小于 target 的，剩下【lo,hi】都是大于等于的\n            lo=mid+1;\n        }else{\n            hi=mid;\n        }\n    }\n    return nums[hi]==target?hi:-1;\n}\n\n//找小于等于 target 的最后一个元素，大于肯定不符合\npublic int right(int []nums,int target,int lo,int hi){\n    while(lo<hi){\n        //选取右中值\n        int mid=lo+(hi-lo)/2+1;\n        if(nums[mid]>target){ //排除大于 target, 剩下 [lo,hi] 都是小于等于的\n            hi=mid-1;\n        }else{\n            //根据这个判断需要选取右中值\n            lo=mid;\n        }\n    }\n    return nums[hi]==target?hi:-1;\n}\n```\n\n**新模板**\n\n新模板比较好写\n\n```java\npublic int[] searchRange(int[] nums, int target) {\n    if(nums==null || nums.length<=0) return new int[]{-1,-1};\n    return new int[]{leftSearch(nums,target),rightSearch(nums,target)};\n}\n\npublic int leftSearch(int[] nums,int target){\n    int left=0,right=nums.length-1;\n    int res=right;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]>=target){\n            res=mid;\n            right=mid-1; \n        }else{\n            left=mid+1;\n        }\n    }\n    return nums[res]==target?res:-1;\n}\n\npublic int rightSearch(int[] nums,int target){\n    int left=0,right=nums.length-1;\n    int res=left;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]<=target){\n            res=mid;\n            left=mid+1; \n        }else{\n            right=mid-1;\n        }\n    }\n    return nums[res]==target?res:-1;\n}\n```\n\n## [面试题 53 - II. 0～n-1 中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)\n\n一个长度为 ~~n-1~~ n 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围~~0～n-1~~ 0~n 之内。在范围~~0～n-1~~ 0~n 内的~~n~~ n+1 个数字中有且只有一个数字不在该数组中，请找出这个数字。\n\n**示例 1:**\n\n```java\n输入：[0,1,3]\n输出：2\n```\n\n**示例 2:**\n\n```java\n输入：[0,1,2,3,4,5,6,7,9]\n输出：8\n```\n\n**限制：**\n\n`1 <= 数组长度 <= 10000`\n\n**解法一**\n\n这题的题目描述感觉有点问题我稍微改了下\n\n```java\npublic int missingNumber(int[] nums) {\n    int left=0,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]==mid){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    if(nums[left]==left) return left+1; //只有一个数\n    return left;\n}\n```\n\n二分找那个索引不对的元素就 ok 了，按照模板写的，排除法，排除相等的，最后返回的索引`left`就是缺失的数字\n\n## [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)\n\n我们把符合下列属性的数组 A 称作山脉：\n\n- A.length >= 3\n- 存在 0 < i < A.length - 1 使得 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]\n\n给定一个确定为山脉的数组，返回任何满足 `A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]` 的 i 的值。\n\n **示例 1：**\n\n```java\n输入：[0,1,0]\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：[0,2,1,0]\n输出：1\n```\n\n**解法一**\n\n其实还是上面的模板，只不过做了一点点改动而已，很傻逼的 WA 了一发，我也是服了自己了\n\n```java\npublic static int peakIndexInMountainArray(int[] A) {\n    int left=0,right=A.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        //System.out.println(mid);\n        if (mid>0 && mid<A.length && A[mid] > A[mid-1] && A[mid]<A[mid+1]) {\n            left=mid+1;\n        }else if (mid>0 && mid<A.length && A[mid]< A[mid-1] && A[mid]>A[mid+1]){\n            right=mid-1;\n        }else{\n            return mid;\n        }\n    }\n    return left;\n}\n```\n\n代码优化 `2020.4.9` 不知道为啥之前写成哪个鬼样子。\n\n```java\npublic static int peakIndexInMountainArray(int[] A) {\n    int left=0,right=A.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if (A[mid]<A[mid+1]) {\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left;\n}\n```\n\n## [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/)\n\n（这是一个 **交互式问题** ）\n\n给你一个 **山脉数组** `mountainArr`，请你返回能够使得 `mountainArr.get(index)` **等于** `target` **最小** 的下标 `index` 值。\n\n如果不存在这样的下标 `index`，就请返回 `-1`。\n\n何为山脉数组？如果数组 `A` 是一个山脉数组的话，那它满足如下条件：\n\n**首先**，`A.length >= 3`\n\n**其次**，在 `0 < i < A.length - 1` 条件下，存在 `i` 使得：\n\n- `A[0] < A[1] < ... A[i-1] < A[i]`\n- `A[i] > A[i+1] > ... > A[A.length - 1]`\n\n你将 **不能直接访问该山脉数组**，必须通过 `MountainArray` 接口来获取数据：\n\n- `MountainArray.get(k)` - 会返回数组中索引为`k` 的元素（下标从 0 开始）\n- `MountainArray.length()` - 会返回该数组的长度\n\n**注意：**\n\n对 `MountainArray.get` 发起超过 `100` 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。\n\n为了帮助大家更好地理解交互式问题，我们准备了一个样例 “**答案**”：<https://leetcode-cn.com/playground/RKhe3ave>，请注意这 **不是一个正确答案**。\n\n**示例 1：**\n\n```java\n输入：array = [1,2,3,4,5,3,1], target = 3\n输出：2\n解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。\n```\n\n**示例 2：**\n\n```java\n输入：array = [0,1,2,4,2,1], target = 3\n输出：-1\n解释：3 在数组中没有出现，返回 -1。\n```\n\n**提示：**\n\n- `3 <= mountain_arr.length() <= 10000`\n- `0 <= target <= 10^9`\n- `0 <= mountain_arr.get(index) <= 10^9`\n\n**解法一**\n\n这题，咋说呢，数据太弱了，配不上 hard 题，顶多算个 mid 偏简单，数据大的时候可以考虑加上缓存，这样就比较有意思了，这里我就懒得加了😁\n\n```go\nfunc findInMountainArray(target int, mountainArr *MountainArray) int {\n    n := mountainArr.length()\n    //寻找山顶\n    left := 0\n    right := n - 1\n    for left < right {\n        mid := left + (right-left)/2\n        //mid+1 肯定不会越界\n        if mountainArr.get(mid) < mountainArr.get(mid+1) {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    res := -1\n    res = binarySearchUp(mountainArr, target, 0, left)\n    if res == -1 {\n        res = binarySearchDown(mountainArr, target, left, n-1)\n    }\n    return res\n}\n\nfunc binarySearchUp(mountainArr *MountainArray, target, left, right int) int {\n    for left < right {\n        mid := left + (right-left)/2\n        if mountainArr.get(mid) < target {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    if mountainArr.get(left) == target {\n        return left\n    }\n    return -1\n}\n\nfunc binarySearchDown(mountainArr *MountainArray, target, left, right int) int {\n    for left < right {\n        mid := left + (right-left)/2\n        if mountainArr.get(mid) > target {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    if mountainArr.get(left) == target {\n        return left\n    }\n    return -1\n}\n```\n\n这两个二分是可以合并的，懒得合了（太懒了吧你也😅）\n\n**UPDATE: 2020.7.14**\n\n自定义函数传递，简化代码\n```golang\nfunc findInMountainArray(target int, mA *MountainArray) int {\n    var n = mA.length()\n    var left = 0\n    var right = n-1\n    var maxIdx = right\n    for left <= right{\n        mid := left + (right-left)/2\n        //左中，所以 mid+1 不会越界\n        if mA.get(mid) > mA.get(mid+1){\n            maxIdx = mid\n            right = mid - 1 \n        }else{\n            left = mid + 1\n        }\n    }\n    lr := search(mA, target, 0, maxIdx, func(i int, j int)bool{\n        return i <= j\n    })\n    if lr != -1{\n        return lr\n    }\n    return search(mA, target, maxIdx+1, n-1, func(i int, j int)bool{\n        return i >= j\n    })\n    \n}\n\nfunc search(mA *MountainArray, target int, left int, right int, less func(int, int)bool) int {\n    var res = left\n    for left <= right{\n        mid := left + (right-left)/2\n        if less(mA.get(mid), target){\n            res = mid\n            left = mid + 1\n        }else{\n            right = mid - 1\n        }\n    }\n    if mA.get(res) != target{\n        return -1\n    }\n    return res\n}\n```\n\n## [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)\n\n峰值元素是指其值大于左右相邻值的元素。\n\n给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。\n\n数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。\n\n你可以假设 `nums[-1] = nums[n] = -∞`。\n\n**示例 1:**\n\n```java\n输入：nums = [1,2,3,1]\n输出：2\n解释：3 是峰值元素，你的函数应该返回其索引 2。\n```\n\n**示例 2:**\n\n```java\n输入：nums = [1,2,1,3,5,6,4]\n输出：1 或 5 \n解释：你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n```\n\n**说明：**\n\n你的解法应该是 `O(logN)` 时间复杂度的。\n\n**解法一**\n\n题目挑明了 logN 的复杂度，那么肯定就是二分了，那是怎么个二分的思路呢？题目其实也说了很清楚了，边界的左右两边都是`-∞` 所以我们直接按照递增的去搜，最后肯定能搜索到峰值\n\n```java\npublic int findPeakElement(int[] nums) {\n    int left=0,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(/*mid+1<nums.length &&*/nums[mid]<nums[mid+1]){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left;\n}\n```\nliweiwei 大佬的二分模板真好用！！！\n\n## [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)\n\n编写一个高效的算法来判断 `m x n` 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n\n每行中的整数从左到右按升序排列。\n每行的第一个整数大于前一行的最后一个整数。\n**示例 1:**\n\n```java\n输入：\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 3\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 13\n输出：false\n```\n\n**解法一**\n\n```java\npublic boolean searchMatrix(int[][] matrix, int target) {\n    if(matrix==null || matrix.length<=0 || matrix[0].length<=0){\n        return false;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    int low=0,high=m-1;\n    if (target>matrix[m-1][n-1] || target < matrix[0][0]) {\n        return false;\n    }\n    while(low<=high){ //二分确定在哪一行\n        int mid=low+(high-low)/2;\n        if (target == matrix[mid][0]) {\n            return true;\n        }else if(matrix[mid][0]<target){\n            low=mid+1;\n        }else{\n            high=mid-1;\n        }\n    }\n    int column=low!=0?low-1:low;\n    low=0;\n    high=n-1;\n    while(low<high){\n        int mid=low+(high-low)/2;\n        if (matrix[column][mid]==target) {\n            return true;\n        }else if(matrix[column][mid] < target){\n            low=mid+1; \n        }else{\n            high=mid-1;\n        }\n    }\n    return target==matrix[column][low];\n}\n```\n\n😔，这题 wa 了 11 次，是的，11 次，可想而知我有多彩，最后写出来的解法还是如此的难看，主要就是在确定在哪一行的时候写出了好多问题，可以看到我上下的两种二分方法是不一样的，前期就揪着一种写，按照上面的板子写，结果写出了一堆 bug... 以后写二分还是要注意啊，1s 确定思路，代码写了 3h。\n\n**解法二**\n\n看了评论区写出来的，利用取模和除将二维数组拉成一维的，相当的优秀，也不用考虑那些边界，时间复杂度和上面一样`log(nm)` \n\n```java\npublic boolean searchMatrix(int[][] matrix, int target) {\n    if(matrix==null || matrix.length<=0 || matrix[0].length<=0){\n        return false;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    int left=0,right=m*n-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(matrix[mid/n][mid%n]<target){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return matrix[left/n][left%n]==target;\n}\n```\n\n## [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n\n编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：\n\n- 每行的元素从左到右升序排列。\n- 每列的元素从上到下升序排列。\n\n**示例：**\n现有矩阵 matrix 如下：\n\n```java\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n```\n\n给定 target = `5`，返回 `true`。\n\n给定 target = `20`，返回 `false`。\n\n**解法一**\n\n看上一题 [240. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)  的评论区的时候看到了这种解法\n\n```java\npublic boolean searchMatrix(int[][] matrix, int target) {\n    if(matrix==null || matrix.length<=0 || matrix[0].length<=0){\n        return false;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    int  column=0,row=m-1;\n    while(column<n && row>=0){\n        //System.out.println(row+\",\"+column);\n        if (matrix[row][column]==target) {\n            return true;\n        }\n        if (matrix[row][column] > target) {\n            row--;\n        }else{\n            column++;\n        }\n    }\n    return false;\n}\n```\n整个矩阵从左上到右下，其实就分为了两块，每个元素的左上一定小于当前元素，右下一定大于当前元素，这题也可以二分，就像下面的 [1351. 统计有序矩阵中的负数](#1351-统计有序矩阵中的负数)一样，但是时间复杂度会高一些\n\n## [1351. 统计有序矩阵中的负数](https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/)\n\nDifficulty: **简单**\n\n给你一个 `m * n` 的矩阵 `grid`，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 \n\n请你统计并返回 `grid` 中 **负数** 的数目。\n\n**示例 1：**\n\n```go\n输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\n输出：8\n解释：矩阵中共有 8 个负数。\n```\n\n**示例 2：**\n\n```go\n输入：grid = [[3,2],[1,0]]\n输出：0\n```\n\n**示例 3：**\n\n```go\n输入：grid = [[1,-1],[-1,-1]]\n输出：3\n```\n\n**示例 4：**\n\n```go\n输入：grid = [[-1]]\n输出：1\n```\n\n**提示：**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `-100 <= grid[i][j] <= 100`\n\n**解法一**\n\n没啥好说的，和上面的解法一样，从左下角向上搜索\n```golang\nfunc countNegatives(grid [][]int) int {\n    if len(grid) <= 0 {\n        return 0\n    }\n    var m, n = len(grid), len(grid[0])\n    var count = 0\n    var i, j = m-1, 0\n    for i >= 0 && j < n {\n        if grid[i][j] < 0 {\n            count += n - j\n            i--\n        }else{\n            j++\n        }\n    }\n    return count;\n}\n```\n\n**解法二**\n\nO(mlogn) 解法\n\n```golang\n//O(mlogn) 只利用了行逆序的条件\nfunc countNegatives(grid [][]int) int {\n    if len(grid) <= 0 {\n        return 0\n    }\n    var count = 0\n    var m = len(grid)\n    var n = len(grid[0])\n    for i := 0; i < m; i++ {\n        count += (n - search(grid[i]))\n    }\n    return count\n}\n\nfunc search(nums []int) int {\n    var left = 0\n    var right = len(nums)-1\n    var res = right+1\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] < 0 {\n            res = mid\n            right = mid - 1\n        }else{\n            left = mid + 1\n        }\n    }\n    return res\n}\n```\n\n## [4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)\n\n给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。\n\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 `O(log(m + n))`。\n\n你可以假设 `nums1` 和 `nums2` 不会同时为空。\n\n**示例 1:**\n\n```java\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n```\n\n**示例 2:**\n\n```java\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n```\n\n**解法一**\n\nHard 题，首先想到的是归并，但是时间复杂度不符合要求，最低要求 `O(log(m+n))`，想了好一会儿实在是想不出来（菜）然后看了评论区的解法\n\n```java\n//find nums1+nums2 /2 大的数\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    int m=nums1.length;\n    int n=nums2.length;\n    int leftMid=(m+n+1)/2;\n    int rightMid=(m+n+2)/2;\n    return (findMedian(nums1,0,m-1,nums2,0,n-1,leftMid) + findMedian(nums1,0,m-1,nums2,0,n-1,rightMid)) * 0.5;\n}\n//    i\n//1 2 3 5\n//    j\n//1 2 4 6 7 8 9     k=6 find k/2=3\n//\n//        i\n//*1 2 3* 5\n//  j  \n//1 2 4 6 7 8 9     k=3 find k/2=1  res=4\npublic double findMedian(int[] nums1,int left1,int right1, int[] nums2,int left2,int right2,int k) {\n    int len1=right1-left1+1;\n    int len2=right2-left2+1;\n    if (len1==0) {\n        return nums2[left2+k-1];\n    }\n    if (len2==0) {\n        return nums1[left1+k-1];\n    }\n    if (k==1) {\n        return Math.min(nums1[left1],nums2[left2]);\n    }\n    int i=left1+Math.min(len1,k/2)-1;\n    int j=left2+Math.min(len2,k/2)-1;\n    if (nums1[i] < nums2[j]) {\n        return findMedian(nums1,i+1,right1,nums2,left2,right2,k-(i-left1+1));\n    }else{\n        return findMedian(nums1,left1,right1,nums2,j+1,right2,k-(j-left2+1));\n    }\n}\n```\n这种解法还是挺妙的，求第 k 小的思路，两个数组都是有序的，我们要求第 k 小，我们可以将 k 一分为二，看看两个数组的 `k/2` 位置的元素哪个大哪个小，小的哪个数组前 `k/2` 个元素就可以直接排除掉，因为他们必不可能是第 k 小的元素，举个例子就很容易理解\n\n```java\n1 2 3 5\n1 2 4 6 7 8 9  k=6\nk/2=3, 分别在两数组中找第三个元素，也即是 3，4 明显 3 比较小，所以我们可以直接排除第一个数组的 1，2，3 三个元素，他们必不可能是第 k 小的元素！\n*1 2 3* 5\n1 2 4 6 7 8 9  k=3\n```\n\n然后重复上面的过程，每次排除`k/2` 的元素，最后在`log(k)` 的时间复杂度下就能找到两个数组的 mid，而这里`k=(m+n+1)/2` 所以是符合题目要求的，除此之外，我们还需要考虑奇数和偶数的情况，那我们就可以分别计算一下，我们求一下左中位数和右中位数，如果是奇数左中和右中就是同一个`(k)/2==(k+1)/2` ，偶数的话就是`(k)/2`和`(k+1)/2`分别就是左中和右中，然后我们直接/2 就得到了解\n\n## [658. 找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)\n\n给定一个排序好的数组，两个整数 `k` 和 `x`，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。如果有两个数与 `x` 的差值一样，优先选择数值较小的那个数。\n\n**示例 1:**\n\n```java\n输入：[1,2,3,4,5], k=4, x=3\n输出：[1,2,3,4]\n```\n\n**示例 2:**\n\n```java\n输入：[1,2,3,4,5], k=4, x=-1\n输出：[1,2,3,4]\n```\n\n**说明：**\n\n1. k 的值为正数，且总是小于给定排序数组的长度。\n2. 数组不为空，且长度不超过 104\n3. 数组里的每个元素与 x 的绝对值不超过 104\n\n**解法一**\n\n双指针，少点套路，多点真诚\n\n```java\npublic List<Integer> findClosestElements(int[] arr, int k, int x) {\n    int left=0,right=arr.length-1;\n    int count=0;\n    while(left<right){\n        if(Math.abs(arr[left]-x)<=Math.abs(arr[right]-x)){\n            right--;\n        }else{\n            left++;\n        }\n        count++;\n        if(count==arr.length-k) break;\n    }\n    List<Integer> res=new ArrayList<>();\n    for(int i=left;i<=right;i++) res.add(arr[i]);\n    return res;\n}\n```\n\n**解法二**\n\n二分的解法，有点 trick，不容易想到，参考 [题解](https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/)\n\n```java\npublic List<Integer> findClosestElements(int[] arr, int k, int x) {\n    //左边界的取值范围\n    int left=0,right=arr.length-k;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(x-arr[mid]>arr[mid+k]-x){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    List<Integer> res=new ArrayList<>();\n    for(int i=left;i<left+k;i++) res.add(arr[i]);\n    return res;   \n}\n```\n## [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)\n\nDifficulty: **简单**\n\n给定一个正整数 _num_，编写一个函数，如果 _num_ 是一个完全平方数，则返回 True，否则返回 False。\n\n**说明：**不要使用任何内置的库函数，如  `sqrt`。\n\n**示例 1：**\n\n```go\n输入：16\n输出：True\n```\n\n**示例 2：**\n\n```go\n输入：14\n输出：False\n```\n\n**解法一**\n\n二分\n```golang\nfunc isPerfectSquare(num int) bool {\n    var left = 0\n    var right = num\n    var res = num + 1\n    for left <= right {\n        mid := left + (right-left)/2\n        if mid*mid >= num {\n            res = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return res*res == num\n}\n```\n\n**解法二**\n\n完全平方数的性质\n```golang\n//完全平方数性质 n^2 = 1 + 3 + 5 +...+2n+1 （前 n 个奇数的和）\n//所以只需要判断 num 能不能被奇数减成 0 就行了\nfunc isPerfectSquare(num int) bool {\n    var i = 1\n    for num > 0 {\n        num -= i\n        i += 2\n    }\n    return num == 0\n}\n```\n\n## [475. 供暖器](https://leetcode-cn.com/problems/heaters/)\n\nDifficulty: **简单**\n\n冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。\n\n现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。\n\n所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。\n\n**说明：**\n\n1.  给出的房屋和供暖器的数目是非负数且不会超过 25000。\n2.  给出的房屋和供暖器的位置均是非负数且不会超过 10^9。\n3.  只要房屋位于供暖器的半径内（包括在边缘上），它就可以得到供暖。\n4.  所有供暖器都遵循你的半径标准，加热的半径也一样。\n\n**示例 1:**\n\n```golang\n输入：[1,2,3],[2]\n输出：1\n解释：仅在位置 2 上有一个供暖器。如果我们将加热半径设为 1，那么所有房屋就都能得到供暖。\n```\n\n**示例 2:**\n\n```golang\n输入：[1,2,3,4],[1,4]\n输出：1\n解释：在位置 1, 4 上有两个供暖器。我们需要将加热半径设为 1，这样所有房屋就都能得到供暖。\n```\n\n**解法一**\n\n这个题目感觉不是 easy 啊，一开始想劈叉了，以为是二分答案，写了半天后来 WA 在一个很大的 case，一直以为是溢出了，改了半天的 bug 没改出来。后来自己按照 case 的规律构建了一个小的 case，发现也 WA 了，然后才意识到是方法错了，(case: [4,9] [4,8])，这个 case 按照二分答案的思路就是错的，二分答案是思路就是验证该半径下能否覆盖整个区间，其实也是题目理解有点问题，题目的要求是**覆盖每个房子**，而**不是覆盖整个区间**，所以只需要找到每个房子最近的供暖器就行了，然后统计这些最小值得最大值就是我们需要的半径\n\n```golang\nfunc findRadius(houses []int, heaters []int) int {\n    //边界处理\n    heaters = append(heaters, math.MaxInt32)\n    heaters = append(heaters, math.MinInt32)\n    sort.Ints(heaters)\n    var Min = func (a, b int) int { if a < b {return a}; return b}\n    var Max = func (a, b int) int { if a < b {return b}; return a}\n    var res = 0\n    for _, h := range houses{\n        left := search(heaters, h)\n        res = Max(res, Min(h-heaters[left], heaters[left+1]-h))\n    }\n    return res\n}\n​\n//target 左边最近的一个\nfunc search(heaters []int, target int) int {\n    var left, right = 0, len(heaters)-1\n    var res = left //左边没有供暖器\n    for left <= right {\n        mid := left + (right-left)/2\n        if heaters[mid] <= target{\n            res = mid\n            left = mid + 1\n        }else{\n            right = mid - 1\n        }\n    }\n    return res\n}\n```\n另一种写法，不额外处理边界，也是一开始的写法\n```golang\nfunc findRadius(houses []int, heaters []int) int {\n    sort.Ints(heaters)\n    var n = len(heaters)\n    var Min = func (a, b int) int { if a < b {return a}; return b}\n    var Max = func (a, b int) int { if a < b {return b}; return a}\n    var res = 0\n    for _, h := range houses{\n        left := search(heaters, h)\n        if left == -1{ //全部大于 hourse, 取最小的那个\n            res = Max(res, heaters[0]-h)\n        }else if left+1 < n{\n            res = Max(res, Min(h-heaters[left], heaters[left+1]-h))\n        }else{\n            res = Max(res, h-heaters[left])\n        }\n    }\n    return res\n}\n\n//target 左边最近的一个\nfunc search(heaters []int, target int) int {\n    var left, right = 0, len(heaters)-1\n    var res = -1 //左边没有供暖器\n    for left <= right {\n        mid := left + (right-left)/2\n        if heaters[mid] <= target{\n            res = mid\n            left = mid + 1\n        }else{\n            right = mid - 1\n        }\n    }\n    return res\n}\n```\n时间复杂度细看的话应该是 `O(MlogM + MlogN)`（M，N 分别代表 houses 和 heaters 的长度）\n\n**解法二**\n\n双指针，时间复杂度差别不大\n```golang\nfunc findRadius(houses []int, heaters []int) int {\n    heaters = append(heaters, math.MaxInt32)\n    heaters = append(heaters, math.MinInt32)\n    sort.Ints(heaters)\n    sort.Ints(houses)\n    var n = len(heaters)\n    var Min = func (a, b int) int { if a < b {return a}; return b}\n    var Max = func (a, b int) int { if a < b {return b}; return a}\n    var res = 0\n    var left = 0\n    for _, h := range houses {\n        for left < n && heaters[left] < h {\n            left++\n        }\n        res = Max(res, Min(heaters[left]-h, h-heaters[left-1]))\n    }\n    return res\n}\n```\n时间复杂度细看的话应该是 `O(NlogN + MlogM + N + M)`（M，N 分别代表 houses 和 heaters 的长度），差别不大，不过很明显双指针的好写很多\n\n## _二分答案_\n\n## [1283. 使结果不超过阈值的最小除数](https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/)\n\n给你一个整数数组 `nums` 和一个正整数 `threshold`  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。\n\n请你找出能够使上述结果小于等于阈值 `threshold` 的除数中 最小 的那个。\n\n每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。\n\n题目保证一定有解。\n\n**示例 1：**\n\n```java\n输入：nums = [1,2,5,9], threshold = 6\n输出：5\n解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。\n如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [2,3,5,7,11], threshold = 11\n输出：3\n```\n\n**示例 3：**\n\n```java\n输入：nums = [19], threshold = 5\n输出：4\n```\n\n**提示：**\n\n- `1 <= nums.length <= 5 * 10^4`\n- `1 <= nums[i] <= 10^6`\n- `nums.length <= threshold <= 10^6`\n\n**解法一**\n\n周赛的题，太蠢了，没做出来。\n\n```java\npublic int smallestDivisor(int[] nums, int threshold) {\n    int left=1,right=1000000;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        int sum=0;\n        for (int i=0;i<nums.length;i++) {\n            sum+=(nums[i]+mid-1)/mid; //向上取整\n        }\n        if (sum>threshold) {\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left;\n}\n```\n其实只要明确一点这题就很容易想到二分，解空间为：`[1，max(nums[i])]` 我们只需要在这个区间之内做二分搜索就 ok 了，再然后就是向上取整的一个小技巧\n\n## [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n给定一个包含 n + 1 个整数的数组 `nums`，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n\n**示例 1:**\n\n```java\n输入：[1,3,4,2,2]\n输出：2\n```\n\n**示例 2:**\n\n```java\n输入：[3,1,3,4,2]\n输出：3\n```\n\n**说明：**\n\n- 不能更改原数组（假设数组是只读的）。\n- 只能使用额外的 O(1) 的空间。\n- 时间复杂度小于 O(n2) 。\n- 数组中只有一个重复的数字，但它可能不止重复出现一次 \n\n**解法一**\n\n这题还是挺有意思的，题目要求了数组 nums 是只读的，且不能使用额外的空间，且时间复杂度还要小于 O(N^2)，否则的话其实可以排序，或者使用 Hash 表来做，这里我们使用二分来做\n\n```java\n//update: 2020.5.26 其实也属于二分答案\npublic int findDuplicate(int[] nums){\n    int left=1,right=nums.length-1;\n    //这里实际上是对【1,2,3,4,...n-1】这个区间进行二分\n    //在过程中对 mid 检测每个数在 nums 数组中出现的次数\n    //1 3 4 2 2 实际上是对【1,2,3,4】区间进行二分\n    while(left<right){\n        int mid=left+(right-left)/2+1;\n        //小于 mid 的数大于 mid, 排除 mid\n        if(count(nums,mid)>=mid){ \n            right=mid-1;\n        }else{\n            left=mid;\n        }\n    }\n    return left;\n}\n\n//n-1 个整数 , 1~n 有 n 个数     \n//1 2 2 3 4     1~4 之间，1 2 3 4\npublic int count(int[] nums,int n){\n    int res=0;\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]<n) {\n            res++;          \n        }\n    }\n    return res;\n}\n```\n这样的解法还是很巧妙的，对 nums 数组的**取值范围**进行二分，二分的核心就是，nums 数组中，小于取值范围中 mid 的元素应该小于等于 mid\n\n举个例子：`[1 3 4 2 2]` 取值范围是`[1 2 3 4]` ，取中点 2，正常情况下 nums 中小于等于 2 的元素，应该最多有 2 个，也就是`[1 2]`2 个，但是这里在 nums 中，有 3 个`[1 2 2]` 大于 2 了，这就说明一定有重复的元素，而且一定是小于中点 2 的，也就是在左半边，下一步就应该舍弃右半边，在`[1,2]`中继续查找 \n\n这里按照我们之前的模板来写，先找排除 mid 的条件，**在 nums 中小于 mid 的元素的数量小于等于 mid 的时候，包括 mid 在内的右边界都会被排除，肯定都不是重复的元素** ，然后就按照模板写出二分就行了\n\n**解法二**\n\n快慢指针的做法，技巧性很强，一般人第一次做是很难想到这种做法的，其实和 [链表专题](http://imlgw.top/2019/02/27/leetcode-lian-biao-tag/#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8) 中的环形链表是一样的做法，然后按照那个思路走就行了，不清楚原理可以看看上面环形链表的解法\n\n```java\npublic int findDuplicate(int[] nums){\n    int slow=0,fast=0;\n    boolean isMeet=false;\n    while(true){\n        fast=isMeet?nums[fast]:nums[nums[fast]];\n        slow=nums[slow];\n        if (fast==slow) {\n            if (isMeet) {\n                return slow;\n            }\n            fast=0;\n            isMeet=true;\n        }\n    }\n}\n```\n这种解法的关键是将数组值看作索引然后再数组像链表一样移动，比如 `[1,2,3,4,5,6,7,8,9,5]`用值作为索引连接起来就是`1 2 3 4 [5 6 7 8 9] [5 6 7 8 9] ....` ，时间复杂度`O(N)` 技巧性比较强，如果面试管不追问的话其实答出上面的二分就 ok 了\n\n## [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)\n\n传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。\n\n传送带上的第 `i` 个包裹的重量为 `weights[i]`。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n\n返回能在 `D` 天内将传送带上的所有包裹送达的船的最低运载能力。\n\n**示例 1：**\n\n```java\n输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5\n输出：15\n解释：\n船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：\n第 1 天：1, 2, 3, 4, 5\n第 2 天：6, 7\n第 3 天：8\n第 4 天：9\n第 5 天：10\n\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 \n```\n\n**示例 2：**\n\n```java\n输入：weights = [3,2,2,4,1,4], D = 3\n输出：6\n解释：\n船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：\n第 1 天：3, 2\n第 2 天：2, 4\n第 3 天：1, 4\n```\n\n**示例 3：**\n\n```java\n输入：weights = [1,2,3,1,1], D = 4\n输出：3\n解释：\n第 1 天：1\n第 2 天：2\n第 3 天：3\n第 4 天：1, 1\n```\n\n**提示：**\n\n1. `1 <= D <= weights.length <= 50000`\n2. `1 <= weights[i] <= 500`\n\n**解法一**\n\n问题的解空间是单调的，所以可以直接二分答案，然后验证是否满足条件就可以了，时间复杂度`O(NlogN)`\n\n```java\npublic int shipWithinDays(int[] weights, int D) {\n    int sum=0,max=0;\n    for(int w:weights){\n        max=Math.max(w,max);\n        sum+=w;\n    }\n    int left=Math.max(sum/D,max),right=sum;\n    int res=0;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(weights,mid,D)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return res;\n}\n\n//模拟判断\npublic boolean check(int[] weights,int load,int D){\n    int temp=0;\n    for(int w:weights){\n        if(temp+w>load){\n            temp=0;\n            D--;\n        }\n        temp+=w;\n    }\n    //return D>=0;\n    return D>0;\n}\n```\n\n上面是用的一个 [大佬](https://www.bilibili.com/video/BV1YT4y137G4) 的模板，不是之前的模板，之前的模板我刚刚写了一发，写错了。\n\n```java\n//之前的二分模板\npublic int shipWithinDays(int[] weights, int D) {\n    int sum=0,max=0;\n    for(int w:weights){\n        max=Math.max(w,max);\n        sum+=w;\n    }\n    int left=Math.max(sum/D,max),right=sum;\n    while(left<right){ //这里一开始写成<=了。...\n        int mid=left+(right-left)/2;\n        if(check(weights,mid,D)){\n            right=mid;\n        }else{\n            left=mid+1;\n        }\n    }\n    return left;\n}\n```\n\n两种模板各有优点吧，这个大佬的模板相对更简单，但是 res 的初始值需要格外注意。\n\n## [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)\n\n珂珂喜欢吃香蕉。这里有 `N` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `H` 小时后回来。\n\n珂珂可以决定她吃香蕉的速度 `K` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `K` 根。如果这堆香蕉少于 `K` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  \n\n珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n\n返回她可以在 `H` 小时内吃掉所有香蕉的最小速度 `K`（`K` 为整数）。\n\n**示例 1：**\n\n```java\n输入：piles = [3,6,7,11], H = 8\n输出：4\n```\n\n**示例 2：**\n\n```java\n输入：piles = [30,11,23,4,20], H = 5\n输出：30\n```\n\n**示例 3：**\n\n```java\n输入：piles = [30,11,23,4,20], H = 6\n输出：23\n```\n\n**提示：**\n\n- `1 <= piles.length <= 10^4`\n- `piles.length <= H <= 10^9`\n- `1 <= piles[i] <= 10^9`\n\n**解法一**\n\n一开始想用`sum/H`向上取整做左边界，结果直接爆掉了，case 还是很给力啊\n\n```java\n//二分答案\npublic int minEatingSpeed(int[] piles, int H) {\n    int max=0;\n    for(int p:piles) max=Math.max(max,p);\n    int left=1,right=max;\n    int res=right;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(piles,mid,H)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[] piles,int k,int H){\n    int count=0;\n    for(int p:piles) count+=(p-1)/k+1; //向上取整\n    return count<=H;\n}\n```\n\n## [1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/) \n\n给你一个大小为 `m x n` 的矩阵 `mat` 和一个整数阈值 `threshold`。\n\n请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 **0** 。\n\n**示例 1：**\n\n![Y2wPne.png](https://s1.ax1x.com/2020/05/17/Y2wPne.png)\n\n```java\n输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\n输出：2\n解释：总和小于 4 的正方形的最大边长为 2，如图所示。\n```\n\n**示例 2：**\n\n```java\n输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\n输出：0\n```\n\n**示例 3：**\n\n```java\n输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6\n输出：3\n```\n\n**示例 4：**\n\n```java\n输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184\n输出：2\n```\n\n**提示：**\n\n- `1 <= m, n <= 300`\n- `m == mat.length`\n- `n == mat[i].length`\n- `0 <= mat[i][j] <= 10000`\n- `0 <= threshold <= 10^5`\n\n**解法一**\n\n这个题是个好题啊，又学到新东西了：**二维前缀和**，首先看到这道题就意识到了这是个二分答案的题，直接二分边长就行了，左端点`1`，右端点`min(m,n)`，某个边长`x`满足的时候，大于`x`的都满足，某个`x`不满足的时候，小于`x`的都不满足，解空间具有单调性\n\n所以关键问题就是`check`怎么写，如果直接暴力枚举所有矩形然后计算时间复杂度会很恐怖，这个时候就可以引入**二维前缀和**，我就不具体讲解了，看看 [官方题解](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution/yuan-su-he-xiao-yu-deng-yu-yu-zhi-de-zheng-fang-2/) 就行了，写的挺好的\n\n```java\npublic int maxSideLength(int[][] mat, int threshold) {\n    int m=mat.length;\n    int n=mat[0].length;\n    int left=1,right=Math.min(m,n);\n    //核心公式\n    //sum([x1,y1]->[x2,y2])\n    //= P[x2][y2]-P[x2][y1-1]-P[x1-1][y2]+P[x1-1][y1-1]\n    //==> mat[i][j]=P[i][j]-P[i-1][j]-P[j-1][i]+P[i-1][j-1]\n    int[][] dp=new int[m+1][n+1];\n    for (int i=1;i<=m;i++) {\n        for (int j=1;j<=n;j++) {\n            dp[i][j]=mat[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n        }\n    }\n    int res=0;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(mat,mid,threshold,dp)){\n            res=mid;\n            left=mid+1;\n        }else{\n            right=mid-1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[][] mat,int side,int threshold,int[][] dp){\n    //枚举所有的左端点\n    for (int i=1;i+side-1<=mat.length;i++) {\n        for (int j=1;j+side-1<=mat[0].length;j++) {\n            int ri=i+side-1,rj=j+side-1;\n            //System.out.println(ri+\",\"+rj+\" dp:\"+ dp[ri][rj]);\n            if(dp[ri][rj]-dp[i-1][rj]-dp[ri][j-1]+dp[i-1][j-1]<=threshold){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n## [1300. 转变数组后最接近目标值的数组和](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/) \n\n给你一个整数数组 `arr` 和一个目标值 `target` ，请你返回一个整数 `value` ，使得将数组中所有大于 `value` 的值变成 `value` 后，数组的和最接近  `target` （最接近表示两者之差的绝对值最小）。\n\n如果有多种使得和最接近 `target` 的方案，请你返回这些整数中的最小值。\n\n请注意，答案不一定是 `arr` 中的数字。\n\n**示例 1：**\n\n```java\n输入：arr = [4,9,3], target = 10\n输出：3\n解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。\n```\n\n**示例 2：**\n\n```java\n输入：arr = [2,3,5], target = 10\n输出：5\n```\n\n**示例 3：**\n\n```java\n输入：arr = [60864,25176,27249,21296,20204], target = 56803\n输出：11361\n```\n\n**提示：**\n\n- `1 <= arr.length <= 10^4`\n- `1 <= arr[i], target <= 10^5`\n\n**解法一**\n\n解空间在`[0,max(arr)]`上单调，所以可以二分答案\n\n一开始傻傻的写了两个二分，一个找第一个小于等于 target 的，一个找大于等于的，其实根本就不用，这两个值肯定是连在一起的🤣\n\n```java\npublic int findBestValue(int[] arr, int target) {\n    int sum=0;\n    int left=0,right=Integer.MIN_VALUE;\n    for(int num:arr){\n        sum+=num;\n        right=Math.max(right,num);\n    }\n    if(sum<=target) return right;\n    int res=left;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(getSum(arr,mid)<=target){\n            res=mid;\n            left=mid+1;\n        }else{\n            right=mid-1;\n        }\n    }\n    //这两个值肯定是连在一起的\n    if(target-getSum(arr,res)<=getSum(arr,res+1)-target){\n        return res;\n    }\n    return res+1;\n}\n\npublic int getSum(int[] arr,int mid){\n    int sum=0;\n    for(int a:arr){\n        sum+=a>mid?mid:a;\n    }\n    return sum;\n}\n```\n\n## [LCP 12. 小张刷题计划](https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/)\n\n为了提高自己的代码能力，小张制定了 `LeetCode` 刷题计划，他选中了 `LeetCode` 题库中的 `n` 道题，编号从 `0` 到 `n-1`，并计划在 `m` 天内**按照题目编号顺序**刷完所有的题目（注意，小张不能用多天完成同一题）。\n\n在小张刷题计划中，小张需要用 `time[i]` 的时间完成编号 `i` 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。\n\n我们定义 `m` 天中做题时间最多的一天耗时为 `T`（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 `T`是多少。\n\n**示例 1：**\n\n> 输入：`time = [1,2,3,3], m = 2`\n>\n> 输出：`3`\n>\n> 解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。\n\n**示例 2：**\n\n> 输入：`time = [999,999,999], m = 4`\n>\n> 输出：`0`\n>\n> 解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。\n\n**限制：**\n\n- `1 <= time.length <= 10^5`\n- `1 <= time[i] <= 10000`\n- `1 <= m <= 1000`\n\n**解法一**\n\n知道是二分答案但是 check 写了好久没写出来，真菜啊\n\n```java\npublic int minTime(int[] time, int m) {\n    int left=0,right=0;//上界最多 sum(time)\n    for(int i=0;i<time.length;i++){\n        right+=time[i];\n    }\n    int res=right+1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(time,mid,m)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    //其实返回 left 就行了，主要是避免搞混\n    return res; \n}\n\n//核心的 check\npublic boolean check(int[] time,int T,int m){\n    int day=1,sum=0,maxt=0;\n    for (int t:time) {\n        sum+=t;\n        maxt=Math.max(maxt,t); //维护每一组的最大值\n        if(sum-maxt>T){ //当前组减去最大值不满足\n            day++;\n            sum=t;\n            maxt=t;\n        }\n    }\n    return day<=m;\n}\n```\n\n## [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)\n\n给定一个非负整数数组和一个整数 *m*，你需要将这个数组分成 *m* 个非空的连续子数组。设计一个算法使得这 *m* 个子数组各自和的最大值最小。\n\n**注意：**\n数组长度 *n* 满足以下条件：\n\n- 1 ≤ *n* ≤ 1000\n- 1 ≤ *m* ≤ min(50, *n*)\n\n**示例：**\n\n```java\n输入：\nnums = [7,2,5,10,8]\nm = 2\n\n输出：\n18\n\n解释：\n一共有四种方法将 nums 分割为 2 个子数组。\n其中最好的方式是将其分为 [7,2,5] 和 [10,8]，\n因为此时这两个子数组各自的和的最大值为 18，在所有情况中最小。\n```\n\n**解法一**\n\nHard 题，但是感觉和前面的 mid 差不多，没啥好说的，个人感觉这题还没上面的 [LCP12. 小张刷题计划](#lcp-12-小张刷题计划) 难，不过有个 case 挺恶心，算的 sum 会溢出，害我 WA 了一次，但是他结果返回的又是个 int，这就很蠢\n\n```java\n//一样的套路\npublic int splitArray(int[] nums, int m) {\n    long left=0,right=0;\n    for(int num:nums){\n        left=Math.max(left,num);\n        right+=num;\n    }\n    long res=0;\n    while(left<=right){\n        long mid=left+(right-left)/2;\n        if(check(nums,mid,m)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return (int)res;\n}\n\n//分为 m 组能否保证每组都小于等于 mid（如果可以说明还可以更小）\npublic boolean check(int[] nums,long limit,int m){\n    long sum=0;\n    int count=1;\n    for(int num:nums){\n        if(sum+num>limit){\n            sum=0;\n            count++;\n        }\n        sum+=num;\n    }\n    return count<=m;\n}\n```\n\n## [NC82. 分组](https://www.nowcoder.com/practice/829419bde0e946b6b4fe813ed3972db8)\n\n题目描述\n牛牛有一个 n 个数字的序列 a1，a2，a3...an 现在牛牛想把这个序列分成 k 段连续段，牛牛想知道分出来的 k 个连续段的段内数字和的最小值最大可以是多少？\n\n**示例 1**\n```go\n输入 : 4,2,[1,2,1,5]\n输出 : 4\n说明：\n有 3 种分法\n[1],[2,1,5]，数字和分别为 1，8，最小值为 1\n[1,2][1,5]，数字和分别为 3，6，最小值为 3\n[1,2,1],[5] 数字和分别为 4，5，最小值为 4\n则最小值的最大值为 4\n```\n**备注：**\n- 1 <= k <= n <= 1e5\n- 0 <= ai <= 1e4\n\n第一个参数整数 n 代表序列数字个数，\n第二个参数整数 k 代表分出的段数，\n第三个参数 vector a 包含 n 个元素代表 n 个数字\n\n**解法一**\n\n我是真的菜啊，上面一题会写这题就不会写了，果然我这种菜鸡刷题就是背题，变一下就不会了。其实和上面的正好是反过来的，上面是要最大值最小，这里是要最小值最大，所以 check 的思路也是相反的，上面是验证：分为 k 组能否保证每组都小于等于 mid。所以这题很显然就应该是：分为 k 组能否保证每组都大于等于 mid（这里验证也是逐渐逼近答案）\n```java\n//最小值最大\npublic int solve (int n, int k, int[] a) {\n    int left = 0;\n    int right = 0;\n    for (int i = 0; i < a.length; i++) {\n        left = Math.min(left, a[i]);\n        right += a[i];\n    }\n    int res = 0;\n    while (left <= right) {\n        int mid = left + (right-left)/2;\n        if (check(mid, a, k)) {\n            res = mid;\n            left = mid + 1;\n        }else {\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n\n//分为 k 组能否保证每组都大于等于 mid（如果可以说明还可以更大）\npublic boolean check(int mid, int[] a, int k) {\n    int sum = 0;\n    int count = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n        if (sum >= mid) {\n            sum = 0;\n            count++;\n        }\n    }\n    return count >= k;\n}\n```\n## [1482. 制作 m 束花所需的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/)\n\n给你一个整数数组 `bloomDay`，以及两个整数 m 和 k 。\n\n现需要制作 `m` 束花。制作花束时，需要使用花园中 `相邻的 k` 朵花 。\n\n花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。\n请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。\n\n**示例 1：**\n\n```java\n输入：bloomDay = [1,10,3,10,2], m = 3, k = 1\n输出：3\n解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。\n现在需要制作 3 束花，每束只需要 1 朵。\n1 天后：[x, _, _, _, _]   // 只能制作 1 束花\n2 天后：[x, _, _, _, x]   // 只能制作 2 束花\n3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3\n```\n**示例 2：**\n```java\n输入：bloomDay = [1,10,3,10,2], m = 3, k = 2\n输出：-1\n解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。\n```\n**示例 3：**\n```\n输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n输出：12\n解释：要制作 2 束花，每束需要 3 朵。\n花园在 7 天后和 12 天后的情况如下：\n7 天后：[x, x, x, x, _, x, x]\n可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。\n12 天后：[x, x, x, x, x, x, x]\n显然，我们可以用不同的方式制作两束花。\n```\n**示例 4：**\n```java\n输入：bloomDay = [1000000000,1000000000], m = 1, k = 1\n输出：1000000000\n解释：需要等 1000000000 天才能采到花来制作花束\n示例 5：\n\n输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2\n输出：9\n ```\n**提示：**\n- bloomDay.length == n\n- 1 <= n <= 10^5\n- 1 <= bloomDay[i] <= 10^9\n- 1 <= m <= 10^6\n- 1 <= k <= n\n\n**解法一**\n\n193th 周赛的 T3，没参加，但是在群里听群友讨论了，是个二分，刚刚具体的看了题目，发现其实是很明显的二分答案，很可惜没参加这次比赛，感觉能 A3 道。\n```java\npublic int minDays(int[] bloomDay, int m, int k) {\n    int n=bloomDay.length;\n    if(m*k>n) return -1; //花园的花不够\n    //直接写就完事了，这里数据范围只到 1e9，log(1e9) 很小的，只有 30 左右\n    int left=1,right=(int)1e9;\n    int res=right+1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(bloomDay,m,k,mid)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return res;\n}\n\n//check 写的好丑。..\npublic boolean check(int[] bloomDay,int m,int k,int day){\n    int i=0;\n    int count=0;\n    while(i<bloomDay.length){\n        int temp=0;\n        while(i<bloomDay.length){\n            if(bloomDay[i]<=day){\n                temp++;\n                if(temp==k){\n                    count++;\n                    break;\n                }\n                i++;\n            }else{\n                break;\n            }\n        }\n        if(count>=m) return true;\n        i++;\n    }\n    return false;\n}\n```\n**解法二**\n\n看了评论区，然后自己思考了下，改进了`check`\n```java\npublic int minDays(int[] bloomDay, int m, int k) {\n    int n=bloomDay.length;\n    if(m*k>n) return -1; //花园的花不够\n    //直接写就完事了，这里数据范围只到 1e9，log(1e9) 很小的，只有 30 左右\n    int left=1,right=(int)1e9; \n    int res=right+1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(bloomDay,m,k,mid)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[] bloomDay,int m,int k,int day){\n    int i=0;\n    int count=0;\n    int temp=0; //相邻的开花数量\n    for(int d:bloomDay){\n        if(d<=day){ //花开了 (md，这个 if 写反两次）\n            temp++;\n        }else{\n            temp=0;\n        }\n        if(temp==k){\n            temp=0;\n            count++;\n        }\n    }\n    return count>=m;\n}\n```\n\n## [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n\nDifficulty: **中等**\n\n给定一个 _`n x n` _矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。  \n请注意，它是排序后的第 `k` 小元素，而不是第 `k` 个不同的元素。\n\n**示例：**\n\n```go\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\n返回 13。\n```\n\n**提示：**  \n你可以假设 k 的值永远是有效的，`1 ≤ k ≤ n<sup>2 </sup>`。\n\n（直接搬运我在 lc 题解区写的 [题解](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/java-xiao-gen-dui-er-fen-da-an-chang-shi-jie-shi-e/)）\n\n**解法一**\n\n小根堆，多路归并，没啥好说的\n```java\npublic int kthSmallest(int[][] matrix, int k) {\n    PriorityQueue<Pair> pq = new PriorityQueue<>((p1,p2)->matrix[p1.x][p1.y] - matrix[p2.x][p2.y]);\n    for(int i = 0;i < matrix.length; i++){\n        pq.add(new Pair(i, 0));  \n    } \n    while(k > 1){\n        Pair pair = pq.poll();\n        if(pair.y + 1 < matrix[0].length){\n            pq.add(new Pair(pair.x, pair.y+1));   \n        }\n        k--;\n    }\n    return matrix[pq.peek().x][pq.peek().y];\n}\n\nclass Pair{\n    int x, y;\n    public Pair(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n}\n```\n\n**解法二**\n\n二分答案，我们求的元素一定是在`matrix[0][0]~matrix[n-1][n-1]`之间，取中间某个元素`mid`，大于`mid`的都分布在右下角，小于`mid`的的分布在右上角，越往右上走，小于`mid`的元素就越少，大于`mid`的元素就越多，所以整体是具有单调性的，所以可以二分\n\n然后我认为很关键的一个地方就是二分的写法，我这里用的是 [zls 的一个二分模板](https://www.bilibili.com/video/BV1YT4y137G4)，两个分支，一个是答案区间，一个是排除区间，在答案区间记录答案，现在问题就是：是用 `<=` 作为答案区间，还是用 `>=`做为答案区间？\n\n两种方法的区别就是区间收缩的方式不一样，前者是`left=mid+1`后者是`right=mid-1`，所以问题其实就变成了：当**小于等于 mid 的数量==k **的时候，二分的区间应该如何缩减？\n\n其实举个例子就懂了\n```go\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 2\n```\nk=2，对应结果应该是 5，但是我们现在 mid=8，这里 8 和 5 在矩阵中小于等于它们的数量是相同的，这个时候很明显应该缩短 right 去逼近 5，所以我们应该选取`>=`作为答案区间并记录答案，并且缩短 right 逼近矩阵中真实存在的值\n\n>这里是一定是可以取到矩阵中的值的，二分最后会在大于等于区域不断缩减 right 直至不能再缩减，也就是缩减成为矩阵中的元素（再缩减就小于 K 了）\n```java\npublic int kthSmallest(int[][] matrix, int k) {\n    int n = matrix.length;\n    int left = matrix[0][0];\n    int right = matrix[n-1][n-1];\n    int res = left;\n    while(left <= right){\n        int mid = left + (right - left)/2;\n        //注意这个地方，很关键，核心就是这个等于号的位置，在小于等于 mid 的数量==k 的时候二分的区间应该如何移动\n        //其实举个例子就懂了，假设 k=2，对于结果应该是 5，但是我们现在 mid=8\n        //这里 8 和 5 在矩阵中小于等于它们的数量是相同的，这个时候很明显应该缩短 right 去逼近 5\n        //所以我们应该在二分的大于等于区间记录答案，并且缩短 right\n        if (check(matrix, mid) >= k){\n            res = mid;\n            right = mid - 1;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return res;\n}\n\n//检查数组中小于等于 mid 的个数\npublic int check(int[][] matrix, int mid){\n    int row = matrix.length-1, column = 0;\n    int count = 0;\n    int lastRow = 0; \n    while(row >= 0){\n        while (column < matrix[0].length && matrix[row][column] <= mid){\n            column++;\n            lastRow++;\n        }\n        count += lastRow;\n        row--;\n    }\n    return count;\n}\n```\n\n## [441. 排列硬币](https://leetcode-cn.com/problems/arranging-coins/)\n\nDifficulty: **简单**\n\n你总共有 _n _枚硬币，你需要将它们摆成一个阶梯形状，第 _k _行就必须正好有 _k _枚硬币。\n\n给定一个数字 _n_，找出可形成完整阶梯行的总行数。\n\n_n _是一个非负整数，并且在 32 位有符号整型的范围内。\n\n**示例 1:**\n\n```\nn = 5\n\n硬币可排列成以下几行：\n¤\n¤ ¤\n\n因为第三行不完整，所以返回 2.\n```\n\n**示例 2:**\n\n```\nn = 8\n\n硬币可排列成以下几行：\n¤\n¤ ¤\n¤ ¤ ¤\n¤ ¤\n\n因为第四行不完整，所以返回 3.\n```\n**解法一**\n\n因为是从二分的 tag 来的，所以知道是二分，然后看了题，确定了有二分答案性质，然后直接二分，可是没想到居然溢出了，看来还是有点大意了啊，时间复杂度 O(logN)\n```java\n//二分答案\npublic int arrangeCoins(int n) {\n    int left = 1;\n    int right = n;\n    int res = 0;\n    while(left <= right){\n        long mid = left + (right - left)/2;\n        long sum = (1 + mid) * mid / 2;\n        if(sum <= n){\n            res = (int)mid;\n            left = (int)mid + 1;\n        }else{\n            right = (int)mid - 1;\n        }\n    }\n    return res;\n}\n```\n这题当然也可以直接模拟，不过意义不大，这题还有数学的解法，根据求和公式直接算出根，然后利用 sqrt 函数，这样并不会比二分快多少，sqrt 也是 logN 级别的，而且面试官应该也不希望你利用库函数（当然人如果能手写牛顿迭代法那肯定没问题）\n\n## [174. 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)\n\nDifficulty: **困难**\n\n一些恶魔抓住了公主（**P**）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（**K**）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。\n\n**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**\n\n例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。\n\n<table class=\"dungeon\" style=\"display: table;\">\n\n<tbody style=\"display: table-row-group;\">\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">-2 (K)</td>\n\n<td style=\"display: table-cell;\">-3</td>\n\n<td style=\"display: table-cell;\">3</td>\n\n</tr>\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">-5</td>\n\n<td style=\"display: table-cell;\">-10</td>\n\n<td style=\"display: table-cell;\">1</td>\n\n</tr>\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">10</td>\n\n<td style=\"display: table-cell;\">30</td>\n\n<td style=\"display: table-cell;\">-5 (P)</td>\n\n</tr>\n\n</tbody>\n\n</table>\n\n**说明：**\n\n*   骑士的健康点数没有上限。\n\n*   任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。\n\n**解法一**\n\n以后每日一题没写出来之前绝壁不看群了，看了一眼群，看见群友讨论了这题，说了二分和 dp，然后我就直接向二分的方向去想了，如果独立的想的话，应该也是可以得出二分的解法的，毕竟题目的描述很明显就是二分答案，**最低的健康血量**，大于这个血量的肯定可以救出来，小于这个血量的肯定救不出来，所以 check 就是判断在某个血量下，能否拯救到公主（DP）\n\n时间复杂度 O(N^2logN)（其实我认为也可以当作 N^2 毕竟上下界都确定了，logN 也就 30 左右），这种解法也挺不错的，融合了二分和 dp\n\n```java\npublic int calculateMinimumHP(int[][] dungeon) {\n    int left = 0;\n    int right = Integer.MAX_VALUE;\n    int res = 0;\n    while(left <= right){\n        int mid = left + (right-left)/2;\n        if(check(dungeon, mid)){\n            res = mid;\n            right = mid - 1;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[][] dungeon, int live){\n    int m = dungeon.length;\n    int n = dungeon[0].length;\n    int INF = Integer.MIN_VALUE;\n    //live 的血量从左上到 dungeon[i][j] 的剩余最多血量\n    int[][] dp = new int[m+1][n+1];\n    //地牢外围加上 INF 的围墙，简化逻辑\n    Arrays.fill(dp[0], INF);\n    dp[0][1] = live;\n    for(int i = 1; i <= m; i++){\n        dp[i][0] = INF;\n        for(int j = 1; j <= n; j++){\n            if(dp[i-1][j] <= 0 && dp[i][j-1] <=0 ){\n                dp[i][j] = INF; //无法到达这里\n            }else{\n                dp[i][j] = dungeon[i-1][j-1] + Math.max(dp[i][j-1], dp[i-1][j]);\n            }\n        }\n    }\n    return dp[m][n] > 0;\n}\n```\n当然这题也有纯 dp 的做法，很可惜，我压根没往上面想，我只想着二分 dp，写完了 AC 之后就去看评论区了，结果发现大家都是直接 dp 的。然后还看到了一个关键词：逆向 dp，然后赶紧关了评论区回来写了下面的 dp 解法\n\n**解法二**\n```java\n/*\n    -2  -3  3\n    -5 -10  1\n    10  30 -5 1\n            \n    7   5   2\n    6  11   5\n    1   1   6\n*/\npublic int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length;\n    int n = dungeon[0].length;\n    int INF = Integer.MAX_VALUE;\n    //从 dungeon[i-1][j-1] 到右下角至少要多少血量\n    int[][] dp = new int[m+1][n+1];\n    Arrays.fill(dp[m], INF);//末行\n    dp[m][n-1] = 1; //初始血量\n    for (int i = m-1; i >= 0; i--) {\n        dp[i][n] = INF; //首列和尾列\n        for (int j = n-1; j >= 0; j--) {\n            dp[i][j] = Math.max(Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1);\n        }\n    }\n    return dp[0][0];\n}\n```\n这题为啥不能正向 dp 呢，设`dp[i][j]`为从左上角到 i,j 所需要的最低血量？其实这个很明显就是有问题的，没办法转移，`dp[i][j]`和`dp[i-1][j]`没有任何关系，都不一定是同一条路径\n\n## [848. 加油站之间的最小距离（LintCode）](https://www.lintcode.com/problem/minimize-max-distance-to-gas-station/description)\n\n在水平数轴上，我们有加油站：stations[0], stations[1], ..., stations[N-1], 这里 N = stations.length。\n\n现在，我们再增加 K 个加油站，D 表示相邻加油站之间的最大距离，这样 D 就变小了。\n\n返回所有可能值 D 中最小值。\n1. stations.length 为整数，范围 [10, 2000].\n2. stations[i] 为整数，范围 [0, 10^8].\n3. K 为整数，范围 [1, 10^6].\n4. 答案范围在 10 ^ -6 之内的有理数。\n   \n**样例 1:**\n```go\n输入：stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，K = 9\n输出：0.50\n解释：相邻加油站的距离均为 0.50\n```\n**样例 2:**\n```go\n输入：stations = [3,6,12,19,33,44,67,72,89,95]，K = 2\n输出：14.00\n解释：在距离 86 处建造加油站 (fix: 还有 58 处）\n```\n\n**解法一**\n\n二分答案的性质很明显，但是这里和之前的不一样，这里是浮点数二分，和整数的不太一样，浮点数/2 的时候都是实际的一分为 2，不会有整除的问题，同时题目给出了 eps=1e-6，只要 left 和 right 误差在这个范围内就是合法的，并不是要求 left 和 right 相等，这里还有一个问题，就是这里如果 eps 太小的话由于精度问题还是可能会 tle，这个时候就可以采取固定循环次数的方式逼近，一般取 100，200 就够了\n```java\npublic double minmaxGasDist(int[] stations, int k) {\n    // Write your code here\n    double left = 0;\n    double right = 1e8+1;\n    double res = right;\n    //for (int i = 0; i <= 100; i++){\n    while (right-left >= 1e-6){\n        double mid = left+(right-left)/2;\n        if (check(stations, k, mid)) {\n            res = mid;\n            right = mid;\n        }else{\n            left = mid;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[] stations, int k, double D) {\n    int count = 0;\n    for (int i = 1; i < stations.length; i++) {\n        count += (stations[i]-stations[i-1]) / D;\n    }\n    return count <= k;        \n}\n```\n\n## [5489. 两球之间的磁力](https://leetcode-cn.com/problems/magnetic-force-between-two-balls/)\n\nDifficulty: **中等**\n\n在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 `n` 个空的篮子，第 `i` 个篮子的位置在 `position[i]` ，Morty 想把 `m` 个球放到这些篮子里，使得任意两球间 **最小磁力** 最大。\n\n已知两个球如果分别位于 `x` 和 `y` ，那么它们之间的磁力为 `|x - y|` 。\n\n给你一个整数数组 `position` 和一个整数 `m` ，请你返回最大化的最小磁力。\n\n**示例 1：**\n\n![mark](http://static.imlgw.top/blog/20200816/1KmEXzfFOozs.png?imageslim)\n```go\n输入：position = [1,2,3,4,7], m = 3\n输出：3\n解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n```\n\n**示例 2：**\n\n```go\n输入：position = [5,4,3,2,1,1000000000], m = 2\n输出：999999999\n解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。\n```\n\n**提示：**\n\n*   `n == position.length`\n*   `2 <= n <= 10^5`\n*   `1 <= position[i] <= 10^9`\n*   所有 `position` 中的整数 **互不相同** 。\n*   `2 <= m <= position.length`\n\n**解法一**\n\n202 周赛 T3，没参赛（实在是没时间打）赛后独立的写出来了，很明显是二分答案，不过这里有一点小不同\n```java\npublic int maxDistance(int[] position, int m) {\n    Arrays.sort(position);\n    int left = 1;\n    int right = (int)1e9+1;\n    int res = 1;\n    while (left <= right) {\n        int mid = left + (right-left)/2;\n        if (check(position, m, mid)) {\n            res = mid;\n            left = mid + 1; \n        }else{\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n//1  1000 2000 3000 m=3\n//验证在距离至少为 force 的情况下能否放下所有的球，然后增大 force 逼近答案\n//所以 check 验证成功的不一定是合法的答案，但是最终一定会到达 real ans\n//类似【378. 有序矩阵中第 K 小的元素】这道题\npublic boolean check(int[] position, int m, int force) {\n    int last = position[0];\n    m--;\n    for (int i = 1; i < position.length; i++) {\n        if (position[i]-last < force) {\n            continue;\n        }\n        last = position[i];\n        m--;\n        if (m==0) return true;\n    }\n    return false;\n}\n```\ncheck 类似 [378. 有序矩阵中第 K 小的元素](#378-有序矩阵中第 k 小的元素)这道题，都是逼近答案，而不是验证答案，其实一开始我的 check 不是这样写的，写的很丑，这里看了别人的写法发现 continue 有时候还是挺好用的","tags":["LeetCode","二分"],"categories":["算法"]},{"title":"堆和优先队列","url":"/2019/12/01/4bb85ba2/","content":"\n### 堆\n\n首先我们要明白，堆实际上是一颗完全二叉树，借助**完全二叉树**父子节点关系的性质，我们就可以很方便的在数组中实现这一结构，而堆也分为两种，一种是大根堆，顾名思义也就是父节点 value 大于子节点 value，小根堆则相反\n\n### 动态数组\n\n借助这个类实现堆结构，直接用`ArrayList`也可以\n\n```java\n\npublic class Array<E> {\n\n    private E[] data;\n    private int size;\n\n    // 构造函数，传入数组的容量 capacity 构造 Array\n    public Array(int capacity){\n        data = (E[])new Object[capacity];\n        size = 0;\n    }\n\n    // 无参数的构造函数，默认数组的容量 capacity=10\n    public Array(){\n        this(10);\n    }\n\n    // 获取数组的容量\n    public int getCapacity(){\n        return data.length;\n    }\n\n    // 获取数组中的元素个数\n    public int getSize(){\n        return size;\n    }\n\n    // 返回数组是否为空\n    public boolean isEmpty(){\n        return size == 0;\n    }\n\n    // 在 index 索引的位置插入一个新元素 e\n    public void add(int index, E e){\n        if(index < 0 || index > size)\n            throw new IllegalArgumentException(\"Add failed. Require index >= 0 and index <= size.\");\n        if(size == data.length)\n            resize(2 * data.length); //2 倍扩容\n        for(int i = size - 1; i >= index ; i --){\n            data[i + 1] = data[i];\n        }\n        data[index] = e;\n        size ++;\n    }\n\n    // 向所有元素后添加一个新元素\n    public void addLast(E e){\n        add(size, e);\n    }\n\n    // 在所有元素前添加一个新元素\n    public void addFirst(E e){\n        add(0, e);\n    }\n\n    // 获取 index 索引位置的元素\n    public E get(int index){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Get failed. Index is illegal.\");\n        return data[index];\n    }\n\n    // 修改 index 索引位置的元素为 e\n    public void set(int index, E e){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Set failed. Index is illegal.\");\n        data[index] = e;\n    }\n\n    // 查找数组中是否有元素 e\n    public boolean contains(E e){\n        for(int i = 0 ; i < size ; i ++){\n            if(data[i].equals(e))\n                return true;\n        }\n        return false;\n    }\n\n    // 查找数组中元素 e 所在的索引，如果不存在元素 e，则返回-1\n    public int find(E e){\n        for(int i = 0 ; i < size ; i ++){\n            if(data[i].equals(e))\n                return i;\n        }\n        return -1;\n    }\n\n    // 从数组中删除 index 位置的元素，返回删除的元素\n    public E remove(int index){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Remove failed. Index is illegal.\");\n\n        E ret = data[index];\n        for(int i = index + 1 ; i < size ; i ++)\n            data[i - 1] = data[i];\n        size --;\n        data[size] = null; // loitering objects != memory leak\n        //数据不到 1/4 的时候缩减\n        if(size == data.length / 4 && data.length / 2 != 0)\n            resize(data.length / 2);\n        return ret;\n    }\n\n    // 从数组中删除第一个元素，返回删除的元素\n    public E removeFirst(){\n        return remove(0);\n    }\n\n    // 从数组中删除最后一个元素，返回删除的元素\n    public E removeLast(){\n        return remove(size - 1);\n    }\n\n    // 从数组中删除元素 e\n    public void removeElement(E e){\n        int index = find(e);\n        if(index != -1)\n            remove(index);\n    }\n\n    //交换\n    public void swap(int a,int b){\n        if (a<0||a>=size || b<0||b>=size) {\n            throw new IllegalArgumentException(\"index illegal\");\n        }\n        E temp=data[a];\n        data[a]=data[b];\n        data[b]=temp;\n    }\n\n    @Override\n    public String toString(){\n\n        StringBuilder res = new StringBuilder();\n        res.append(String.format(\"Array: size = %d , capacity = %d\\n\", size, data.length));\n        res.append('[');\n        for(int i = 0 ; i < size ; i ++){\n            res.append(data[i]);\n            if(i != size - 1)\n                res.append(\", \");\n        }\n        res.append(']');\n        return res.toString();\n    }\n\n    // 将数组空间的容量变成 newCapacity 大小\n    private void resize(int newCapacity){\n        E[] newData = (E[])new Object[newCapacity];\n        for(int i = 0 ; i < size ; i ++)\n            newData[i] = data[i];\n        data = newData;\n    }\n}\n\n```\n\n### 大根堆\n\n```java\npublic class MaxHeap<E extends Comparable<E>>{\n    private Array<E> data;\n\n    public MaxHeap(int capacity){\n        data=new Array<>(capacity);\n    }\n\n    public MaxHeap(){\n        data=new Array<>();\n    }\n\n    public int size(){\n        return data.getSize();\n    }\n\n    public boolean isEmpty(){\n        return data.isEmpty();\n    }\n\n    //父节点\n    private int parent(int index){\n        if (index==0) {\n            throw new IllegalArgumentException(\"index 0 don't have parent\");\n        }\n        return (index-1)/2;\n    }\n\n    //左孩子\n    private int leftChild(int index){\n        return index*2+1;\n    }\n\n    //右孩子\n    private int rightChild(int index){\n        return index*2+2;\n    }\n\n    public void add(E e){\n        data.addLast(e);\n        siftUp(data.getSize()-1);\n    }\n\n    //上浮\n    private void siftUp(int cur){\n        while(cur>0 && data.get(parent(cur)).compareTo(data.get(cur)) < 0){\n            data.swap(cur,parent(cur));\n            cur=parent(cur);\n        }\n    }\n\n    public E findMax(){\n        if (data.getSize()==0) {\n            throw new IllegalArgumentException(\"heap is empty !!!\");\n        }\n        return  data.get(0);\n    }\n\n    public E popMax(){\n        if (data.getSize()==0) {\n            throw new IllegalArgumentException(\"heap is empty !!!\");\n        }\n        E res=findMax();\n        data.swap(0,data.getSize()-1);\n        data.removeLast();\n        siftDown(0);\n        return res;\n    }    \n\n    private void siftDown(int cur){\n        while(leftChild(cur)<data.getSize()){ //有左孩子\n            int large=leftChild(cur);\n            //如果也有右孩子，就比较下两个节点的值取最大值\n            if (large+1<data.getSize() && data.get(large).compareTo(data.get(large+1))<0) {\n                large=large+1;\n            }\n            //比左右孩子都大就直接结束了\n            if (data.get(large).compareTo(data.get(cur))<=0){\n                return;\n            }\n            data.swap(large,cur);\n            cur=large;\n        }\n    }\n}\n```\n\n其实上面的实现还是有一些缺陷的，只能按照给定的键的默认排序规则进行比较，不方便实现自定义的比较规则，需要进行封装才可以，关于这一点其实可以借鉴 Java 中的`PriorityQueue`\n\n### 测试\n\n```java\nimport java.util.*;\npublic class HeapTest{\n    public static void main(String[] args) {\n        int[] nums=generateRandomArray(50000000,500);\n        MaxHeap heap=new MaxHeap();\n        for (int i=0;i<nums.length;i++) {\n            heap.add(nums[i]);\n        }\n        for (int i=0;i<nums.length;i++) {\n            nums[i]=(int)heap.popMax();\n        }\n        for (int i=1;i<nums.length;i++) {\n            if (nums[i-1]<nums[i]) {\n                System.out.println(\"fuxk!!!\");\n                return;\n            }\n        }\n        System.out.println(\"sucess!!!!!\");\n    }\n\n    // for test\n    public static int[] generateRandomArray(int maxSize, int maxValue) {\n        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());\n        }\n        return arr;\n    }\n}\n```\n\n### PriorityQueue\n\n```java\npackage java.util;\n\nimport java.util.function.Consumer;\nimport sun.misc.SharedSecrets;\n\n/**\n * An unbounded priority {@linkplain Queue queue} based on a priority heap.\n * The elements of the priority queue are ordered according to their\n * {@linkplain Comparable natural ordering}, or by a {@link Comparator}\n * provided at queue construction time, depending on which constructor is\n * used.  A priority queue does not permit {@code null} elements.\n * A priority queue relying on natural ordering also does not permit\n * insertion of non-comparable objects (doing so may result in\n * {@code ClassCastException}).\n *\n * <p>The <em>head</em> of this queue is the <em>least</em> element\n * with respect to the specified ordering.  If multiple elements are\n * tied for least value, the head is one of those elements -- ties are\n * broken arbitrarily.  The queue retrieval operations {@code poll},\n * {@code remove}, {@code peek}, and {@code element} access the\n * element at the head of the queue.\n *\n * <p>A priority queue is unbounded, but has an internal\n * <i>capacity</i> governing the size of an array used to store the\n * elements on the queue.  It is always at least as large as the queue\n * size.  As elements are added to a priority queue, its capacity\n * grows automatically.  The details of the growth policy are not\n * specified.\n *\n * <p>This class and its iterator implement all of the\n * <em>optional</em> methods of the {@link Collection} and {@link\n * Iterator} interfaces.  The Iterator provided in method {@link\n * #iterator()} is <em>not</em> guaranteed to traverse the elements of\n * the priority queue in any particular order. If you need ordered\n * traversal, consider using {@code Arrays.sort(pq.toArray())}.\n *\n * <p><strong>Note that this implementation is not synchronized.</strong>\n * Multiple threads should not access a {@code PriorityQueue}\n * instance concurrently if any of the threads modifies the queue.\n * Instead, use the thread-safe {@link\n * java.util.concurrent.PriorityBlockingQueue} class.\n *\n * <p>Implementation note: this implementation provides\n * O(log(n)) time for the enqueuing and dequeuing methods\n * ({@code offer}, {@code poll}, {@code remove()} and {@code add});\n * linear time for the {@code remove(Object)} and {@code contains(Object)}\n * methods; and constant time for the retrieval methods\n * ({@code peek}, {@code element}, and {@code size}).\n *\n * <p>This class is a member of the\n * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n * Java Collections Framework</a>.\n *\n * @since 1.5\n * @author Josh Bloch, Doug Lea\n * @param <E> the type of elements held in this collection\n */\npublic class PriorityQueue<E> extends AbstractQueue<E>\n    implements java.io.Serializable {\n\n    private static final long serialVersionUID = -7720805057305804111L;\n\n    private static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n    /**\n     * Priority queue represented as a balanced binary heap: the two\n     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The\n     * priority queue is ordered by comparator, or by the elements'\n     * natural ordering, if comparator is null: For each node n in the\n     * heap and each descendant d of n, n <= d.  The element with the\n     * lowest value is in queue[0], assuming the queue is nonempty.\n     */\n    transient Object[] queue; // non-private to simplify nested class access\n\n    /**\n     * The number of elements in the priority queue.\n     */\n    private int size = 0;\n\n    /**\n     * The comparator, or null if priority queue uses elements'\n     * natural ordering.\n     * 如果没有传入比较器的话，按照元素的自然排序进行比较\n     */\n    private final Comparator<? super E> comparator;\n\n    /**\n     * The number of times this priority queue has been\n     * <i>structurally modified</i>.  See AbstractList for gory details.\n     */\n    transient int modCount = 0; // non-private to simplify nested class access\n\n    /**\n     * Creates a {@code PriorityQueue} with the default initial\n     * capacity (11) that orders its elements according to their\n     * {@linkplain Comparable natural ordering}.\n     */\n    public PriorityQueue() {\n        this(DEFAULT_INITIAL_CAPACITY, null);\n    }\n\n    public PriorityQueue(int initialCapacity) {\n        this(initialCapacity, null);\n    }\n    \n    //传入自定义的比较规则\n    public PriorityQueue(Comparator<? super E> comparator) {\n        this(DEFAULT_INITIAL_CAPACITY, comparator);\n    }\n\n    public PriorityQueue(int initialCapacity,\n                         Comparator<? super E> comparator) {\n        // Note: This restriction of at least one is not actually needed,\n        // but continues for 1.5 compatibility\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.queue = new Object[initialCapacity];\n        this.comparator = comparator;\n    }\n\n    /**\n     * Creates a {@code PriorityQueue} containing the elements in the\n     * specified collection.  If the specified collection is an instance of\n     * a {@link SortedSet} or is another {@code PriorityQueue}, this\n     * priority queue will be ordered according to the same ordering.\n     * Otherwise, this priority queue will be ordered according to the\n     * {@linkplain Comparable natural ordering} of its elements.\n     * 传入一个集合类型，如果是 SortSet（有序）类型的集合或者也是 PriorityQueue 就会按照相同的规则去比较。\n     * 否则就会按照元素的自然排序规则去比较。\n     * \n     * @param  c the collection whose elements are to be placed\n     *         into this priority queue\n     * @throws ClassCastException if elements of the specified collection\n     *         cannot be compared to one another according to the priority\n     *         queue's ordering\n     * @throws NullPointerException if the specified collection or any\n     *         of its elements are null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public PriorityQueue(Collection<? extends E> c) {\n        if (c instanceof SortedSet<?>) {\n            SortedSet<? extends E> ss = (SortedSet<? extends E>) c;\n            //拿到 SortSet 集合中元素的比较器，用于后序的操作\n            this.comparator = (Comparator<? super E>) ss.comparator();\n            initElementsFromCollection(ss);\n        }\n        else if (c instanceof PriorityQueue<?>) {\n            PriorityQueue<? extends E> pq = (PriorityQueue<? extends E>) c;\n            this.comparator = (Comparator<? super E>) pq.comparator();\n            initFromPriorityQueue(pq);\n        }\n        else {\n            this.comparator = null;\n            initFromCollection(c);\n        }\n    }\n\n    /**\n     * Creates a {@code PriorityQueue} containing the elements in the\n     * specified priority queue.  This priority queue will be\n     * ordered according to the same ordering as the given priority\n     * queue.\n     *\n     * @param  c the priority queue whose elements are to be placed\n     *         into this priority queue\n     * @throws ClassCastException if elements of {@code c} cannot be\n     *         compared to one another according to {@code c}'s\n     *         ordering\n     * @throws NullPointerException if the specified priority queue or any\n     *         of its elements are null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public PriorityQueue(PriorityQueue<? extends E> c) {\n        this.comparator = (Comparator<? super E>) c.comparator();\n        initFromPriorityQueue(c);\n    }\n\n    /**\n     * Creates a {@code PriorityQueue} containing the elements in the\n     * specified sorted set.   This priority queue will be ordered\n     * according to the same ordering as the given sorted set.\n     *\n     * @param  c the sorted set whose elements are to be placed\n     *         into this priority queue\n     * @throws ClassCastException if elements of the specified sorted\n     *         set cannot be compared to one another according to the\n     *         sorted set's ordering\n     * @throws NullPointerException if the specified sorted set or any\n     *         of its elements are null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public PriorityQueue(SortedSet<? extends E> c) {\n        this.comparator = (Comparator<? super E>) c.comparator();\n        initElementsFromCollection(c);\n    }\n\n    private void initFromPriorityQueue(PriorityQueue<? extends E> c) {\n        if (c.getClass() == PriorityQueue.class) {\n            this.queue = c.toArray();\n            this.size = c.size();\n        } else {\n            initFromCollection(c);\n        }\n    }\n\t\n\t//从 SortSet 有序集合中的元素直接复制到当前的 queue 中\n    private void initElementsFromCollection(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        // If c.toArray incorrectly doesn't return Object[], copy it.\n        if (a.getClass() != Object[].class)\n            a = Arrays.copyOf(a, a.length, Object[].class);\n        int len = a.length;\n        if (len == 1 || this.comparator != null)\n            for (int i = 0; i < len; i++)\n                if (a[i] == null)\n                    throw new NullPointerException();\n        this.queue = a;\n        this.size = a.length;\n    }\n\n    /**\n     * Initializes queue array with elements from the given Collection.\n     * 从无序集合中构建 queue\n     * @param c the collection\n     */\n    private void initFromCollection(Collection<? extends E> c) {\n        initElementsFromCollection(c);\n        //复制完成之后进行调整\n        heapify();\n    }\n\n    /**\n     * The maximum size of array to allocate.\n     * Some VMs reserve some header words in an array.\n     * Attempts to allocate larger arrays may result in\n     * OutOfMemoryError: Requested array size exceeds VM limit\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * Increases the capacity of the array.\n     * queue 数组扩容\n     * @param minCapacity the desired minimum capacity\n     */\n    private void grow(int minCapacity) {\n        int oldCapacity = queue.length;\n        // Double size if small; else grow by 50%\n        int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                         (oldCapacity + 2) :\n                                         (oldCapacity >> 1));\n        // overflow-conscious code\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        queue = Arrays.copyOf(queue, newCapacity);\n    }\n\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    /**\n     * Inserts the specified element into this priority queue.\n     *\n     * @return {@code true} (as specified by {@link Collection#add})\n     * @throws ClassCastException if the specified element cannot be\n     *         compared with elements currently in this priority queue\n     *         according to the priority queue's ordering\n     * @throws NullPointerException if the specified element is null\n     */\n    public boolean add(E e) {\n        return offer(e);\n    }\n\n    /**\n     * Inserts the specified element into this priority queue.\n     *\n     * @return {@code true} (as specified by {@link Queue#offer})\n     * @throws ClassCastException if the specified element cannot be\n     *         compared with elements currently in this priority queue\n     *         according to the priority queue's ordering\n     * @throws NullPointerException if the specified element is null\n     */\n    public boolean offer(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        modCount++;\n        int i = size;\n        if (i >= queue.length)\n            grow(i + 1);\n        size = i + 1;\n        if (i == 0)\n            queue[0] = e;\n        else\n            siftUp(i, e);\n        return true;\n    }\n\n    public E peek() {\n        return (size == 0) ? null : (E) queue[0];\n    }\n\n    private int indexOf(Object o) {\n        if (o != null) {\n            for (int i = 0; i < size; i++)\n                if (o.equals(queue[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Removes a single instance of the specified element from this queue,\n     * if it is present.  More formally, removes an element {@code e} such\n     * that {@code o.equals(e)}, if this queue contains one or more such\n     * elements.  Returns {@code true} if and only if this queue contained\n     * the specified element (or equivalently, if this queue changed as a\n     * result of the call).\n     *\n     * @param o element to be removed from this queue, if present\n     * @return {@code true} if this queue changed as a result of the call\n     */\n    public boolean remove(Object o) {\n        int i = indexOf(o);\n        if (i == -1)\n            return false;\n        else {\n            removeAt(i);\n            return true;\n        }\n    }\n\n    /**\n     * Version of remove using reference equality, not equals.\n     * Needed by iterator.remove.\n     *\n     * @param o element to be removed from this queue, if present\n     * @return {@code true} if removed\n     */\n    boolean removeEq(Object o) {\n        for (int i = 0; i < size; i++) {\n            if (o == queue[i]) {\n                removeAt(i);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n\n    public Object[] toArray() {\n        return Arrays.copyOf(queue, size);\n    }\n\n    public <T> T[] toArray(T[] a) {\n        final int size = this.size;\n        if (a.length < size)\n            // Make a new array of a's runtime type, but my contents:\n            return (T[]) Arrays.copyOf(queue, size, a.getClass());\n        System.arraycopy(queue, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n    private final class Itr implements Iterator<E> {\n        /**\n         * Index (into queue array) of element to be returned by\n         * subsequent call to next.\n         */\n        private int cursor = 0;\n\n        /**\n         * Index of element returned by most recent call to next,\n         * unless that element came from the forgetMeNot list.\n         * Set to -1 if element is deleted by a call to remove.\n         */\n        private int lastRet = -1;\n\n        private ArrayDeque<E> forgetMeNot = null;\n\n        /**\n         * Element returned by the most recent call to next iff that\n         * element was drawn from the forgetMeNot list.\n         */\n        private E lastRetElt = null;\n\n        /**\n         * The modCount value that the iterator believes that the backing\n         * Queue should have.  If this expectation is violated, the iterator\n         * has detected concurrent modification.\n         */\n        private int expectedModCount = modCount;\n\n        public boolean hasNext() {\n            return cursor < size ||\n                (forgetMeNot != null && !forgetMeNot.isEmpty());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public E next() {\n            if (expectedModCount != modCount)\n                throw new ConcurrentModificationException();\n            if (cursor < size)\n                return (E) queue[lastRet = cursor++];\n            if (forgetMeNot != null) {\n                lastRet = -1;\n                lastRetElt = forgetMeNot.poll();\n                if (lastRetElt != null)\n                    return lastRetElt;\n            }\n            throw new NoSuchElementException();\n        }\n\n        public void remove() {\n            if (expectedModCount != modCount)\n                throw new ConcurrentModificationException();\n            if (lastRet != -1) {\n                E moved = PriorityQueue.this.removeAt(lastRet);\n                lastRet = -1;\n                if (moved == null)\n                    cursor--;\n                else {\n                    if (forgetMeNot == null)\n                        forgetMeNot = new ArrayDeque<>();\n                    forgetMeNot.add(moved);\n                }\n            } else if (lastRetElt != null) {\n                PriorityQueue.this.removeEq(lastRetElt);\n                lastRetElt = null;\n            } else {\n                throw new IllegalStateException();\n            }\n            expectedModCount = modCount;\n        }\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public void clear() {\n        modCount++;\n        for (int i = 0; i < size; i++)\n            queue[i] = null;\n        size = 0;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public E poll() {\n        if (size == 0)\n            return null;\n        int s = --size;\n        modCount++;\n        E result = (E) queue[0];\n        E x = (E) queue[s];\n        queue[s] = null;\n        if (s != 0)\n            siftDown(0, x);\n        return result;\n    }\n\n    /**\n     * Removes the ith element from queue.\n     * 删除某个位置的元素\n     * Normally this method leaves the elements at up to i-1,\n     * inclusive, untouched.  Under these circumstances, it returns\n     * null.  Occasionally, in order to maintain the heap invariant,\n     * it must swap a later element of the list with one earlier than\n     * i.  Under these circumstances, this method returns the element\n     * that was previously at the end of the list and is now at some\n     * position before i. This fact is used by iterator.remove so as to\n     * avoid missing traversing elements.\n     */\n    private E removeAt(int i) {\n        // assert i >= 0 && i < size;\n        modCount++;\n        int s = --size;\n        if (s == i) // removed last element 移除最后一个元素\n            queue[i] = null;\n        else {\n            E moved = (E) queue[s]; //保存队列尾部的元素\n            queue[s] = null; //置为 null\n            siftDown(i, moved); //moved 直接插入到 i 位置，相当于直接删除了 i 位置的元素\n            if (queue[i] == moved) {\n                siftUp(i, moved);\n                if (queue[i] != moved)\n                    return moved;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Inserts item x at position k, maintaining heap invariant by\n     * promoting x up the tree until it is greater than or equal to\n     * its parent, or is the root.\n     * 将 x 插入 k 位置，并进行上浮调整\n     * To simplify and speed up coercions and comparisons. the\n     * Comparable and Comparator versions are separated into different\n     * methods that are otherwise identical. (Similarly for siftDown.)\n     *\n     * @param k the position to fill\n     * @param x the item to insert\n     */\n    private void siftUp(int k, E x) {\n        if (comparator != null)\n            siftUpUsingComparator(k, x);\n        else\n            siftUpComparable(k, x);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void siftUpComparable(int k, E x) {\n        Comparable<? super E> key = (Comparable<? super E>) x;\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (key.compareTo((E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = key;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void siftUpUsingComparator(int k, E x) {\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (comparator.compare(x, (E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = x;\n    }\n\n    /**\n     * Inserts item x at position k, maintaining heap invariant by\n     * demoting x down the tree repeatedly until it is less than or\n     * equal to its children or is a leaf.\n     * 插入元素 x 到到位置 k, 并进行下沉调整\n     * \n     * @param k the position to fill\n     * @param x the item to insert\n     */\n    private void siftDown(int k, E x) {\n        if (comparator != null)\n            siftDownUsingComparator(k, x);  //带比较器的\n        else\n            siftDownComparable(k, x); //不带比较器，用 x 的 compator\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void siftDownComparable(int k, E x) {\n        Comparable<? super E> key = (Comparable<? super E>)x;\n        int half = size >>> 1;        // loop while a non-leaf\n        while (k < half) {\n            int child = (k << 1) + 1; // assume left child is least\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)\n                c = queue[child = right];\n            if (key.compareTo((E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = key;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void siftDownUsingComparator(int k, E x) {\n        int half = size >>> 1;\n        while (k < half) {\n            int child = (k << 1) + 1;\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                comparator.compare((E) c, (E) queue[right]) > 0)\n                c = queue[child = right];\n            if (comparator.compare(x, (E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = x;\n    }\n\n    /**\n     * Establishes the heap invariant (described above) in the entire tree,\n     * assuming nothing about the order of the elements prior to the call.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void heapify() {\n        for (int i = (size >>> 1) - 1; i >= 0; i--)\n            siftDown(i, (E) queue[i]);\n    }\n\n    public Comparator<? super E> comparator() {\n        return comparator;\n    }\n\n    /**\n     * Saves this queue to a stream (that is, serializes it).\n     *\n     * @serialData The length of the array backing the instance is\n     *             emitted (int), followed by all of its elements\n     *             (each an {@code Object}) in the proper order.\n     * @param s the stream\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n        // Write out element count, and any hidden stuff\n        s.defaultWriteObject();\n\n        // Write out array length, for compatibility with 1.5 version\n        s.writeInt(Math.max(2, size + 1));\n\n        // Write out all elements in the \"proper order\".\n        for (int i = 0; i < size; i++)\n            s.writeObject(queue[i]);\n    }\n\n    /**\n     * Reconstitutes the {@code PriorityQueue} instance from a stream\n     * (that is, deserializes it).\n     *\n     * @param s the stream\n     */\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        // Read in size, and any hidden stuff\n        s.defaultReadObject();\n\n        // Read in (and discard) array length\n        s.readInt();\n\n        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size);\n        queue = new Object[size];\n\n        // Read in all elements.\n        for (int i = 0; i < size; i++)\n            queue[i] = s.readObject();\n\n        // Elements are guaranteed to be in \"proper order\", but the\n        // spec has never explained what that might be.\n        heapify();\n    }\n\n    /**\n     * Creates a <em><a href=\"Spliterator.html#binding\">late-binding</a></em>\n     * and <em>fail-fast</em> {@link Spliterator} over the elements in this\n     * queue.\n     *\n     * <p>The {@code Spliterator} reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, and {@link Spliterator#NONNULL}.\n     * Overriding implementations should document the reporting of additional\n     * characteristic values.\n     *\n     * @return a {@code Spliterator} over the elements in this queue\n     * @since 1.8\n     */\n    public final Spliterator<E> spliterator() {\n        return new PriorityQueueSpliterator<E>(this, 0, -1, 0);\n    }\n\n    static final class PriorityQueueSpliterator<E> implements Spliterator<E> {\n        /*\n         * This is very similar to ArrayList Spliterator, except for\n         * extra null checks.\n         */\n        private final PriorityQueue<E> pq;\n        private int index;            // current index, modified on advance/split\n        private int fence;            // -1 until first use\n        private int expectedModCount; // initialized when fence set\n\n        /** Creates new spliterator covering the given range */\n        PriorityQueueSpliterator(PriorityQueue<E> pq, int origin, int fence,\n                             int expectedModCount) {\n            this.pq = pq;\n            this.index = origin;\n            this.fence = fence;\n            this.expectedModCount = expectedModCount;\n        }\n\n        private int getFence() { // initialize fence to size on first use\n            int hi;\n            if ((hi = fence) < 0) {\n                expectedModCount = pq.modCount;\n                hi = fence = pq.size;\n            }\n            return hi;\n        }\n\n        public PriorityQueueSpliterator<E> trySplit() {\n            int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;\n            return (lo >= mid) ? null :\n                new PriorityQueueSpliterator<E>(pq, lo, index = mid,\n                                                expectedModCount);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public void forEachRemaining(Consumer<? super E> action) {\n            int i, hi, mc; // hoist accesses and checks from loop\n            PriorityQueue<E> q; Object[] a;\n            if (action == null)\n                throw new NullPointerException();\n            if ((q = pq) != null && (a = q.queue) != null) {\n                if ((hi = fence) < 0) {\n                    mc = q.modCount;\n                    hi = q.size;\n                }\n                else\n                    mc = expectedModCount;\n                if ((i = index) >= 0 && (index = hi) <= a.length) {\n                    for (E e;; ++i) {\n                        if (i < hi) {\n                            if ((e = (E) a[i]) == null) // must be CME\n                                break;\n                            action.accept(e);\n                        }\n                        else if (q.modCount != mc)\n                            break;\n                        else\n                            return;\n                    }\n                }\n            }\n            throw new ConcurrentModificationException();\n        }\n\n        public boolean tryAdvance(Consumer<? super E> action) {\n            if (action == null)\n                throw new NullPointerException();\n            int hi = getFence(), lo = index;\n            if (lo >= 0 && lo < hi) {\n                index = lo + 1;\n                @SuppressWarnings(\"unchecked\") E e = (E)pq.queue[lo];\n                if (e == null)\n                    throw new ConcurrentModificationException();\n                action.accept(e);\n                if (pq.modCount != expectedModCount)\n                    throw new ConcurrentModificationException();\n                return true;\n            }\n            return false;\n        }\n\n        public long estimateSize() {\n            return (long) (getFence() - index);\n        }\n\n        public int characteristics() {\n            return Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.NONNULL;\n        }\n    }\n}\n\n```\n\n### 扩展\n\n**d 叉堆**：多叉堆，上面我们实现的都是二叉堆，但是其实我们还可以将其扩展为多叉堆，一个节点有多个子节点\n\n**索引堆**：我们上面实现的二叉堆只能看见堆顶的元素，看不到堆中的元素，有时候我们可能需要操作堆中间的元素，索引堆顾名思义就是有索引可以对应每个元素，借此就可以操作堆中间的元素\n\n**二项堆**，**斐波拉契堆** ..... 这些结构其实都是扩展的，简单了解即可\n\n### 源码地址\n\n[Github](https://github.com/imlgw/LeetCode/blob/master/tree/heap/MaxHeap.java)\n","tags":["数据结构","堆","优先队列"],"categories":["数据结构"]},{"title":"LeetCode 背包问题","url":"/2019/11/29/f68a53d9/","content":"\n> 从 [动态规划专题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/) 中抽取出来的\n\n## [92. 背包问题（lintCode）](https://www.lintcode.com/problem/backpack/description)\n\n在 n 个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为 m，每个物品的大小为 A[i]\n\n- 你不可以将物品进行切割\n\n**样例**\n\n```java\n样例 1:\n\t输入：[3,4,8,5], backpack size=10\n\t输出：9\n样例 2:\n\t输入：[2,3,5,7], backpack size=12\n\t输出：12\n```\n\n**挑战**\n\n- O(n x m) time and O(m) memory.\n\n- O(n x m) memory is also acceptable if you do not know how to optimize memory.\n\n**解法一**\n\n记忆化递归，对于每个元素，有两种选择，装或者不装\n\n```java\n//用 Integer[][], 空间会超空间。lintCode 好严格\nint [][] cache=null;    \n\npublic int backPack2(int m,int[] A) {\n    cache=new int[A.length+1][m+1];\n    for (int i=0;i<A.length;i++) {\n        Arrays.fill(cache[i],-1);   \n    }\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    return putPack(m,A,A.length-1);\n}\n\n//将 A[index,A.len-1] 范围内的元素装进大小为 m 的背包的最大收益\npublic int putPack(int m,int[] A,int index) {\n    //index==0 的时候不应该返回=0 代表第一个，是可以装的\n    //对于 m 也是一样，这种边界思考一下 m 就等于 0，或者就只有一个元素，index 就等于 0 这种特例就可以\n    //只要这种特例是正确的那么整个递归就是正确的，并不需要去思考整个递归的结束条件\n    if (index<0 || m<=0) {\n        return 0;\n    }\n    if (cache[index][m]!=-1) {\n        return cache[index][m];\n    }\n    //不装 index 位置的元素\n    int res=putPack(m,A,index-1);\n    if (A[index]<=m) {\n        //说明可以装下 index 位置的元素，所以我们将 index 位置的元素装进去试试看\n        //然后求出剩下的空间还最多能装多少，最后求是装 index 收益大还是不装 index 收益大\n        res=Math.max(res,A[index]+putPack(m-A[index],A,index-1));\n    }\n    cache[index][m]=res;\n    return res;\n}\n```\n\n暴力递归的时间复杂度将会是`O((2^N)*N)`\n\n其实整个递归的思路是很清晰明白的，对于每个元素，有两种情况，这也是之所以称之为 0-1 背包的原因\n\n- 不选的话，背包的容量不变，改变为问题`putPack(m,A,index-1)`\n- 选的话，背包的容量变小，改变为问题`putPack(m-A[index],A,index-1)+A[index]`\n\n到底选还是不选，取决于两种方案哪一种更好，我们要求的，就是这个最好的方案，知道了这样的递推关系后我们就可以很容易的写出递归方程，这里在递归的过程中有可能会产生重叠的子问题（其实这里我还纠结了好一会儿，我一直感觉没有重叠的子问题，后来画一下递归树就明白了，只是重叠的不明显），所以我们可以通过缓存每次计算的结果来进行记忆化递归，整体的时间复杂度应该是`O(2^N)`，空间`O(M*N)`显然不是我们想要的结果\n\n> 这里一开始我是想用`Integer[][]`的数组，然后就不用赋初始值，判断不为 null 就行，结果空间溢出了。lintCode 好严格，换成`int[][]`然后赋个初始值就过了\n\n**解法二**\n\n动态规划解法，在讲解之前，我们用一个二维表来分析下整个递推的过程\n\n物品列表（样例 1），因为这题价值就是重量，所以 w 和 v 是一样的\n\n![mark](http://static.imlgw.top/blog/20200227/XIvS0eAf1FqA.png?imageslim)\n\n**DpTable（样例 1）**\n\n![mark](http://static.imlgw.top/blog/20200227/YkPisR3fx1wa.png?imageslim)\n\n一行一行的看，从左到右，`dp[index][m]`代表 **背包总容量不超过 m 的情况下，考虑装入`[0,index]`中的元素能获得最大收益**，比如`dp[1][7]`代表的就是背包总容量不超过 7 的情况下，考虑装入`[0,1]` 范围内的元素所能获得的最大收益，人脑思考结果自然是 7 了，下面我们分析下如果 dp 推出这个结果\n\n前面我们已经分析过 0-1 背包的递归过程，每个元素面临两个选择，这里也一样\n\n`dp[1][7]`如果我们选择不装入当前 index 位置的元素的话，那么最大收益就是`dp[0][7]=3`这一点应该没啥疑问\n\n如果我们考虑装入当前 index 位置的元素的话，m 肯定会减小，那么所获得的最大收益就应该是`A[index]+dp[0][7-4]=7` \n\n> 注意这里当前 index 的值都是依赖于上一层`index-1`的计算结果的，也就是依赖于上一次`m,[0,index-1]`最大值的结果，所以我们需要手动的初始化第一层的值）\n\n最后我们得到的核心状态方程就是下面这样的\n\n`dp[index][m]=max(dp[index-1][m],A[index]+dp[index-1][j-A[index]])`\n\n然后我们根据这个很容易就可以写出 dp 的解法\n\n```java\n//二维动态规划\npublic int backPack(int m,int[] A) {\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    int[][] dp=new int[A.length][m+1];\n    for (int i=0;i<A.length;i++) {\n        for (int j=0;j<=m;j++) {\n            if (j==0) {//初始化第一列\n                dp[i][j]=0;\n            }else if (i==0) {//初始化第一行\n                dp[i][j]=j-A[i]>=0?A[i]:0;\n            }else if (i>0) {\n                dp[i][j]=j-A[i]>=0?Math.max(dp[i-1][j],dp[i-1][j-A[i]]+A[i]):dp[i-1][j];\n            }\n        }\n    }\n    return dp[A.length-1][m];\n}\n```\n当然我们肯定是不满足于这种二维的 dp 的，所以我们还得优化下空间，这里每一层都只依赖于上一层的结果，所以我么很容易就可以改成一维的，当然这里还有个小坑，如果直接按照上面的代码来改的话就是错的，我们先看看正确的改法\n\n```java\npublic int backPack4(int m,int[] A) {\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[m+1];\n    for (int i=0;i<A.length;i++) {\n        for (int j=m;j>=0;j--) {//从右向左，避免覆盖\n            if (j==0) {//初始化第一列\n                dp[j]=0;\n            }else if (i==0) {//初始化第一行\n                dp[j]= j-A[i]>=0?A[i]:0;\n            }else{\n                dp[j]=j-A[i]>=0?Math.max(dp[j],dp[j-A[i]]+A[i]):dp[j];\n            }\n        }\n    }\n    return dp[m];\n}\n```\n可以看到，我们的内层循环不再是从左往右，而是从右往左，这样的好处就是避免了`dp[j-A[i]]`已经被**当前内层循环前面的元素**覆盖的尴尬情况，结合上面的表推一下就知道了\n\n**解法三**\n\n算是对之前代码的优化吧，之前写的乱七八糟的\n\n```java\n//代码优化\npublic int backPack(int m,int[] A) {\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[m+1];\n    for (int i=0;i<A.length;i++) {\n        for (int j=m;j>=A[i];j--) {\n            dp[j]=Math.max(dp[j],dp[j-A[i]]+A[i]);\n        }\n    }\n    return dp[m];\n}\n```\n## [完全背包问题（acwing）](https://www.acwing.com/problem/content/description/3/) \n\n有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。\n\n第 i 种物品的体积是 vi，价值是 wi。\n\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。\n\n**输入格式**\n\n第一行两个整数，N，V 用空格隔开，分别表示物品种数和背包容积。\n\n接下来有 N 行，每行两个整数 vi,wi 用空格隔开，分别表示第 i 种物品的体积和价值。\n\n**输出格式**\n\n输出一个整数，表示最大价值。\n\n**数据范围**\n\n0<N,V≤10000<N,V≤1000\n0<vi,wi≤10000<vi,wi≤1000\n\n**输入样例**\n\n```java\n4 5\n1 2\n2 4\n3 4\n4 5\n```\n\n**输出样例：**\n\n```java\n10\n```\n\n**解法一**\n\n相比 01 背包交换了内循环的顺序就 ok 了，当然也可以将每个物品拆分，不过复杂度会变高\n\n```java\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int V=sc.nextInt();\n        int[] dp=new int[V+1];\n        for(int i=0;i<N;i++){\n            int vi=sc.nextInt();\n            int wi=sc.nextInt();\n            for(int j=vi;j<=V;j++) {\n                dp[j]=Math.max(dp[j],dp[j-vi]+wi);\n            }\n        }\n        System.out.println(dp[V]);\n    }\n}\n```\n\n其实这个结论要直接理解还是有点难懂的，具体的推导过程可以看下面的 [零钱兑换](#322-零钱兑换)\n\n## [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n**注意：**\n\n1. 每个数组中的元素不会超过 100\n2. 数组的大小不会超过 200\n\n**示例 1:**\n\n```java\n输入：[1, 5, 11, 5]\n\n输出：true\n\n解释：数组可以分割成 [1, 5, 5] 和 [11].\n```\n\n**示例 2:**\n\n```\n输入：[1, 2, 3, 5]\n\n输出：false\n\n解释：数组不能分割成两个元素和相等的子集。\n```\n\n**解法一**\n\n现在递归写起来已经有点感觉了，类似的题基本上都能写出记忆化递归的方法来\n\n```java\n//记忆化递归 37ms 44%, 开始慢是因为 stream 的原因\nBoolean[][] cache=null;\n\npublic boolean canPartition(int[] nums) {\n    if (nums==null || nums.length<=0) return false;\n    //int sum=Arrays.stream(nums).sum();\n    int sum=0;\n    for (int e:nums) sum+=e; //求和\n    cache=new Boolean[nums.length][sum+1];\n    if (sum%2!=0) {\n        return false;\n    }\n    return partition(nums,0,0,sum/2);\n}\n\n//尝试添加 [0,index] 位置的元素，看能否使得 half=sum （这里其实应该直接在 sum 上减，看能不能减为 0)\npublic boolean partition(int[] nums,int index,int half,int sum) {\n    if (index==nums.length) {\n        return false;\n    }\n    if (cache[index][half]!=null) {\n        return cache[index][half];\n    }\n\n    if (half==sum) {\n        return true;\n    }\n    cache[index][half]=partition(nums,index+1,half,sum) || \n        (half<sum&&partition(nums,index+1,half+nums[index],sum));\n    return cache[index][half];\n}\n```\n**解法二**\n\n动态规划，依然是典型的背包问题，可以理解为用 nums 中的元素，填满 sum/2 容量大小的背包，递推公式\n\n `dp[i][j] =dp[i-1][j] || dp[i-1][j-nums[i]]`  选当前元素和不选当前元素，有一个能填满就 ok\n\n`dp[i][j]` 含义为：考虑`[0,i]` 范围内的元素，能否恰好装满 `j`大小的容器\n\n```java\n//二维 dp\npublic boolean canPartition(int[] nums) {\n    if (nums==null || nums.length<=0) return false;\n    //int sum=Arrays.stream(nums).sum(); 用 stream 好慢\n    int sum=0;\n    for (int e:nums) sum+=e; //求和\n    if (sum%2!=0) {\n        return false;\n    }\n    int half=sum/2;\n    //dp[i][j] 的含义是从 [0,i] 中选取元素，能否刚好填满 j\n    boolean[][] dp=new boolean[nums.length][half+1];\n    for (int j=0;j<=half;j++) {\n        dp[0][j]= nums[0]==j;\n    }\n    for (int i=1;i<nums.length;i++) {\n        for (int j=0;j<=half;j++) {\n            dp[i][j]= j>=nums[i]?dp[i-1][j] || dp[i-1][j-nums[i]]:dp[i-1][j];\n        }\n        //如果在某个位置（每行最后一个）已经刚好填满了就直接返回\n        if (dp[i][half]) {\n            return true;\n        }\n    }\n    return dp[nums.length-1][half];\n}\n```\n空间上的优化\n\n```java\npublic boolean canPartition(int[] nums) {\n    if (nums==null || nums.length<=0) return false;\n    int sum=0;\n    for (int e:nums) sum+=e; //求和\n    if (sum%2!=0) {\n        return false;\n    }\n    int half=sum/2;\n    //dp[j] 的含义是从 [0,i] 中选取元素，能否刚好填满 j\n    boolean[] dp=new boolean[half+1];\n    for (int j=0;j<=half;j++) {\n        dp[j]= nums[0]==j;\n    }\n\n    for (int i=1;i<nums.length;i++) {\n        for (int j=half;j>=nums[i];j--) {\n            //dp[i][j]= j>=nums[i]?dp[i-1][j] || dp[i-1][j-nums[i]]:dp[i-1][j];\n            dp[j]=dp[j]||dp[j-nums[i]];\n        }\n        if (dp[half]) {\n            return true;\n        }\n    }\n    return dp[half];\n}\n```\n## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n**示例 1:**\n\n```java\n输入：coins = [1, 2, 5], amount = 11\n输出：3 \n解释：11 = 5 + 5 + 1\n```\n\n**示例 2:**\n\n```java\n输入：coins = [2], amount = 3\n输出：-1\n```\n\n**说明：**\n你可以认为每种硬币的数量是无限的\n\n**解法一**\n\n其实就是 dfs，我最开始就是写的 dfs 只不过时间复杂度太高，没做记忆化，这里其实一开始做了记忆化也一直没跑过，一直超时，最后给的 case 是 6249 好像也不算很大吧，然后我后来把`fill` 填充数组删了，用 Integer 就跑过了。\n\n```java\n//记忆化递归 AC 50%左右\nprivate Integer[] cache=null;\n\npublic int coinChange2(int[] coins,int amount){\n    cache=new Integer[amount+1];\n    //Arrays.fill(cache,-1); 这里 fill 直接 tle 了。\n    return takeCoins(coins,amount);\n}\n\npublic int takeCoins(int[] coins, int amount) {\n    if (amount==0) {\n        return 0;\n    }\n    if (cache[amount]!=null) {\n        return cache[amount];\n    }\n    //int t1=coins(coins,amount,index+1);\n    int res=Integer.MAX_VALUE;\n    for (int i=0;i<coins.length;i++) {\n        if (amount<coins[i]) continue;\n        int sub=takeCoins(coins,amount-coins[i]);\n        if (sub!=-1) {\n            res=Math.min(sub+1,res);\n        }\n    }\n    cache[amount]= res==Integer.MAX_VALUE?-1:res;\n    return cache[amount];\n}\n```\n**解法二**\n\n动态规划，二维 dp，注意这里其实和前面的背包问题就有区别了，这里实际上就是个`无限背包`问题，因为这里的硬币是无限的，每个面值的硬币都可以重复的选取\n\n**DPTable**\n\n![mark](http://static.imlgw.top/blog/20200227/ekmjFAHgA2K4.png?imageslim)\n\n**状态定义**\n\n这里`dp[i][j]` 的含义为：**考虑`[0，i]` 范围内的元素，能凑成 `j` 所需的最少硬币数**，和之前的 01 背包问题状态定义没什么区别\n\n**状态方程**\n\n首先明确一点，这里我们对第`coins[i]`个硬币有两种选择 \n\n1. 不拿 \n2.  拿，拿 1~k 个 (k 为硬币个数的限制，这里没有限制，所以是无穷大）\n\n进而我们可以的到状态转移的方程：\n\n`f[i][j] = min(f[i-1][j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)`\n\n但是这个方程有很多计算是重复的\n\n`f[i][j-c]=min(f[i-1][j-c], f[i-1][j-2*c]+1, ..., f[i-1][j-k*c]+k-1)`\n\n两者合并得到\n\n`f[i][j] = min(f[i-1]f[j], f[i][j-c]+1)`  有了状态方程，代码就好写了\n\n```java\npublic int coinChange4(int[] coins,int amount){\n    int[][] dp=new int[coins.length][amount+1];\n    for (int j=0;j<=amount;j++) {\n        dp[0][j]=j%coins[0]==0?j/coins[0]:Integer.MAX_VALUE;\n    }\n    for (int i=1;i<coins.length;i++) {\n        for (int j=0;j<=amount;j++) {\n            if (j<coins[i] || dp[i][j-coins[i]]==Integer.MAX_VALUE) {\n                //放不下\n                dp[i][j]=dp[i-1][j];\n            }else {\n                dp[i][j]=Math.min(dp[i][j-coins[i]]+1,dp[i-1][j]);\n            }\n        }\n    }\n    return dp[coins.length-1][amount]!=Integer.MAX_VALUE?dp[coins.length-1][amount]:-1;\n}\n```\n\n**空间优化**\n\n将上面的二维改成一维就是像下面一样，注意内层的循环！因为后面是 `f[i][j-c]+1` 所以需要依赖同一层前面的结果，所以必须顺序的遍历\n\n```java\npublic int coinChange(int[] coins,int amount){\n    int[] dp=new int[amount+1];\n    //填充初始值为 Integer.MAX_VALUE, 代表不可达\n    Arrays.fill(dp,Integer.MAX_VALUE);\n    dp[0]=0; //除了 dp[0]\n    for (int i=0;i<coins.length;i++) {\n        //注意这里不能逆序！\n        for (int j=coins[i];j<=amount;j++) {\n            if (dp[j-coins[i]]!=Integer.MAX_VALUE) {\n                dp[j]=Math.min(dp[j-coins[i]]+1,dp[j]);   \n            }\n        }\n    }\n    return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];\n}\n```\n## [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)\n\n给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个\n\n**示例 1:**\n\n```java\n输入：amount = 5, coins = [1, 2, 5]\n输出：4\n解释：有四种方式可以凑成总金额：\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n```\n\n**示例 2:**\n\n```java\n输入：amount = 3, coins = [2]\n输出：0\n解释：只用面额 2 的硬币不能凑成总金额 3。\n```\n\n**示例 3:**\n\n```java\n输入：amount = 10, coins = [10] \n输出：1\n```\n\n**注意：**\n\n你可以假设：\n\n- 0 <= amount （总金额） <= 5000\n- 1 <= coin （硬币面额） <= 5000\n- 硬币种类不超过 500 种\n- 结果符合 32 位符号整数\n\n**解法一**\n\n求方案数，不考虑顺序\n\n```java\npublic int change(int amount, int[] coins) {\n    if (coins==null || coins.length<=0) {\n        return amount==0?1:0;\n    }\n    int[][] dp=new int[coins.length][amount+1];\n    for (int i=0;i<coins.length;i++) {\n        for (int j=0;j<=amount;j++) {\n            if (i==0) {\n                dp[0][j]=j%coins[i]==0?1:0;\n            }else if (j==0) {\n                dp[i][0]=1;\n            }else{\n                  dp[i][j]= j>=coins[i]?dp[i-1][j]+dp[i][j-coins[i]]:dp[i-1][j];\n                //dp[i][j]= j>=coins[i]?dp[i-1][j]+dp[i-1][j-coins[i]]:dp[i-1][j];\n            }\n        }\n    }\n    return dp[coins.length-1][amount];\n}\n```\n**空间优化**\n\n`f(5)=f(4)+f(3)+f(0)` 突然感觉写二维的有点多余。这种子结构要清晰的多\n\n```java\n//直接理解一维 dp 还是不太容易，但是知道递推公式后先写个二维 dp 再改为一维就很容易\npublic int change(int amount, int[] coins) {\n    int[] dp=new int[amount+1];\n    dp[0]=1;\n    //这种方式相当于对 dpTable 从左向右，一行行的递推\n    for (int i=0;i<coins.length;i++) {\n        for (int j=0;j<=amount;j++) {\n            //dp[j]+= dp[j-coins[i]]:0;\n            dp[j]=j-coins[i]>=0?dp[j]+dp[j-coins[i]]:dp[j];\n        }\n    }\n    /* 交换一下内外顺序就变成了另一个问题的解\n    for (int j=0;j<=amount;j++) {\n        for (int i=0;i<coins.length;i++) {\n            dp[j]+= j-coins[i]>=0?dp[j-coins[i]]:0;\n        }\n    }*/\n    return dp[amount];\n}\n```\n**解法二**\n\n记忆化递归，基本上 dp 能过得，记忆化递归一定能过，相比之下，我觉得记忆化递归会好写一些\n\n```java\npublic int change(int amount, int[] coins) {\n    if (coins==null || coins.length<=0) {\n        return amount==0?1:0;\n    }\n    cache=new Integer[coins.length][amount+1];\n    return takeCoins(amount,coins,0);\n}\n\nInteger[][] cache=null;\n\n//[index,coins.length] 中凑成 amount 的方案数，考虑顺序\npublic int takeCoins(int amount,int[] coins,int index){\n    if (index>=coins.length || amount<0) {\n        return 0;\n    }\n    if (cache[index][amount]!=null) {\n        return cache[index][amount];\n    }\n    if (amount==0) {\n        return 1;\n    }\n    return cache[index][amount]=takeCoins(amount-coins[index],coins,index)+takeCoins(amount,coins,index+1);\n}\n```\n## [面试题 08.11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)\n\n硬币。给定数量不限的硬币，币值为 25 分、10 分、5 分和 1 分，编写代码计算 n 分有几种表示法。（结果可能会很大，你需要将结果模上 1000000007)\n\n**解法一**\n\n和上面的一样的，但是这里有一些其他的方法，记录下，元素解法就不写了，和上面的一样\n\n```java\nint mod=1000000007;\n\npublic int waysToChange(int n) {\n    n/=5; //余数没有影响，都用 1 补\n    int[] coins={5,2,1}; //币值也/5\n    long[] dp=new long[n+1];\n    Arrays.fill(dp,1L); //排除 1 分的硬币，所有的面额都可以用 1 分的凑出来\n    for(int i=0;i<coins.length;i++){\n        for(int j=coins[i];j<=n;j++){\n            dp[j]=(dp[j]+dp[j-coins[i]])%mod;\n        }\n    }\n    return (int)(dp[n]%mod);\n}\n```\n\n直接把时间从 114ms 干到了 17ms，其实时间复杂度没变，但是缩小了解空间，所以整体的时间会提高很多，当然这里能缩小的原因主要还是因为题目比较特殊\n\n## [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)\n\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n\n**示例：**\n\n```java\nnums = [1, 2, 3]\ntarget = 4\n\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\n请注意，顺序不同的序列被视作不同的组合。\n\n因此输出为 7。\n```\n\n**进阶：**\n如果给定的数组中含有负数会怎么样？\n问题会产生什么变化？\n我们需要在题目中添加什么限制来允许负数的出现？\n\n**解法一**\n\n记忆化递归，没啥好说的\n\n```java\n//记忆化递归 1ms 100%\npublic int combinationSum4(int[] nums, int target) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    cache=new Integer[target+1];\n    return combination(nums,target);\n}\n\nInteger[] cache=null;\n\npublic int combination(int[] nums,int target){\n    if (cache[target]!=null) {\n        return cache[target];\n    }\n    if (target==0) {\n        return 1;\n    }\n    int res=0;\n    for (int i=0;i<nums.length;i++) {\n        if (target-nums[i]>=0) {\n            res+=combination(nums,target-nums[i]);\n        }\n    }\n    return cache[target]=res;\n}\n```\n**解法二**\n\n动态规划，乍一看好像和上面一题一样，实际上并不一样，这里是考虑顺序的，最优子结构也是\n\n`f(5)=f(4)+f(3)+f(0)` 这样的\n\n```java\n//一维 dp\npublic int combinationSum4(int[] nums,int target){\n    int[] dp=new int[target+1];\n    dp[0]=1;\n    for (int i=0;i<=target;i++) {\n        for (int j=0;j<nums.length;j++) {\n            dp[i]+= i>=nums[j]?dp[i-nums[j]]:0;\n        }\n    }\n    return dp[target];\n}\n```\n\n这里还是要存个疑啊，没搞明白啊，为啥交换个顺序就不一样了呢？一个是按行打表，一个是按列打表？？？还是递归好写。\n\n## [494. 目标和](https://leetcode-cn.com/problems/target-sum/)\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n**示例 1:**\n\n```java\n输入：nums: [1, 1, 1, 1, 1], S: 3\n输出：5\n解释：\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有 5 种方法让最终目标和为 3。\n```\n\n**注意：**\n\n- 数组非空，且长度不会超过 20。\n- 初始的数组的和不会超过 1000。\n- 保证返回的最终结果能被 32 位整数存下\n\n**解法一**\n\n后面的题都优先写记忆化递归了，动态规划确实有点难顶\n\n```java\nInteger[][] cache=null;\n\n//HashMap<Integer,Integer> cache=new HashMap<>\n\npublic int findTargetSumWays(int[] nums, int S) {\n    if (nums==null || nums.length<=0 || S>1000) {\n        return 0;\n    }\n    //\n    int sum=0;\n    for(int n:nums)sum+=n;\n    if(S>sum)return 0;\n    \n    //相当于平移了一下，从 [-sum,sum] --> [0,2*sum]\n    cache=new Integer[nums.length][2*sum+1];\n    return findTarget(nums,S,0,2*sum+1);\n}\n\npublic int findTarget(int[] nums,int S,int index,int max){\n    if (S==0 && index ==nums.length) {\n        return 1;\n    }\n    if (index>=nums.length) {\n        return 0;\n    }\n    if(S <0  && cache[index][S+max]!=null){\n        return cache[index][S+max];\n    }\n    if (S>=0 && cache[index][S]!=null) {\n        return cache[index][S];\n    }\n    int temp=findTarget(nums,S-nums[index],index+1,max)+findTarget(nums,S+nums[index],index+1,max);\n    if (S<0) {\n        cache[index][S+max]=temp;\n    }else{\n        cache[index][S]=temp;\n    }\n    return  temp;\n}\n```\n这题还是挺有意思的，因为里面是有负数的，直接记忆化是不行的，需要转换一下，这里我是直接将 cache 数组扩大，同时保证不会有覆盖，所以直接扩大为 2sum 就 ok，这样整个 S 的范围就从`[-sum,+sum]` 变为 `[0,2sum]` 从而可以缓存所有的递归结果，其实也可以使用两个数组一个存正数，一个存负数，然后只需要符号取反就 ok 了，只不过占用的空间会大一点\n\n**解法二**\n\n正儿八经的 01 背包做法\n\n```java\npublic int findTargetSumWays(int[] nums, int S) {\n    if(nums==null || nums.length<=0) return 0;\n    //nsum 负，psum 正；sum;\n    //sum=psum+nsum;\n    //S=psum-nsum;\n    //(sum+S)/2 = psum\n    int sum=0;\n    for(int i=0;i<nums.length;i++) sum+=nums[i];\n    if((sum+S)%2!=0 || S>sum) return 0;\n    int target=(sum+S)/2;\n    int[] dp=new int[target+1];\n    //Arrays.fill(dp,-1);\n    dp[0]=1;\n    for(int i=0;i<nums.length;i++){\n        for(int j=target;j>=nums[i];j--){\n            dp[j]+=dp[j-nums[i]];\n        }\n    }\n    return dp[target];\n}\n```\n\n## [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n- 如果 `x == y`，那么两块石头都会被完全粉碎；\n- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n\n最后，最多只会剩下一块石头。返回此石头**最小的可能重量**。如果没有石头剩下，就返回 `0`。\n\n**示例：**\n\n```go\n输入：[2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n```\n\n**提示：**\n\n1. `1 <= stones.length <= 30`\n2. `1 <= stones[i] <= 1000`\n\n**解法一**\n\n想了一下，其实就是在所有石头中选取部分石头，求这部分的石头和大于`sum/2`的最小值（和正常的背包思路反着来的）\n\n```java\n//   sum   = psum + nsum\n//  target = psum - nsum  (psum >= nsum)\n//  sum+target = 2*psum\n//  target = 2*psum-sum\n//  2*psum-sum>=0\n//记忆化递归\nInteger[][] dp=null;\n\npublic int lastStoneWeightII(int[] stones) {\n    int sum=0;\n    for (int i=0;i<stones.length;i++) {\n        sum+=stones[i];\n    }\n    dp=new Integer[stones.length+1][sum];\n    return 2*dfs(stones,0,0,sum)-sum;\n}\n\npublic int dfs(int[] stones,int index,int psum,int sum){\n    if(2*psum>=sum){\n        return psum;\n    }\n    if(dp[index][psum]!=null){\n        return dp[index][psum];\n    }\n    int min=Integer.MAX_VALUE;\n    for (int i=index;i<stones.length;i++) {\n        min=Math.min(dfs(stones,i+1,psum+stones[i],sum),min);\n    }\n    return dp[index][psum]=min;\n}\n```\n当我按照这个思路 i 写出来后发现不好改递推了😂，这个思路确实有一点点怪\n\n**解法二**\n\n正常的 01 背包解法，其实把上面的结论反过来就行了，既然要求一个大于等于`sum/2`的最小值，其实就是求一个小于等于`sum/2` 的最大值，这样一说就很清楚了，经典的 01 背包\n\n```java\npublic int lastStoneWeightII(int[] stones) {\n    if(stones==null ||stones.length<=0){\n        return 0;\n    }\n    int n=stones.length;\n    int sum=0;\n    for(int i=0;i<n;i++){\n        sum+=stones[i];\n    }\n    //背包容量为 sum/2, 求最多能装多少，经典的 01 背包\n    int amount=sum/2;\n    int[] dp=new int[amount+1];\n    for (int i=0;i<stones.length;i++) {\n        for (int j=amount;j>=stones[i];j--) {\n            dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);\n        }\n    }\n    //wrong: return (amount-dp[amount])*2;\n    //return sum%2==0?(amount-dp[amount])*2:(amount-dp[amount])*2+1\n    //nsum=dp[amount]\n    //target=psum-nsum = sum-nusm-nsum\n    return sum-2*dp[amount];\n}\n```\n这里的 retrun 有两种写法，推荐第二种，第一种还要判奇偶\n\n> 拿到这题的的第一个解法其实是贪心，每次消除两个最大的，用优先队列维护石头大小\n>\n> 天真的错误解法 74 / 82 个通过测试用例\n> [21,26,31,33,40] ->[7,21,26,31] -> [5,7,21] -> [5,14] ->[9]\n> [21,26,31,33,40] ->[19,26,31,33]->[5]\n>\n> 这个思路其实是 这题的弱化版本 [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/) 的解法\n\n## [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n在计算机界中，我们总是追求用有限的资源获取最大的收益。\n\n现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。\n\n你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。\n\n**注意：**\n\n- 给定 0 和 1 的数量都不会超过 100。\n- 给定字符串数组的长度不会超过 600。\n\n**示例 1:**\n\n```java\n输入：Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3\n输出：4\n\n解释：总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 \"10\",\"0001\",\"1\",\"0\" 。\n```\n\n**示例 2:**\n\n```java\n输入：Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\n输出：2\n\n解释：你可以拼出 \"10\"，但之后就没有剩余数字了。更好的选择是拼出 \"0\" 和 \"1\" 。\n```\n\n**解法一**\n\n之前只用 Java 写了个记忆化的，补一下纯 dp 的\n```golang\n//之前只用 Java 写了个记忆化的，补一下纯 dp 的\nfunc findMaxForm(strs []string, m int, n int) int {\n    var sn = len(strs)\n    var dp = make([][]int, m+1)\n    var Max = func(a, b int) int {if a>b {return a};return b}\n    for i := 0; i <= m; i++ {\n        dp[i] = make([]int, n+1)\n    }\n    for i := 0; i < sn; i++ {\n        zero, one := count(strs[i])\n        for j := m; j >= zero; j-- {\n            for k := n; k >= one; k-- {\n                dp[j][k] = Max(dp[j][k], dp[j-zero][k-one]+1)\n            }\n        }\n    }\n    return dp[m][n]\n}\n\nfunc count(str string) (int, int) {\n    var one, zero = 0, 0\n    for i := 0; i < len(str); i++ {\n        if str[i] == '0' {\n            zero++\n        }\n        if str[i] == '1' {\n            one++\n        }\n    }\n    return zero, one\n}\n```\n\n**解法二**\n\n其实这是一个多重背包问题，一个物品有多个权值\n\n```java\nInteger [][][] cache=null;\n\npublic int findMaxForm(String[] strs, int m, int n) {\n    cache=new Integer[m+1][n+1][strs.length];\n    return findMax(strs,m,n,0);\n}\n\n//m:0 n:1\npublic int findMax(String[] strs, int m, int n,int index) {\n    if (index>=strs.length) {\n        return 0;\n    }\n    if (cache[m][n][index]!=null) {\n        return cache[m][n][index];\n    }\n    int[] oz=count(strs[index]);\n    if (oz[1]<=n && oz[0]<=m) {\n        return cache[m][n][index]=Math.max(1+findMax(strs,m-oz[0],n-oz[1],index+1),findMax(strs,m,n,index+1));\n    }\n    return cache[m][n][index]=findMax(strs,m,n,index+1);\n}\n\npublic int[] count(String str){\n    int one=0,zero=0;\n    char[] s=str.toCharArray();\n    for (char c:s) {\n        if (c=='1') {\n            one++;\n        }else{\n            zero++;\n        }\n    }\n    return new int[]{zero,one};\n}\n```\n\n## [1255. 得分最高的单词集合](https://leetcode-cn.com/problems/maximum-score-words-formed-by-letters/)\n\n你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。\n\n请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。\n\n单词拼写游戏的规则概述如下：\n\n- 玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。\n- 可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。\n- 单词表 words 中每个单词只能计分（使用）一次。\n- 根据字母得分情况表 score，字母 'a', 'b', 'c', ... , 'z' 对应的得分分别为 score[0], score[1], ..., score[25]。\n- 本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和\n\n**示例 1：**\n\n```java\n输入：words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\n输出：23\n解释：\n字母得分为  a=1, c=9, d=5, g=3, o=2\n使用给定的字母表 letters，我们可以拼写单词 \"dad\" (5+1+5) 和 \"good\" (3+2+2+5)，得分为 23 。\n而单词 \"dad\" 和 \"dog\" 只能得到 21 分。\n```\n\n**示例 2：**\n\n```java\n输入：words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\n输出：27\n解释：\n字母得分为  a=4, b=4, c=4, x=5, z=10\n使用给定的字母表 letters，我们可以组成单词 \"ax\" (4+5)， \"bx\" (4+5) 和 \"cx\" (4+5) ，总得分为 27 。\n单词 \"xxxz\" 的得分仅为 25 。\n```\n\n**示例 3：**\n\n```java\n输入：words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\n输出：0\n解释：\n字母 \"e\" 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。\n```\n\n**提示：**\n\n- `1 <= words.length <= 14`\n- `1 <= words[i].length <= 15`\n- `1 <= letters.length <= 100`\n- `letters[i].length == 1`\n- `score.length == 26`\n- `0 <= score[i] <= 10`\n- `words[i] 和 letters[i] `只包含小写的英文字母\n\n**解法一**\n\n看着题目就知道这题不简单😂，11.10 的周赛最后一题，1ms，用 01 背包的思路做的，很多地方其实还没处理好\n\n```java\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\n    int[] les=new int[26];\n    for (int i=0;i<letters.length;i++) {\n        les[letters[i]-'a']++;\n    }\n    return maxScoreWords(words,letters,score,0,les);\n}\n\npublic int maxScoreWords(String[] words, char[] letters, int[] score,int index,int[] les) {\n    if (index==words.length) {\n        return 0;\n    }\n    int res=maxScoreWords(words,letters,score,index+1,les);\n    String word=words[index];\n    if (hasWord(les,word)) {\n        int[] bak=new int[les.length];\n        System.arraycopy(les,0,bak,0,les.length);\n        res=Math.max(res,getScore(bak,word,score)+maxScoreWords(words,letters,score,index+1,bak));\n    }\n    return res;\n}\n\npublic boolean hasWord(int[] les,String word){\n    int[] bak=new int[les.length];\n    System.arraycopy(les,0,bak,0,les.length);\n    int count=0;\n    for(char c:word.toCharArray()){\n        if (bak[c-'a']!=0) {\n            bak[c-'a']--;\n            count++;\n        }\n    }\n    return count==word.length();\n}   \n\npublic int getScore(int[] les,String word,int[] score){\n    int sc=0;\n    for (char c:word.toCharArray()) {\n        les[c-'a']--;\n        sc+=score[c-'a'];\n    }\n    return sc;\n}\n```\n\n## [HUD4501. 小明系列故事——买年货（HUDOJ）](http://acm.hdu.edu.cn/showproblem.php?pid=4501)\n\n**Problem Description**\n\n春节将至，小明要去超市购置年货，于是小明去了自己经常去的都尚超市。\n\n刚到超市，小明就发现超市门口聚集一堆人。用白云女士的话说就是：“那家伙，那场面，真是人山人海，锣鼓喧天，鞭炮齐呤，红旗招展。那可真是相当的壮观啊！”。好奇的小明走过去，奋力挤过人群，发现超市门口贴了一张通知，内容如下\n\n值此新春佳节来临之际，为了回馈广大顾客的支持和厚爱，特举行春节大酬宾、优惠大放送活动。凡是都尚会员都可用会员积分兑换商品，凡是都尚会员都可**免费拿 k 件商品**，凡是购物顾客均有好礼相送。满 100 元送 bla bla bla bla，满 200 元送 bla bla bla bla bla...blablabla....\n\n还没看完通知，小明就高兴的要死，因为他就是都尚的会员啊。迫不及待的小明在超市逛了一圈发现超市里有** n 件他想要的商品**。小明顺便对这 n 件商品打了分，表示商品的实际价值。小明发现身上带了** v1 的人民币**，会员卡里面有** v2 的积分**。他想知道他最多能买多大价值的商品。\n\n由于小明想要的商品实在太多了，他算了半天头都疼了也没算出来，所以请你这位聪明的程序员来帮帮他吧。\n \n\n**Input**\n```go\n输入包含多组测试用例。\n每组数据的第一行是四个整数 n，v1，v2，k；\n然后是 n 行，每行三个整数 a，b，val，分别表示每个商品的价钱，兑换所需积分，实际价值。\n[Technical Specification]\n1 <= n <= 100\n0 <= v1, v2 <= 100\n0 <= k <= 5\n0 <= a, b, val <= 100\n\nPs. 只要钱或者积分满足购买一件商品的要求，那么就可以买下这件商品。\n```\n\n**Output**\n```go\n对于每组数据，输出能买的最大价值。\n详细信息见 Sample。\n```\n**Sample Input**\n\n```go\n5 1 6 1\n4 3 3\n0 3 2\n2 3 3\n3 3 2\n1 0 2\n4 2 5 0\n0 1 0\n4 4 1\n3 3 4\n3 4 4\n```\n\n**Sample Output**\n\n```go\n12\n4\n```\nSource\n2013 腾讯编程马拉松初赛第〇场（3 月 20 日）\n\n**解法一**\n\n三维费用的背包，但是和前面的 [474. 一和零](#474-一和零)还有点不一样，三个维度的费用是无关的，而 1 和 0 中 1 的个数和 0 的个数是相关的\n> 代码使用了 Petr 的输入模板，自己改进了下，增加了输入结束判断，所以看起来特别长\n```java\nimport java.util.*;\nimport java.io.*;// petr 的输入模板\nimport java.math.*; // 不是大数题可以不要这个\n\npublic class Solve_HDOJ_4501 {\n\n    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) throws Exception{\n        InputReader in = new InputReader(System.in);\n        //InputReader in = new InputReader(new FileInputStream(\"./input.txt\"));\n        while(!in.EOF()) {\n            int n = in.nextInt();\n            int v1 = in.nextInt();\n            int v2 = in.nextInt();\n            int k = in.nextInt();\n            int[][] cost = new int[n][3];\n            for (int i = 0; i < n; i++) {\n                cost[i][0] = in.nextInt();\n                cost[i][1] = in.nextInt();\n                cost[i][2] = in.nextInt();\n            }\n            solve(n, v1, v2, k, cost);\n        }\n        //别忘了 flush\n        out.flush();\n        out.close();\n    }\n\n    //因为数据量不大，就直接 Scanner 了\n    public static void solve(int n, int v1, int v2, int k, int[][] cost) {\n        int[][][] dp = new int[k+1][v1+1][v2+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= 0; j--) {\n                for (int u = v1; u >= 0; u--) {\n                    for (int w = v2; w >= 0; w--) {\n                        //这里不能直接 u>=cost[i][0] w >= cost[i][1]，因为积分和钱和免费拿是分开的，没有关联的\n                        //即使我不能免费拿，但是我能用积分拿，即使不能用积分拿，我可以用钱买\n                        //dp[j][u][w] = Math.max(dp[j][u][w], dp[j-1][u-cost[i][0]][w-cost[i][1]] + cost[i][2]);\n                        int ans = 0;\n                        if (j >= 1) { //免费拿\n                            ans = Math.max(ans, dp[j-1][u][w] + cost[i][2]);\n                        }\n                        if (u >= cost[i][0]) { //钱\n                            ans = Math.max(ans, dp[j][u-cost[i][0]][w] + cost[i][2]);\n                        }\n                        if (w >= cost[i][1]) { //积分\n                            ans = Math.max(ans, dp[j][u][w-cost[i][1]] + cost[i][2]);\n                        }\n                        dp[j][u][w] = Math.max(ans, dp[j][u][w]);\n                    }\n                }\n            }\n        }\n        out.println(dp[k][v1][v2]);\n    }\n}\n\nclass InputReader {\n\n    public BufferedReader reader;\n    \n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        //char[32768]\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    //默认以\" \"作为分隔符，读一个\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    //有的题目不给有多少组测试用例，只能一直读，读到结尾，需要自己判断结束\n    //该函数也会读取一行，并初始化 tokenizer，后序直接 nextInt.. 等就可以读到该行\n    public boolean EOF() {\n        String str = null;\n        try {\n            str = reader.readLine();\n            if (str == null) {\n                return true;\n            }\n            //创建 tokenizer\n            tokenizer = new StringTokenizer(str);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }\n\n    int nextInt(){\n        return Integer.parseInt(next());\n    }\n    \n    long nextLong(){\n        return Long.parseLong(next());\n    }\n    \n    double nextDouble(){\n        return Double.parseDouble(next());\n    }\n    \n    BigInteger nextBigInteger(){\n        return new BigInteger(next());\n    }\n\n    BigDecimal nextBigDecimal(){\n        return new BigDecimal(next());\n    }\n}\n```","tags":["LeetCode","背包"],"categories":["算法"]},{"title":"Map 映射结构","url":"/2019/11/25/96f168ad/","content":"\n## Map 接口\n\n```java\npublic interface Map<K,V>{\n    void put(K key,V value);\n    V remove(K key);\n    boolean contains(K key);\n    V get(K key);\n    void set(K key,V newValue);\n    int getSize();\n    boolean isEmpty();\n}\n```\n\n## LinkedListMap\n\n```java\npublic class LinkedListMap<K,V> implements Map<K,V>{\n    \n    private class Node{\n        public K key;\n        public V value;\n        public Node next;\n\n        public Node(K key,V value,Node next){\n            this.key=key;\n            this.value=value;\n            this.next=next;\n        }\n\n        public Node(K key){\n            this(key,null,null);\n        }\n\n        public Node(){\n            this(null,null,null);\n        }\n\n        @Override\n        public String toString(){\n            return key.toString()+\" : \"+value.toString();\n        }\n    }\n\n    private Node dummyNode;\n\n    private int size;\n\n    public LinkedListMap(){\n        dummyNode=new Node();\n        size=0;\n    }\n\n    @Override\n    public int getSize(){\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty(){\n        return size==0;\n    }\n\n    private Node getNode(K key){\n        Node cur=dummyNode.next;\n        while(cur!=null){\n            if (cur.key.equals(key)) {\n                return cur;\n            }\n            cur=cur.next;\n        }\n        return null;\n    }\n\n    @Override\n    public boolean contains(K key){\n        return getNode(key)==null;\n    }\n\n    @Override\n    public V get(K key){\n        Node node=getNode(key);\n        return node==null?null:node.value;\n    }\n\n    @Override\n    public void put(K key,V value){\n        Node node = getNode(key);\n        if(node==null){\n            dummyNode.next=new Node(key,value,dummyNode.next);\n            size++;\n        }else{\n            node.value=value;\n        }\n    }\n\n    @Override\n    public void set(K key,V value){\n        Node node = getNode(key);\n        if(contains(key)){\n            node.value=value;\n        }else{\n            throw new IllegalArgumentException(key +\" doesn't exist!\");\n        }\n    }\n\n    @Override\n    public V remove(K key){\n        Node prev=dummyNode;\n        while(prev.next!=null){\n            if (prev.next.key.equals(key)) {\n                break;\n            }\n            prev=prev.next;\n        }\n        if (prev.next==null) {\n            //其实可以和上面一样抛一个异常\n            return null;\n        }\n        Node deleNode=prev.next;\n        prev.next=deleNode.next;\n        deleNode.next=null;\n        size--;\n        return deleNode.value;\n    }\n}\n```\n\n## BSTMap\n\n```java\npublic class BSTMap<K extends Comparable,V> implements Map<K,V>{\n\n    private class Node{\n        public K key;\n        public V value;\n        public Node left;\n        public Node right;\n        public Node(K key,V value){\n            this.key=key;\n            this.value=value;\n            left=null;\n            right=null;\n        }\n    }  \n\n    public Node root;\n\n    private int size;\n\n    public BSTMap(){\n        root=null;\n        size=0;\n    }\n\n    public int getSize(){\n        return size;\n    }\n\n    public boolean isEmpty(){\n        return size==0;\n    }\n\n    public void put(K key,V value){\n        root=put(root,key,value);\n    }\n\n    //add 元素后返回新的根节点\n    private Node put(Node node,K key,V value){\n        if (node == null) {\n            size++;\n            return new Node(key,value);\n        }\n        if(key.compareTo(node.key) < 0){\n            node.left=put(node.left, key,value);\n        }else if (key.compareTo(node.key) > 0) {\n            node.right=put(node.right, key,value);   \n        }else{\n            //相等的情况\n            node.value=value;\n        }\n        return node;\n    }\n\n    private Node getNode(Node node,K key){\n        if (node==null) {\n            return null;\n        }\n        int temp=node.key.compareTo(key);\n        if (temp==0) {\n            return node;\n        }\n        if (temp>0) { //node.key > key\n            return getNode(node.left,key);\n        }\n        return getNode(node.right,key);\n    }\n\n    public boolean contains(K key){\n        return getNode(root,key)!=null;\n    }\n\n    public V get(K key){\n        Node node=getNode(root,key);\n        return node==null?null:node.value;\n    }\n\n    public void set(K key,V newValue){\n        Node node=getNode(root,key);\n        if (node!=null) {\n            node.value=newValue;\n            return;\n        }\n        throw new IllegalArgumentException(key+ \" doesn't exist\");\n    }\n\n    private Node getMin(Node root){\n        if (root.left==null) {\n            return root;\n        }\n        return getMin(root.left);\n    }\n\n    private Node deleteMin(Node node){\n        if (node.left==null) {\n            return node.right;\n        }\n        node.left=deleteMin(node.left);\n        return node;\n    }\n\n    public V remove(K key){\n        Node node=getNode(root,key);\n        if (node==null) {\n            return null;\n        }\n        root=remove(node,key);\n        size--;\n        return node.value;\n    }\n\n    public Node remove(Node root,K key){\n        if (key.compareTo(root.key)>0) { //key > root\n            root.right=remove(root.right,key);\n        }else if (key.compareTo(root.key)<0) {\n            root.left=remove(root.left,key);\n        }else{\n            if (root.left==null) {\n                return root.right;\n            }\n            if (root.right==null) {\n                return root.left;\n            }\n            Node deleNode=root;\n            root=getMin(root.right);\n            root.right=deleteMin(deleNode.right);\n            root.left=deleNode.left;\n        }\n        return root;\n    }\n}\n```\n\n## MapTest\n\n```java\npublic class MapTest{\n    public static void main(String[] args) {\n        Map<Integer,Integer> map=new BSTMap<>();\n        map.put(1,2);\n        map.put(2,2);\n        map.put(3,2);\n        map.put(4,2);\n        map.put(5,2);\n        map.put(6,2);\n        map.put(7,2);\n        map.put(8,2);\n        map.put(9,32131);\n        map.put(11,2);\n        System.out.println(map.contains(13)); //false\n        System.out.println(map.getSize()); //10\n        System.out.println(map.get(9)); //32131\n        map.remove(9);\n        System.out.println(map.get(9)); //null\n        System.out.println(map.getSize()); //10\n        map.set(11,1234567);\n        System.out.println(map.get(11)); //1234567\n    }\n}\n```\n\n## HashMap\n\n```java\nimport java.util.TreeMap;\n\npublic class HashTable<K,V>{\n    private TreeMap<K,V>[] hashtable;\n    private int M;\n    private int size;\n\n    private static final int upperTol=10;\n    private static final int lowerTol=2;\n    private static final int initCapacity=7;\n\n    public HashTable(int M){\n        this.M=M;\n        size=0;\n        hashtable=new TreeMap[M];\n        for (int i=0;i<M;i++) {\n            hashtable[i]=new TreeMap<>();\n        }\n    }\n\n    public HashTable(){\n        this(initCapacity);\n    }\n\n    private int hash(K key){\n        return key.hashCode() & 0x7fffffff %M;\n    }\n\n    private int getSize(){\n        return size;\n    }\n\n    public void add(K key,V value){\n        TreeMap<K,V> map=hashtable[hash(key)];\n        if(map.containsKey(key)){\n            map.put(key,value);\n        }else{\n            map.put(key,value);\n            size++;\n            //扩容\n            // size/M >=upperTol\n            if (size>=upperTol*M) {\n                resize(2*M);\n            }\n        }\n    }\n\n    public V remove(K key){\n        TreeMap<K,V> map=hashtable[hash(key)];\n        V ret=null;\n        if(map.containsKey(key)){\n            ret=map.remove(key);\n            size--;\n            if (size<lowerTol*M && M/2 >= initCapacity) {\n                resize(M/2);\n            }\n        }\n        return ret;\n    }\n\n    public void resize(int size){\n        TreeMap<K,V> newHashTable=new TreeMap[size];\n        for (int i=0;i<size;i++) {\n            newHashTable[i]=new TreeMap<>();\n        }\n        int oldSize=M;\n        this.M=size; //要先将 M 设置好，不然 hash 的值不对\n        for (int i=0;i<oldSize;i++) {\n            TreeMap<K,V> map=hashtable[i];\n            for (K key:map.keySet()) {\n                newHashTable[hash(key)].put(key,map.get(key));\n            }\n        }\n        this.hashtable=newHashTable;\n    }\n\n    public void set(K key,V value){\n        TreeMap<K,V> map=hashtable[hash(key)];\n        if(!map.containsKey(key)){\n            throw new IllegalArgumentException(\"key not exist!\");\n        }\n        map.put(key,value);\n    }\n\n    public boolean contains(K key){\n        return hashtable[hash(key)].containsKey(key);\n    }\n\n    public V get(K key){\n        return hashtable[hash(key)].get(key);\n    }\n}\n```\n\n## 源码地址\n\n[Github](https://github.com/imlgw/LeetCode/tree/master/tree/map)\n","tags":["数据结构","映射"],"categories":["数据结构"]},{"title":"LRU 队列实现","url":"/2019/11/16/c0884f64/","content":"\n## [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\n运用你所掌握的数据结构，设计和实现一个  LRU （最近最少使用） 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n\n获取数据 `get(key)` - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。\n写入数据 `put(key, value)` - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。\n\n**进阶：**\n\n你是否可以在 `O(1)` 时间复杂度内完成这两种操作？\n\n**示例：**\n\n```java\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得密钥 2 作废\ncache.get(2);       // 返回 -1 （未找到）\ncache.put(4, 4);    // 该操作会使得密钥 1 作废\ncache.get(1);       // 返回 -1 （未找到）\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n```\n\n**解法一**\n\n改了好几次才改对，核心思路就是利用 HashMap+双向链表\n\n```java\npublic class LRUCache {\n\n    class Node{\n        int key;\n        int value;\n        Node pre;\n        Node next;\n        public Node(int key,int value){\n            this.value=value;\n            this.key=key;\n        }\n    }\n\n    HashMap<Integer,Node> map=new HashMap<>();\n\n    Node head=null;\n\n    Node tail=null;\n\n    int capacity=0;\n\n    public LRUCache(int capacity) {\n        this.capacity=capacity;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node node=map.get(key);\n            //移动到链表头\n            move2Head(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        Node newHead=new Node(key,value);\n        if (map.containsKey(key)) {\n            Node node=map.get(key);\n            node.value=value;\n            //移动到链表头\n            move2Head(node);\n            return;\n        }\n        if (map.size()==capacity) {\n            map.remove(tail.key);\n            removeNode(tail);\n        }\n        move2Head(newHead);\n        map.put(key,newHead);\n    }\n\n    public void removeNode(Node node){\n        if (node.key==tail.key) {\n            tail=tail.pre;\n            return;\n        }\n        if (node.pre==null || node.next==null) {\n            return;\n        }\n        node.pre.next=node.next;\n        node.next.pre=node.pre;\n    }\n\n    public void move2Head(Node newHead){\n        if (map.size()==0) {\n            head=tail=newHead;\n            return;\n        }\n        if (newHead.key==head.key) {\n            return;\n        }\n        removeNode(newHead);\n        newHead.next=head;\n        newHead.pre=null;\n        head.pre=newHead;\n        head=newHead;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n既然已经实现了，我们就来考虑下为啥要这样实现\n\n其实我一开始也不知道咋实现，查了下才知道，这里有几个点需要注意：\n\n1. 首先是题目要求 get/put 时间复杂度是`O(1)` 的，而我们在 get/put 的时候肯定会频繁的移动元素的位置，那我们肯定是不能用数组，队列之类的结构了\n\n2. 那我们能用单链表么？我们可以将最近访问的节点放在头部，然后每次满的时候剔除尾节点的元素，由于是链表，移动节点的位置都是很容易的，但是我们如果要 get 一个元素的时候就麻烦了，需要遍历整个链表才能取到元素，也就是说单链表定位某个元素比较耗时，所以我们考虑用 HashMap 来辅助单链表，这样我们以 key 为 map 的 key，Node 节点为 map 的 value 就可以迅速定位到某个元素\n\n3. 单链表+HashMap 就可以了么？其实还差点儿，如果现在满了，需要删除最后一个节点，那我们就需要将 tail 的前一个作为新的 tail，但是由于是单链表，没有前置指针，不方便定位前一个节点，所以我们最后的方案就是采用**双向链表+HashMap **来实现 LRU\n\n   ![img](https://pic4.zhimg.com/80/v2-09f037608b1b2de70b52d1312ef3b307_hd.jpg)\n\n其实 LRU 思想并不复杂，按照规则来移动节点，删除节点就 OK，操作系统教程上也有类似的过程图，理解了下面的图代码就好写了\n\n![mark](http://static.imlgw.top/blog/20191116/BISfMVdI96FT.png?imageslim)\n\n但是如果实现的方式不太好的话，就会写很多 if-else 判断一些边界，比如我上面自己的实现就是。\n\n其实还有一个原因就是我上面的方式 head 和 tail 是真实的节点，不是虚节点，所以会有很多边界的逻辑判断，面试的时候不建议那样写，很容易出问题！！！\n\n**解法二**\n\n面试中比较推荐像这样写\n\n```java\npublic class LRUCache {\n\n    class Node{\n        int key;\n        int value;\n        Node pre;\n        Node next;\n        public Node(int key,int value){\n            this.value=value;\n            this.key=key;\n        }\n    }\n\t\n    HashMap<Integer,Node> map=new HashMap<>();\n\n    Node head=null;\n\n    Node tail=null;\n\n    int capacity=0;\n\n    public LRUCache(int capacity) {\n        this.capacity=capacity;\n        //初始化头尾节点，注意这两个节点只是个哨兵节点，并不会存入 map 中\n        head=new Node(-1,-1);\n        tail=new Node(-1,-1);\n        head.next=tail;\n        tail.pre=head;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node node=map.get(key);\n            //移动到链表头\n            move2Head(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        Node newHead=new Node(key,value);\n        if (map.containsKey(key)) {\n            Node node=map.get(key);\n            //设置节点值为新 value\n            node.value=value;\n            //移动到链表头\n            move2Head(node);\n            return;\n        }\n        //满了，先剔除 tail 再插入\n        if (map.size()==capacity) {\n            map.remove(popTail().key);\n        }\n        addFirst(newHead);\n        map.put(key,newHead);\n    }\n\n    //弹出 tail\n    private Node popTail(){\n        Node newTail=tail.pre;\n        removeNode(newTail);\n        return newTail;\n    }\n\n    //移除节点\n    private void removeNode(Node node){\n        node.pre.next=node.next;\n        node.next.pre=node.pre;\n    }\n\n    //从头添加\n    private void addFirst(Node node){\n        node.next=head.next;\n        head.next.pre=node;\n        head.next=node;\n        node.pre=head;\n    }\n\n    //移动节点到 head\n    private void move2Head(Node node){\n        //删除原链表中对应位置的 node\n        removeNode(node);\n        //从头再添加一遍\n        addFirst(node);\n    }\n}\n```\n\n像这样写，就不用考虑那么多边界，写那么多的 if 和 else，预先开辟两个节点的作为哨兵节点，这样代码就显得清晰简洁，也不容易出问题\n\n[参考](https://zhuanlan.zhihu.com/p/34133067)\n\n## UPDATE\n随便重写了下\n\n```java\nclass LRUCache {\n    \n    HashMap<Integer, Node> map = null;\n        \n    int capacity = 0;\n    \n    Node head = null;\n    \n    Node tail = null;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        Node node = map.get(key);\n        if (node == null) {\n            return -1;\n        }\n        removeNode(node);\n        insert2head(node);\n        return node.val;\n    }\n    \n    public void put(int key, int value) {\n        Node node = map.get(key);\n        if (node == null) {\n            node = new Node(key, value);\n            insert2head(node);\n            map.put(key, node);\n        } else {\n            removeNode(node);\n            node.val = value;\n            insert2head(node);\n        }\n        if (map.size() > capacity) {\n            map.remove(tail.prev.key);\n            removeNode(tail.prev);\n        }\n    }\n    \n    public void insert2head(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    //移除 Node 节点\n    public void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        node.next = null;\n        node.prev = null;\n    }\n    \n    class Node {\n        Node prev, next;\n        int key, val;\n        public Node (int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\nGolang\n\n```golang\ntype LRUCache struct {\n    capacity int\n    cache map[int]*Node\n    head *Node\n    tail *Node\n}\n\ntype Node struct {\n    prev *Node\n    next *Node\n    key int\n    val int\n}\n\nfunc Constructor(capacity int) LRUCache {\n    head := &Node{key : -1, val : -1}\n    tail := &Node{key : -1, val : -1}\n    head.next = tail\n    tail.next = head\n    return LRUCache{\n        capacity : capacity,\n        cache : make(map[int]*Node),\n        head : head,\n        tail : tail,\n    }\n}\n\nfunc (this *LRUCache) Get(key int) int {\n    if v, ok := this.cache[key]; ok {\n        this.removeNode(v)\n        this.insert2Head(v)\n        return v.val\n    }\n    return -1\n}\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    if v, ok := this.cache[key]; ok {\n        this.removeNode(v)\n        v.val = value\n        this.insert2Head(v)\n    } else {\n        newNode := &Node{key : key, val : value}\n        this.cache[key] = newNode\n        this.insert2Head(newNode)\n    }\n    if len(this.cache) > this.capacity {\n        delete(this.cache, this.tail.prev.key)\n        this.removeNode(this.tail.prev)\n    }\n}\n\nfunc (this *LRUCache) removeNode (node *Node) {\n    node.next.prev = node.prev\n    node.prev.next = node.next\n    node.prev = nil\n    node.next = nil\n}\n\nfunc (this *LRUCache) insert2Head (node *Node) {\n    node.prev = this.head\n    node.next = this.head.next\n    this.head.next.prev = node\n    this.head.next = node\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n```","tags":["LeetCode","LRU"],"categories":["算法"]},{"title":"Redis 思维导图","url":"/2019/11/16/eed9fc2a/","content":"\n## 原始 Xmind 文件\n\n[Redis 思维导图](http://static.imlgw.top/Redis.xmind)\n\n![Redis](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/Redis.png)\n","tags":["Redis"],"categories":["Web"]},{"title":"二分搜索树","url":"/2019/11/08/a49b5008/","content":"\n## 二分搜索树\n\n**二叉查找树**（英语：Binary Search Tree），也称为**二分搜索树**，**二叉搜索树**、**有序二叉树**（ordered binary tree）或**排序二叉树**（sorted binary tree）也可以简写为 `BST`，是指一棵空树或者具有下列性质的 [二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)：\n\n1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n3. 任意节点的左、右子树也分别为二叉查找树；\n4. 没有键值相等的节点。\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的 [时间复杂度](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6) 较低。为` O(logN) `。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合，映射等\n\n## 基本结构\n\n先搭一个基本的架子出来，后面再来慢慢的完善功能\n\n```java\npublic class BST<E extends Comparable<E>>{\n    //TreeNode\n    private class Node{\n        public E e;\n        public Node left;\n        public Node right;\n        public Node(E e){\n            this.e=e;\n            left=null;\n            right=null;\n        }\n    }\n\n    private Node root;\n\n    private int size;\n\n    public BST(){\n        root=null;\n        size=0;\n    }\n\n    public int size(){\n        return size;\n    }\n\n    public boolean isEmpty(){\n        return size==0;\n    }\n\n    public void add(E e){\n        //...\n    }\n\n    public boolean contains(E e){\n        //...\n    }\n}\n```\n\n## 添加\n\n添加函数，时间复杂度`O(logN)`，只要抓住了它的性质就很好写，画个图描述下这个过程\n\n![mark](http://static.imlgw.top/blog/20191113/P39b50Ikv4sV.png?imageslim)\n\n① 首先和 root 节点 8 比较，比 8 小，所以肯定再 8 的左子树中\n\n② 再和 root 的左子树根节点 5 比较，比 5 大，所以最后肯定插入 5 的右子树中\n\n③ 再和 5 节点的右子树根节点 6 比较，比 6 大，所以最后插入 6 的右子树中\n\n④ 右子树为空，直接插入到 6 的右边\n\n根据上面的流程我们很容易写出代码\n\n```java\npublic void addLoop(E e){\n    if (root==null) {\n        size++;\n        root=new Node(e);\n        return;\n    }\n    Node temp=root;\n    while(temp!=null){\n        if (e.compareTo(temp.e)>0) {\n            if (temp.right==null) {\n                temp.right=new Node(e);\n                size++;\n                return;\n            }\n            temp=temp.right;\n        }else if (e.compareTo(temp.e)<0) {\n            if (temp.left==null) {\n                temp.left=new Node(e);\n                size++;\n                return;\n            }\n            temp=temp.left;\n        }else return; //不能有相等元素\n    }\n}\n```\n这里既然是树结构，用循环似乎有的显得不够优雅😂\n\n所以我们尝试把这个改成递归\n\n```java\npublic void add2(E e){\n    if(root == null){\n        root = new Node(e);\n        size ++;\n    }else add(root, e);\n}\n\n// 向以 node 为根的二分搜索树中插入元素 e, 略显繁琐\nprivate void add2(Node node, E e){\n    if(e.equals(node.e)) return;\n    if(e.compareTo(node.e) < 0 && node.left == null){\n        node.left = new Node(e);\n        size ++;\n        return;\n    }\n    if(e.compareTo(node.e) > 0 && node.right == null){\n        node.right = new Node(e);\n        size ++;\n        return;\n    }\n    if(e.compareTo(node.e) < 0)\n        add(node.left, e);\n    else //e.compareTo(node.e) > 0\n    \tadd(node.right, e);\n}\n```\n这个递归？？？咋感觉比循环还繁琐🙄 \n\n确实，上面这个递归的终止条件太繁琐了，`compareTo`一共比较了 4 次，有很多重复代码，所以我们还得改改😋\n\n我们让这个`add`函数有返回值，返回插入后的根节点，这样我们的函数 `add(Node node,E e)` 定义就变成了 **插入元素`e`到 以 `node` 为根节点的 BST 中，并且返回根节点** ，清楚了递归函数的定义，我们再来写方法就会容易很多\n\n```java\npublic void add(E e){\n    root=add(root,e);\n}\n\n//插入元素`e`到 以 `node` 为根节点的 BST 中，并且返回根节点\nprivate Node add(Node node, E e){\n    if (node == null) {\n        size++;\n        return new Node(e);\n    }\n    if(e.compareTo(node.e) < 0){\n        //插入左子树中，并返回根节点，然后接在 node.left\n        node.left=add(node.left, e);\n    }else if (e.compareTo(node.e) > 0) { //注意不要写 else, 前面没有对相等的元素做判断\n        //插入右子树中，并返回根节点，然后接在 node.right\n        node.right=add(node.right, e);   \n    }\n    return node;\n}\n```\n还是那句话，写递归函数，不要纠结于函数的每一步是如何去进行，如何去得到结果的，从全局出发，只要搞清楚递归函数的定义，按照函数的定义来写代码，最后思考一下边界，最后的代码就一定是正确的！\n\n这个边界的思考，其实也很简单，就比如上面的这个结束条件，我们不用去考虑一步步直到递归终结时是什么情况，我们思考一下极端的边界情况（其实这就是终结的情况），root 为 null，还没有初始化，BST 还是空的，这个时候 add 元素，其实想都不用想，肯定是直接把这个 e 作为根节点返回就 ok 了，所以很自然的就写出了终止条件\n\n## 查找\n\n查找相比于上面的添加，会简单很多，可以很容易的写出代码\n\n```java\n//查询操作\npublic boolean contains(E e){\n    if (e==null) {\n        return false;\n    }\n    return contains(e,root);\n}\n\nprivate boolean contains(E e,Node root){\n    if (root==null) {\n        return false;\n    }\n    if (e.compareTo(root.e)==0) {\n        return true;\n    }\n    return e.compareTo(root.e)<0?contains(e,root.left):contains(e,root.right);\n}\n```\n这里我为了简洁写了三目，不熟悉的可以改成 if，整体时间复杂度依然是`O(logN)` ，比线性表的查找会快很多！\n\n## 遍历\n\n老生常谈的话题，这个在我之前的 [LeetCode-二叉树](http://imlgw.top/2019/11/06/leetcode-er-cha-shu-di-gui/) 里面也做过了，这里再翻出来看看，其实重点是想把后序遍历给搞清楚了，之前一直挺迷糊的\n\n### 前序遍历\n\n#### 递归写法\n\n```java\n//前序遍历，递归\npublic void preorderTravelRecur(){\n    preorderTravel(root);\n}\n\nprivate void preorderTravel(Node root){\n    if (root==null) {\n        return;\n    }\n    System.out.print(root.e+\" \");\n    preorderTravel(root.left);\n    preorderTravel(root.right);\n}\n```\n#### 非递归写法\n\n```java\n//前序遍历，非递归实现\npublic void preorderTravelNoRecur(){\n    Stack<Node> stack=new Stack<>();\n    Node cur=root;\n    while( cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            System.out.print(cur.e+\" \");\n            stack.push(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        cur=cur.right;\n    }\n}\n```\n注意这里并不是经典的前序遍历方式，是按照 “模板” 来的，首先我们考虑栈里面存的是什么，这里的栈里面存的实际上是 `左子树的左边` 的集合，这里我不知道咋描述，画个图吧\n\n![mark](http://static.imlgw.top/blog/20191113/BF0cCcWcy3zP.png?imageslim)\n\n图中绿色部分就是我所说的**左子树的左边的集合**，整个栈的入栈顺序就是从左往右，从上到下，依次的将这些“左边” 入栈，并且在没有左子树，也就是遍历到叶子节点的时候开始出栈，然后切换成`当前出栈的节点`的右子树，将右子树的`左子树的左边`重复前面的过程继续入栈出栈，我们要考虑的就是在什么时候访问节点！\n\n细心的同学肯定已经发现了，其实这里进栈顺序和出栈顺序，分别对应的就是这颗树前序遍历和中序遍历！！！所以我们就只需要在进栈和出栈的时候，进行访问节点的操作，就可以完成前序和后序遍历\n\n### 中序遍历\n\n#### 递归写法\n\n```java\n//中序遍历，递归\npublic void inorderTravelRecur(){\n    inorderTravel(root);\n}\n\nprivate void inorderTravel(Node root){\n    if (root==null) {\n        return;\n    }\n    inorderTravel(root.left);\n    System.out.print(root.e+\" \");\n    inorderTravel(root.right);\n}\n```\n#### 非递归写法\n\n结合上面的分析，我们也可以很容易的得出非递归的中序遍历的写法\n\n```java\n//中序遍历，非递归\npublic void inorderTravelNoRecur(){\n    Stack<Node> stack=new Stack<>();\n    Node cur=root;\n    while( cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            stack.push(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        System.out.print(cur.e+\" \");\n        cur=cur.right;\n    }\n}\n```\n### 后序遍历\n\n#### 递归写法\n\n```java\n//后序遍历，递归\npublic void postorderTravelRecur(){\n    postorderTravel(root);\n}\n\nprivate void postorderTravel(Node root){\n    if (root==null) {\n        return;\n    }\n    postorderTravel(root.left);\n    postorderTravel(root.right);\n    System.out.print(root.e+\" \");\n}\n```\n#### 非递归写法\n\n这里的非递归写法就不一样了，比前两种要复杂\n\n```java\n//后序遍历，非递归\npublic void postorderTravelNoRecur(){\n    Stack<Node> stack=new Stack<>();\n    Node cur=root,lastNode=null;\n    while(cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            stack.push(cur);\n            cur=cur.left;\n        }\n        cur=stack.peek();//查看栈顶元素\n        //如果右子树为空或者右节点已经访问过，则当前节点出栈，并记录 lastNode\n        if (cur.right==null || lastNode==cur.right) { \n            System.out.print(cur.e+\" \");\n            stack.pop();\n            lastNode=cur;\n            //为了下一次能直接查看栈顶元素\n            //cur 的使命其实已经结束了，cur 和它的孩子都已经访问了，下一次直接从栈顶取，不然就死循环了\n            cur=null; \n        }else{\n            cur=cur.right;\n        }\n    }\n}\n```\n![mark](http://static.imlgw.top/blog/20191113/zM80igBy0RDX.png?imageslim)\n\n其实不管是什么遍历，对于这个模板来说，**栈的轨迹都是一样的**，只不过访问节点的时机有所不同，蓝色线条代表审查的顺序，红色辅助的代表出栈部分，右边对应的就是遍历过程中栈的变化，和对应结果的变化，对照这个图再分析下就很清楚了。\n\n如果觉得实在是不好理解也可以换用下面的方式\n\n```java\npublic void postorderTravelNoRecur2() {\n    Stack<Node> stack=new Stack<>();\n    stack.push(root);\n    Node lastNode=null;\n    while(!stack.isEmpty()){\n        //取栈顶元素\n        Node cur=stack.peek();\n        //左右子树都为空，或者上一个访问的节点是当前节点的子节点就输出该节点\n        if ( (cur.left==null && cur.right ==null) || \n             (lastNode!=null &&(cur.left==lastNode || cur.right==lastNode))){\n            stack.pop();\n            System.out.print(cur.e+\" \");\n            lastNode=cur;\n        }else{\n            if (cur.right!=null) {\n                stack.push(cur.right);\n            } if (cur.left!=null) {\n                stack.push(cur.left);\n            }  \n        } \n    }\n}\n```\n这种方式相比上面就好理解多了，左右子树都为空，或者上一个访问的节点是当前节点的子节点，就可以输出该节点了，注意添加的时候是逆序添加的，这样就可以保证先访问左节点，再访问右节点，最后访问根节点\n\n### 层次遍历\n\n#### 递归写法\n\n```java\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> res = new ArrayList<>();\n    helper(res, root, 0);\n    return res;\n}\n\nprivate void helper(List<List<Integer>> res, TreeNode root, int depth) {\n    if (root == null) return;\n    //需要增加一层\n    if (res.size() == depth) res.add(new LinkedList<>());\n    res.get(depth).add(root.val);\n    helper(res, root.left, depth + 1);\n    helper(res, root.right, depth + 1);\n}\n```\n\n#### 非递归写法\n\n经典的 BFS\n\n```java\n//层次遍历\npublic void levelorderTravel(){\n    Queue<Node> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        while(count>0){\n            Node node=queue.poll();\n            System.out.print(node.e+\" \");\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n    }\n}\n```\n\n> 其实关于前中后序的遍历方式，还有很多，我这里主要记录的是` 模板 `的思路，其实还有一种很🐂🍺的做法，模拟系统栈的方式，具体可以参考我之前的  [LeetCode 二叉树](http://imlgw.top/2019/11/06/leetcode-er-cha-shu-di-gui/#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86) 这里就不多解释了\n\n## 取整\n\n### 向下取整（floor）\n\n```java\npublic E floor(E e){\n    Node node=floor(root,e);\n    return node!=null?node.e:null;\n}\n\npublic Node floor(Node root,E e){\n    if (root==null) {\n        return null;\n    }\n    int temp=e.compareTo(root.e);\n    if (temp==0) {\n        return root;\n    }\n    if (temp<0) { //root.e > e, 求小于 e 的值，一定在左边\n        return floor(root.left,e);\n    }\n    //tmep>0 e>root.e\n    Node node=floor(root.right,e);\n    return node!=null?node:root;\n}\n```\n### 向上取整（ceiling）\n\n```java\npublic E ceiling(E e){\n    Node node=ceiling(root,e);\n    return node!=null?node.e:null;\n}\n\npublic Node ceiling(Node root,E e){\n    if (root==null) {\n        return null;\n    }\n    int temp=e.compareTo(root.e);\n    if (temp==0) {\n        return root;\n    }\n    if (temp>0) { //root.e<e, 求的是最后大于 root.e 的元素，一定在右边\n        return ceiling(root.right,e);\n    }\n    //tmep<0 e<root.e\n    Node node=ceiling(root.left,e);\n    return node!=null?node:root;\n}\n```\n这两个函数还是挺有用的，比如这个题 [220-存在重复元素-III ](http://imlgw.top/2019/09/15/leetcode-cha-zhao/#220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III) 通过率只有 25%的 mid 题。\n\n## 获取第 K 大\n\n获取第 k 大（从 0 开始）的元素，如果左子树节点数小于`k`，则第 k 大的元素肯定在右子树，同时我们可以直接排除`size(left)+1` 个元素（加上根节点） 。\n\n然后直接在 右子树中继续搜索 `getKth(root.right,k-size(left)-1)`  ，只有当左子树刚好 k 个元素的时候，根节点就是我们要找的`Kth`\n\n```java\npublic E getKth(int k){\n    if (k>=size || k<0) {\n        return null;\n    }\n    return getKth(root,k).e;\n}\n\npublic Node getKth(Node root,int k){\n    if (root==null) {\n        return root;\n    }\n    int temp = childSize(root.left);\n    if (temp>k) {\n        return getKth(root.left,k);\n    }\n    if (temp<k) {\n        return getKth(root.right,k-temp-1);\n    }\n    return root;\n}\n```\n> 这里其实我的实现是有问题的，我的时间复杂度是`O(NlogN)`！！！！主要是`childSize()`时间复杂度是 O(N) 不是 O(1)，在《算法 4》中这个实现的时间复杂度就是 O(1)，书上在定义的 Node 的时候给 Node 加了一个 count 属性，用来记录每个节点的子节点数（包括自己），在每次 add 和 delete 的时候动态的维护这个 count，这样最后求子节点数的操作时间复杂度就是 O(1) 的了，那个版本的我也实现了一下，但是我没有在这篇文章中这样写（主要是懒得改），而且这也不是重点，感兴趣可以去看看 [BSTWithCount](https://github.com/imlgw/LeetCode/blob/master/tree/BSTWithCount.java) 主要就是要**注意操作 count 的时机**\n>\n这里既然没有 count 数组，那么其实就不应该这样求，应该直接中序遍历，求第 K 大，时间复杂度 O(N)\n\n## Rank()\n\n其实是上面的逆过程，如果根节点等于 key，那么直接返回左子树的键总数；如果 key 小于根节点，就继续去左子树中递归找，如果大于根节点，返回`size(left)+1`加上它在右子树中的`rank()`\n\n```java\npublic int getRank(E e){\n    return getRank(root,e);\n}\n\npublic int getRank(Node root,E e){\n    if (e.compareTo(root.e)<0) { //e<root.e\n        return getRank(root.left,e);\n    }\n    if (e.compareTo(root.e)>0) {\n        return getRank(root.right,e)+childSize(root.left)+1;\n    }\n    return childSize(root.left);\n}\n```\n## Max&Min\n\n没啥好说的\n\n```java\n//求最大值，递归比较优雅\npublic E getMax(){\n    return getMax(root).e;\n}\n\npublic Node getMax(Node root){\n    if (root.right==null) {\n        return root;\n    }\n    return getMax(root.right);\n}\n\n//求最小值\npublic E getMin(){\n    return getMin(root).e;\n}\n\npublic Node getMin(Node root){\n    if (root.left==null) {\n        return root;\n    }\n    return getMin(root.left);\n}\n```\n## 删除\n\n删除应该来说是 BST 中里面比较复杂的一个操作了，我们先从简单的开始\n\n### 删除最值\n\n```java\n//删除最小的键\npublic void deleteMin(){\n    root=deleteMin(root);\n}\n//删除 node 为头节点的树中的最小值，并返回头节点\nprivate Node deleteMin(Node node){\n    if (node.left==null) {\n        return node.right;\n    }\n    node.left=deleteMin(node.left);\n    return node;\n}\n\n//删除最大的键\npublic void deleteMax(){\n    root=deleteMax(root);\n}\n\nprivate Node deleteMax(Node node){\n    if (node.right==null) {\n        return node.left;\n    }\n    node.right=deleteMax(node.right);\n    return node;\n}\n```\n递归函数定义为**删除 node 为头节点的树中的最小值，并返回头节点**，删除最小值实际上就是删除二叉树最左边的节点，所以我们递归的删除 node.left 就 ok，当 node.left 为空的时候返回 node.right，这样前面节点的 left 就接在了 node.right 上，就达到了删除的作用\n\n### 删除任意值\n\n```java\n//删除任意的键\npublic void delete(E e){\n    root=delete(root,e);\n}\n\n//删除以 node 为首的 BST 中，值为 e 的节点并且返回根节点\nprivate Node delete(Node node,E e){\n    if (node==null) {\n        return null;\n    }\n    if (e.compareTo(node.e)>0) { //e>root.e\n        node.right=delete(node.right,e);\n    }else if (e.compareTo(node.e)<0) {\n        node.left=delete(node.left,e);\n    }else{ //e==root.e\n        if (node.left==null) { //如果没有左子树就返回右子树\n            return node.right;\n        }\n        if (node.right==null) { //如果没有右子树就返回左子树\n            return node.left;\n        }\n        Node delNode=node;\n        //有左右子节点都有\n        node=getMin(node.right); //用右子树的最小值填补删除的元素的空位\n        //删除对应的右子树的最小值，然后连接起来\n        node.right=deleteMin(delNode.right);\n        node.left=delNode.left;\n    }\n    return node;\n}\n```\n这里文字的描述比较无力，画个图就清晰明白了，核心的思想就是利用右子树中的最小值填补待删除节点\n\n![mark](http://static.imlgw.top/blog/20191113/yyI0q2yftm0X.png?imageslim)\n\n当然这里其实也是有坑的，主要就是连最后两句\n\n```java\n//删除对应的右子树的最小值，然后连接起来\nnode.right=deleteMin(delNode.right);\nnode.left=delNode.left;\n```\n这里的两句话是不能交换的，如果我们交换了两句话的位置，那么我们下一步删除最小值就会出现问题，我们希望的是删除右子树中最小的 node 节点，结果你先把待删除节点的 left 接到了 node 的左边，这样的话 node 就不再是 delNode.right 中的最小值，最后结果可能就会成这个样子，成了一个闭环！！！\n\n![mark](http://static.imlgw.top/blog/20191113/qc5kHljj03uq.png?imageslim)\n\n所以最后的结果肯定是不对的，其实这一点书上并没有提到，我也是在做这道题 [删除节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/) 的时候写反了，才发现这个问题，感兴趣可以去试试\n\n> 其实这样的删除时一种很随机的做法，虽然能正确的删除元素，但是并没有考虑树的对称性，关于树的对称性，我们后面再来研究\n\n## 代码地址\n\n[BST.java](https://github.com/imlgw/LeetCode/blob/master/tree/BST.java)\n\n[BSTTest.java](https://github.com/imlgw/LeetCode/blob/master/tree/BSTTest.java)\n\n[BSTWithCount.java](https://github.com/imlgw/LeetCode/blob/master/tree/BSTWithCount.java)\n","tags":["数据结构","树"],"categories":["数据结构"]},{"title":"LeetCode 二叉树","url":"/2019/11/06/43c532c9/","content":"\n## _LeetCode 二叉树_\n\n> 善用** ctrl+f**\n\n## [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n\nGiven a binary tree, return the *preorder* traversal of its nodes' values.\n\n**Example:**\n\n```java\nInput: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput: [1,2,3]\n```\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n**解法一**\n\n递归，没啥好说的\n\n```java\nprivate List<Integer> res=new ArrayList<>();\n\npublic List<Integer> preorderTraversal(TreeNode root) {\n    if(root!=null){\n        res.add(root.val);\n        preorderTraversal(root.left);\n        preorderTraversal(root.right);\n    }\n    return res;\n}\n```\n**解法二**\n\n教科书上的写法，经典的前序遍历非递归实现方式\n\n```java\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    stack.push(root);\n    while(!stack.isEmpty()){\n        TreeNode top=stack.pop();\n        res.add(top.val);\n        //注意顺序\n        if (top.right!=null) {\n            stack.push(top.right);\n        }\n        if (top.left!=null) {\n            stack.push(top.left);\n        }\n    }\n    return res;\n}\n```\n**解法三**\n\n非递归，模拟递归栈的方式，记录节点以及是否需要继续寻找子节点\n\n```java\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<Command> stack=new Stack<>();\n    stack.push(new Command(true,root));\n    while(!stack.isEmpty()){\n        Command command=stack.pop();\n        if (!command.isGo) {\n            res.add(command.node.val);\n        }else{\n            TreeNode node=command.node;\n            //逆序进栈\n            if (node.right!=null) {\n                stack.push(new Command(true,node.right));\n            }\n            if (node.left!=null) {\n                stack.push(new Command(true,node.left));\n            }    \n            stack.push(new Command(false,node));\n        }\n    }\n    return res;\n}\n\nstatic class Command{\n    boolean  isGo; //是否继续寻找子节点\n    TreeNode node; //当前节点\n    public Command(boolean isGo,TreeNode node){\n        this.isGo=isGo;\n        this.node=node;\n    }\n}\n```\nbobo 老师的一种思路，可以说是相当妙了👏，一下就解决了三种遍历的非递归实现，另外两种只需要调整一下进栈的顺序就可以了！\n\n**解法四**\n\n找到一个板子，可以很好的解决三种遍历\n\n```java\n//经典的非递归实现方式\npublic List<Integer> preorderTraversal4(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    while(cur!=null||!stack.isEmpty()){\n        while (cur!=null) {\n            res.add(cur.val);\n            stack.push(cur);\n            cur=cur.left;\n        }\n        //没有左子树了\n        cur=stack.pop();\n        //切换为右子树\n        cur=cur.right;\n        \n    }\n    return res;\n}\n```\n> 关于 `while(cur!=null||!stack.isEmpty())`，其实栈中存的只是某一个根节点的所有左子树，并不是所有的节点，所以栈为空不代表已经遍历完所有节点了，只能代表当前节点的左子树都遍历完了，还有右子树还没遍历，只有当右子树也为空也就是`cur==null` 的时候才是遍历完了，具体看一下下面这颗树就明白了\n>\n> ```java\n>       5\n>      / \\\n>     4    6 \n>   /      \\\n> 3       8\n> ```\n>\n> \n\n## [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)\n\n给定一个 N 叉树，返回其节点值的*前序遍历*。\n\n例如，给定一个 `3 叉树` :\n\n![MWwEt0.png](https://s2.ax1x.com/2019/11/20/MWwEt0.png)\n\n返回其前序遍历：`[1,3,5,6,2,4]`。\n\n**说明：** 递归法很简单，你可以使用迭代法完成此题吗？\n\n**解法一**\n\n递归没啥好说的\n\n```java\n//递归的方式\nList<Integer> res=new LinkedList<>();\n\npublic List<Integer> preorder(Node root) {\n    dfs(root);\n    return res;\n}\n\npublic void dfs(Node root) {\n    if (root==null) {\n        return;\n    }\n    List<Node> children=root.children;\n    res.add(root.val);\n    for (Node node:children) {\n        preorder(node);\n    }\n}\n```\n**解法二**\n\n迭代的方式\n\n```java\npublic List<Integer> preorder(Node root) {\n    List<Integer> res=new LinkedList<>();\n    if (root==null) {\n        return res;\n    }\n    Stack<Node> stack=new Stack<>();\n    stack.add(root);\n    while(!stack.isEmpty()){\n        Node node=stack.pop();\n        res.add(node.val);\n        List<Node> children=node.children;\n        //逆序添加\n        for (int i=children.size()-1;i>=0;i--) {\n            stack.add(children.get(i));\n        }\n    }\n    return res;\n}\n```\n到这里我是真的对遍历的那个板子无感了，这里我开始想用板子写，结果发现并不好写，无从下手（可能是我太菜），所以采用了经典的前序遍历方式，果然经典就是经典，通用性很强，而且相当好理解，所以以后遇到遍历的题目，尽量还是自己写，别套板子（对后序的板子也一直不是特别理解，所以也一直没记住，套板子还是要建立在理解的基础上啊，不然永远不会做！）\n\n## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\nGiven a binary tree, return the *inorder* traversal of its nodes' values.\n\n**Example:**\n\n```java\nInput: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput: [1,3,2]\n```\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n**解法一**\n\n递归的方式和模拟栈的方式就不记录了，重点看一下这个板子\n\n```java\n//经典的非递归实现方式\npublic List<Integer> inorderTraversal3(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    while(cur!=null||!stack.isEmpty()){\n        while (cur!=null) {\n            stack.push(cur);\n            cur=cur.left;\n        }\n        //没有左子树了\n        cur=stack.pop();\n        //将当前节点添加到 res 中\n        res.add(cur.val);\n        //切换为右子树\n        cur=cur.right;\n    }\n    return res;\n}\n```\n## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n\nGiven a binary tree, return the *postorder* traversal of its nodes' values.\n\n**Example:**\n\n```java\nInput: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput: [3,2,1]\n```\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n**解法一**\n\n这题是个 hard 题，没那么容易（不过根据 bobo 老师的方式来做确实简单😂）\n\n```java\npublic List<Integer> postorderTraversal3(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root,lastNode=null; //lastNode 为上一次访问的节点\n    while(cur!=null||!stack.isEmpty()){\n        while (cur!=null) {\n            stack.push(cur);\n            cur=cur.left;\n        }\n        //没有左子树了，把后一个左节点拿出来\n        cur=stack.peek();\n        //如果没有右节点，或者右节点访问过了\n        if (cur.right==null||cur.right==lastNode) {\n            //添加节点\n            res.add(cur.val);\n            //记录当前节点为 lastNode\n            lastNode=cur;\n            //将他 pop 出去\n            stack.pop();\n            //节点已经弹出\n            //指向 null, 不然就死循环了\n            cur=null;\n        }else{\n            //右节点不为空，并且没访问过\n            //切换为右子树，重复上面的步骤\n            cur=cur.right;\n        }\n        \n    }\n    return res;\n}\n```\n这种题一定要记住 \"招式\"，乱写只会越写越乱\n\n**解法二**\n\n这种解法似乎更加容易理解！！！\n\n```java\npublic List<Integer> postorderTraversals(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    stack.push(root);\n    TreeNode lastNode=null;\n    while(!stack.isEmpty()){\n        TreeNode cur=stack.peek();\n        if ((cur.left==null && cur.right ==null) || (lastNode!=null &&( cur.left==lastNode || cur.right==lastNode))) {\n            stack.pop();\n            res.add(cur.val);\n            lastNode=cur;\n        }else{\n            if (cur.right!=null) {\n                stack.push(cur.right);\n            }\n            if (cur.left!=null) {\n                stack.push(cur.left);\n            }\n        }\n    }\n    return res;\n}\n```\n## [590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n\n给定一个 N 叉树，返回其节点值的*后序遍历*。\n\n例如，给定一个 `3 叉树` :\n\n![NTree](https://i.loli.net/2019/12/01/KAQP9UNfV5bau7J.png)\n\n返回其后序遍历：`[5,6,3,2,4,1]`.\n\n**说明：** 递归法很简单，你可以使用迭代法完成此题吗？\n\n**解法一**\n\n递归的解法，没啥好说的\n\n```java\nList<Integer> res=new LinkedList<>();\n\npublic List<Integer> postorder(Node root) {\n    if (root==null) {\n        return res;\n    }\n    dfs(root);\n    return res;\n}\n\npublic void dfs(Node root) {\n    List<Node> children=root.children;\n    for (Node node:children) {\n        dfs(node);\n    }\n    res.add(root.val);\n}\n```\n\n**解法二**\n\n锁了！这才是树遍历的板子\n\n```java\npublic List<Integer> postorder(Node root) {\n    List<Integer> res=new LinkedList<>();\n    if (root==null) {\n        return res;\n    }\n    Stack<Node> stack=new Stack<>();\n    stack.push(root);\n    Node lastNode=null;\n    while(!stack.isEmpty()){\n        Node node=stack.peek();\n        List<Node> children=node.children;\n        if (children.isEmpty() || (lastNode!=null && lastNode == children.get(children.size()-1))) {\n            res.add(node.val);\n            stack.pop();\n            lastNode=node;\n        }else{\n            for (int i=children.size()-1;i>=0;i--) {\n                stack.push(children.get(i));\n            }\n        }\n    }\n    return res;\n}\n```\n\n这题开始因为一个空的 case 把我搞晕了，搞了半天才发现\n\n## [102. 二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n\nGiven a binary tree, return the *level order* traversal of its nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\nreturn its level order traversal as:\n\n```java\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\n**解法一**\n\nBFS，利用队列\n\n```java\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> res=new ArrayList<>();\n    if (root==null)return res;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        //count 代表的其实就是每一层的节点个数\n        int count=queue.size();\n        List<Integer> list=new ArrayList<>();\n        while(count>0){\n            //取出当前节点，并将其左右子节点入队列\n            TreeNode node=queue.poll();\n            list.add(node.val);\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n        res.add(list);\n    }\n    return res;\n}\n```\n\n**解法二**\n\n递归 DFS，这种其实还是挺有意思的，可以看下\n\n```java\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> res = new ArrayList<>();\n    helper(res, root, 0);\n    return res;\n}\n\nprivate void helper(List<List<Integer>> res, TreeNode root, int depth) {\n    if (root == null) return;\n    //需要增加一层\n    if (res.size() == depth) res.add(new LinkedList<>());\n    res.get(depth).add(root.val);\n    helper(res, root.left, depth + 1);\n    helper(res, root.right, depth + 1);\n}\n```\n## [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)\n\n给定一个 N 叉树，返回其节点值的*层序遍历*。 （即从左到右，逐层遍历）。\n\n例如，给定一个 `3 叉树` :\n\n![NTee](https://i.loli.net/2019/12/01/He8KVlms1jynbvr.png)\n\n返回其层序遍历：\n\n```java\n[\n     [1],\n     [3,2,4],\n     [5,6]\n]\n```\n\n**说明：**\n\n1. 树的深度不会超过 `1000`。\n2. 树的节点总数不会超过 `5000`。\n\n**解法一**\n\n```java\npublic List<List<Integer>> levelOrder(Node root) {\n    List<List<Integer>> res=new LinkedList<>();\n    if (root==null) {\n        return res;\n    }\n    Queue<Node> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        List<Integer> temp=new LinkedList<>();\n        while(count>0){\n            Node node=queue.poll();\n            temp.add(node.val);\n            for (Node child:node.children) {\n                queue.add(child);\n            }\n            count--;\n        }\n        if (!temp.isEmpty()) {\n            res.add(temp);   \n        }\n    }\n    return res;\n}\n```\n## [107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)\n\nGiven a binary tree, return the *bottom-up level order* traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n\nFor example:\nGiven binary tree `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\nreturn its bottom-up level order traversal as:\n\n```java\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n```\n\n**解法一**\n\n```java\npublic List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> res=new ArrayList<>();\n    if(root==null)return res;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        List<Integer> list=new ArrayList<>();\n        int count=queue.size();\n        while(count>0){\n            TreeNode top=queue.poll();\n            if (top.left!=null) {\n                queue.add(top.left);\n            }\n            if (top.right!=null) {\n                queue.add(top.right);\n            }\n            list.add(top.val);\n            count--;\n        }\n        //从头添加\n        res.add(0,list);\n    }\n    return res;\n}\n```\n主要是复习下层次遍历，相比上面就多了 `res.add(0,list)` 从头部添加\n\n## [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)\n\nGiven a binary tree, return the *zigzag level order* traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n\nFor example:\nGiven binary tree `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\nreturn its zigzag level order traversal as:\n\n```java\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n```\n\n**解法一**\n\n```java\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    List<List<Integer>> res=new ArrayList<>();\n    if(root==null)return res;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    boolean reverse=false;\n    while(!queue.isEmpty()){\n        LinkedList<Integer> list=new LinkedList<>();\n        int count=queue.size();\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (reverse) {\n                //从头添加，相当于逆序了\n                list.addFirst(node.val);\n            }else{\n                list.add(node.val);\n            }\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n        reverse=!reverse;\n        res.add(list);\n    }\n    return res;\n}\n```\n和上面一题一样，老想着怎么去按照题目的要求去遍历节点，哎，太蠢了，灵活一点啊\n\n## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)\n\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n**示例：**\n\n```java\n输入：[1,2,3,null,5,null,4]\n输出：[1, 3, 4]\n解释：\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n```\n\n**解法一**\n\n还是和上面一样，一上午做了三道一样的题，这题吸取了上面的教训没有去想怎么遍历了\n\n```java\npublic List<Integer> rightSideView(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if(root==null) return res;\n    LinkedList<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            //取每一层最后一个节点\n            if (count==1) {\n                res.add(node.val);\n            }\n            count--;\n        }\n    }\n    return  res;\n}\n```\n只记录每一层最后一个节点，最后得到的就是右视图\n\n**解法二**\n\ndfs，其实就是一直向右走，走不动就向左走，这样遍历的轨迹就是沿着二叉树的右边缘向下的，我们只需要记录层数，然后当层数和 res 数量相等的时候记录结果就行了（看见头条面试要求写 logN 空间的，应该就是这种解法了，但是下面的解法空间复杂度应该还是 O(N) 的，最坏情况下形成一链表就成 N 了，不过相比上面层次遍历永远是 N 的做法还是要好一点）\n\n```go\nfunc rightSideView(root *TreeNode) []int {\n    var dfs func(root *TreeNode, depth int)\n    var res = make([]int, 0)\n    dfs = func(root *TreeNode, depth int) {\n        if root == nil {\n            return\n        }\n        if depth > len(res) {\n            res = append(res, root.Val)\n        }\n        dfs(root.Right, depth+1)\n        dfs(root.Left, depth+1)\n    }\n    dfs(root, 1)\n    return res\n}\n```\n\n## [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/) \n\n给定一个非空二叉树，返回一个由每层节点平均值组成的数组。\n\n**示例 1:**\n\n```java\n输入：\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出：[3, 14.5, 11]\n解释：\n第 0 层的平均值是 3,  第 1 层是 14.5, 第 2 层是 11. 因此返回 [3, 14.5, 11].\n```\n\n**注意：**\n\n1. 节点值的范围在 32 位有符号整数范围内。\n\n**解法一**\n\n一百遍啊一百遍，这应该属于树类型题的 HelloWorld 吧 ~ \n\n```java\npublic List<Double> averageOfLevels(TreeNode root) {\n    if (root==null) {\n        return new LinkedList<>();\n    }\n    Queue<TreeNode> queue=new LinkedList<>();\n    List<Double> res=new ArrayList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        int size=queue.size();\n        int temp=size;\n        double average=0;\n        while(size-->0){\n            TreeNode cur=queue.poll();\n            average+=cur.val;\n            if (cur.left!=null) {\n                queue.add(cur.left);\n            }\n            if (cur.right!=null) {\n                queue.add(cur.right);\n            }\n        }\n        average/=temp;\n        res.add(average);\n    }\n    return res;\n}\n```\n## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明：** 叶子节点是指没有子节点的节点。\n\n**示例：**\n给定二叉树 [3,9,20,null,null,15,7]\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回它的最大深度 3 。\n\n**解法一**\n\n递归解法，很简洁\n\n```java\n//maxDepth(root)=1+max(maxDepth(root.left),maxDepth(root.right));\npublic int maxDepth(TreeNode root) {\n    if(root==null){\n        return 0;\n    }\n    int maxLeft=maxDepth(root.left);\n    int maxRight=maxDepth(root.right);\n    return (maxLeft>maxRight?maxLeft:maxRight)+1;\n}\n```\n**解法二**\n\nBFS，广度优先搜索\n\n```java\npublic int maxDepth(TreeNode root) {\n    if (root==null) return 0;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    int max=0;//注意初始值\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n        max++;\n    }\n    return max;\n}\n```\n## [559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)\n\n给定一个 N 叉树，找到其最大深度。\n\n最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\n\n例如，给定一个 `3 叉树` :\n\n![3 叉树](https://s2.ax1x.com/2019/11/20/MWwEt0.png)\n\n我们应返回其最大深度，3。\n\n**说明：**\n\n1. 树的深度不会超过 `1000`。\n2. 树的节点总不会超过 `5000`。\n\n**解法一**\n\n没啥好说的\n\n```java\npublic int maxDepth(Node root) {\n    if (root==null) {\n        return 0;\n    }\n    int max=0;\n    List<Node> children=root.children;\n    for (Node node:children) {\n        max=Math.max(max,maxDepth(node));\n    }\n    return max+1;\n}\n```\n## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n**说明：** 叶子节点是指没有子节点的节点。\n\n**示例：**\n\n给定二叉树 `[3,9,20,null,null,15,7]`   \n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回它的最小深度  2.\n\n**解法一**\n\n最大都求了，最小也来一发，经典 BFS 做法，求最短路径\n\n```java\npublic int minDepth(TreeNode root) {\n    if (root==null) return 0;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    int min=0;\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        min++;\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (node.left==null && node.right==null) {\n                return min;\n            }\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n    }\n    return min;\n}\n```\n**解法二**\n\n递归\n\n```java\npublic int minDepth(TreeNode root) {\n    if (root==null) return 0;\n    if (root.left==null) {\n        return minDepth(root.right)+1;\n    }\n    if (root.right==null) {\n        return minDepth(root.left)+1;\n    }\n    return Math.min(minDepth(root.left),minDepth(root.right))+1;\n}\n```\n很上面最大的相反，但是有个细节需要注意，如果一个根节点左右子树，**有一颗为空**，如果不处理，按照之前的逻辑，这颗空子树下一次就会返回 0，肯定会比另一颗小最后返回的就是到这颗子树的路径，但是仔细想想这样是正确的么？明显不是，最短路径的尽头一定是叶子节点也就是左右子树都为空的时候，所以这里需要特别注意\n\n## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)\n\n翻转一棵二叉树。\n\n**示例：**\n\n输入：\n\n```java\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n```\n\n输出：\n\n```java\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n```\n\n**备注：**\n这个问题是受到 Max Howell 的 原问题 启发的 ：\n\n> 谷歌：我们 90％的工程师使用您编写的软件 (Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。\n\n**解法一**\n\n```java\npublic TreeNode invertTree(TreeNode root) {\n    if (root==null) {\n        return null;\n    }\n    invertTree(root.left);\n    invertTree(root.right);\n    //交换左右节点\n    TreeNode temp=root.left;\n    root.left=root.right;\n    root.right=temp;\n    return root;\n}\n```\n注意递归调用和交换节点的顺序，不能搞反了\n\n```java\npublic TreeNode invertTree(TreeNode root) {\n    if (root==null) {\n        return null;\n    }\n    TreeNode right=root.right;\n    root.right=invertTree(root.left);\n    root.left=invertTree(right);\n    return root;\n}\n```\n比较简洁也比较符合递归的做法\n\n## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n给定两个二叉树，编写一个函数来检验它们是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n**示例 1:**\n\n```java\n输入：1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：1          1\n          /           \\\n         2             2\n    \n        [1,2],     [1,null,2]\n\n输出：false\n```\n\n**示例 3:**\n\n```java\n输入：1         1\n          / \\       / \\\n         2   1     1   2\n        \n        [1,2,1],   [1,1,2]\n输出：false\n```\n\n**解法一**\n\n```java\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p==null && q==null) {\n        return true;\n    }\n    if (p!=null && q!=null && p.val==q.val) {\n        return isSameTree(p.right,q.right)&&isSameTree(p.left,q.left);\n    }\n    return false;\n}\n```\n\n## [951. 翻转等价二叉树](https://leetcode-cn.com/problems/flip-equivalent-binary-trees/)\n\nDifficulty: **中等**\n\n我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。\n\n只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X _翻转等价_于二叉树 Y。\n\n编写一个判断两个二叉树是否是_翻转等价_的函数。这些树由根节点 `root1` 和 `root2` 给出。\n\n**示例：**\n\n```go\n输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\n输出：true\n解释：我们翻转值为 1，3 以及 5 的三个节点。\n\n```\n\n**提示：**\n\n1.  每棵树最多有 `100` 个节点。\n2.  每棵树中的每个值都是唯一的、在 `[0, 99]` 范围内的整数。\n\n**解法一**\n\n交错的比较就行了\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc flipEquiv(root1 *TreeNode, root2 *TreeNode) bool {\n    if root1 == nil && root2 == nil {\n        return true\n    }\n    if root1 == nil || root2 == nil {\n        return false\n    }\n    if root1.Val != root2.Val {\n        return false\n    }\n    return (flipEquiv(root1.Left, root2.Left) && \n            flipEquiv(root1.Right, root2.Right)) || \n           (flipEquiv(root1.Left, root2.Right) &&\n            flipEquiv(root1.Right, root2.Left))\n}\n```\n\n## [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)\n\n给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。\n\n**示例 1:**\n给定的树 s:\n\n```java\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n```\n\n给定的树 t：\n\n```java\n   4 \n  / \\\n 1   2\n```\n\n返回 **true**，因为 t 与 s 的一个子树拥有相同的结构和节点值。\n\n**示例 2:**\n给定的树 s：\n\n```java\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n    /\n   0\n```\n\n给定的树 t：\n\n```java\n   4\n  / \\\n 1   2\n```\n\n返回 **false**\n\n**解法一**\n\n先上一个错误解法\n\n```java\npublic boolean isSubtree(TreeNode s, TreeNode t) {\n    if (t==null && s==null) {\n        return true;\n    }\n    if (s==null) {\n        return false;\n    }\n    if (s!=null&& t!=null && s.val == t.val) {\n        return isSubtree(s.left,t.left) && isSubtree(s.right,t.right);\n    }\n    return isSubtree(s.left,t) | isSubtree(s.right,t);\n}\n```\n过了 146/176 的 case，但是这个明显是错的，不过核心的递归还是大概雏形写出来了\n\n**解法二**\n\n思考了一会，光速瞄了一眼评论区，隐约看到了有人说双递归，然后想到了下面的解\n\n```java\n//简化代码\npublic boolean isSubtree(TreeNode s, TreeNode t) {\n    if (s==null) {\n        return false;\n    }\n    return isSame(s,t)| isSubtree(s.left,t) | isSubtree(s.right,t);\n}\n\npublic boolean isSame(TreeNode s, TreeNode t){\n    if (s==null && t==null) {\n        return true;        \n    }\n    if (s==null || t==null) {\n        return false;\n    }\n    return s.val==t.val && isSame(s.left,t.left) && isSame(s.right,t.right);\n}\n```\n\n开始的代码没这么简洁，比较罗嗦，要判断一棵树是不是另一颗的子树很好判断，要么 s 和 t 直接相等，要么 t 是 s 左子树的子树，或者右子树的子树，所以我们还需要一个函数判断两个两棵树是否相等，只用一个函数确实不好实现\n\n**解法三**\n\n其实还有一种解法，也是最开始想到的，就是直接中序遍历和前序遍历，得到两个序列，然后用 kmp 匹配两棵树，kmp 很久没看了，不会写了，后面有时间再来写\n\n## [面试题 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)\n\n输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。（约定空树不是任意一个树的子结构）\n\nB 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。\n\n**例如：**\n给定的树 A:\n\n```java\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n```\n\n给定的树 B：\n\n```java\n   4 \n  /\n 1\n```\n\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n\n**示例 1：**\n\n```java\n输入：A = [1,2,3], B = [3,1]\n输出：false\n```\n\n**示例 2：**\n\n```java\n输入：A = [3,4,5,1,2], B = [4,1]\n输出：true\n```\n\n**限制：**\n\n0 <= 节点个数 <= 10000\n\n**解法一**\n\n一样的题为啥还加上？仔细看题，我开始也以为是一样的\n\n```java\npublic boolean isSubStructure(TreeNode A, TreeNode B) {\n    if(A==null || B==null){\n        return false;\n    }\n    return isSame(A,B) | isSubStructure(A.left,B) | isSubStructure(A.right,B);\n}\n\npublic boolean isSame(TreeNode A,TreeNode B){\n    if (B==null) { //AB 同时为 NULL 应该返回 true, 所以上下不能交换\n        return true;\n    }\n    if(A==null){\n        return false;\n    }\n    return A.val==B.val && isSame(A.left,B.left) && isSame(A.right,B.right);\n}\n```\n这里说的是子结构不是子树，isSame 函数不需要保证完全相等，这里就需要注意了，当`A!=null && B==null`的时候就说明 B 已经匹配完了 A 还没有，这就说明 B 是 A 的子结构\n\n**UPDATE(2020.5.7)**\n\n换了一下写法，不用考虑顺序了\n\n```go\nfunc isSubStructure(A *TreeNode, B *TreeNode) bool {\n    if B==nil || A==nil{\n        return false\n    }\n    return dfs(A,B) || isSubStructure(A.Left,B) || isSubStructure(A.Right,B)\n}\n\nfunc dfs(A *TreeNode, B *TreeNode)bool{\n    if A==nil && B==nil{\n        return true\n    }\n    if A==nil || B==nil{\n        return B==nil\n    }\n    return A.Val==B.Val && dfs(A.Left,B.Left) && dfs(A.Right,B.Right)\n}\n```\n\n## [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)\n\n给出一个**完全二叉树**，求出该树的节点个数。\n\n**说明：**\n\n完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n\n**示例：**\n\n```java\n输入：\n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\n输出：6\n```\n\n**解法一**\n\nBFS，权当复习了\n\n```java\n//BFS\npublic int countNodes(TreeNode root) {\n    Queue<TreeNode> queue=new LinkedList<>();\n    if (root == null) return 0;\n    queue.add(root);\n    int count=1;\n    while(!queue.isEmpty()){\n        int nextLevel=queue.size();\n        while(nextLevel>0){\n            TreeNode node=queue.poll(); \n            count++;\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            nextLevel--;\n        }\n    }\n    return count;\n}\n```\n**解法二**\n\n递归解法\n\n```java\n//暴力\npublic int countNodes(TreeNode root) {\n    if (root==null) return 0;\n    return countNodes(root.left)+countNodes(root.right)+1;\n}\n```\n更加精简点可以缩减成一行\n\n**解法三**\n\n这题是 mid 难度，而且题目给的条件还没用上：**这是一颗完全二叉树**，所以我们可以利用它的性质来做，众所周知，**满二叉树的节点个数**可以直接根据公式 `2^H-1` 计算得来，所以我们只要判断当前的完全二叉树是不是**满二叉树**，如果是直接算出来，这样就可以省去中间很多节点的遍历\n\n```java\n//利用完全二叉树的性质\npublic int countNodes(TreeNode root) {\n    if (root==null) return 0;\n    TreeNode left=root.left;\n    TreeNode right=root.right;\n    int hight=0;\n    while(left!=null && right!=null){\n        left=left.left;\n        right=right.right;\n        hight++;\n    }\n    //同时向左向右走，走到最后 left==null 就说明这颗树是满二叉树，可以利用公式直接求出节点个数\n    //否则就对其左右子树递归求解\n    return left==null?(1<<hight)-1:countNodes(root.left)+countNodes(root.right)+1;\n}\n```\n不得不说这样的方式还是挺巧妙的，时间复杂度应该是`O(2logN)`? \n\n## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)\n\n给定一个二叉树和一个目标和，判断该树中是否存在**根节点到叶子节点**的路径，这条路径上所有节点值相加等于目标和。\n\n**说明：** 叶子节点是指没有子节点的节点。\n\n**示例：** \n给定如下二叉树，以及目标和 `sum = 22`\n\n```java\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n```\n返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`\n\n**解法一**\n\n递归解法\n\n```java\npublic boolean hasPathSum(TreeNode root, int sum) {\n    if (root==null) {\n        return false;\n    }\n    //需要注意这里的叶节点判断\n    if (root.left==null && root.right==null&&root.val==sum) {\n        return true;\n    }\n    return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\n}\n```\n值得注意的地方就是这个叶子节点的判断，一开始没注意到，直接写的 `root.val==sum` ，其实如果不是叶子节点的话，其实是不成立的，比如\n\n```java\n  1\n /\n2       sum=1\n```\n\n其实这就是`false` ，因为他没有右子树，而题目要求的是从**根节点到叶子节点**\n\n## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)\n\n计算给定二叉树的所有左叶子之和。\n\n**示例：**\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n\n**解法一**\n\n说实话，这些题给的例子都挺误导人的，会让人不自觉地忽略**叶子节点**这个条件😂\n\n```java\nprivate int sum=0;\n\npublic int sumOfLeftLeaves(TreeNode root){\n    sumOfLeft(root);\n    return sum;\n};\n\npublic void sumOfLeft(TreeNode root) {\n    if (root==null) {\n        return;\n    }\n    //注意这里的条件！！！！\n    if (root.left!=null && root.left.left==null &&root.left.right==null) {\n        sum+=root.left.val;\n    }\n    sumOfLeft(root.left);\n    sumOfLeft(root.right);\n}\n```\n## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n**说明：** 叶子节点是指没有子节点的节点。\n\n**示例：**\n\n```java\n 输入：\n\n   1\n /   \\\n2     3\n \\\n  5\n\n输出：[\"1->2->5\", \"1->3\"]\n\n解释：所有根节点到叶子节点的路径为：1->2->5, 1->3\n```\n\n**解法一**\n\n递归 DFS 的解法\n\n```java\n//DFS\npublic List<String> binaryTreePaths(TreeNode root) {\n    List<String> res=new ArrayList<>();\n    if (root==null) return res;\n\n    if (root!=null&&root.left==null&&root.right==null) {\n        res.add(String.valueOf(root.val));\n        return res;\n    }\n    //左子树的所有路径\n    List<String> lefts=binaryTreePaths(root.left);\n    //右子树的所有路径\n    List<String> rights=binaryTreePaths(root.right);\n    \n    //在每条路径前面加上当前根节点\n    for (int i=0;i<lefts.size();i++) {\n        res.add(root.val+\"->\"+lefts.get(i));\n    }\n    for (int i=0;i<rights.size();i++) {\n        res.add(root.val+\"->\"+rights.get(i));\n    }\n    return res;\n}\n```\n比上面的递归稍微复杂点，核心思想还是要抓住递归的本质，不要去纠结递归每一步都是怎么得到的，从宏观上去写代码，还是要多练啊\n\n**解法二**\n\nBFS 广搜\n\n```java\npublic List<String> binaryTreePaths(TreeNode root) {\n    List<String> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> node_stack=new Stack<>();\n    Stack<String> path_stack=new Stack<>();\n    node_stack.add(root);\n    path_stack.add(String.valueOf(root.val));\n    String path=\"\";\n    while(!node_stack.isEmpty()){\n        TreeNode node=node_stack.pop();\n        path=path_stack.pop();\n        //叶子节点，这条路径搜索结束，添加到 res 中\n        if (node.left==null&&node.right==null) {\n            res.add(path);\n        }\n        \n        if (node.left!=null) {\n            node_stack.add(node.left);\n            path_stack.add(path+\"->\"+node.left.val);\n        }\n        if (node.right!=null) {\n            node_stack.add(node.right);\n            path_stack.add(path+\"->\"+node.right.val);\n        }\n    }\n    return res;\n}\n```\n这里和传统的 BFS 不太一样，是用的栈来遍历的\n\n**解法三**\n\n这种解法应该会比上面的解法复杂度低一点\n\n```go\nfunc binaryTreePaths(root *TreeNode) []string {\n    var res []string\n    dfs(root,\"\",&res)\n    return res\n}\n\n//注意这个 res 要传指针\nfunc dfs(root *TreeNode,path string,res *[]string){\n    if root==nil {return}\n    path+=strconv.Itoa(root.Val)\n    if root.Left==nil && root.Right==nil{\n        *res=append(*res,path)\n        return\n    }\n    dfs(root.Left,path+\"->\",res)\n    dfs(root.Right,path+\"->\",res)\n}\n```\n\n## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)\n\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n\n**说明：** 叶子节点是指没有子节点的节点\n\n**示例：**\n给定如下二叉树，以及目标和 `sum = 22`，\n\n```java\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\    / \\\n    7    2  5   1\n```\n返回：\n\n```java\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n```\n\n**解法一**\n\n和上一题的做法基本一致，本来应该是一遍 bugfree 的，编译错误整了半天\n\n```java\npublic List<List<Integer>> pathSum(TreeNode root, int sum) {\n    List<List<Integer>> res=new LinkedList<>();\n    if (root==null) {\n        return res;\n    }\n    if (root!=null && root.left==null && root.right==null && root.val==sum) {\n        LinkedList<Integer>  lis= new LinkedList<>(); \n        lis.add(root.val);\n        res.add(lis);\n        return res;\n    }\n    //左右子树符合条件的路径\n    List<List<Integer>> lefts=pathSum(root.left,sum-root.val);\n    List<List<Integer>> rights=pathSum(root.right,sum-root.val);\n\n    for (int i=0;i<lefts.size();i++) {\n        ((LinkedList<Integer>)lefts.get(i)).addFirst(root.val);\n        res.add(lefts.get(i));\n    }\n\n    for (int i=0;i<rights.size();i++) {\n        ((LinkedList<Integer>)rights.get(i)).addFirst(root.val);\n        res.add(rights.get(i));\n    }\n    return res;\n}\n```\n**解法二**\n\n废了老大劲终于把 BFS 写出来了。可以看出还是借鉴的上面的思路\n\n```java\npublic List<List<Integer>> pathSum2(TreeNode root,int sum) {\n    List<List<Integer>> res=new LinkedList<>();\n    if (root==null) return res;\n    //节点栈\n    Stack<TreeNode> node_stack=new Stack<>();\n    //路径栈\n    Stack<List<Integer>> path_stack=new Stack<>();\n    //节点 sum 栈\n    Stack<Integer> sum_stack=new Stack<>();\n    //给每个栈存入初始值\n    node_stack.add(root);\n    path_stack.add(new LinkedList(){{\n        add(root.val);\n    }});\n    sum_stack.add(root.val);\n    //BFS\n    while(!node_stack.isEmpty()){\n        TreeNode node=node_stack.pop();\n        List<Integer> pathList=path_stack.pop();\n        int tempS=sum_stack.pop();\n        //终止条件\n        if (node.left==null && node.right==null&&tempS==sum) {\n            res.add(pathList);\n            continue;\n        }\n        if (node.left!=null) {\n            //这三个栈是同步的，node 栈存放当前节点\n            //path 栈存放根节点到当前节点的路径\n            //sum 栈存放的是 path 栈中所有节点的 val 和\n            node_stack.add(node.left);\n            //这里不要直接操作 pathList, 否则左右的路径会混在一起\n            LinkedList<Integer> tlis= new LinkedList(pathList);\n            tlis.add(node.left.val);\n            path_stack.add(tlis);\n            //累加路径上的节点值\n            sum_stack.add(tempS+node.left.val);\n        }\n        if (node.right!=null) {\n            node_stack.add(node.right);\n            //同上\n            LinkedList<Integer> tlis= new LinkedList(pathList);\n            tlis.add(node.right.val);\n            path_stack.add(tlis);\n            sum_stack.add(tempS+node.right.val);\n        }\n    }\n    return res;\n}\n```\n用到三个栈，同步保存节点的信息，还是挺简单的\n\n**解法三**\n\n补一种 dfs+回溯的思路，上面的所有路径也可以这样做，感觉会比上面的要好一点\n\n```java\npublic List<List<Integer>> pathSum(TreeNode root, int sum) {\n    dfs(root,sum,new ArrayList<>());\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic void dfs(TreeNode root,int sum,List<Integer> lis){\n    if(root==null) return;\n    lis.add(root.val);\n    if(root.left==null && root.right==null && sum==root.val){\n        res.add(new ArrayList(lis)); //这里不能 return，得到后面回溯后才能 return\n    }else{\n        dfs(root.left,sum-root.val,lis);\n        dfs(root.right,sum-root.val,lis);\n    }\n    lis.remove(lis.size()-1);\n}\n```\n\n## [894. 所有可能的满二叉树](https://leetcode-cn.com/problems/all-possible-full-binary-trees/)\n\n*满二叉树*是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。\n\n返回包含 `N` 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。\n\n答案中每个树的每个`结点`都**必须**有 `node.val=0`。\n\n你可以按任何顺序返回树的最终列表。\n\n![tXXu4A.png](https://s1.ax1x.com/2020/06/13/tXXu4A.png)\n\n**示例：**\n\n```java\n输入：7\n输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n解释：\n```\n\n**提示：**\n\n- `1 <= N <= 20`\n\n**解法一**\n\n这题和上面两题很类似，可惜我并没有直接做出来，菜啊，看了一眼评论区看见了几个 for 循环立马就懂了，然后过了好几天实现了下，一开始 root 的位置放错了，改了一会儿\n\n```java\npublic List<TreeNode> allPossibleFBT(int N) {\n    List<TreeNode> res=new ArrayList<>();\n    if(N%2==0) return res; //偶数提前返回，加快速度\n    if(N==1){\n        res.add(new TreeNode(0));\n        return res;  \n    }\n    N--; //减去根节点\n    for(int i=1;i<N;i+=2){ //将左右子树划分位两个奇数\n        List<TreeNode> lefts=allPossibleFBT(i);\n        List<TreeNode> rights=allPossibleFBT(N-i);\n        for(TreeNode le:lefts){\n            for(TreeNode ri:rights){\n                //一路从最外层移动到这里。\n                TreeNode root=new TreeNode(0); \n                root.left=le;\n                root.right=ri;\n                res.add(root);\n            }\n        }\n    }\n    return res;\n}\n```\n\n## [129. 求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)\n\n给定一个二叉树，它的每个结点都存放一个 `0-9` 的数字，每条从根到叶子节点的路径都代表一个数字。\n\n例如，从根到叶子节点路径 `1->2->3` 代表数字 `123`\n\n计算从根到叶子节点生成的所有数字之和。\n\n**说明：** 叶子节点是指没有子节点的节点。\n\n**示例 1:**\n\n```java\n输入：[1,2,3]\n    1\n   / \\\n  2   3\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12.\n从根到叶子节点路径 1->3 代表数字 13.\n因此，数字总和 = 12 + 13 = 25.\n```\n\n**示例 2:**\n\n```java\n输入：[4,9,0,5,1]\n    4\n   / \\\n  9   0\n / \\\n5   1\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495.\n从根到叶子节点路径 4->9->1 代表数字 491.\n从根到叶子节点路径 4->0 代表数字 40.\n因此，数字总和 = 495 + 491 + 40 = 1026.\n```\n\n**解法一**\n\nBFS，延续上面的做法\n\n```java\npublic int sumNumbers(TreeNode root) {\n    int res=0;\n    if (root == null ) return res;\n    Stack<TreeNode> node_stack=new Stack<>();\n    Stack<Integer> sum_stack=new Stack<>();\n    node_stack.add(root);\n    sum_stack.add(root.val);\n    while(!node_stack.isEmpty()){\n        TreeNode node=node_stack.pop();\n        int tempS=sum_stack.pop();\n        if (node.left==null && node.right==null) {\n            res+=tempS;\n            continue;\n        }\n        if (node.left!=null) {\n            node_stack.add(node.left);\n             //注意* 10, 在上一层的基础上* 10\n            sum_stack.add(tempS*10+node.left.val);\n        }\n        if (node.right!=null) {\n            node_stack.add(node.right);\n            sum_stack.add(tempS*10+node.right.val);\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\nDFS 解法，一开始没想出来。\n\n```java\nprivate int sum=0;\n//DFS\npublic int sumNumbers2(TreeNode root) {\n    sumNumber(0,root);\n    return sum;\n}\n\npublic void sumNumber(int parent,TreeNode root) {\n    if (root==null) {\n        return;\n    }\n    int cur=parent*10+root.val;\n    //叶子节点\n    if (root!=null && root.left==null&& root.right==null) {\n        sum+=cur;\n    }\n    sumNumber(cur,root.left);\n    sumNumber(cur,root.right);\n}\n```\n\n## [1022. 从根到叶的二进制数之和](https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/)\n\n给出一棵二叉树，其上每个结点的值都是 `0` 或 `1` 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 `0 -> 1 -> 1 -> 0 -> 1`，那么它表示二进制数 `01101`，也就是 `13` 。\n\n对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。\n\n以 **10^9 + 7** 为**模**，返回这些数字之和。\n\n**示例：**\n\n![JI4uDI.png](https://s1.ax1x.com/2020/04/28/JI4uDI.png)\n\n```java\n输入：[1,0,1,0,1,0,1]\n输出：22\n解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n```\n\n \n\n**提示：**\n\n1. 树中的结点数介于 `1` 和 `1000` 之间。\n2. node.val 为 `0` 或 `1` 。\n\n**解法一**\n\n和上一题一摸一样，没啥好说的，只不过一个是 10 进制，一个是二进制\n\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nvar mod=int(1e9+7)\n\nfunc sumRootToLeaf(root *TreeNode) int {\n    sum:=0;\n    dfs(root,0,&sum)\n    return sum\n}\n\nfunc dfs(root *TreeNode,cur int,sum *int){\n    if root==nil{\n        return\n    }\n    cur=(cur<<1+root.Val)%mod\n    if root!=nil && root.Left==nil && root.Right==nil{\n        *sum=(*sum+cur)%mod\n        return\n    }\n    dfs(root.Left,cur,sum)\n    dfs(root.Right,cur,sum)\n}\n```\n\n> 这题的数据太弱了，甚至都不用取模照样可以过。我一开始看到 1000 个节点，还考虑要不要处理大数的情况，看到返回值是 int 才作罢🤣\n\n## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)\n\n给定一个二叉树，它的每个结点都存放着一个整数值。\n\n找出路径和等于给定数值的路径总数。\n\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n二叉树不超过 1000 个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n\n**示例：**\n\n```java\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n```\n\n返回 3。和等于 8 的路径有：\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3.  -3 -> 11\n\n**解法一**\n\n```java\npublic int pathSum(TreeNode root, int sum) {\n    if (root == null ) {\n        return 0;\n    }\n    int res=findPath(root,sum);\n    res+=pathSum(root.left,sum);\n    res+=pathSum(root.right,sum);\n    return res;\n}\n\npublic int findPath(TreeNode node,int sum){\n    int res=0;\n    if (node==null) {\n        return res;\n    }\n    if (node.val==sum) {\n        res++;\n    }\n    res+=findPath(node.left,sum-node.val);\n    res+=findPath(node.right,sum-node.val);\n    return res;\n}\n```\n~~emmmm，这题分类是 easy 确实太迷了，嵌套的递归，看了解法确实看的懂，但是写是绝对写不出来的（眼睛：我懂了，脑子：你懂个锤子）除非能记住~~\n\n回头来看发现其实挺简单的，确实是 easy 题~ 但是这个解很明显不是最优解，这个里面会有很多的重复的计算，最优解是利用 前缀和+回溯的解法，有点小顶~\n\n**解法二**\n\n补上前缀和的做法，之前好像是看了答案，然后感觉很难，就没写？今天又重新做了下，先写了暴力解，然后就直接写出了前缀和的做法，感觉前缀和的思路还是挺优秀的，一开始忘了回溯，思考了下意识到这里记录的应该是一条分支之上而下的前缀和，所以在统计完某个节点后应该回溯\n```golang\n//前缀和的思路 O(N) 挺不错的\nfunc pathSum(root *TreeNode, sum int) int {\n    if root == nil {\n        return 0\n    }\n    var res = 0\n    //前缀和，记录一条自上而下的路径前缀和\n    var preSum = make(map[int]int)\n    preSum[0] = 1\n    dfs(root, 0, sum, preSum, &res)\n    return res\n}\n\nfunc dfs(root *TreeNode, sum int, target int, preSum map[int]int, res *int) {\n    if root == nil {\n        return\n    }\n    sum += root.Val\n    //preSum[sum]++，这里 WA 了一发，写在上面如果 tatget 为 0 就把当前节点算进去了\n    *res += preSum[sum-target]\n    preSum[sum]++\n    dfs(root.Left, sum, target, preSum, res)\n    dfs(root.Right, sum, target, preSum, res)\n    preSum[sum]--\n}\n\n```\n\n## [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）\n\n例如，给定如下二叉搜索树：`root = [6,2,8,0,4,7,9,null,null,3,5]`\n\n![mark](http://static.imlgw.top/blog/20191001/KlQJmqmdWmP3.png?imageslim)\n\n**示例 1:**\n\n```java\n输入：root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出：6 \n解释：节点 2 和节点 8 的最近公共祖先是 6\n```\n\n**示例 2:**\n\n```java\n输入：root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出：2\n解释：节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n```\n\n**说明：**\n\n- 所有节点的值都是唯一的。\n- p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n**解法一**\n\n看了一点点思路，然后 bugfree\n\n```java\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    //特殊情况，其中一个已经是另一个的祖先了\n    //if (p==root || q==root) return root;\n    //都小于根节点\n    if (p.val<root.val && q.val<root.val) {\n        return lowestCommonAncestor(root.left,p,q);\n    }else if (p.val > root.val && q.val > root.val) {\n        //都大于根节点\n        return lowestCommonAncestor(root.right,p,q);\n    }else{\n        //一大一小 或者有一个是 root\n        return root;\n    }\n}\n```\n其实核心就是利用好 BST 的性质，左子树一定小于根节点，右子树一定大于根节点，求公共祖先，如果一个节点在左子树，一个在右子树，那么最近的公共祖先一定是 root，除此之外，还有一种特殊情况就是当两个节点已经有祖先关系的时候，那么直接返回祖先节点就可以了\n\n> 这里其实前面的`if`可以去掉，题目中说到了所有节点的值都是唯一的，所以节点值相等就说明是同一个节点，就已经包含在最后一个 else 的情况中了\n\n## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n- 节点的左子树只包含**小于**当前节点的数。\n- 节点的右子树只包含**大于**当前节点的数。\n- 所有左子树和右子树自身必须也是二叉搜索树。\n\n**示例 1:**\n\n```java\n输入：\n    2\n   / \\\n  1   3\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出：false\n解释：输入为：[5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 \n```\n\n**解法一**\n\n递归解法，很巧妙\n\n```java\npublic boolean isValidBST(TreeNode root) {\n    if (root==null) {\n        return true;\n    }\n    return isValidBST(root,null,null);\n}\n\npublic boolean isValidBST(TreeNode node,Integer low,Integer high){\n    if (node==null) return true;\n    if (low!=null && low>=node.val || high!=null && high<=node.val) {\n        return false;\n    }\n    return isValidBST(node.left,low,node.val) && isValidBST(node.right,node.val,high);\n}\n```\n一定要注意 BST 的性质是根节点**大于所有** 右子树的节点，**小于所有**左子树的节点，而不是简单的验证当前节点和左右节点的大小关系就可以了，所以我们在验证的时候传入对应的**上界**和**下界**，节点必须要大于下界，小于上界，那么上界和下界从哪里来？_当前节点就是左子树的上界，右子树的下界！_  然后递归左右子树就 ok 了\n\n> 这题其实还有一个坑，只不过我这个做法直接跳过了，题目的 case 中有的节点值是`Integer.MIN_VALUE`，和`Integer.MAX_VALUE`  ，如果上界下界直接用 int 来传递的话，很有可能递归初始调用就是这样的\n>\n> `return isValidBST(root,Integer.MIN_VALUE,Integer.MAX_VALUE);` 这就正中出题人下怀，所以我们这里用一个包装类型，这样我们只需要检测上界下界是不是 null 就可以了\n\n**解法二**\n\n这个就利用了 BST 和中序遍历的关系，我们知道中序遍历是 `左->根->右`  这个顺序放到 BST 中恰好就是一个升序的序列，所以我们就可以利用这个性质来判断二叉树是不是 BST\n\n```java\n//BST 的中序遍历一定是升序的\npublic boolean isValidBST(TreeNode root){\n    LinkedList<Integer> order=new LinkedList<>();\n    if (root==null) {\n        return true;\n    }\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    while(cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            stack.add(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        //和上一次的最后一个节点值比较\n        if (!order.isEmpty() && order.getLast()>= cur.val) {\n            return false;\n        }\n        order.add(cur.val);\n        cur=cur.right;\n    }\n    return true;\n}\n```\n这里其实可以不用 list 保存结果，~~用一个 int 保存上一次的节点值就行了~~ md 重做的时候因为这个 WA 了好几次，如果用 int 的话需要加一个标志位用来初始化\n\n## [958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)\n\nDifficulty: **中等**\n\n给定一个二叉树，确定它是否是一个_完全二叉树_。\n\n**中对完全二叉树的定义如下：**\n\n若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2<sup>h</sup> 个节点。）\n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png)\n\n```go\n输入：[1,2,3,4,5,6]\n输出：true\n解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。\n```\n\n**示例 2：**\n\n**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png)**\n\n```go\n输入：[1,2,3,4,5,null,7]\n输出：false\n解释：值为 7 的结点没有尽可能靠向左侧。\n```\n\n**提示：**\n\n1.  树中将会有 1 到 100 个结点。\n\n**解法一**\n\n一开始思路出现了问题，想着去按照节点个数去校验，然后对最后一层做特判，然后发现这种思路是死胡同，实际上判断是否是完全二叉树很简单，只要节点**中间**没有出现 null 就说明是完全二叉树\n```java\npublic boolean isCompleteTree(TreeNode root) {\n    if (root == null) {\n        return true;\n    }\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    TreeNode pre = root;\n    while(!queue.isEmpty()){\n        TreeNode cur = queue.poll();\n        //当前节点前面出现了 null\n        if (pre==null && cur!=null){\n            return false;\n        }\n        if (cur!=null) {\n            //因为要判断 null 是否在中间，所以 null 节点也要存进去\n            queue.add(cur.left);\n            queue.add(cur.right);\n        }\n        pre = cur;\n    }\n    return true;\n}\n```\n\n## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)\n\n将一个按照升序排列的有序数组，转换为一棵**高度平衡二叉搜索树**\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n**示例：**\n\n```java\n给定有序数组：[-10,-3,0,5,9]\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n```\n\n**解法一**\n\n```java\npublic TreeNode sortedArrayToBST(int[] nums) {\n    return sortedArrayToBST(nums,0,nums.length-1);\n}\n\npublic TreeNode sortedArrayToBST(int[] nums,int left,int right) {\n    if (left>right) {\n        return null;\n    }\n    int mid=(right-left)/2+left;\n    TreeNode node=new TreeNode(nums[mid]);\n    node.left=sortedArrayToBST(nums,left,mid-1);\n    node.right=sortedArrayToBST(nums,mid+1,right);\n    return node;\n}\n```\n这题最开始终止条件写错了，思路是对的，对递归运用的还是不够熟练，终止条件其实只需要想一下极端情况就可以了\n\n## [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。\n\n**示例：**\n\n```sql\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n```\n\n**解法一**\n\n~~BST 不太熟看了下评论写出来的~~\n\n好久之前写的题了，每日打卡题出了上面的题目，随便做一下这题，发现这题被记录在链表专题中了，移过来下，和上面的一样，只不过找中点的方式不一样（UPDATE: 2020.7.3）\n\n```java\npublic TreeNode sortedListToBST(ListNode head) {\n    return build(head,null);\n}\n\npublic static TreeNode build(ListNode head,ListNode tail){\n    if(head==tail){\n        return null;\n    }\n    //快慢指针找中点\n    ListNode fast=head,slow=head;\n    while(fast!=tail&&fast.next!=tail){\n        //左闭右开\n        fast=fast.next.next;\n        slow=slow.next;\n    }\n    //slow 为中点或中点后一个\n    //1 2 3 4\n    TreeNode root=new TreeNode(slow.val);\n    root.left=build(head,slow);\n    root.right=build(slow.next,tail);\n    return root;\n}\n```\n**UPDATE: 2020.7.3**\n```golang\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    if head == nil{\n        return nil\n    }\n    if head.Next == nil{\n        return &TreeNode{Val : head.Val}\n    }\n    var fast = head\n    var slow = head //slow 为左中点\n    var pre  = head\n    for fast != nil && fast.Next !=nil{\n        fast = fast.Next.Next\n        pre = slow\n        slow = slow.Next\n    }\n    pre.Next = nil //斩断和 slow 的联系\n    root := &TreeNode{Val : slow.Val}\n    root.Left = sortedListToBST(head)\n    root.Right = sortedListToBST(slow.Next)\n    return root\n}\n```\n\n## [230. 二叉搜索树中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n\n给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 k 个最小的元素\n\n**说明：**\n你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。\n\n**示例 1:**\n\n```java\n输入：root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n输出：1\n```\n\n**示例 2:**\n\n```java\n输入：root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n输出：3\n```\n\n**进阶：**\n如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？\n\n**解法一**\n\n非递归中序遍历\n\n```java\npublic int kthSmallest(TreeNode root, int k) {\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    int count=0;\n    while(cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            stack.add(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        if (count==k-1) {\n            return cur.val;\n        }\n        cur=cur.right;\n        count++;\n    }\n    //没找到\n    return -1;\n}\n```\n还是利用 BST 中序遍历是升序的性质，在取到第 k 个元素的时候就直接`break`\n\n**解法二**\n\n递归的方式，加了两个额外的实例变量其实不太好\n\n```java\npublic int kthSmallest(TreeNode root, int k) {\n    kthSmallest(root,k);\n    return res;\n}\n\nprivate int count=0;\n\nprivate int res=0;\n\npublic void kthSmall(TreeNode root, int k) {\n    if (root==null) {\n        return;\n    }\n    kthSmall(root.left,k);\n    if (count==k-1) {\n        res=root.val;\n        return;\n    }\n    count++;\n    kthSmall(root.right,k);\n}\n```\n如果是第 K 大就交换下遍历顺序就行了\n```golang\nfunc kthLargest(root *TreeNode, k int) int {\n    var res = root.Val\n    var count = 0\n    var dfs func(*TreeNode)\n    dfs = func(root *TreeNode){\n        if root == nil{\n            return\n        }\n        //先 right\n        dfs(root.Right)\n        count++\n        if count == k{\n            res = root.Val\n        }\n        dfs(root.Left)\n    }\n    dfs(root)\n    return res\n}\n```\n**进阶**\n\n可以维护一个大根堆，就和最小栈一样，每次对 BST 操作的时候同步操作这个大根堆\n\n## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n给定一个二叉树，找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树：root = [3,5,1,6,2,0,8,null,null,7,4]\n\n ![mark](http://static.imlgw.top/blog/20191003/m0bWNSMUQWy2.png?imageslim)\n\n**示例 1:**\n\n```java\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3。\n```\n\n**示例 2:**\n\n```java\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n```\n\n**说明：**\n\n- 所有节点的值都是唯一的。\n- p、q 为不同节点且均存在于给定的二叉树中。\n\n**解法一**\n\n```java\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if(root==null || root==p || root==q) return root; \n    TreeNode left=lowestCommonAncestor(root.left,p,q);\n    TreeNode right=lowestCommonAncestor(root.right,p,q);\n    if(left==null){\n        return right;\n    }else if(right==null){\n        return left;\n    }\n    return root;\n}\n```\n\n这个函数的功能有三个：给定两个节点 pp 和 qq\n\n- 如果 pp 和 qq 都存在，则返回它们的公共祖先\n- 如果只存在一个，则返回存在的一个\n- 如果 pp 和 qq 都不存在，则返回 NULL \n\n**解法二**\n\n2020.4.9 新增解法，利用 Map 记录父节点，然后根据 p,q 倒推就行了\n\n```java\n//update: 2020.5.10 原来用的 TreeNode 做键，居然能过也是很神奇，我试了下，TreeNode 应该是没有覆盖 equals 的\n//所以要是碰撞的够多，那种做法就错了\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || p==root ||q==root) {\n        return root;\n    }\n    Deque<TreeNode> stack=new ArrayDeque<>();\n    //题目说了值唯一，所以可以用 Integer 当键\n    HashMap<Integer,TreeNode> map=new HashMap<>();\n    map.put(root.val,null); //根节点\n    stack.push(root);\n    while(!stack.isEmpty()){\n        TreeNode cur=stack.poll();\n        if(cur.right!=null){\n            stack.push(cur.right);\n            map.put(cur.right.val,cur);\n        }\n        if(cur.left!=null){\n            stack.push(cur.left);\n            map.put(cur.left.val,cur);\n        }\n    }\n    HashSet<Integer> set=new HashSet<>();\n    while(p!=null){\n        set.add(p.val);\n        p=map.get(p.val);\n    }\n    while(!set.contains(q.val)){\n        q=map.get(q.val);\n    }\n    return q;\n}\n```\n## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的\n\n```java\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是**镜像对称**的：\n\n```java\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n\n**说明：**\n\n如果你可以运用递归和迭代两种方法解决这个问题，会很加分。\n\n**解法一**\n\n哎，感觉刷题还是得在白天，脑子清醒点，下午就感觉做题老是出问题，一开始题都没看清就开始做\n\n其实一开始是想 BFS 层次遍历然后判断每一层是不是镜像对称的，然后发现有些 case 是过不了的，比如\n\n`[1,3,3,2,null,2]` 这样的 case\n\n```java\n    1\n   / \\\n  3   3\n /   /\n2   2\n```\n\n~~层序遍历判断不出了这样的 case~~   下面解法四打脸\n\n然后换一种遍历方式，其实一开始就想到了前序遍历，如果是镜像对称的话，前序遍历刚好就是对称的，但是！！！还是有 case 过不了！！！我们再看上面的 case，我们改一改\n\n```java\n    1\n   / \\\n  2   2\n /   /\n2   2\n```\n\n第`192/195 个 case`，我惊了，居然还有这种操作！！！实在没办法翻了下解答，发现有位老兄也是这样做的，然后他很巧妙的在每个节点值后面加了一个**层数**，他好像是直接当作字符串添加的，我感觉不太好，改用了数组，最后判断的时候需要保证层数和值都相同才行，完整代码如下\n\n```java\n//[1,2,2,2,null,2] 忘了还有这样的 case 了，哭了\npublic boolean isSymmetric(TreeNode root) {\n    if (root == null) {\n        return true;\n    }\n    List<Integer[]> lis=new ArrayList<>();\n    preTravle(root,lis,0); \n    for (int i=0,j=lis.size()-1;i<=j;i++,j--) {\n        if (lis.get(i)[0]!= lis.get(j)[0] ||  lis.get(j)[1]!= lis.get(i)[1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//前序遍历\npublic void preTravle(TreeNode node,List<Integer[]> lis,int k){\n    if (node!=null) {\n        preTravle(node.left,lis,k+1);\n        //这里其实用个字符串就可以，但是感觉拼接的效率不高，而且，是不是有可能出现问题？\n        // 11+3 ==1+13 ？？？是不是有可能出现类似这样的情况\n        Integer[] temp=new Integer[2];\n        temp[0]=node.val;\n        temp[1]=k;\n        lis.add(temp);\n        preTravle(node.right,lis,k+1);\n    }\n}\n```\n\n**解法二**\n\n递归的解法，应该算是官解了，一开始也是想用递归写的，没抓住问题的本质，太菜了\n\n```java\npublic boolean isSymmetric(TreeNode root) {\n    if (root ==null) {\n        return true;\n    }\n    //转换为求左右子树是否镜像对称的问题\n    return isSymmetric(root.left,root.right);\n    //return isSymmetric(root,root);\n}\n\n//dfs\npublic boolean isSymmetric(TreeNode t1,TreeNode t2) {\n    if (t1==null && t2==null) {\n        return true;\n    }\n    //有一个为 null\n    if (t1== null || t2==null) {\n        return false;\n    }\n    //都不为 null\n    return t1.val==t2.val && isSymmetric(t1.left,t2.right) && isSymmetric(t1.right,t2.left);\n}\n```\n一棵树是镜像对称，说明左右子树左右对称，所以这个问题就可以转换为，判断左右两颗子树是否是镜像对称的问题\n\n![mark](http://static.imlgw.top/blog/20191107/Ae6daB6SuXdl.png?imageslim)\n\n判断两颗树是否成镜像对称的话，其实就和照镜子一样的，如上图，判断左子树和右子树是否成镜像对称，就需要判断** t1 的左子树和 t2 的右子树是否镜像对称，t1 的右子树和 t2 的左子树是否镜像对称**，根据这个就可以写出递归函数，还是挺妙的\n\n**解法三**\n\n类似于层次遍历，其实就是根据上面的递归方法改来的，核心思想和上面递归的是一样的\n\n```java\n//非递归解法\npublic boolean isSymmetric(TreeNode root) {\n    if (root ==null) {\n        return true;\n    }\n    Stack<TreeNode> stack=new Stack<>();\n    stack.push(root.left);\n    stack.push(root.right);\n    while(!stack.isEmpty()){\n        TreeNode t1=stack.pop();\n        TreeNode t2=stack.pop();\n        if (t1==null && t2==null) {\n            continue;\n        }\n        if (t1==null||t2==null || t1.val!=t2.val) {\n            return false;\n        }\n        /*if (t1.val!=t2.val) {\n                return false;\n         }*/\n        stack.push(t1.left);\n        stack.push(t2.right);\n        stack.push(t1.right);\n        stack.push(t2.left);\n    }\n    return true;\n}       \n```\n\n**解法四**\n\n前序遍历，其实我一开始也想到了用占位的方式，但是因为之前遍历方式不同，导致没想好在哪里加\n\n```java\npublic boolean isSymmetric(TreeNode root) {\n    if (root ==null) {\n        return true;\n    }\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        ArrayList<Integer> lis=new ArrayList<>();\n        while(count>0){\n            TreeNode node=queue.poll();\n            //lis.add(node.val);\n            if (node.left!=null) {\n                queue.add(node.left);\n                lis.add(node.left.val);\n            }else{\n                //-1 占位\n                lis.add(-1);\n            }\n            \n            if (node.right!=null) {\n                queue.add(node.right);\n                lis.add(node.right.val);\n            }else{\n                //为空加-1 占位\n                lis.add(-1);\n            }\n            count--;\n        }\n        //对每一层经常判断\n        for (int i=0,j=lis.size()-1;i<=j;i++,j--) {\n            if (lis.get(i)!=lis.get(j)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n这样的做法明显时间复杂度会之前要高，不仅遍历了整颗树一遍，还对每一层遍历了一遍，一共遍历了两遍\n\n## [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)\n\n给定一个二叉树，在树的最后一行找到最左边的值。\n\n示例 1:\n```java\n输入：\n    2\n   / \\\n  1   3\n输出：\n1\n```\n\n示例 2:\n```java\n输入：\n        1\n       / \\\n      2   3\n     /   / \\\n    4   5   6\n       /\n      7\n输出：\n7\n```\n**注意：** 您可以假设树（即给定的根节点）不为 NULL。\n\n**解法一**\n\n这种题写一百遍了😂，然而我还是没有 bugfree\n\n```java\n//其实这种层序遍历的方式对这题有一点小题大作，不过我还是比较习惯这种方式\npublic int findBottomLeftValue(TreeNode root) {\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    int res=-1;\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        int temp=count;\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (count==temp) {\n                res=node.val;\n            }\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n    }\n    return res;   \n}\n```\n**解法二**\n\n最左边的值，也就是最后一行的第一个元素，dfs 深度优先，深度每增加一次就更新一次 res\n\n```java\n//DFS\npublic int findBottomLeftValue2(TreeNode root) {\n    dfs(root,0);\n    return res;\n}\n\nint res=-1,max=Integer.MIN_VALUE;\n\npublic void dfs(TreeNode node,int depth){\n    if (node==null) return;\n    if (depth>max) {\n        max=depth;\n        res=node.val;\n    }\n    dfs(node.left,depth+1);\n    dfs(node.right,depth+1);\n}\n```\n\n## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n**注意：**\n你可以假设树中没有重复的元素。\n\n例如，给出\n\n```java\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n```\n\n返回如下的二叉树：\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n**解法一**\n\n```java\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\n    if (preorder==null) {\n        return null;\n    }\n    return buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1);\n}\n\npublic TreeNode buildTree(int[] preorder,int preleft,int preright,int[] inorder,int inleft,int inright) {\n    //递归出口只需要想一下边界，比如只要一个节点的时候，很明显只有一个节点的时候这几个值都是 0\n    //但是此时肯定不能返回 null, 所以这里递归出口不是大于等于，而是大于\n    if (preleft>preright || inleft>inright) {\n        return null;\n    }\n    TreeNode root=new TreeNode(preorder[preleft]);\n    int index=inleft;\n    while(inorder[index] != preorder[preleft]) {\n        index++;\n    }\n    root.left=buildTree(preorder,preleft+1,preleft+index-inleft,inorder,inleft,index-1);\n    root.right=buildTree(preorder,preleft+index-inleft+1,preright,inorder,index+1,inright);\n    return root;\n}\n```\n这题核心思想就是利用这几种遍历的性质，文字总是苍白的，看个图吧\n\n![mark](http://static.imlgw.top/blog/20191106/pcmvnEK8Hwg8.png?imageslim)\n\n这样一看就清晰了，前序遍历左边第一个节点 `1` 一定是根节点，所以我们首先确定了根节点，然后我们去中序遍历中去找这个根节点（一定有），如上图，我们找到了中间的 `1`然后再根据中序遍历的性质，我们可以就知道，中序遍历中，这个`1` 的左边是 `1` 的左子树，右边是`1` 的右子树，到这里我们就确定了根节点及其左右子树，剩下的就交给递归去完成了😁，我们只需要对左右子树分别递归该过程就可以得到一颗完整的树了\n\n当然这里值得注意的地方就是下标的变换，要十分注意，自己带入几个值试试\n\n**UPDATE(2020.5.22)**\n\n```go\nvar m map[int]int\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n    n:=len(inorder)\n    //m:=make(map[int]int,n) 靠！这个 bug 看了半天\n    m=make(map[int]int,n)\n    for i,val:=range inorder{\n        m[val]=i\n    }\n    return build(preorder,0,n-1,inorder,0,n-1)\n}\n\nfunc build(pre []int,pl int,pr int,in []int,il int,ir int) *TreeNode{\n    if pl>pr || il>ir{\n        return nil\n    }\n    root:=&TreeNode{Val:pre[pl]}\n    idx:=m[pre[pl]]\n    root.Left=build(pre,pl+1,pl+idx-il,in,il,idx-1)\n    root.Right=build(pre,pl+idx-il+1,pr,in,idx+1,ir)\n    return root\n}\n```\n\n## [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n**注意：**\n你可以假设树中没有重复的元素。\n\n例如，给出\n\n```java\n中序遍历 inorder = [9,3,15,20,7]\n后序遍历 postorder = [9,15,7,20,3]\n```\n\n返回如下的二叉树：\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n**解法一**\n\n方法同上，只不过是从后往前了\n\n```java\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\n    if (inorder==null || inorder.length<=0) {\n        return null;\n    }\n    return buildTree(inorder,0,inorder.length-1,postorder,0,postorder.length-1);\n}\n\npublic TreeNode buildTree(int[] inorder,int inL,int inR, int[] postorder,int pL,int pR) {\n    //递归出口只需要想一下边界，比如只要一个节点的时候，很明显只有一个节点的时候这几个值都是 0\n    //但是此时肯定不能返回 null, 所以这里递归出口不是大于等于，而是大于\n    if (inL>inR || pL>pR) { \n        return null;\n    }\n    TreeNode root=new TreeNode(postorder[pR]);\n    int index=inL;\n    while(inorder[index]!=postorder[pR]){\n        index++; //一定有，所以不用担心越界的问题\n    }\n    root.left=buildTree(inorder,inL,index-1,postorder,pL,pL+index-inL-1);\n    root.right=buildTree(inorder,index+1,inR,postorder,pL+index-inL,pR-1);\n    return root;\n}\n```\n和上面一样没啥好说的\n\n**解法二**\n\n上面两种解法提交后效率都不高，这里去中序遍历中找根节点的操作其实可以用 Hash 表代替\n\n```java\n//hash 表优化\nHashMap<Integer,Integer> map=new HashMap<>();\n\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\n    if (inorder==null || inorder.length<=0) {\n        return null;\n    }\n    for (int i=0;i<inorder.length;i++) {\n        map.put(inorder[i],i);\n    }\n    return buildTree(inorder,0,inorder.length-1,postorder,0,postorder.length-1);\n}\n\npublic TreeNode buildTree(int[] inorder,int inL,int inR, int[] postorder,int pL,int pR) {\n    //递归出口只需要想一下边界，比如只要一个节点的时候，很明显只有一个节点的时候这几个值都是相等的\n    //但是此时肯定不能返回 null, 所以这里递归出口不是大于等于，而是大于\n    if (inL>inR || pL>pR) { \n        return null;\n    }\n    TreeNode root=new TreeNode(postorder[pR]);\n    int index=map.get(postorder[pR]);\n    root.left=buildTree(inorder,inL,index-1,postorder,pL,pL+index-inL-1);\n    root.right=buildTree(inorder,index+1,inR,postorder,pL+index-inL,pR-1);\n    return root;\n}\n```\n\n## [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n\n返回与给定的前序和后序遍历匹配的任何二叉树。\n\n pre 和 post 遍历中的值是不同的正整数。\n\n**示例：**\n\n```java\n输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\n输出：[1,2,3,4,5,6,7]\n```\n\n**提示：**\n\n- `1 <= pre.length == post.length <= 30`\n- `pre[]` 和 `post[]` 都是 1, 2, ..., pre.length 的排列\n- 每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。\n\n**解法一**\n\n和上面的有一点点区别\n\n```java\nHashMap<Integer,Integer> map=new HashMap<>();\n\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\n    for (int i=0;i<post.length;i++) {\n        map.put(post[i],i);\n    }\n    return constructFromPrePost(pre,0,pre.length-1,post,0,post.length-1);\n}\n\npublic TreeNode constructFromPrePost(int[] pre,int preL,int preR,int[] post,int postL,int postR){\n    if (preL>preR || postL>preR) {\n        return null;\n    }\n    TreeNode root=new TreeNode(pre[preL]);\n    if (preL==preR) {\n        return root;\n    }\n    int postIndex=map.get(pre[preL+1]); //这种位置一定要注意溢出\n    int len=postIndex-postL;\n    root.left=constructFromPrePost(pre,preL+1,preL+1+len,post,postL,postIndex);\n    root.right=constructFromPrePost(pre,preL+2+len,preR,post,postIndex+1,postR-1);\n    return root;\n}\n```\n![mark](http://static.imlgw.top/blog/20191106/pcmvnEK8Hwg8.png?imageslim)\n\n还是这张图，前序的第一个是根节点，后序的最后一个是根节点，而我们要找的是左右子树的分界线，这里没有中序遍历，乍一看似乎不好确定，其实不然，注意观察前序的第二个节点，也就是左子树的根节点，比如上面的 2，对应到后序遍历中其实正好就可以作为左子树的分界线，这样一来就和上面一样了，所以这里的关键就是找到一个划分点\n\n🔔 **有一点需要注意，题目说了这题的结果可能是不唯一的，数据结构的课程里面也讲过，仅凭前序和后序是无法确定一颗二叉树的，但是一定么？**\n\n并不一定，我们题目的 case 就是个反例，它就可以通过前序和后序唯一的确定这颗二叉树，那什么时候可以确定，什么时候无法确定呢？\n\n无法确定的例子好说，【1，2】，【2，1】这个就无法确定\n\n ```java\n  1              1   \n   \\            /\n    2          2        两种可能都有\n ```\n\n 但是如果是这样的【1，2，3】【2，3，1】这种就可以唯一的确定\n\n ```java\n  1\n / \\\n2   3  只可能是这种情况\n ```\n归纳总结一下，可以发现，**如果这颗二叉树每个节点的度都是 0 或者 2** 那么他就可以通过前序和后序确定，反之就不一定了，因为你只有一个子节点那么就无法确定这个节点是左节点还是右节点，如果没有或者两个都有那么就可以确定了（根据顺序确定，前面的是左后面的是右，但是你只有一个我就不知道是左还是右了）\n\n## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n\n给定一个二叉树，原地将它展开为链表。\n\n例如，给定二叉树\n\n```java\n\t1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n```\n\n将其展开为：\n\n```java\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n```\n\n> 题目没抄错，就是这样的，确实题目没有说明按照什么方式展开，但是看 case 能猜到是前序遍历的方式展开（靠猜的？）\n\n**解法一**\n\n前序遍历，递归的解法，用一个全局变量保存链表的结尾，每次将节点添加到 last 的后面\n\n```java\nTreeNode last=null;\n\npublic void flatten(TreeNode root) {\n    if (root==null) {\n        return;\n    }\n    if (last!=null) {\n        last.left=null;\n        last.right=root;\n    }\n    last=root;\n    TreeNode right=root.right;//保存右子树\n    flatten(root.left);\n    flatten(right);\n}\n```\n需要注意的地方就是需要保存右子树，因为前面的操作将左子树添加到根节点右子树的时候，会导致原本的右子树丢失\n\n**非递归的写法**\n\n```java\npublic void flatten(TreeNode root) {\n    if (root==null) return;\n    TreeNode last=null;\n    Deque<TreeNode> stack=new ArrayDeque<>();\n    stack.push(root);\n    while(!stack.isEmpty()){\n        TreeNode cur=stack.pop();\n        if(last!=null){\n            last.right=cur;\n            last.left=null;\n        }\n        last=cur;\n        if(cur.right!=null){\n            stack.push(cur.right);\n        }\n        if(cur.left!=null){\n            stack.push(cur.left);\n        }\n    }\n}\n```\n\n**解法二**\n\n变形的后序遍历，递归解法\n\n```java\nTreeNode pre=null;\n\npublic void flatten(TreeNode root) {\n    if (root==null) {\n        return;\n    }\n    flatten(root.right);\n    flatten(root.left);\n    root.right=pre;\n    root.left=null;\n    pre=root;\n}\n```\n相比前面的解法，为了不丢失右子树，先遍历右子树，再遍历左子树，整个序列就是`6 5 4 3 2 1`  我们只需要将每个节点的 right 指向前一个节点就 ok 了\n\n**解法三**\n\n迭代，我觉得这种解法挺秀，而且是完全的 `in-place`，但是时间复杂度会高一些，每个元素不只遍历一次\n\n```java\npublic void flatten(TreeNode root) {\n    TreeNode mRight=null;\n    while(root!=null){\n        if (root.left!=null) {\n            mRight=root.left;\n            //找到左子树的最右节点\n            while(mRight.right!=null){\n                mRight=mRight.right;\n            }\n            //将根的右节点接在 mRight.right\n            mRight.right=root.right;\n            //将 root.left 接在 root.right\n            root.right=root.left;\n            //左节点置为 null\n            root.left=null;\n        }\n        //重复该过程\n        root=root.right;\n    }\n}\n```\n画个图就是这样\n\n![mark](http://static.imlgw.top/blog/20191108/BIx12P1AYjeX.png?imageslim)\n\n## [面试题 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n\n![3VE7QO.png](https://s2.ax1x.com/2020/02/19/3VE7QO.png)\n\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n![Nn3iZR.png](https://s1.ax1x.com/2020/06/18/Nn3iZR.png)\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n\n**解法一**\n\n开始还以为挺难搞，一遍就写出来了😁比上一题简单\n\n```java\npublic Node treeToDoublyList(Node root) {\n    if(root==null) return root;\n    dfs(root);\n    head.left=lastNode;\n    lastNode.right=head;\n    return head;\n}\n\nNode lastNode,head=null;\n\npublic void dfs(Node root){\n    if(root==null) return;\n    dfs(root.left);\n    if(lastNode==null){\n        head=lastNode=root;\n    }else{\n        root.left=lastNode;\n        lastNode.right=root;\n        lastNode=root;\n    }\n    dfs(root.right);\n}\n```\n\n## [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)\n\n给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n```java\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL\n\n初始状态下，所有 next 指针都被设置为 NULL\n\n![leet](https://i.loli.net/2019/11/10/eC4VBqXmwuspZlG.png)\n\n**解法一**\n\n开始没做出来，菜！！！然后特意留到今天总结，又在 web 上提交了一遍\n\n```java\npublic Node connect(Node root) {\n    if (root ==null ||root.left==null) {\n        return root;\n    }\n    root.left.next=root.right;\n    if (root.next!=null) {\n        root.right.next=root.next.left;   \n    }\n    connect(root.left);\n    connect(root.right);\n    return root;\n}\n```\n**解法二**\n\n这个解法梳理还是很清奇的，类似拉拉链的过程\n\n```java\npublic Node connect(Node root) {\n    if (root ==null ||root.left==null) {\n        return root;\n    }\n    Node left=root.left;\n    Node right=root.right;\n    //有的像拉拉链的过程\n    while(left!=null){\n        left.next=right;\n        left=left.right;\n        right=right.left;\n    }\n    connect(root.left);\n    connect(root.right);\n    return root;\n}\n```\n\n> 还有一个很直白的层序遍历的方法，这里就不写了\n\n## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/) \n\n给定一个二叉树\n\n```java\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。\n\n初始状态下，所有 next 指针都被设置为 `NULL`。\n\n**进阶：**\n\n- 你只能使用常量级额外空间。\n- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n**示例：**\n\n![Y7BwBd.png](https://s1.ax1x.com/2020/05/20/Y7BwBd.png)\n\n```java\n输入：root = [1,2,3,4,5,null,7]\n输出：[1,#,2,3,#,4,5,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。\n```\n\n**提示：**\n\n- 树中的节点数小于 `6000`\n- `-100 <= node.val <= 100`\n\n**解法一**\n\n题目要求的 O(1) 空间，参考了大佬的解法，模拟层序遍历，着实是很巧妙，代码简洁清晰，值得细细品味\n\n```java\npublic Node connect(Node root) {\n    Node dummyNode=new Node(-1);\n    Node cur=root;\n    //cur 在上层，dummyNode 和 tail 在下层，tail 负责连接下层所有子节点\n    while(cur!=null){\n        dummyNode.next=null; //重置\n        Node tail=dummyNode;\n        while(cur!=null){\n            if(cur.left!=null){\n                tail.next=cur.left;\n                tail=tail.next;\n            }\n            if(cur.right!=null){\n                tail.next=cur.right;\n                tail=tail.next;\n            }\n            cur=cur.next;\n        }\n        cur=dummyNode.next; //cur 转换到下一层\n    }\n    return root;\n}\n```\n\n## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)\n\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n1. 首先找到需要删除的节点；\n\n2. 如果找到了，删除它。\n\n**说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。\n\n**示例：**\n\n```java\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\n给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n\n```\n\n**解法一**\n\n更多解释看另一篇 [二叉搜索树](http://imlgw.top/2019/11/08/er-fen-sou-suo-shu/#%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E5%80%BC)\n\n```java\npublic TreeNode deleteNode(TreeNode root, int key) {\n    if (root ==null) {\n        return null;           \n    }\n    if (root.val>key) {\n        root.left=deleteNode(root.left,key);\n    }else if (root.val<key) {\n        root.right=deleteNode(root.right,key);\n    }else{\n        if (root.left==null) {\n            return root.right;\n        }\n        if (root.right==null) {\n            return root.left;\n        }\n        //用右子树的最小值填补删除的元素\n        TreeNode delNode=root;\n        root=getMin(root.right);\n        //下面的 left 和 right 不能交换，还好刚开始写错了一波，不然也不会发现，哈哈啊哈哈哈\n        //这里的 deleteMin 是为了删除 delNode 的最小值 root, 如果你先把 delNode.left 连接到了 root.left\n        //那么 root 就不再是最小值了，再进行 deleteMin 就会导致 root 无法删除，最后返回 root, 导致 root.right=root 形成环\n        //结果无法打印\n        root.right=deleteMin(delNode.right);\n        root.left=delNode.left;\n    }\n    return root;\n}\n\npublic TreeNode deleteMin(TreeNode node){\n    if (node.left==null) {\n        return node.right;\n    }\n    node.left=deleteMin(node.left);\n    return node;\n}\n\npublic TreeNode getMin(TreeNode node){\n    if (node.left==null) {\n        return node;\n    }\n    return getMin(node.left);\n}\n```\n\n## [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。\n\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。\n\n例如，\n\n给定二叉搜索树：\n\n```java\n    4\n   / \\\n  2   7\n / \\\n1   3\n\n和 插入的值：5\n```\n\n你可以返回这个二叉搜索树：\n\n```java\n     4\n   /   \\\n  2     7\n / \\   /\n1   3 5\n```\n或者这个树也是有效的：\n\n```java\n     5\n   /   \\\n  2     7\n / \\   \n1   3\n     \\\n      4\n```\n\n**解法一**\n\n```java\npublic TreeNode insertIntoBST(TreeNode root, int val) {\n    if (root==null) {\n        return new TreeNode(val);\n    }\n    if (root.val>val) {\n        root.left=insertIntoBST(root.left,val);   \n    }else if (root.val<val) {\n        root.right=insertIntoBST(root.right,val);   \n    }\n    return root;\n}\n```\n没啥好说的，看代码就懂了\n\n## [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n\n给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。**这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。**\n\n每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的 null 节点也计入长度）之间的长度。\n\n**Example 1:**\n\n```java\nInput: \n\n           1\n         /   \\\n        3     2\n       / \\     \\  \n      5   3     9 \n\nOutput: 4\nExplanation: The maximum width existing in the third level with the length 4 (5,3,null,9).\n```\n\n**Example 2:**\n\n```java\nInput: \n\n          1\n         /  \n        3    \n       / \\       \n      5   3     \n\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n```\n\n**Example 3:**\n\n```java\nInput: \n\n          1\n         / \\\n        3   2 \n       /        \n      5      \n\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n```\n\n**Example 4:**\n\n```java\nInput: \n\n          1\n         / \\\n        3   2\n       /     \\  \n      5       9 \n     /         \\\n    6           7\nOutput: 8\nExplanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).\n```\n\n**Note:** Answer will in the range of 32-bit signed integer.\n\n**解法一**\n\n一开始居然没想到，哎😐还是菜啊\n\n```java\npublic int widthOfBinaryTree(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    Queue<TreeNode> queue=new LinkedList<>();\n    LinkedList<Integer> idxs=new LinkedList<>();\n    int max=1;\n    idxs.add(1);\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int size=queue.size();\n        while(size>0){\n            TreeNode top=queue.poll();\n            int index=idxs.removeFirst();\n            if (top.left!=null) {\n                queue.add(top.left);\n                idxs.add(index*2);\n            }\n            if (top.right!=null) {\n                queue.add(top.right);\n                idxs.add(index*2+1);\n            }\n            size--;\n        }\n        if (idxs.size()!=0) {\n            max=Math.max(idxs.getLast()-idxs.getFirst()+1,max);    \n        }\n    }\n    return max;\n}\n```\n还是层次遍历的思路，不过需要额外添加一个索引列表，用来**记录每个节点对应在完全二叉树中的索引**，这个索引值完全可以根据上一层父节点的索引的到，我们初始化定义根节点的 index 为 1，然后进行层次遍历记录每一层的每个节点的 index 就 ok，当遍历完一层之后统计列表最左和最右两个节点之差，这个值就是当前层的宽度，最后求个最大值就 ok 了，很可惜，看了答案才知道\n\n**解法二**\n\n递归版本\n\n```java\npublic int widthOfBinaryTree(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    dfs(root,0,0,new LinkedList<>());\n    return max;\n}\n\nint max=1;\n\npublic void dfs(TreeNode node,int depth,int index,List<Integer> leftIdxs){\n    if (node==null) {\n        return;\n    }\n    if (depth>=leftIdxs.size()) {\n        leftIdxs.add(index);\n    }\n    //记录当前节点和当前层最左节点的差\n    max=Math.max(index-leftIdxs.get(depth)+1,max);\n    dfs(node.left,depth+1,index*2,leftIdxs);\n    dfs(node.right,depth+1,index*2+1,leftIdxs);\n}\n```\n这个版本在空间复杂度可能会低一点，list 中只存每个层最左的节点，当深度大于等于 list 的长度时候说明当前节点一定是新一层的最左节点，这个时候添加进去就 ok，然后求每个节点和当前层最左的节点 index 差值就最后更新最大值就 ok，这个解法还是没有那么自然，还是上面的 BFS 好理解一点\n\n## [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)\n\n给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 \n\n给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。\n\n**示例 1:**\n\n```java\n输入：\n    2\n   / \\\n  2   5\n     / \\\n    5   7\n\n输出：5\n说明：最小的值是 2 ，第二小的值是 5 。\n```\n\n**示例 2:**\n\n```java\n输入：\n    2\n   / \\\n  2   2\n\n输出：-1\n说明：最小的值是 2, 但是不存在第二小的值。\n```\n\n**解法一**\n\n```go\n//自然的从上到下的思路\nvar INT_MAX = int(^uint(0) >> 1)\n\nfunc findSecondMinimumValue(root *TreeNode) int {\n\tres := dfs(root)\n\tif res == INT_MAX {\n\t\treturn -1\n\t}\n\treturn res\n}\n\nfunc dfs(root *TreeNode) int {\n\tif root == nil || root.Left == nil {\n\t\treturn INT_MAX\n\t}\n\t//和左右子树都不等，谁小就是谁\n\tif root.Val != root.Left.Val && root.Val != root.Right.Val {\n\t\treturn min(root.Left.Val, root.Right.Val)\n\t}\n\t//和左右子树都相等，分别在左右子树中找第二小比较\n\tif root.Val == root.Left.Val && root.Val == root.Right.Val {\n\t\treturn min(dfs(root.Left), dfs(root.Right))\n\t}\n\t//和左子树相等，在左子树中找第二小和右子树比较\n\tif root.Val == root.Left.Val {\n\t\treturn min(dfs(root.Left), root.Right.Val)\n\t}\n\t//同上\n\treturn min(dfs(root.Right), root.Left.Val)\n}\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t}\n\treturn a\n}\n```\n\n## [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)\n\n给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。\n\n二叉搜索树保证具有唯一的值。\n\n**示例 1：**\n\n```java\n输入：root = [10,5,15,3,7,null,18], L = 7, R = 15\n输出：32\n```\n\n**示例 2：**\n\n```java\n输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10\n输出：23\n```\n\n**提示：**\n\n- 树中的结点数量最多为 10000 个。\n- 最终的答案保证小于 2^31\n\n**解法一**\n\n还行，这题反应过来了，中序遍历\n\n```java\nprivate int sum=0;\n\npublic int rangeSumBST(TreeNode root, int L, int R) {\n    preorder(root,L,R);\n    return sum;\n}\n\npublic void preorder(TreeNode root, int L, int R) {\n    if (root==null) {\n        return;\n    }\n    rangeSumBST(root.left,L,R);\n    if (root.val>=L && root.val<=R) {\n        sum+=root.val;\n    }\n    rangeSumBST(root.right,L,R);\n}\n```\n\n## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)\n\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\n\n**示例 1:**\n\n```java\n输入：\n\tTree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \n输出：\n合并后的树：\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n```\n\n**注意：** 合并必须从两个树的根节点开始。\n\n**解法一**\n\n```java\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n    if (t2==null) {\n        return  t1;\n    }\n    if (t1==null) {\n        return t2;\n    }\n    t1.val+=t2.val;\n    t1.left=mergeTrees(t1.left,t2.left);\n    t1.right=mergeTrees(t1.right,t2.right);\n    return t1;\n}\n```\n\n## [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)\n\n给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。\n\n**示例 :**\n\n```java\n输入：\n\n   1\n    \\\n     3\n    /\n   2\n\n输出：\n1\n\n解释：\n最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。\n```\n\n**注意：** 树中至少有 2 个节点。\n\n**解法一**\n\n很可惜，这题还 WA 了一次。\n\n```java\npublic int getMinimumDifference(TreeNode root) {\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    int diff=Integer.MAX_VALUE,last=-1;\n    while(!stack.isEmpty() || cur!=null){\n        while(cur!=null){\n            stack.push(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        if (last!=-1) {\n            diff=Math.min(diff,Math.abs(last-cur.val));   \n        }\n        last=cur.val;\n        cur=cur.right;\n    }\n    return diff;\n}\n```\n**解法二**\n\n递归的方式\n\n```java\nprivate int diff = Integer.MAX_VALUE;\n\nprivate int last = -1;\n\npublic int getMinimumDifference(TreeNode root) {\n    inorder(root);\n    return diff;\n}\n\npublic void inorder(TreeNode root){\n    if (root==null) {\n        return;\n    }\n    inorder(root.left);\n    diff = last==-1?diff:Math.min(diff,Math.abs(last-root.val));\n    last = root.val;\n    inorder(root.right);\n}\n```\n\n## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)\n\nDifficulty: **简单**\n\n给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。\n\n假定 BST 有如下定义：\n\n*   结点左子树中所含结点的值小于等于当前结点的值\n*   结点右子树中所含结点的值大于等于当前结点的值\n*   左子树和右子树都是二叉搜索树\n\n例如：  \n给定 BST `[1,null,2,2]`,\n\n```go\n   1\n    \\\n     2\n    /\n   2\n```\n\n`返回 [2]`.\n\n**提示**：如果众数超过 1 个，不需考虑输出顺序\n\n**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\n\n**解法一**\n\n之前忘了记录了，中序遍历统计答案就 ok，但是非要严格的 O(1) 就需要使用 Morris 遍历（不会\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findMode(root *TreeNode) []int {\n    var dfs func(root *TreeNode)\n    var prev *TreeNode\n    var count, max = 0, 0\n    var res []int\n    dfs = func(root *TreeNode) {\n        if root == nil {\n            return\n        }\n        dfs(root.Left)\n        if prev == nil || prev.Val == root.Val {\n            count++\n        } else {\n            count = 1\n        }\n        if count == max {\n            res = append(res, root.Val)\n        }\n        if count > max {\n            res = []int{}\n            res = append(res, root.Val)\n            max = count\n        }\n        prev = root\n        dfs(root.Right)\n    }\n    dfs(root)\n```\n\n## [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)\n\n您需要在二叉树的每一行中找到最大的值。\n\n**示例：**\n\n```java\n输入：\n\t  1\n     / \\\n    3   2\n   / \\   \\  \n  5   3   9 \n输出：[1, 3, 9]\n```\n\n**解法一**\n\n娱乐题\n\n```java\npublic List<Integer> largestValues(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    dfs(root,res,0);\n    return res;\n}\n\npublic void dfs(TreeNode node,List<Integer> list,int level){\n    if (node==null) {\n        return;\n    }\n    if (level>=list.size()) {\n        list.add(node.val);\n    }\n    if(node.val>list.get(level)){\n        list.set(level,node.val);\n    }\n    dfs(node.left,list,level+1);\n    dfs(node.right,list,level+1);\n}\n```\n\n## [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n\n实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。\n\n调用 `next()` 将返回二叉搜索树中的下一个最小的数。\n\n **示例：**\n\n![leetcode](https://i.loli.net/2019/12/25/TXK397rI5hwjG4B.png)\n\n```java\nBSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false\n```\n\n**提示：**\n\n- next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 **O(h)** 内存，其中 h 是树的高度。\n- 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。 \n\n**解法一**\n\n注意这题空间复杂度要求是`O(h)` ，并不是憨憨题\n\n```java\nStack<TreeNode> stack=new Stack<>();\n\npublic BSTIterator(TreeNode root) {\n    pushLeft(root);\n}\n\npublic int next() {\n    TreeNode node=stack.pop();\n    if (node.right!=null) {\n        pushLeft(node.right);\n    }\n    return node.val;\n}\n\npublic boolean hasNext() {\n    return !stack.isEmpty();\n}\n\npublic void pushLeft(TreeNode node){\n    while(node!=null){\n        stack.add(node);\n        node=node.left;\n    }\n}\n```\n\n我们可以用一个 stack 存储 BST 的左链，当取最小值就从 stack 中直接取，如果取出来的 node 还有右子树就将右子树的左链也添加进来，是不是有点熟悉？其实就是中序遍历的过程\n\n## [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n给定一个整数 n，生成所有由 1 ... n 为节点所组成的**二叉搜索树**。\n\n**示例：**\n\n```java\n输入：3\n输出：\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n解释：\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n```\n\n**解法一**\n\n```java\npublic  List<TreeNode> generateTrees(int n) {\n    if(n<=0){\n        return new ArrayList<>();\n    }\n    return generateTrees(1,n);\n}\n\npublic List<TreeNode> generateTrees(int start,int end) {\n    List<TreeNode> res=new ArrayList<>();\n    if (start>end) {\n        //null 也是一种情况，左右子树为空\n        res.add(null);\n        return res;\n    }\n    for (int i=start;i<=end;i++) {\n        List<TreeNode> left=generateTrees(start,i-1);\n        List<TreeNode> right=generateTrees(i+1,end);\n        for (TreeNode l:left) {\n            for (TreeNode r:right) {\n                TreeNode currentNode=new TreeNode(i);\n                currentNode.left=l;\n                currentNode.right=r;\n                res.add(currentNode);\n            }\n        }\n    }\n    return res;\n}\n```\n很久之前做过的题，今天又拿出来看看，其实属于分治思路\n\n## [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)\n\n给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。\n\n**例如：**\n\n```java\n输入：二叉搜索树：\n              5\n            /   \\\n           2     13\n\n输出：转换为累加树：\n             18\n            /   \\\n          20     13\n```\n\n**解法一**\n\n这里我想先上一个**错误的解法**\n\n```java\n//以下代码纯属娱乐\npublic TreeNode convertBST(TreeNode root) {\n    if (root==null) {\n        return new TreeNode(0);//这里肯定是错的，null 应该直接返回 null\n    }\n    if (root.left==null && root.right==null) {\n        return root;\n    }\n    root.val+= convertBST(root.right).val;\n    convertBST(root.left).val+=root.val;\n    return root;\n}\n```\n\n忽略返回值的部分，乍一看好像是对的😂，其实问题大了，首先是左边的值算的不对，因为是 DFS 会从最左边开始算，都只加了他的父节点原始的值，而父节点的累加值还没有算出来，其次有些情况是算不出来的比如左子树的某一个右节点你就算不出来\n\n**解法二**\n\n其实一开始就知道可以直接中序遍历做，只是想玩一些其他的方法，可惜没搞出来😂\n\n```java\npublic TreeNode convertBST(TreeNode root) {\n    dfs(root);\n    return root;\n}\n\nprivate int sum=0;\n\npublic void dfs(TreeNode root){\n    if (root==null) {\n        return;\n    }\n    dfs(root.right);\n    sum+=root.val;\n    root.val=sum;\n    dfs(root.left);\n}\n```\n这里需要注意的就是要翻过来遍历，从大到小，因为它求的是比它大的节点的值\n\n## [508. 出现次数最多的子树元素和](https://leetcode-cn.com/problems/most-frequent-subtree-sum/)\n\n给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。\n\n**示例 1**\n\n```java\n输入：\n\n  5\n /  \\\n2   -3\n返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。\n```\n\n**示例 2**\n\n```java\n输入：\n\n  5\n /  \\\n2   -5\n返回 [2]，只有 2 出现两次，-5 只出现 1 次。\n```\n\n**解法一**\n\n左子树和+右子树和，HashMap 记录出现的次数，记录最大值然后取出出现次数最多的\n\n```java\nprivate Map<Integer,Integer> map = new HashMap<>();\n\nprivate int maxCount=0;\n\npublic int[] findFrequentTreeSum(TreeNode root) {\n    if (root ==null) {\n        return new int[]{};\n    }\n    dfs(root);\n    List<Integer> res=new ArrayList<>();\n    map.keySet().stream().filter(val->map.get(val)==maxCount).forEach(res::add);\n    return res.stream().mapToInt(Integer::valueOf).toArray(); //list 转数组的又一个小技巧，单纯的 toArray 只能转换成 Integer[], 还需要转\n}\n\npublic int dfs(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    int value=root.val+dfs(root.right)+dfs(root.left);\n    map.put(value,map.getOrDefault(value,0)+1);\n    maxCount=Math.max(maxCount,map.get(value));\n    return value;\n}\n```\n\n写法是基于 Lambda 的，函数式写起来真的舒服\n\n## [606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)\n\n你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。\n\n空节点则用一对空括号 \"()\" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。\n\n**示例 1:**\n\n```java\n输入：二叉树：[1,2,3,4]\n       1\n     /   \\\n    2     3\n   /    \n  4     \n\n输出：\"1(2(4))(3)\"\n\n解释：原本将是“1(2(4)())(3())”，\n在你省略所有不必要的空括号对之后，\n它将是“1(2(4))(3)”。\n```\n\n**示例 2:**\n\n```java\n输入：二叉树：[1,2,3,null,4]\n       1\n     /   \\\n    2     3\n     \\  \n      4 \n\n输出：\"1(2()(4))(3)\"\n\n解释：和第一个示例相似，\n除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。\n```\n\n**解法一**\n\n```java\npublic String tree2str(TreeNode t) {\n    StringBuilder s=new StringBuilder();\n    dfs(t,s);\n    return s.toString();\n}\n\npublic void dfs(TreeNode node,StringBuilder s){\n    if (node==null) {\n        return;\n    }\n    s.append(node.val);\n    if(node.left==null && node.right==null){//没有子节点\n        return;\n    }\n    s.append(\"(\");\n    dfs(node.left,s);\n    s.append(\")\");\n    if (node.right==null) { //没有右节点\n        return;\n    }\n    s.append(\"(\");\n    dfs(node.right,s);\n    s.append(\")\");\n}\n```\n\n没啥好说的，搞清楚题目意思然后注意递归的几个出口就行了\n\n## [1315. 祖父节点值为偶数的节点和](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/)\n\n给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：\n\n该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）\n如果不存在祖父节点值为偶数的节点，那么返回 0 。\n\n**示例：**\n\n![1473_ex1.png](https://i.loli.net/2020/01/13/CgBK9WOMbNvxJpY.png)\n\n```java\n输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n输出：18\n解释：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。\n```\n\n**提示：**\n\n- 树中节点的数目在 `1` 到 `10^4` 之间。\n- 每个节点的值在 `1` 到 `100` 之间。\n\n**解法一**\n\n好像是 170 前一天的双周赛的第 3 题，还是很直白的题，遍历的时候带上它的 father 的值和 grandfather 的值带到下一层，然后判断就可以了\n\n```java\npublic int sumEvenGrandparent(TreeNode root) {\n    return dfs(root,-1,-1);\n}\n\npublic int dfs(TreeNode node,int fa,int ga){\n    if (node==null) {\n        return 0;\n    }\n    int sum=0;\n    if (fa!=-1 && ga!=-1 && ga%2==0) {\n        sum+=node.val;\n    }\n    sum+=dfs(node.left,node.val,fa);\n    sum+=dfs(node.right,node.val,fa);\n    return sum;\n}\n```\n\n## [1026. 节点与其祖先之间的最大差值](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/) \n\n给定二叉树的根节点 `root`，找出存在于不同节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。\n\n（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）\n\n**示例：**\n\n![YpF3r9.png](https://s1.ax1x.com/2020/05/03/YpF3r9.png)\n\n```java\n输入：[8,3,10,1,6,null,14,null,null,4,7,13]\n输出：7\n解释： \n我们有大量的节点与其祖先的差值，其中一些如下：\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\n在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。\n```\n\n**提示：**\n\n1. 树中的节点数在 `2` 到 `5000` 之间。\n2. 每个节点的值介于 `0` 到 `100000` 之间。\n\n**解法一**\n\n水题，维护每条路径上的最值，然后统计最大差就行了\n\n```go\nfunc maxAncestorDiff(root *TreeNode) int {\n    var res = 0\n    dfs(root, 1<<30, -1>>30, &res)\n    return res\n}\n\nfunc dfs(root *TreeNode, min, max int, res *int) {\n    if root == nil {\n        return\n    }\n    min = fmin(min, root.Val)\n    max = fmax(max, root.Val)\n    *res = fmax(max-min, *res)\n    dfs(root.Left, min, max, res)\n    dfs(root.Right, min, max, res)\n}\n\nfunc fmin(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc fmax(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n```\n\n## [1325. 删除给定值的叶子节点](https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/)\n\n给你一棵以 `root` 为根的二叉树和一个整数 `target` ，请你删除所有值为 `target` 的 叶子节点 。\n\n注意，一旦删除值为 `target` 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 `target` ，那么这个节点也应该被删除。\n\n也就是说，你需要重复此过程直到不能继续删除。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/01/28/e7dOxoLNciVa4Uf.png)\n\n```java\n输入：root = [1,2,3,2,null,2,4], target = 2\n输出：[1,null,3,null,4]\n解释：\n上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。\n有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。\n```\n\n**示例 2：**\n\n![image.png](https://i.loli.net/2020/01/28/aNLo4wQz3C1ZiAf.png)\n\n```java\n输入：root = [1,3,3,3,2], target = 3\n输出：[1,3,null,null,2]\n```\n\n**示例 3：**\n\n![image.png](https://i.loli.net/2020/01/28/JHBRy7uZDFWLMVT.png)\n\n```java\n输入：root = [1,2,null,2,null,2], target = 2\n输出：[1]\n解释：每一步都删除一个绿色的叶子节点（值为 2）。\n```\n\n**提示：**\n\n- `1 <= target <= 1000`\n- 每一棵树最多有 `3000` 个节点。\n- 每一个节点值的范围是 `[1, 1000]` 。\n\n**解法一**\n\n某次周赛的第三题\n\n```java\npublic TreeNode removeLeafNodes(TreeNode root, int target) {\n    return delete(root,target);\n}\n\npublic TreeNode delete(TreeNode root,int target){\n    if (root==null) {\n        return null;\n    }\n    root.left=delete(root.left,target);\n    root.right=delete(root.right,target);\n    if (root.left==null && root.right==null && root.val==target) {\n        return null;\n    }\n    return root;\n}\n```\n搞了半天。一开始写的时候写的前序遍历的方式，先删除自己然后再去删除左右孩子，然后在如何判断是否有叶子节点上卡了半天，最后写了个 for3000 的循环过的。好菜啊，只要交换一下顺序变成后序遍历的方式，先删除左右子节点，然后再回头删除自己的就可以一直删了。\n\n## [1305. 两棵二叉搜索树中的所有元素](https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/)\n\n给你 `root1` 和 `root2` 这两棵二叉搜索树。\n\n请你返回一个列表，其中包含 **两棵树** 中的所有整数并按 **升序** 排序。.\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/01/31/Hy3MEwa4sRO6jUq.png)\n\n```java\n输入：root1 = [2,1,4], root2 = [1,0,3]\n输出：[0,1,1,2,3,4]\n```\n\n**示例 2：**\n\n```java\n输入：root1 = [0,-10,10], root2 = [5,1,7,0,2]\n输出：[-10,0,0,1,2,5,7,10]\n```\n\n**示例 3：**\n\n```java\n输入：root1 = [], root2 = [5,1,7,0,2]\n输出：[0,1,2,5,7]\n```\n\n**示例 4：**\n\n```java\n输入：root1 = [0,-10,10], root2 = []\n输出：[-10,0,10]\n```\n\n**解法一**\n\n某次周赛的题，大水题，白板回忆写出了中序的非递归 haha，感觉忘不了了\n\n```java\npublic List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n    //return megerList(inorder(root1),0,inorder(root2),0);\n    return megerList(inorder(root1),inorder(root2));\n}\n\npublic List<Integer> inorder(TreeNode root){\n    List<Integer> res=new ArrayList<>();\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    while(!stack.isEmpty() || cur!=null){\n        while(cur!=null){\n            stack.add(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        res.add(cur.val);\n        cur=cur.right;\n    }\n    return res;\n}\n\npublic List<Integer> megerList(List<Integer> list1,List<Integer> list2){\n    List<Integer> res=new ArrayList<>();\n    int index1=0,index2=0;\n    while(index1<list1.size() && index2<list2.size()){\n        res.add(list1.get(index1)<list2.get(index2)?list1.get(index1++):list2.get(index2++));\n    }\n    while(index1<list1.size()){\n        res.add(list1.get(index1++));\n    }\n    while(index2<list2.size()){\n        res.add(list2.get(index2++));\n    }\n    return res;\n}\n\n//递归的 TLE 了 42/48, 不停的创建 list 太耗时了\npublic List<Integer> megerList(List<Integer> list1,int index1,List<Integer> list2,int index2){\n    List<Integer> res=new ArrayList<>();\n    if (index1==list1.size()) {\n        for (int i=index2;i<list2.size();i++) {\n            res.add(list2.get(i));\n        }\n        return res;\n    }\n    if (index2==list2.size()) {\n        for (int i=index1;i<list1.size();i++) {\n            res.add(list1.get(i));\n        }\n        return res;\n    }\n    if (list1.get(index1)<list2.get(index2)) {\n        res.add(list1.get(index1));\n        res.addAll(megerList(list1,index1+1,list2,index2));\n    }else{\n        res.add(list2.get(index2));\n        res.addAll(megerList(list1,index1,list2,index2+1));\n    }\n    return res;\n}\n```\n\n## [1339. 分裂二叉树的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/)\n\n给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。\n\n由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/02/HT93vAj7gcXwY8U.png)\n\n```java\n输入：root = [1,2,3,4,5,6]\n输出：110\n解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）\n```\n\n**示例 2：**\n\n![image.png](https://i.loli.net/2020/02/02/Fit7Xl2jkzCZyhV.png)\n\n```java\n输入：root = [1,null,2,3,4,null,null,5,6]\n输出：90\n解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）\n```\n\n**解法一**\n\n174 周赛的第三题，当时比赛 TLE 了。写了个很蠢的算法\n\n```java\nprivate long mod=1000000007;\n\npublic int maxProduct(TreeNode root) {\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    long sumAll=sum(root);\n    while(!stack.isEmpty() || cur!=null){\n        TreeNode temp=null;\n        long s=0L;\n        while(cur!=null){\n            temp=cur.left;\n            cur.left=null;\n            long r=sum(root);\n            s=r*(sumAll-r);\n            max=Math.max(s,max);\n            cur.left=temp;\n            stack.add(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        temp=cur.right;\n        cur.right=null;\n        long r=sum(root);\n        s=r*(sumAll-r);\n        max=Math.max(s,max);\n        cur.right=temp;\n        cur=cur.right;\n    }\n    return (int)(max%mod);\n}\n\nprivate long max=-1;\n\npublic long sum(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    return root.val+sum(root.left)+sum(root.right);\n}\n```\n\n我居然真的去删除节点去了。导致后面都没办法对 sum 做记忆化，太菜了啊\n\n**解法二**\n\n能 AC 但是效率感人\n\n```java\nprivate long mod=1000000007;\n\nprivate long sumAll=0;\n\nprivate long max=-1;\n\npublic int maxProduct(TreeNode root) {\n    sumAll=sum(root);\n    dfs(root);\n    return (int)(max%mod);\n}\n\npublic void dfs(TreeNode root){\n    if (root==null) {\n        return;\n    }\n    long temp=sum(root);\n    max=Math.max(max,temp*(sumAll-temp));\n    dfs(root.left);\n    dfs(root.right);\n}\n\nprivate HashMap<String,Long> cache=new HashMap<>();\n\npublic long sum(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    if (cache.containsKey(root.toString())) {\n        return cache.get(root.toString());\n    }\n    cache.put(root.toString(),root.val+sum(root.left)+sum(root.right));\n    return cache.get(root.toString());\n}\n```\n\n**解法三**\n\n标准`O(N)`的解法\n\n```java\nprivate long mod=1000000007;    \n\nList<Long> sum=new ArrayList<>();\n\n//标准解法\npublic int maxProduct(TreeNode root) {\n    long max=-1;\n    long sumAll=dfs(root);\n    for (Long s:sum) {\n        max=Math.max(max,s*(sumAll-s));    \n    }\n    return (int)(max%mod);\n}\n\npublic long dfs(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    sum.add(root.val+dfs(root.left)+dfs(root.right));\n    return sum.get(sum.size()-1);\n}\n```\n\n在 dfs 的过程中将子树的 sum 存起来，然后直接遍历 list，求 `max(s*(sumAll-s))`就 ok\n\n> 这里最开始被大数据也卡了一会儿，不知道啥时候取模，其实这里题目没有那么难，相乘的结果并不会溢出 Long，如果要是溢出 Long 的话可能就要用什么带模快速乘了\n\n## [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n**示例：** \n\n```java\n你可以将以下二叉树：\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\n序列化为 \"[1,2,3,null,null,4,5]\"\n```\n\n**提示：** 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n**说明：** 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。\n\n**解法一**\n\n层序遍历非递归的方式\n\n```java\n//层序遍历的方式\npublic String serialize(TreeNode root) {\n    if (root==null) {\n        return \"\";\n    }\n    //BFS\n    StringBuilder sb=new StringBuilder();\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        TreeNode cur=queue.poll();\n        if (cur!=null) {\n            sb.append(cur.val+\",\");\n            queue.add(cur.left);\n            queue.add(cur.right);\n        }else{\n            sb.append(\"null,\"); //会多很多 null, 不过影响不大\n        }\n    }\n    return sb.toString();\n}\n\n//按照题目意思写代码就 ok\npublic TreeNode deserialize(String data) {\n    if (\"\".equals(data)) {\n        return null;\n    }\n    String[] treeData=data.split(\",\");\n    int index=0;\n    TreeNode root=node(treeData[index]);\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        TreeNode cur=queue.poll();\n        cur.left=node(treeData[++index]);\n        if (cur.left!=null) {\n            queue.add(cur.left);\n        }\n        cur.right=node(treeData[++index]);\n        if (cur.right!=null) {\n            queue.add(cur.right);\n        }\n    }\n    return root;\n}\n\npublic TreeNode node(String str){\n    if (!\"null\".equals(str)) {\n        return new TreeNode(Integer.valueOf(str));\n    }\n    return null;\n}\n```\n\n**解法二**\n\n前序遍历递归方式，我们将序列化的结果存在一个`queue`中，然后从头开始取，因为是前序遍历，所以整体结构肯定是`【root,root.left,root.right】` \n\n反序列化关键就是如何区分左右子树，仅仅依靠一个前序遍历是无法重建二叉树的，所以我们可以做一些小手段，在序列化节点为空的时候加入`null`字符，这样左右节点就会被连续的两个`[null,null]`分隔开，方便重建\n\n> eg.  示例一：  1,2,null,null,3,4,null,null,5,null,null\n\n```java\npublic TreeNode node(String str){\n    if (!\"null\".equals(str)) {\n        return new TreeNode(Integer.valueOf(str));\n    }\n    return null;\n}\n\npublic String serialize(TreeNode root) {\n    if (root==null) {\n        return \"null\";\n    }\n    return root.val+\",\"+serialize(root.left)+\",\"+serialize(root.right);\n}\n\npublic TreeNode deserialize(String data) {\n    if (\"\".equals(data)) {\n        return null;\n    }\n    String[] dataTree=data.split(\",\");\n    Queue<String> queue=new LinkedList<>(Arrays.asList(dataTree));\n    return deserialize(queue);\n}\n\npublic TreeNode deserialize(Queue<String> queue){\n    String val=queue.poll();\n    if (\"null\".equals(val)) {\n        return null;\n    }\n    TreeNode root=node(val);\n    root.left=deserialize(queue);\n    root.right=deserialize(queue);\n    return root;\n}\n```\n**解法三**\n\n补充一个 go 的写法，和解法二的思路是一样的\n```go\ntype Codec struct {\n}\n\nfunc Constructor() Codec {\n    return Codec{}\n}\n\n// Serializes a tree to a single string.\nfunc (this *Codec) serialize(root *TreeNode) string {\n    if root == nil {\n        return \"nil\"\n    }\n    return strconv.Itoa(root.Val) + \",\" + this.serialize(root.Left) + \",\" + this.serialize(root.Right)\n}\n\n// Deserializes your encoded data to tree.\nfunc (this *Codec) deserialize(data string) *TreeNode {\n    queue := strings.Split(data, \",\")\n    return this.des(&queue)\n}\n\nfunc (this *Codec) des(queue *[]string) *TreeNode {\n    if len(*queue) == 0 {\n        return nil\n    }\n    cur := (*queue)[0]\n    *queue = (*queue)[1:]\n    if cur == \"nil\" {\n        return nil\n    }\n    val, _ := strconv.Atoi(cur)\n    root := &TreeNode{Val: val}\n    root.Left = this.des(queue)\n    root.Right = this.des(queue)\n    return root\n}\n```\n## [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)\n序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。\n\n设计一个算法来序列化和反序列化二叉搜索树。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。\n\n编码的字符串应尽可能紧凑。\n\n**注意：** 不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。\n\n**解法一**\n\n题目说 `编码的字符串应尽可能紧凑`，所以直接把上面 297 的搬过来其实不太好，因为会有很多 null 字符，并且也没有用到题目二`bst`的条件，`bst`只需要知道一个前序或者后序就可以还原整棵树，题目就变成了根据`前序/后序`和`中序`还原二叉树\n\n`golang`新手，用`golang`写了一发，感觉写复杂了（官方解法中还有更加激进的压缩编码的方式，感觉有点偏了）\n\n```go\ntype Codec struct {\n}\n\nfunc Constructor() Codec {\n    return Codec{}\n}\n\n// Serializes a tree to a single string.\nfunc (this *Codec) serialize(root *TreeNode) string {\n    if root == nil {\n        return \"\"\n    }\n    var queue []string\n    var dfs func(root *TreeNode)\n    dfs = func(root *TreeNode) {\n        if root == nil {\n            return\n        }\n        queue = append(queue, strconv.Itoa(root.Val))\n        dfs(root.Left)\n        dfs(root.Right)\n    }\n    dfs(root)\n    return strings.Join(queue, \",\")\n}\n\n// Deserializes your encoded data to tree.\nfunc (this *Codec) deserialize(data string) *TreeNode {\n    if data == \"\" {\n        return nil\n    }\n    //fmt.Println(data)\n    queue := strings.Split(data, \",\")\n    inOrder := make([]int, len(queue))\n    for i, v := range queue {\n        inOrder[i], _ = strconv.Atoi(v)\n    }\n    preOrder := make([]int, len(inOrder))\n    copy(preOrder, inOrder)\n    sort.Ints(inOrder)\n    var dfs func(preOrder, inOrder []int) *TreeNode\n    dfs = func(preOrder, inOrder []int) *TreeNode {\n        if len(inOrder) == 0 {\n            return nil\n        }\n        root := &TreeNode{Val: preOrder[0]}\n        rootIdx := 0\n        for i, v := range inOrder {\n            if v == preOrder[0] {\n                rootIdx = i\n                break\n            }\n        }\n        root.Left = dfs(preOrder[1:rootIdx+1], inOrder[:rootIdx])\n        root.Right = dfs(preOrder[rootIdx+1:], inOrder[rootIdx+1:])\n        return root\n    }\n    return dfs(preOrder, inOrder)\n}\n```\n\n## [面试题 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n\n参考以下这颗二叉搜索树：\n\n```java\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n```\n**示例 1：**\n\n```java\n输入：[1,6,3,2,5]\n输出：false\n```\n\n**示例 2：**\n\n```java\n输入：[1,3,2,6,5]\n输出：true\n```\n\n**提示：**\n\n1. `数组长度 <= 1000`\n\n**解法一**\n\n核心在于意识到最后一个节点是根节点\n\n```java\npublic boolean verifyPostorder(int[] postorder) {\n    if(postorder==null || postorder.length<=0) return true;\n    return verify(postorder,0,postorder.length-1);\n}\n\npublic boolean verify(int[] postorder,int left,int right){\n    if(left>=right) return true;\n    int root=postorder[right];\n    //WA 点，这里要设置成 left-1 防止没有左子树的情况，比如 5 4 3 2 1\n    //这样可以跳过第二个循环并且不用递归验证左子树\n    int index=left-1;\n    for(int i=right-1;i>=left;i--){ //从后往前找第一个小于 root\n        if(postorder[i]<root){\n            index=i; //找到第一个小于 root 的，作为左子树的根\n            break;\n        }\n    }\n    //判断左子树是否都是小于 root 的\n    for(int i=index;i>=left;i--){\n        if(postorder[i]>root){\n            return false;\n        }\n    }\n    //递归验证左右子树\n    return verify(postorder,left,index) && verify(postorder,index+1,right-1);\n}\n```\n这题 WA 了 3 发，前两发是代码逻辑的问题，想简化代码，结果把自己带坑里面去了，最后一次是因为一个变量设置的问题，代码中已经注释\n\n**UPDATE: 2020.7.14**\n\n重写了下，这样写就不会有奇怪的 WA 点了，还是要多注意细节和边界\n```golang\nfunc verifyPostorder(post []int) bool {\n    return dfs(post, 0, len(post)-1)\n}\n\nfunc dfs(post[] int, left int, right int) bool {\n    if left>=right{\n        return true\n    }\n    var p = right-1\n    for p >= left && post[p] > post[right]{\n        p--\n    }\n    for i := p; i >= left; i--{\n        if post[i] > post[right]{\n            return false\n        }\n    }\n    return dfs(post, left, p) && dfs(post, p+1,right-1)\n}\n```\n\n**解法二**\n\n单调栈的解法，放在 [单调栈专题](http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/#%E9%9D%A2%E8%AF%95%E9%A2%9833-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97) 中\n\n## [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)\n\n给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：\n\n1. 二叉树的根是数组中的最大元素。\n2. 左子树是通过数组中最大值左边部分构造出的最大二叉树。\n3. 右子树是通过数组中最大值右边部分构造出的最大二叉树。\n\n通过给定的数组构建最大二叉树，并且输出这个树的根节点。\n\n**示例 ：**\n\n```java\n输入：[3,2,1,6,0,5]\n输出：返回下面这棵树的根节点：\n\t  6\n\t/   \\\n   3     5\n    \\    / \n     2  0   \n       \\\n        1\n```\n\n**提示：**\n\n1. 给定的数组的大小在 [1, 1000] 之间。\n\n**解法一**\n\n```java\n//不做预处理，直接搜索 2ms, 我这个 50ms+..... 懒得改的就当练手了\npublic TreeNode constructMaximumBinaryTree(int[] nums) {\n    int n=nums.length;\n    int[][] max=new int[n][n];\n    for(int i=0;i<n;i++){\n        max[i][i]=i;\n        for(int j=i+1;j<n;j++){\n            max[i][j]=nums[j]>nums[max[i][j-1]]?j:max[i][j-1];\n        }\n    }\n    return dfs(nums,0,n-1,max);\n}\n\npublic TreeNode dfs(int[] nums,int left,int right,int[][] max){\n    if(left>right) return null;\n    int maxIdx=max[left][right];\n    TreeNode root=new TreeNode(nums[maxIdx]);\n    root.left=dfs(nums,left,maxIdx-1,max);\n    root.right=dfs(nums,maxIdx+1,right,max);\n    return root;\n}\n```\n\n> 慢的主要原因是构建这个树的话大概只会查询 logN 次（树高度）最大值，而每层查询的复杂度和为 N，所以整体的复杂度其实只要 O(NlogN)，除非数组完全有序，这样每次分割都及其不均匀，数的高度为 N 时间复杂度才会到 N^2，而我这个就直接是 N^2 了 hhhhh，太菜了，预处理的思想是好的，但是还是要看具体的题目，这里其实很多的区间值都用不上（除非搞线段树🤣\n\n**解法二**\n\n这题也可以用单调栈做，明天写，这题还有个 2，明天一起做了\n\n## [998. 最大二叉树 II](https://leetcode-cn.com/problems/maximum-binary-tree-ii/)\n\n题目描述很辣鸡，简单来说就是在`最大二叉树 A`的右边插入一个 val，仍然是最大二叉树\n\n**解法一**\n\n```java\npublic TreeNode insertIntoMaxTree(TreeNode root, int val) {\n    if(root==null){\n        return new TreeNode(val);\n    }\n    if(root.val>val){\n        root.right=insertIntoMaxTree(root.right,val);    \n        return root;\n    }\n    TreeNode newRoot=new TreeNode(val);\n    newRoot.left=root;\n    return newRoot;\n}\n```\n## [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)\n\n给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意**一棵**的根结点即可。\n\n两棵树重复是指它们具有相同的结构以及相同的结点值。\n\n**示例 1：**\n\n```java\n        1\n       / \\\n      2   3\n     /   / \\\n    4   2   4\n       /\n      4\n```\n\n下面是两个重复的子树：\n\n```java\n      2\n     /\n    4\n```\n\n和\n\n```java\n    4\n```\n\n因此，你需要以列表的形式返回上述重复子树的根结点。\n\n**解法一**\n\n做了忘了加上了，序列化子树，用哈希表判重就行了\n\n```java\nHashMap<String,Integer> map=new HashMap<>();\n\nList<TreeNode> res=new ArrayList<>();\n\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n    dfs(root);\n    return res;\n}\n\npublic String dfs(TreeNode root){\n    if(root==null){\n        //return \"#null\";\n        return \"null\";\n    }\n    //String key=\"#\"+root.val+dfs(root.left)+dfs(root.right);\n    String key=root.val+dfs(root.left)+dfs(root.right);\n    int count=map.getOrDefault(key,0);\n    if(count==1){\n        res.add(root);\n    }\n    map.put(key,count+1);\n    return key;\n}\n```\n\n> 这题少了 case，不加分隔符也能 A，我以为会卡这个，试了下结果没卡，100 积分到手 ==>  [issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/284) \n\n## [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)\n\n给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\n\n**案例 1:**\n\n```java\n输入：\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 9\n\n输出：True\n```\n\n**案例 2:**\n\n```java\n输入：\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 28\n\n输出：False\n```\n\n**解法一**\n\n开始还想着在 logN 的解法，发现好像搞不了，而且这是个 easy 题，所以肯定就是直接中序+双指针了\n\n```go\nfunc findTarget(root *TreeNode, k int) bool {\n    var inorder []int\n    dfs(root, &inorder)\n    i, j := 0, len(inorder)-1\n    for i < j {\n        if inorder[i]+inorder[j] < k {\n            i++\n        } else if inorder[i]+inorder[j] > k {\n            j--\n        } else {\n            return true\n        }\n    }\n    return false\n}\n\nfunc dfs(root *TreeNode, inorder *[]int) {\n    if root == nil {\n        return\n    }\n    dfs(root.Left, inorder)\n    *inorder = append(*inorder, root.Val)\n    dfs(root.Right, inorder)\n}\n```\n\n## [872. 叶子相似的树](https://leetcode-cn.com/problems/leaf-similar-trees/)\n\n请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 *叶值序列* 。\n\n![YDcL28.png](https://s1.ax1x.com/2020/05/14/YDcL28.png)\n\n举个例子，如上图所示，给定一颗叶值序列为 `(6, 7, 4, 9, 8)` 的树。\n\n如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 *叶相似* 的。\n\n如果给定的两个头结点分别为 `root1` 和 `root2` 的树是叶相似的，则返回 `true`；否则返回 `false` 。\n\n**提示：**\n\n- 给定的两颗树可能会有 `1` 到 `200` 个结点。\n- 给定的两颗树上的值介于 `0` 到 `200` 之间。\n\n**解法一**\n\n换成`StringBuilder`可能会快一点\n\n```java\n//没啥好说的\npublic boolean leafSimilar(TreeNode root1, TreeNode root2) {\n    if(root1==null || root2==null) return false;\n    return dfs(root1).equals(dfs(root2));\n}\n\npublic String dfs(TreeNode root){\n    if(root==null){\n        return \"\";\n    }\n    if(root.left==null && root.right==null){\n        return \"#\"+root.val;\n    }\n    return dfs(root.left)+dfs(root.right);\n}\n```\n> 当时看到这题就着会不会又有 case 遗漏，比如不加分隔符什么的，结果看到 github 已经有人先手提交了\n\n## [5398. 统计二叉树中好节点的数目](https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/)\n\n给你一棵根为 `root` 的二叉树，请你返回二叉树中好节点的数目。\n\n「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。\n\n**示例 1：**\n\n![YREc7j.png](https://s1.ax1x.com/2020/05/17/YREc7j.png)\n\n```java\n输入：root = [3,1,4,3,null,1,5]\n输出：4\n解释：图中蓝色节点为好节点。\n根节点 (3) 永远是个好节点。\n节点 4 -> (3,4) 是路径中的最大值。\n节点 5 -> (3,4,5) 是路径中的最大值。\n节点 3 -> (3,1,3) 是路径中的最大值。\n```\n\n**示例 2：**\n\n![YREukR.png](https://s1.ax1x.com/2020/05/17/YREukR.png)\n\n```java\n输入：root = [3,3,null,4,2]\n输出：3\n解释：节点 2 -> (3, 3, 2) 不是好节点，因为 \"3\" 比它大。\n```\n\n**示例 3：**\n\n```java\n输入：root = [1]\n输出：1\n解释：根节点是好节点。\n```\n\n**提示：**\n\n- 二叉树中节点数目范围是 `[1, 10^5]` 。\n- 每个节点权值的范围是 `[-10^4, 10^4]` 。\n\n**解法一**\n\n26th 双周赛的 t3，水题\n\n```java\nint count=0;\n\npublic int goodNodes(TreeNode root) {\n    if(root==null) return 0;\n    dfs(root,root.val);\n    return count;\n}\n\npublic void dfs(TreeNode root,int max){\n    if(root==null){\n        return;\n    }\n    if(max<=root.val){\n        count++;\n        max=root.val;\n    }\n    dfs(root.left,max);\n    dfs(root.right,max);\n}\n```\n\n## [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)\n\n给定一个二叉搜索树，同时给定最小边界`L` 和最大边界 `R`。通过修剪二叉搜索树，使得所有节点的值在`[L, R]`中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。\n\n**示例 1:**\n\n```\n输入：\n    1\n   / \\\n  0   2\n\n  L = 1\n  R = 2\n\n输出：\n    1\n      \\\n       2\n```\n\n**示例 2:**\n\n```java\n输入：\n    3\n   / \\\n  0   4\n   \\\n    2\n   /\n  1\n\n  L = 1\n  R = 3\n\n输出：\n      3\n     / \n   2   \n  /\n 1\n```\n\n**解法一**\n\n没啥好说的，递归后序遍历就完事了，树的题还是挺套路的\n\n```java\npublic TreeNode trimBST(TreeNode root, int L, int R) {\n    if(root==null){\n        return root;\n    }\n    root.left=trimBST(root.left,L,R);\n    root.right=trimBST(root.right,L,R);\n    //root.val<L, 左子树全部小于 L\n    if(root.val<L){\n        return root.right;\n    }\n    if(root.val>R){\n        return root.left;\n    }\n    return root;\n}\n```\n## [814. 二叉树剪枝](https://leetcode-cn.com/problems/binary-tree-pruning/)\n\nDifficulty: **中等**\n\n给定二叉树根结点 `root` ，此外树的每个结点的值要么是 0，要么是 1。\n\n返回移除了所有不包含 1 的子树的原二叉树。\n\n( 节点 X 的子树为 X 本身，以及所有 X 的后代。)\n\n```golang\n示例 1:\n输入：[1,null,0,0,1]\n输出：[1,null,0,null,1]\n\n解释：\n只有红色节点满足条件“所有不包含 1 的子树”。\n右图为返回的答案。\n```\n\n```golang\n示例 2:\n输入：[1,0,1,0,0,0,1]\n输出：[1,null,1,null,1]\n\n```\n\n```golang\n示例 3:\n输入：[1,1,0,1,1,0,1,0]\n输出：[1,1,0,1,1,null,1]\n\n```\n\n**说明：**\n\n*   给定的二叉树最多有 `100` 个节点。\n*   每个节点的值只会为 `0` 或 `1` 。\n\n**解法一**\n\n和上面差不多，感觉应该是是 easy。\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc pruneTree(root *TreeNode) *TreeNode {\n    if root == nil{\n        return nil\n    }\n    root.Left = pruneTree(root.Left)\n    root.Right = pruneTree(root.Right)\n    if root.Left == nil && root.Right==nil && root.Val == 0{\n        return nil\n    }\n    return root\n}\n```\n\n## [965. 单值二叉树](https://leetcode-cn.com/problems/univalued-binary-tree/)\n\n题目就不 copy 了，二叉树只有一个值，水题\n\n**解法一**\n\n```java\npublic boolean isUnivalTree(TreeNode root) {\n    return dfs(root,root.val);\n}\n\npublic boolean dfs(TreeNode root,int val){\n    if(root==null) return true;\n    return root.val==val && dfs(root.left,val) && dfs(root.right,val);\n}\n```\n\n## [1145. 二叉树着色游戏](https://leetcode-cn.com/problems/binary-tree-coloring-game/)\n\n有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 `root`，树上总共有 `n` 个节点，且 `n` 为奇数，其中每个节点上的值从 `1` 到 `n` 各不相同。\n\n游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，\n\n「一号」玩家从 `[1, n]` 中取一个值 `x`（`1 <= x <= n`）；\n\n「二号」玩家也从 `[1, n]` 中取一个值 `y`（`1 <= y <= n`）且 `y != x`。\n\n「一号」玩家给值为 `x` 的节点染上红色，而「二号」玩家给值为 `y` 的节点染上蓝色。\n\n之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 **未着色** 的邻节点（即左右子节点、或父节点）进行染色。\n\n如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。\n\n若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。\n\n现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 `y` 值可以确保你赢得这场游戏，则返回 `true`；若无法获胜，就请返回 `false`。\n\n**示例：**\n\n![tpXUW6.png](https://s1.ax1x.com/2020/05/25/tpXUW6.png)\n\n```java\n输入：root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\n输出：True\n解释：第二个玩家可以选择值为 2 的节点。\n```\n\n**提示：**\n\n- 二叉树的根节点为 `root`，树上由 `n` 个节点，节点上的值从 `1` 到 `n` 各不相同。\n- `n` 为奇数。\n- `1 <= x <= n <= 100`\n\n**解法一**\n\n第一个选手选择了一个节点之后，将二叉树实际上划分为了 3 个区域，左孩子区域，右孩子区域，还有父节点所在区域，三个区域以 x 为界限，没有交集，第二个选手需要在三个区域中选取一个区域，使自己能赢，很明显我们肯定要选最大的那个区域，所以我们只需要判断最大的区域是否比剩下其他部分和都要大就行了\n\n```java\nint max=0;\n\npublic boolean btreeGameWinningMove(TreeNode root, int n, int x) {\n    dfs(root,x,n);\n    return max>n-max;\n}\n\npublic int dfs(TreeNode root,int x,int n){\n    if(root==null) return 0;\n    int left=dfs(root.left,x,n);\n    int right=dfs(root.right,x,n);\n    if(root.val==x){\n        max=Math.max(left,max);\n        max=Math.max(right,max);\n        max=Math.max(n-left-right-1,max);\n    }\n    return left+right+1;\n}\n```\n\n## [993. 二叉树的堂兄弟节点](https://leetcode-cn.com/problems/cousins-in-binary-tree/)\n\n在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。\n\n如果二叉树的两个节点深度相同，但**父节点不同**，则它们是一对*堂兄弟节点*。\n\n我们给出了具有唯一值的二叉树的根节点 `root`，以及树中两个不同节点的值 `x` 和 `y`。\n\n只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true`。否则，返回 `false`。\n\n**示例 1：**\n\n![tsO8yR.png](https://s1.ax1x.com/2020/06/05/tsO8yR.png)\n\n```java\n输入：root = [1,2,3,4], x = 4, y = 3\n输出：false\n```\n\n**示例 2：**\n\n![tsOYex.png](https://s1.ax1x.com/2020/06/05/tsOYex.png)\n\n```java\n输入：root = [1,2,3,null,4,null,5], x = 5, y = 4\n输出：true\n```\n\n**示例 3：**\n\n![tsOaFO.png](https://s1.ax1x.com/2020/06/05/tsOaFO.png)\n\n```java\n输入：root = [1,2,3,null,4], x = 2, y = 3\n输出：false\n```\n\n**提示：**\n\n1. 二叉树的节点数介于 `2` 到 `100` 之间。\n2. 每个节点的值都是唯一的、范围为 `1` 到 `100` 的整数。\n\n**解法一**\n\n二叉树水题（3 天没刷新题了，再不刷几道实在是说不过其了，刷题还是要保持手感啊）\n\n```go\nfunc isCousins(root *TreeNode, x int, y int) bool {\n    var depX = -1\n    var pX *TreeNode\n    var depY = -1\n    var pY *TreeNode\n    var dfs func(root, parent *TreeNode, x, y int, depth int)\n    dfs = func(root, parent *TreeNode, x, y int, depth int) {\n        if root == nil { //按题目说的这里其实不需要\n            return\n        }\n        if root.Val == x {\n            depX = depth\n            pX = parent\n            //结束该子树的搜索，加快速度，下面即使有 Y 也肯定不是 X 的堂兄弟\n            return\n        }\n        if root.Val == y {\n            depY = depth\n            pY = parent\n            //同上\n            return\n        }\n        dfs(root.Left, root, x, y, depth+1)\n        dfs(root.Right, root, x, y, depth+1)\n    }\n    dfs(root, nil, x, y, 0)\n    return pX != pY && depX == depY\n}\n```\n\n有一个小的优化点还是挺有意思的，就是 return 的地方，一开始没考虑这么多，AC 了之后感觉不对，是不是 LC 又少 CASE 了，结果仔细一想发现这里是个优化点😁\n\n## [440. 字典序的第 K 小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)\n\n给定整数 `n` 和 `k`，找到 `1` 到 `n` 中字典序第 `k` 小的数字。\n\n注意：1 ≤ k ≤ n ≤ 1e9。\n\n**示例 :**\n\n```java\n输入：\nn: 13   k: 2\n\n输出：\n10\n\n解释：\n字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。\n```\n**解法一**\n\n一开始看了评论区说了 10 叉树，然后我就顺着这个思路去想了，然后就直接去前序遍历了，然后就 T 了，这里看下数据范围就知道肯定是过不了的\n```java\n//TLE\npublic int findKthNumber(int n, int k) {\n    for (int i=1;i<=9;i++) {\n        dfs(i,n,k);\n    }\n    return res;\n}\n\nint idx=0,res=-1;\n\npublic void dfs(int cur,int n,int k){\n    if(res!=-1) return;\n    if(cur>n) return;\n    idx++;\n    if(k==idx){\n        res=cur;\n        return;\n    }\n    for (int i=0;i<=9;i++) {\n        dfs(cur*10+i,n,k);\n    }\n}\n```\n**解法二**\n\n直接遍历肯定是行不通，那么就只能想办法跳过一些节点，这里我们就可以通过计算每个节点的子节点的个数来判断第 k 个是不是在该节点下，而子节点的个数就可以用`Min(n+1,next*10)-cur`计算得到，`next`是和 cur 相邻的节点，`n`是最大值，画个图就懂了\n![mark](http://static.imlgw.top/blog/20200614/3WPecCGnzxQl.png?imageslim)\n```golang\n//UPDATE: 2020.7.29 之前的代码细节有的不好理解，重写了一版\n//正解\nfunc findKthNumber(n int, k int) int {\n    //k 和 count 都是从 1 开始\n    var cur = 1\n    for k > 1 {\n        count := getChild(cur, n)\n        if count < k { //不在该节点下，切换成兄弟节点\n            cur++ \n            k-=count\n        } else { //在该节点下，切换成子节点\n            cur *= 10\n            k--\n        }\n    }\n    return cur\n}\n\n//当前节点下有多少个子节点，也就是以 cur 开头的有多少个（包括 cur）\nfunc getChild(cur int, n int) int {\n    var count = 0\n    var next = cur+1\n    for cur <= n {\n        count += Min(n+1, next) - cur\n        cur *= 10\n        next *= 10\n    }\n    return count\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n## [386. 字典序排数](https://leetcode-cn.com/problems/lexicographical-numbers/)\n给定一个整数 n, 返回从 1 到 n 的字典顺序。\n\n例如，\n\n给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。\n\n请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。\n\n**解法一**\n\n先做的上面那一题，再做这一题就简单多了，前面 tle 的方法就是这里的正解，十叉树的前序遍历\n```java\nList<Integer> res=new ArrayList<>();\n\npublic List<Integer> lexicalOrder(int n) {\n    for(int i=1;i<=9;i++){\n        dfs(i,n);   \n    }\n    return res;\n}\n\npublic void dfs(int cur,int n){\n    if(cur>n) return;\n    res.add(cur);\n    for(int i=0;i<=9;i++){\n        dfs(cur*10+i,n);   \n    }\n}\n```\n## [1028. 从先序遍历还原二叉树](https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/)\n\n我们从二叉树的根节点 root 开始进行深度优先搜索。\n\n在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。\n\n如果节点只有一个子节点，那么保证该子节点为左子节点。\n\n给出遍历输出 S，还原树并返回其根节点 root。\n\n**示例 1：**\n```java\n输入：\"1-2--3--4-5--6--7\"\n输出：[1,2,5,3,4,6,7]\n```\n**示例 2：**\n```java\n输入：\"1-2--3---4-5--6---7\"\n输出：[1,2,5,3,null,6,null,4,null,7]\n```\n**示例 3：**\n```java\n输入：\"1-401--349---90--88\"\n输出：[1,401,null,349,88,90]\n```\n**提示：**\n原始树中的节点数介于 1 和 1000 之间。\n每个节点的值介于 1 和 10 ^ 9 之间。\n\n**解法一**\n\n抄答案，第一天看了几分钟，一开始想写递归，直接看了答案，第二天还是没有完整的写出来，其实这题迭代会好理解很多，递归的看了下，有点不好理解，很 trick\n```java\npublic TreeNode recoverFromPreorder(String S) {\n    //栈中存的是深度严格单调递增（步伐为 1）的节点 0 1 2 3 4....\n    Deque<TreeNode> stack=new ArrayDeque(); \n    int i=0;\n    while(i<S.length()){\n        int depth=0;\n        while(i<S.length() && S.charAt(i)=='-') {\n            depth++;\n            i++;\n        }\n        int val=0;\n        while(i<S.length() && S.charAt(i)>='0' && S.charAt(i)<='9'){\n            val=val*10+S.charAt(i)-48;\n            i++;\n        }\n        TreeNode node=new TreeNode(val);\n        if(depth==stack.size()){ //栈的节点数量就是当前的深度\n            if(!stack.isEmpty()) stack.peek().left=node;\n        }else{\n            while(depth!=stack.size()){\n                stack.pop();\n            }\n            //depth==0 的只有一个根节点，是不会走这个分支的，所以这里肯定不为空\n            stack.peek().right=node;\n        }\n        stack.push(node);\n    }\n    while(stack.size()!=1) stack.pop();\n    return stack.pop();\n}\n```\n\n## [897. 递增顺序查找树](https://leetcode-cn.com/problems/increasing-order-search-tree/)\n\n给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。\n\n**示例 ：**\n```java\n输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]\n\n       5\n      / \\\n    3    6\n   / \\    \\\n  2   4    8\n /        / \\ \n1        7   9\n\n输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\n 1\n  \\\n   2\n    \\\n     3\n      \\\n       4\n        \\\n         5\n          \\\n           6\n            \\\n             7\n              \\\n               8\n                \\\n                 9  \n```\n \n**提示：**\n\n给定树中的结点数介于 1 和 100 之间。每个结点都有一个从 0 到 1000 范围内的唯一整数值。\n\n**解法一**\n\ngo 中序遍历配合全局变量，没啥好说的（看评论区很多人直接 new TreeNode 感觉不太好吧，题目的意思不是在原树上改么？）\n```golang\nfunc increasingBST(root *TreeNode) *TreeNode {\n    var dfs func(root *TreeNode)\n    dummyNode:=&TreeNode{}\n    last:=dummyNode\n    dfs = func(root *TreeNode){\n        if root==nil{\n            return\n        }\n        dfs(root.Left)\n        root.Left=nil\n        last.Right=root\n        last = root\n        dfs(root.Right)\n    }\n    dfs(root)\n    return dummyNode.Right\n}\n```\n> 这题和 [面试题 17.12. BiNode](https://leetcode-cn.com/problems/binode-lcci/) 解法是一摸一样的，但是这个 sb 题的描述我是真没看懂，结合评论区和 case 才知道到底要干啥，看评论区好像都整的挺明白的，一度以为我理解能力出了问题\n\n## [979. 在二叉树中分配硬币](https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/)\n\nDifficulty: **中等**\n\n给定一个有 `N` 个结点的二叉树的根结点 `root`，树中的每个结点上都对应有 `node.val` 枚硬币，并且总共有 `N` 枚硬币。\n\n在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。（移动可以是从父结点到子结点，或者从子结点移动到父结点。)。\n\n返回使每个结点上只有一枚硬币所需的移动次数。\n\n**示例 1：**\n![UTOOLS1594052444483.png](https://upload.cc/i1/2020/07/07/w2G7JY.png)\n\n```go\n输入：[3,0,0]\n输出：2\n解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。\n```\n\n**示例 2：**\n\n![UTOOLS1594052495418.png](https://upload.cc/i1/2020/07/07/kPOvxa.png)\n\n```go\n输入：[0,3,0]\n输出：3\n解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。\n```\n\n**示例 3：**\n\n![UTOOLS1594052508155.png](https://upload.cc/i1/2020/07/07/j4YpZS.png)\n\n```go\n输入：[1,0,2]\n输出：2\n```\n\n**示例 4：**\n\n![UTOOLS1594052519453.png](https://upload.cc/i1/2020/07/07/DYZ6cE.png)\n\n```go\n输入：[1,0,0,null,3]\n输出：4\n```\n\n**提示：**\n\n1.  `1<= N <= 100`\n2.  `0 <= node.val <= N`\n\n**解法一**\n\n一开始直接想出来的做法，后面看了其他人的解法发现还不太一样😂，不过我还是感觉我的方法更好理解\n```golang\n//闭包的写法\nfunc distributeCoins(root *TreeNode) int {\n    var res = 0\n    var Abs = func(a int) int {\n        if a < 0 {\n            return -a\n        }\n        return a\n    }\n    //dfs 返回树的节点数量 和 金币数量\n    var dfs func(*TreeNode) (int, int)\n    dfs = func(root *TreeNode) (int, int) {\n        if root == nil {\n            return 0, 0\n        }\n        lCount, lCoins := dfs(root.Left)\n        //其实两者的差值就是需要经过该节点中转的次数\n        //统计出所有节点的中转次数就是整体的转移次数\n        res += Abs(lCount - lCoins)\n        rCount, rCoins := dfs(root.Right)\n        res += Abs(rCount - rCoins)\n        return 1 + lCount + rCount, root.Val + lCoins + rCoins\n    }\n    dfs(root)\n    return res\n}\n```\n\n**解法二**\n\n其他人的做法，dfs 返回节点的盈亏值（节点数和金币数的差值），盈亏值绝对值之和就是总体的转移次数（所以两种解法其实是一样的，只是计算的时间不一样，我的是函数返回后计算盈亏，而下面的解法是返回前计算盈亏，感觉我的更好理解😂）\n```golang\n//另一种做法\nfunc distributeCoins(root *TreeNode) int {\n    var res = 0\n    var Abs = func(a int) int {\n        if a < 0 {\n            return -a\n        }\n        return a\n    }\n    var dfs func(*TreeNode) int\n    dfs = func(root *TreeNode) int {\n        if root == nil {\n            return 0\n        }\n        left := dfs(root.Left)\n        right := dfs(root.Right)\n        res += Abs(left) + Abs(right)\n        return root.Val + left + right - 1\n    }\n    dfs(root)\n    return res\n}\n```\n\n## [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)\n\nDifficulty: **困难**\n\n二叉搜索树中的两个节点被错误地交换。\n\n请在不改变其结构的情况下，恢复这棵树。\n\n**示例 1:**\n\n```go\n输入：[1,3,null,null,2]\n\n   1\n  /\n 3\n  \\\n   2\n\n输出：[3,1,null,null,2]\n\n   3\n  /\n 1\n  \\\n   2\n```\n\n**示例 2:**\n\n```go\n输入：[3,1,4,null,null,2]\n\n  3\n / \\\n1   4\n   /\n  2\n\n输出：[2,1,4,null,null,3]\n\n  2\n / \\\n1   4\n   /\n  3\n```\n\n**进阶：**\n\n*   使用 O(_n_) 空间复杂度的解法很容易实现。\n*   你能想出一个只使用常数空间的解决方案吗？\n\n**解法一**\n\n中序遍历，记录下位置不对的节点，最后交换他们的值就行了\n```golang\nfunc recoverTree(root *TreeNode) {\n    var node1 *TreeNode\n    var node2 *TreeNode\n    //这里犯了一个错误，一开始给 pre 赋值了一个 root, 导致节点记录错了\n    var pre *TreeNode\n    var dfs func(*TreeNode)\n    dfs = func(root *TreeNode) {\n        if root == nil {\n            return\n        }\n        dfs(root.Left)\n        if pre != nil && root.Val < pre.Val {\n            if node1 == nil {\n                node1 = pre\n            }\n            node2 = root\n        }\n        pre = root\n        dfs(root.Right)\n    }\n    dfs(root)\n    node1.Val, node2.Val = node2.Val, node1.Val\n}\n```\n这种解法严格来说空间复杂度并不是 O(1)，递归会有系统栈的开销，空间复杂度应该是 O(h)，h 是树的高度，真正的 O(1) 的做法应该是 Morris 遍历，这种解法就称得上 hard 了\n\n## [1302. 层数最深叶子节点的和](https://leetcode-cn.com/problems/deepest-leaves-sum/)\n\nDifficulty: **中等**\n\n给你一棵二叉树，请你返回层数最深的叶子节点的和。\n\n**示例：**\n\n![wmC0aT.png](https://s1.ax1x.com/2020/09/06/wmC0aT.png)\n\n```\n输入：root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n输出：15\n```\n\n**提示：**\n\n*   树中节点数目在 `1` 到 `10^4` 之间。\n*   每个节点的值在 `1` 到 `100` 之间。\n\n**解法一**\n\nBFS 没啥好说的，DFS 的挺有意思\n```golang\nfunc deepestLeavesSum(root *TreeNode) int {\n    var dfs func(*TreeNode, int)\n    var maxDep = 0\n    var sum = 0\n    dfs = func(root *TreeNode, dep int) {\n        if root == nil {\n            return\n        }\n        if maxDep == dep {\n            sum += root.Val\n        }\n        if dep > maxDep {\n            sum = root.Val\n            maxDep = dep\n        }\n        dfs(root.Left, dep+1)\n        dfs(root.Right, dep+1)\n        \n    }\n    dfs(root, 0)\n    return sum\n}\n```\n\n## _树形 DP（大概）_\n\n> 2020.5.10 更新，在看了左神的书后，大概了解了树形 DP，所谓的树形 DP 实际上就是把递推方程搬到了树结构上，按我的理解树形 DP 很大的特点就是最终的解可能存在于树上每个节点，像我下面的题有的暴力解用的就是双重递归，就是 dfs 遍历没个节点，然后再对每个节点递归求解，但是对根节点求解的时候，实际上其他的子节点都成了子问题，所以后面再对子节点求解的时候问题就重复了，所以就可以采用后序遍历，自底向上，先求左右节点的值再更新根节点，**下面的题其实我不知道到底是不是属于树形 DP，可能太简单了，但是再我看来解法比较统一，很有套路所以整理到一起**，我查了下网上介绍的树形 DP 还是挺难的，后面有时间了解后再来记录\n\n## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n>  一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1\n\n**示例 1:**\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回 true 。\n\n**示例 2:**\n\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n\n```java\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n```\n\n返回 false 。\n\n**解法一**\n\n暴力法，结合上面的 [二叉树最大深度](#104. 二叉树的最大深度)，**自顶向下**，求左右子树的高度差\n\n```java\n//top 2 bottom\npublic boolean isBalanced(TreeNode root) {\n    if (root==null) return true;\n    if (Math.abs(hight(root.left)-hight(root.right))>1) {\n        return false;\n    }\n    return isBalanced(root.left) && isBalanced(root.right);\n}\n\npublic int hight(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    return Math.max(hight(root.right),hight(root.left))+1;\n}\n```\n自顶向下，先判断根节点，然后判断左右子树，很明显。在判断左右子树的时候，会重复的遍历判断根节点的时候已经遍历过的节点，时间复杂度应该是`O(N^2)`\n\n**解法二**\n\n自底向上，利用一个实例变量保存结果，其实就是在上面的求 heigh 过程中将左右子树的高度先取出来直接比较，如果差距大于 1 就直接记录下结果 false，但是其实这里还是可以优化下\n\n```java\nprivate boolean ans=true;\n\n//buttom 2 top\npublic boolean isBalanced(TreeNode root) {\n    if (root==null) return true;\n    hight(root);\n    return ans;\n}\n\npublic int hight(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    //递归分治，自底向上，在求高度的过程中计算左右高度差\n    int left=hight(root.left);\n    int right=hight(root.right);\n    if (Math.abs(left-right)>1) {\n        ans=false;\n    }\n    return Math.max(left,right)+1;\n}\n```\n自底向上，只需要遍历一遍二叉树就可以得到结果，时间复杂度`O(N)` \n\n**解法三**\n\n```java\npublic boolean isBalanced(TreeNode root) {\n    if (root==null) return true;\n    return hight(root)!=-1;\n}\n\npublic int hight(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    int left=hight(root.left);\n    if (left==-1) {\n        return -1;\n    }\n    int right=hight(root.right);\n    if (right==-1) {\n        return -1;\n    }\n    return Math.abs(left-right)>1?-1:Math.max(left,right)+1;\n}\n```\n\n在不符合的时候一路`return -1` 节省后面的计算\n\n## [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)\n\n给定一个二叉树，计算整个树的坡度。\n\n一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是 0。\n\n整个树的坡度就是其所有节点的坡度之和。\n\n**示例：**\n\n```java\n输入：\n         1\n       /   \\\n      2     3\n输出：1\n解释：\n结点的坡度 2 : 0\n结点的坡度 3 : 0\n结点的坡度 1 : |2-3| = 1\n树的坡度 : 0 + 0 + 1 = 1\n```\n\n**注意：**\n\n1. 任何子树的结点的和不会超过 32 位整数的范围。\n2. 坡度的值不会超过 32 位整数的范围。. \n\n**解法一**\n\n很快写出来的解法，发现这题和上面的 **平衡二叉树** 有异曲同工之妙！\n\n```java\n//首先想到的解法\npublic int findTilt(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    return findTilt(root.left)+findTilt(root.right)+Math.abs(childSum(root.left)-childSum(root.right));\n}\n\npublic int childSum(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    return childSum(root.left)+childSum(root.right)+root.val;\n}\n```\n嵌套递归，相当暴力\n\n**解法二**\n\n上面的做法确实有点可惜，其实在计算 childSum 的时候就可以字节把坡度算出来然后累加就是整体的坡度\n\n```java\nint tilt=0;\n\n//结果发现上面的做法傻逼了。其实我知道是不对的，但是不知道咋改，不过写了个嵌套递归也还行 hahaha\npublic int findTilt(TreeNode root) {\n    childSum(root);\n    return tilt;\n}\n\npublic int childSum(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    int left=childSum(root.left);\n    int right=childSum(root.right);\n    tilt+=Math.abs(left-right);\n    return left+right+root.val;\n}\n```\n\n## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)\n\n给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。\n\n**示例 :**\n给定二叉树\n\n```java\n      1\n     / \\\n    2   3\n   / \\     \n  4   5    \n```\n返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n\n**注意：**两结点之间的路径长度是以它们之间边的数目表示\n\n**解法一**\n\n树的题目做多了，发现其实也就几种题型，都很熟悉，这题就和上面的 [二叉树的坡度]() ，[平衡二叉树]() 很类似，这题需要注意**直径不一定过根节点**\n\n```java\nint max=Integer.MIN_VALUE;\n\npublic int diameterOfBinaryTree(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    hight(root);\n    return max;\n}\n\npublic int hight(TreeNode node){\n    if (node==null) {\n        return 0;\n    }\n    int left=hight(node.left);\n    int right=hight(node.right);\n    max=Math.max(left+right,max);\n    return Math.max(left,right)+1;\n}\n```\n\n**解法二**\n\n和之前一样，先写了个暴力的嵌套递归😂，代码确实简介，难道这就是暴力美学么，i 了\n\n```java\npublic int diameterOfBinaryTree(TreeNode root) {\n    return root==null?0:Math.max(hight(root.left)+hight(root.right),Math.max(diameterOfBinaryTree(root.right),diameterOfBinaryTree(root.left)));\n}\n\npublic int hight(TreeNode node){\n    return node==null?0:Math.max(hight(node.left),hight(node.right))+1;\n}\n```\n\n## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)\n\n给定一个**非空**二叉树，返回其最大路径和。\n\n本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。\n\n**示例 1:**\n\n```java\n输入：[1,2,3]\n   1\n  / \\\n 2   3\n输出：6\n```\n\n**示例 2:**\n\n```java\n输入：[-10,9,20,null,null,15,7]\n   -10\n   / \\\n  9  20\n    /  \\\n   15   7\n\n输出：42\n```\n\n**错误解法**\n\n先上一个错误答案，过了 `71/93` 个 case（lc 的 case 好少）\n\n```java\npublic int maxPathSum(TreeNode root) {\n    if (root==null) {\n        return Integer.MIN_VALUE;\n    }\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    int res=helper(root);\n    return Math.max(res,Math.max(maxPathSum(root.left),maxPathSum(root.right)));\n}\n\n//以当前节点为根的最大路径和\npublic int helper(TreeNode root){\n    if(root==null) return Integer.MIN_VALUE;;\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    int left=helper(root.left);\n    int right=helper(root.right);\n    return root.val+(left>0?left:0)+(right>0?right:0);\n}\n```\n我一开始的想法是按照根节点来讨论的，每个节点的最大值就是 左右子树的最大路径和（大于 0）加上当前节点的值，改了半天 WA 了几发后发现是有问题的\n\n```java\n     1 \n   /   \\\n  2     3\n / \\   / \\\n7   9  5  6\n```\n\n比如这样的，2 为根的最长路径是 1，2，9 但是这个在 1 为根的节点中是不合法的，所以我们需要的只有单边的路径和，如上图的树，我们需要的就是 `2->9` 这条路径，所以我们需要再添加一个求最长路径的函数\n\n**解法二**\n\n可 AC，但是效率较低\n\n```java\npublic int maxPathSum(TreeNode root) {\n    if (root==null) {\n        return Integer.MIN_VALUE;\n    }\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    int res=helper(root);\n    return Math.max(res,Math.max(maxPathSum(root.left),maxPathSum(root.right)));\n}\n\n//以当前节点为根的最大路径和（双边）\npublic int helper(TreeNode root){\n    if(root==null) return Integer.MIN_VALUE;\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    int left=dfs(root.left);\n    int right=dfs(root.right);\n    return root.val+(left>0?left:0)+(right>0?right:0);\n}\n\n//root 为起始节点的最大路径和（单边）\n//这里可以 cache 一下\n//cache 前 219ms\n//cache 后 30ms\n\nprivate  HashMap<String,Integer> cache=new HashMap<>();\n\npublic int dfs(TreeNode root){\n    if (root==null) {\n        return Integer.MIN_VALUE;\n    }\n    if (cache.containsKey(root.toString())) {\n        return cache.get(root.toString());\n    }\n    int left=dfs(root.left);\n    int right=dfs(root.right);\n    int max=Math.max(left,right);\n    cache.put(root.toString(),root.val+(max>0?max:0));\n    return root.val+(max>0?max:0);\n}\n```\n**解法三**\n\n这个解法其实就是将我前面的代码逻辑简化了，核心的思路还是一样的\n\n```java\nprivate int res=Integer.MIN_VALUE;\n\npublic int maxPathSum(TreeNode root) {\n    helper(root);\n    return res;\n}\n\n//返回以当前节点为*起点*的最大路径和（单边，左右子树中选最大的一个）\npublic int helper(TreeNode root){\n    if(root==null) return 0;\n    int left=Math.max(helper(root.left),0);\n    int right=Math.max(helper(root.right),0);\n    res=Math.max(res,root.val+left+right); //在这里记录最大值\n    return root.val+Math.max(left,right); //返回的实际上是我上面 dfs 的结果\n}\n```\n\n在递归函数中用全局变量记录最大值，最后返回的却是**单边**的最大值，也就是我上面写的 dfs 函数返回的值，可以说是相当巧妙了，除此外对递归的出口也进行了简化\n\n**Update: 2020.6.21**\n\n用 go 重写一下，最近很喜欢写这种闭包的结构，感觉比较简洁\n```golang\nfunc maxPathSum(root *TreeNode) int {\n    res:=-1<<31\n    var Max =func(a,b int) int {\n        if a>b{\n            return a   \n        }\n        return b\n    }\n    //以 root 开头最大单侧路径\n    var dfs func(root *TreeNode) int\n    dfs = func(root *TreeNode) int {\n        if root==nil{\n            return -1<<31 //返回的小于 0 就行\n        }\n        left:=Max(0,dfs(root.Left))\n        right:=Max(0,dfs(root.Right))\n        res=Max(res,left+right+root.Val)\n        return root.Val+Max(left,right)\n    }\n    dfs(root)\n    return res\n}\n```\n\n## [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)\n\n给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。\n\n**注意**：两个节点之间的路径长度由它们之间的边数表示。\n\n**示例 1:**\n\n输入：\n\n```java\n              5\n             / \\\n            4   5\n           / \\   \\\n          1   1   5\n```\n\n输出：\n\n```java\n2\n```\n\n**示例 2:**\n\n输入：\n\n```java\n              1\n             / \\\n            4   5\n           / \\   \\\n          4   4   5\n```\n\n输出：\n\n```java\n2\n```\n\n**注意：** 给定的二叉树不超过 10000 个结点。 树的高度不超过 1000。\n\n**错误解法**\n\n其实写了一会儿就意识到和上面的 [124. 二叉树的最大路径和](#124-二叉树的最大路径和），[543. 二叉树的直径](#543-二叉树的直径)是一样的思路，但是自己还是没写好，递归函数的写着写着就写变了，脱离了最开始的定义\n\n```java\n//错误解法，其实整体思路是对的，但是细节没处理好\npublic int longestUnivaluePath(TreeNode root) {\n    dfs(root);\n    return res;\n}\n\nint res=0;\n\npublic int dfs(TreeNode root){\n    if(root==null){\n        return 0;\n    }\n    int leftMax=dfs(root.left);\n    int rightMax=dfs(root.right);\n    int flag=0;\n    if(root.left!=null && root.left.val==root.val){\n        flag++;\n        leftMax++;\n    }\n    if(root.right!=null && root.right.val==root.val){\n        flag++;\n        rightMax++;\n    }\n    if(flag==2){\n        res=Math.max(res,leftMax+rightMax);\n    }\n    res=Math.max(res,Math.max(leftMax,rightMax));\n    return flag==0?0:Math.max(leftMax,rightMax);\n}\n```\n\n**解法一**\n\n在看了题解后对上面错误解法的纠正\n\n```java\npublic int longestUnivaluePath(TreeNode root) {\n    if(root==null) return 0;\n    dfs(root);\n    return res;\n}\n\nint res=0;\n\n//以 root 开头的同值路径长度\npublic int dfs(TreeNode root){\n    if(root==null){\n        return 0;\n    }\n    int leftMax=dfs(root.left);\n    int rightMax=dfs(root.right);\n    if(root.left!=null){\n        //不相等就直接设置成 0\n        leftMax=root.left.val==root.val?leftMax+1:0;\n    }\n    if(root.right!=null){\n        rightMax=root.right.val==root.val?rightMax+1:0;\n    }\n    //其实 3 种情况都包含了\n    res=Math.max(res,leftMax+rightMax);\n    return Math.max(leftMax,rightMax);\n}\n```\n\n注意 dfs 函数的定义：_**以 root 开头的最长同值路径**_\n\n既然是以 root 开头，所以代表的其实是**单侧**的最长路径，也就是说这个路径不能穿过 root，所以我们要分别求左右的值，然后取最大值，再判断和左右节点是否相等\n\n再然后我们需要判断 root 和左右节点值是否相等，如果和左右节点不想等，那么`leftMax`和`rightMax`应该直接置为 0，不应该再代入做计算，上面的错误解法就是错在这里，如果相等那就应该+1，然后统计最大值的时候也就可以很轻松的包含所有的 3 种情况\n\n> 这里为什么要先求最大值，再判断，先判断在求最大值不行么？\n>\n> 其实想想就知道不行，先判断其实相当于`前序遍历`，在访问节点第一次的时候如果不符合条件就直接返回了，这样根本无法遍历完所有的节点自然是不行，所以这种类型的一般都是`后序遍历`，待子节点都处理完之后再返回根节点做处理，和分治的思想很像\n\n**Update: 2020.6.21**\n\ngo 重写一遍，换了个方式，统计节点个数最后减一\n```golang\nfunc longestUnivaluePath(root *TreeNode) int {\n    if root==nil{\n        return 0\n    }\n    var Max=func(a,b int)int{\n        if a>b{return a}\n        return b\n    }\n    var res=0\n    var dfs func(root *TreeNode)int\n    dfs = func (root *TreeNode)int{\n        if root==nil{\n            return 0\n        }\n        //root 和左右子节点能形成的最长同值路径（至少是 1)\n        left := 1+dfs(root.Left) \n        right := 1+dfs(root.Right)\n        if root.Left==nil || root.Val!=root.Left.Val{\n            left=1\n        }\n        if root.Right==nil || root.Val!=root.Right.Val{\n            right=1\n        }\n        res=Max(res,left+right-1)\n        return Max(left,right)\n    }\n    dfs(root)\n    return res-1\n}\n```\n**解法二**\n\n另一种 dfs 的思路，代码更加简洁一点，但是稍微有一点不好想\n\n```java\npublic int longestUnivaluePath(TreeNode root) {\n    if(root==null) return 0;\n    //起点的值无所谓，root 节点没有父节点不用向上层函数返回值\n    dfs(root,-1); \n    return res;\n}\n\nint res=0;\n\n//以 root 父节点和 root 开始的同值路径长度\npublic int dfs(TreeNode root,int parent){\n    if(root==null){\n        return 0;\n    }\n    int leftMax=dfs(root.left,root.val);\n    int rightMax=dfs(root.right,root.val);\n    //这里 res 的计算其实 3 种情况都包含了\n    res=Math.max(res,leftMax+rightMax);\n    if(root.val==parent){\n        //和父节点同值，返回左右最大值+1\n        return Math.max(leftMax,rightMax)+1;\n    }\n    //和父节点不同值，直接返回 0\n    return 0;\n}\n```\n\n注意 dfs 函数的定义：_**以 node 父节点和 node 开始的同值路径长度**_\n\n在函数中添加一个父节点的值，然后在遍历到一个节点的时候判断当前节点和父节点的关系就行了，如果和父节点不相等，那么直接返回 0，相等就返回左右最大值+1（这个+1 加的是当前节点），然后同样采用后序遍历，这个思路没有那么自然，不过也挺不错的\n\n> 还有一种暴力解法，这里就不贴了\n\n## [595. 二叉树最长连续序列（LintCode）](https://www.lintcode.com/problem/binary-tree-longest-consecutive-sequence/description?ordering=-updated_at) \n\n**描述**\n\n给一棵二叉树，找到最长连续路径的长度。\n这条路径是指 任何的节点序列中的起始节点到树中的任一节点都必须遵循 父-子 联系。最长的连续路径必须是从父亲节点到孩子节点（`不能逆序`）。\n\n**样例 1:**\n\n```java\n输入：\n{1,#,3,2,4,#,#,#,5}\n输出：3\n说明：\n这棵树如图所示\n   1\n    \\\n     3\n    / \\\n   2   4\n        \\\n         5\n最长连续序列是 3-4-5，所以返回 3.\n```\n\n**样例 2:**\n\n```java\n输入：\n{2,#,3,2,#,1,#}\n输出：2\n说明：\n这棵树如图所示：\n   2\n    \\\n     3\n    / \n   2    \n  / \n 1\n最长连续序列是 2-3，而不是 3-2-1，所以返回 2.\n```\n\n**解法一**\n\n和上一题最长同值路径几乎一摸一样，这题 leetCode 也有，[但是是会员题](https://leetcode-cn.com/problems/binary-tree-longest-consecutive-sequence)，前几天每日一题出了这个（后来改了），然后我在 lintcode 找到了，应该是同一题，随手做一下\n\n```java\npublic int longestConsecutive(TreeNode root) {\n    // write your code here\n    dfs(root);\n    return max;\n}\n\nint max=0;\n\n//以 root 开始的最长连续序列\npublic int dfs(TreeNode root){\n    if(root == null){\n        return 0;\n    }\n    //保证至少是 1\n    int leftMax = Math.max(1,dfs(root.left));\n    int rightMax = Math.max(1,dfs(root.right));\n    if(root.left!=null){\n        leftMax = root.val==root.left.val-1 ? leftMax+1:1;\n    }\n    if(root.right!=null){\n        rightMax = root.val==root.right.val-1 ? rightMax+1:1;\n    }\n    max=Math.max(max,Math.max(leftMax,rightMax));\n    return Math.max(leftMax,rightMax);\n}\n```\n\n其实一开始写了一个很复杂的，dfs 的定义又和父节点耦合了，感觉和父节点耦合之后就很难搞，很容易搞晕，所以尽量不和父节点耦合，直接以当前节点定义\n\n**Update: 2020.6.21**\n\n```golang\nfunc longestConsecutive (root *TreeNode) int {\n    var Max = func(a,b int)int{\n        if a>b{return a}\n        return b\n    }\n    var dfs func(root *TreeNode) int\n    var res=0\n    dfs = func(root *TreeNode)int{\n        if root ==nil {\n            return 0\n        }\n        left:= 1+dfs(root.Left)\n        right:= 1+dfs(root.Right)\n        if root.Left==nil ||root.Left.Val!=root.Val+1{\n            left=1\n        }\n        if root.Right==nil ||root.Right.Val!=root.Val+1{\n            right=1\n        }\n        res=Max(res,Max(left,right))\n        return Max(left,right)\n    }\n    dfs(root)\n    return res\n}\n```\n\n## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)\n\n在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n**示例 1:**\n\n```java\n输入：[3,2,3,null,3,null,1]\n \t 3\n\t/ \\\n   2   3\n    \\   \\ \n     3   1\n\n输出：7 \n解释：小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\n```\n\n**示例 2:**\n\n~~~java\n输入：[3,4,5,1,3,null,1]\n\n \t 3\n\t/ \\\n   4   5\n  / \\   \\ \n 1   3   1\n\n输出：9\n解释：小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n~~~\n\n**解法一**\n\n暴力递归，应该还是写得出来\n\n```java\n//AC 了，但是效率很低\n//可以用 hashMap 缓存一下每个节点 rob 的值，但是没必要\npublic int rob(TreeNode root) {\n    return tryRob(root);\n}\n\npublic int tryRob(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    //偷取当前节点\n    int res=root.val;\n    if (root.left!=null) {\n        res+=tryRob(root.left.left)+tryRob(root.left.right);\n    }\n    if (root.right!=null) {\n        res+=tryRob(root.right.left)+tryRob(root.right.right);\n    }\n    //不偷当前节点\n    int res2=0;\n    res2=tryRob(root.left)+tryRob(root.right);\n    return Math.max(res,res2);\n}\n```\n**解法二**\n\n看评论区说是啥树形 dp ? 知识盲区了 hahaha\n\n```java\npublic int rob(TreeNode root) {\n    int[] res=tryRob(root);\n    return Math.max(res[0],res[1]);\n}\n\n//树形 dp???\n//看的懂，但是肯定写不出来 。\npublic int[] tryRob(TreeNode root) {\n    int[] dp=new int[2];\n    if (root==null) {\n        return dp;\n    }\n\n    int[] left=tryRob(root.left);\n    int[] right=tryRob(root.right);\n    //不包含当前节点的最大值\n    dp[0]=Math.max(left[0],left[1])+Math.max(right[0],right[1]);\n    //包含当前节点的最大值\n    dp[1]=left[0]+right[0]+root.val;\n    return dp;\n}\n```\n~~不是我吹，就这样的题目，再遇见多少次我都写不出来这样的解（笑~~\n\n> 2020.5.10 更新，在看了左神的书后，了解到这种其实就是树形 DP，所谓的树形 DP 实际上就是把递推方程搬到了树结构上，按我的理解树形 DP 很大的特点就是最终的解可能存在于树上每个节点，所以每个节点都是个子问题，可以从子问题推出父问题\n\n## [1372. 二叉树中的最长交错路径](https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/)\n\n给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：\n\n- 选择二叉树中 **任意** 节点和一个方向（左或者右）。\n- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。\n- 改变前进方向：左变右或者右变左。\n- 重复第二步和第三步，直到你在树中无法继续移动。\n\n交错路径的长度定义为：**访问过的节点数目 - 1**（单个节点的路径长度为 0 ）。\n\n请你返回给定树中最长 **交错路径** 的长度。\n\n**示例 1：**\n\n![YX1tJO.png](https://s1.ax1x.com/2020/05/22/YX1tJO.png)\n\n```java\n输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\n输出：3\n解释：蓝色节点为树中最长交错路径（右 -> 左 -> 右）。\n```\n\n**示例 2：**\n\n![YX1NWD.png](https://s1.ax1x.com/2020/05/22/YX1NWD.png)\n\n```java\n输入：root = [1,1,1,null,1,null,null,1,1,null,1]\n输出：4\n解释：蓝色节点为树中最长交错路径（左 -> 右 -> 左 -> 右）。\n```\n\n**示例 3：**\n\n```java\n输入：root = [1]\n输出：0\n```\n\n**提示：**\n\n- 每棵树最多有 `50000` 个节点。\n- 每个节点的值在 `[1, 100]` 之间。\n\n**解法一**\n\n某次周赛的 T3，树形 DP\n\n```java\nint max=0;\n\npublic int longestZigZag(TreeNode root) {\n    dfs(root);\n    return max-1;\n}\n\n//当前节点左右交错路径的长度\npublic int[] dfs(TreeNode root){\n    int[] res=new int[2];\n    if(root==null){\n        return res;\n    }\n    res[0]=dfs(root.left)[1]+1;\n    res[1]=dfs(root.right)[0]+1;\n    max=Math.max(max,Math.max(res[0],res[1]));\n    return res;\n}\n```\n**Update: 2020.6.21**\n\n用 go 重写（回顾）下\n```golang\nfunc longestZigZag(root *TreeNode) int {\n    var Max = func(a,b int)int{\n        if a>b{return a}\n        return b\n    }\n    var dfs func(root *TreeNode)[]int\n    var res = 0\n    dfs = func(root *TreeNode)[]int{\n        if root==nil{\n            return []int{0,0}\n        }\n        //0：向左走最长交错 1：向右最长交错路径\n        left := dfs(root.Left)\n        right := dfs(root.Right)\n        res=Max(res,Max(left[1]+1,right[0]+1))\n        return []int{left[1]+1,right[0]+1}\n    }\n    dfs(root)\n    return res-1\n}\n```\n\n**解法二**\n\n直接搜索的做法，其实这种做法没有上面树形 dp 好理解，dfs 函数的定义会和父节点混合\n\n```java\nint res=0;\n\npublic int longestZigZag(TreeNode root) {\n    dfs(root,false);//true false 都无所谓，root 没有父节点\n    return res-1;\n}\n\n//当前节点和父节点形成的交错路径长度，isRight 代表父节点到当前节点的走向是不是 right\npublic int dfs(TreeNode root,boolean isRight){\n    if(root==null){\n        return 0;\n    }\n    int l=dfs(root.left,false);\n    int r=dfs(root.right,true);\n    res=Math.max(res,Math.max(l+1,r+1));\n    if(isRight){\n        return l+1;\n    }\n    return r+1;\n}\n```\n\n## [968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/)\n\nDifficulty: **困难**\n\n给定一个二叉树，我们在树的节点上安装摄像头。\n\n节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**\n\n计算监控树的所有节点所需的最小摄像头数量。\n\n**示例 1：**\n\n![wjBgQ1.png](https://s1.ax1x.com/2020/09/23/wjBgQ1.png)\n\n```golang\n输入：[0,0,null,0,0]\n输出：1\n解释：如图所示，一台摄像头足以监控所有节点。\n```\n\n**示例 2：**\n\n![wjBfeK.png](https://s1.ax1x.com/2020/09/23/wjBfeK.png)\n\n```golang\n输入：[0,0,null,0,null,0,null,null,0]\n输出：2\n解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。\n```\n\n**提示：**\n\n1.  给定树的节点数的范围是 `[1, 1000]`。\n2.  每个节点的值都是 0。\n\n**解法一**\n\n树形 DP\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n//0: 覆盖整棵树，root 必须设置监控\n//1: 覆盖整棵树，无论 root 是否设置监控\n//2: 覆盖两颗子树，无论 root 是否被覆盖\nfunc minCameraCover(root *TreeNode) int {\n    var Min = func(a, b int) int {if a < b {return a}; return b}\n    var INF = 0x3f3f3f3f\n    var dfs func(root *TreeNode) [3]int \n    dfs = func (root *TreeNode) [3]int {\n        var res [3]int\n        if root == nil {\n            return [3]int{INF, 0, 0}\n        }\n        left := dfs(root.Left)\n        right := dfs(root.Right)\n        res[0] = left[2] + right[2] + 1\n        res[1] = Min(res[0], Min(left[0]+right[1], left[1]+right[0]))\n        res[2] = Min(res[0], left[1] + right[1])\n        return res\n    }\n    r := dfs(root)\n    return r[1]\n}\n```\n\n## _树状数组（BIT）_\n\n暂时先放在这里，等以后累计多了再单独开辟专题\n\n## [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)\n\nDifficulty: **困难**\n\n给定一个整数数组 _nums_，按要求返回一个新数组 _counts_。数组 _counts_ 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。\n\n**示例：**\n\n```java\n输入：nums = [5,2,6,1]\n输出：[2,1,1,0] \n解释：\n5 的右侧有 2 个更小的元素 (2 和 1)\n2 的右侧仅有 1 个更小的元素 (1)\n6 的右侧有 1 个更小的元素 (1)\n1 的右侧有 0 个更小的元素\n```\n\n**提示：**\n\n*   `0 <= nums.length <= 10^5`\n*   `-10^4 <= nums[i] <= 10^4`\n\n**解法一**\n\n这题有 [更好的做法](http://imlgw.top/2019/05/04/leetcode-shu-zu/#315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0)，直接归并就行了，这里主要是为了学习 BIT\n\n暴力的做法：其实就是桶排序的思想，我们从右向左扫数组，扫描一个就在对应的桶+1，同时计算该位置左边的前缀和，就是右边比当前元素小的值，也就是我们需要的结果，但是问题是这个`bit`数组是一直在变化的，扫描一个元素就会在 bit 数组对应的位置上+1，每次变化后都需要 O(N) 来重新计算后缀和，这样整体的复杂度就是 O(N^2)，数据量 1e5，过不了 OJ\n\n所以我们可以用线段树来维护区间和，但是线段树代码量比较大，常数也比较大，所以这里学一下新科技：**[树状数组](https://blog.csdn.net/Yaokai_AssultMaster/article/details/79492190)**，区间查询，单点修改时间复杂度都是 logN，且代码简单。\n\n同时还有一个问题，这里我们直接按照值来定位是不合适的，数据范围比较大，直接按照元素值来定位会造成很大空间的浪费，并且题目也不允许开这么大的空间，所以还需要离散化，因为我们只关系元素之间的大小关系，所以我们转换成每个元素说对应的 rank 就行了\n\n```java\nint[] tree;\n\nint n = 0;\n\npublic int lowbit(int i) {\n    return i & -i;\n}\n\n//update 索引 i 位置\npublic void update(int i, int delta) {\n    while (i <= n) {\n        tree[i] += delta;\n        i += lowbit(i);\n    }\n}\n\npublic int query(int i) {\n    int sum = 0;\n    //从 1 开始\n    while (i > 0) {\n        sum += tree[i];\n        i -= lowbit(i);\n    }\n    return sum;\n}\n\n/*\n暴力的做法：其实就是桶排序的思想，我们从右向左扫数组，扫描一个就在对应的桶+1，\n同时计算该位置左边的前缀和，就是右边比当前元素小的值，也就是我们需要的结果，\n但是问题是这个`bit`数组是一直在变化的，扫描一个元素就会在 bit 数组对应的位置上+1，\n每次变化后都需要 O(N) 来重新计算后缀和，这样整体的复杂度就是 O(N^2)，数据量 1e5，过不了 OJ\n\n所以我们可以用线段树来维护区间和，但是线段树代码量比较大，常数也比较大\n所以这里学一下新科技：**树状数组**，区间查询，单点修改时间复杂度都是 logN，且代码简单。\n同时还有一个问题，这里我们直接按照值来定位是不合适的，数据范围比较大，\n直接按照元素值来定位会造成很大空间的浪费，并且题目也不允许开这么大的空间\n所以还需要离散化，因为我们只关系元素之间的大小关系，所以我们转换成每个元素说对应的 rank 就行了\n*/\npublic List<Integer> countSmaller(int[] nums) {\n    n = nums.length;\n    tree = new int[n+1];\n    List<Integer> res = new LinkedList<>();\n    int[] rank = new int[n];\n    //temp[0]: index temp[1]: val\n    int[][] temp = new int[n][2];\n    for (int i = 0; i < n; i++) {\n        temp[i] = new int[]{i, nums[i]};\n    }\n    //离散化\n    Arrays.sort(temp, (t1, t2) -> t1[1]-t2[1]);\n    for (int i = 0; i < n; i++) {\n        rank[temp[i][0]] = i+1;\n    }\n    for (int i = n-1; i >= 0; i--) {\n        //O(NlogN) 构建 BIT（可以优化成 O(N))\n        update(rank[i], 1);\n        res.add(0, query(rank[i]-1));\n    }\n    return res;\n}\n```","tags":["LeetCode","二叉树"],"categories":["算法"]},{"title":"LeetCode 回溯&递归","url":"/2019/10/10/26679fc/","content":"\n## [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n\n给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）注意 1 不对应任何字母\n\n![mark](http://static.imlgw.top/blog/20191012/Ro4wr1dv5pR7.png?imageslim)\n\n**示例：**\n\n```java\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n\n**说明：**\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n**解法一**\n\n```java\nString[] letter={\" \",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n\nprivate List<String> res=new LinkedList<>();\n\npublic List<String> letterCombinations(String digits) {\n    //空字符串要注意\n    if (\"\".equals(digits)) return res;\n    letterCombinations(digits,0,\"\");\n    return res;\n}\n\npublic void letterCombinations(String digits,int index,String str) {\n    //递归出口，当 index==digits 的长度的时候就说明走到尽头了\n    //需要回头尝试其他的情况\n    if (index==digits.length()) {\n        res.add(str);\n        return;\n    }\n    //当前字符对应的字母组合\n    char[] ls=letter[digits.charAt(index)-48].toCharArray();\n    //遍历每种可能，其实就是 DFS\n    for (int i=0;i<ls.length;i++) {\n        letterCombinations(digits,index+1,str+ls[i]);\n    }\n    return;\n}\n```\n\n可想而知，这个算法的时间复杂度相当高，`3^N * 4^M = O(2^N)` M 是能表示 3 个字符的数字个数，N 是表示 4 个字符的数字个数，指数级别的算法，但是也没有其他别的比较好的算法了\n\n## [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)\n\n给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。\n\n**示例：**\n\n```java\n输入：\"25525511135\"\n输出：[\"255.255.11.135\", \"255.255.111.35\"]\n```\n\n**解法一**\n\n其实还是有一个大致的思路，但是没写出来，很多细节不知道咋处理\n\n```java\npublic List<String> restoreIpAddresses(String s) {\n    restoreIpAddresses(s,0,\"\",0);\n    return res;\n}\n\nLinkedList<String> res=new LinkedList<>();\n\npublic void restoreIpAddresses(String s,int index,String des,int count) {\n    if (count>4) {\n        return;\n    }\n    //到字符串末尾了\n    if (index==s.length()) {\n        if (count==4) {\n            res.add(des.substring(0,des.length()-1));    \n        }\n        return;\n    }\n    //如果为 0 就不用切分了，这里就相当于直接跳过\n    if (s.charAt(index)=='0') {\n        restoreIpAddresses(s,index+1,des+\"0.\",count+1);\n    }else{\n        //不为 0 就需要继续切分为 1，2，3\n        //切分过程中需要注意要小于 255, 同时需要一个计数器来判度是否终止\n        for (int i=1;i<4;i++) {\n            if (index+i<=s.length()) {\n                String temp=s.substring(index,index+i);\n                if (Integer.valueOf(temp)<=255){\n                    restoreIpAddresses(s,index+i,des+temp+\".\",count+1);    \n                }\n            }\n        }\n    }\n}\n```\n\n**UPDATE: 2020.8.9**\n\n今天的打卡题，用 go 重写了下，比之前写的好多了，不过一开始忘了处理 0WA 了一发，然后懒的对长度不合法的剪枝又 T 了一发。\n```golang\nfunc restoreIpAddresses(s string) []string {\n    var res []string\n    if len(s) < 4 || len(s) > 12 {\n        return res\n    }\n    var dfs func(s string, lis []string)\n    dfs = func(s string, lis []string) {\n        if s == \"\" {\n            if len(lis) == 4 {\n                res = append(res, strings.Join(lis, \".\"))\n            }\n            return\n        }\n        //s 未遍历完就集齐了 4 块\n        if len(lis) >= 4 {\n            return\n        }\n        for i := 1; i <= 3; i++ {\n            if i <= len(s) && check(s[:i]) {\n                lis = append(lis, s[:i])\n                dfs(s[i:], lis)\n                lis = lis[:len(lis)-1]\n                //前导 0 的处理，读取 0 之后就不再向后扩展\n                if s[:i] == \"0\" {\n                    return\n                }\n            }\n        }\n    }\n    dfs(s, []string{})\n    return res\n}\n\nfunc check(s string) bool {\n    if ns, _ := strconv.Atoi(s); ns <= 255 {\n        return true\n    }\n    return false\n}\n\n```\n\n## [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)\n\n给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。\n\n返回 s 所有可能的分割方案。\n\n**示例：**\n\n```java\n输入：\"aab\"\n输出：\n[\n  [\"aa\",\"b\"],\n  [\"a\",\"a\",\"b\"]\n]\n```\n\n**解法一**\n\n总算自己完整做了一题出来了\n\n```java\npublic List<List<String>> partition(String s) {\n    partition(s,0,new ArrayList());\n    return res;\n}   \n\nList<List<String>> res=new ArrayList<>();\n\npublic void partition(String s,int index,List<String> lis) {\n    if (index==s.length()) {\n        //注意这里要 copy 一个 list 不能直接添加 lis\n        //lis 引用的对象后面还会继续变化，最后会变为 null\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=index+1;i<=s.length();i++) {\n        String temp=s.substring(index,i);\n        //System.out.println(index+\"=\"+i+\"=\"+temp);\n        if (isPalind(temp)) {\n            lis.add(temp);\n            partition(s,i,lis);\n            //不能直接 remove(temp), 主要是会有重复的字符，所以会导致最后的顺序不一致，而且效率也很低\n            //lis.remove(temp);\n            lis.remove(lis.size()-1);\n        }\n    }\n}\n\npublic boolean isPalind(String s){\n    for (int i=0,j=s.length()-1;i<=j;i++,j--) {\n        if (s.charAt(i)!=s.charAt(j)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n4ms，93%，其实就是暴力回溯，还是挺简单的，一开始忘了`remove()`，直接把所有结果打出来了， 然后一直在想怎么调整递归的结构。DFS 基本的套路都忘了😂\n\n## [46. 全排列](https://leetcode-cn.com/problems/permutations/)\n\n给定一个**没有重复**数字的序列，返回其所有可能的全排列。\n\n**示例：**\n\n```java\n输入：[1,2,3]\n输出：\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n**解法一**\n\n经典的全排列问题，熟悉了 DFS 套路之后都挺简单的，注意回溯就行了\n\n```java\npublic List<List<Integer>> permute(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return res;\n    }\n    boolean[] visit=new boolean[nums.length];\n    permute(nums,new ArrayList(),visit);\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic void permute(int[] nums,List<Integer> lis,boolean[] visit) {\n    if (lis.size()==nums.length) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=0;i<nums.length;i++) {\n        if (visit[i]) continue;\n        lis.add(nums[i]);\n        visit[i]=true;\n        permute(nums,lis,visit);\n        //回溯\n        visit[i]=false;\n        lis.remove(lis.size()-1);\n    }\n}\n```\n## [60. 第 k 个排列](https://leetcode-cn.com/problems/permutation-sequence/)\n\n给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。\n\n按大小顺序列出所有排列情况，并一一标记，当 n = 3 时，所有排列如下：\n\n1. `\"123\"`\n2. `\"132\"`\n3. `\"213\"`\n4. `\"231\"`\n5. `\"312\"`\n6. `\"321\"`\n\n给定 n 和 k，返回第 k 个排列。\n\n**说明：**\n\n- 给定 n 的范围是 [1, 9]。\n- 给定 k 的范围是 [1,  n!]。\n\n**示例 1: **\n\n```java\n输入：n = 3, k = 3\n输出：\"213\"\n```\n\n**示例 2:**\n\n```java\n输入：n = 4, k = 9\n输出：\"2314\"\n```\n\n**解法一**\n\n```java\npublic String getPermutation(int n, int k) {\n    boolean[] visit=new boolean[n+1];\n    getPermutation(n,k,0,visit,new StringBuilder(\"\"));\n    return res.get(k-1).toString();\n}\n\nprivate List<StringBuilder> res=new LinkedList<>();\n\npublic void getPermutation(int n, int k,int count,boolean[] visit,StringBuilder str) {\n    if (count == n) {\n        res.add(new StringBuilder(str));\n        return;\n    }\n    if (res.size()==k) {\n        return;\n    }\n    for (int i=1;i<=n;i++) {\n        if (!visit[i]) {\n            str.append(i);\n            visit[i]=true;\n            getPermutation(n,k,count+1,visit,str);\n            visit[i]=false;\n            str.delete(str.length()-1,str.length());\n        }\n    }\n}\n```\n偶然发现这一题并没有记录，之前没有记录的原因肯定是因为方法太垃圾了，这题最优解是 `康托展开`，说实话，暂时并不想去了解😂，后面有时间再说吧\n\n## [5374. 长度为 n 的开心字符串中字典序第 k 小的字符串](https://leetcode-cn.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/) \n\n一个 「开心字符串」定义为：\n\n- 仅包含小写字母 ['a', 'b', 'c'].\n- 对所有在 1 到 s.length - 1 之间的 i ，满足 s[i] != s[i + 1] （字符串的下标从 1 开始）。\n\n比方说，字符串 \"abc\"，\"ac\"，\"b\" 和 \"abcbabcbcb\" 都是开心字符串，但是 \"aa\"，\"baa\" 和 \"ababbc\" 都不是开心字符串。\n\n给你两个整数 n 和 k ，你需要将长度为 n 的所有开心字符串按字典序排序。\n\n请你返回排序后的第 k 个开心字符串，如果长度为 n 的开心字符串少于 k 个，那么请你返回 空字符串 。\n\n**示例 1：**\n\n```java\n输入：n = 1, k = 3\n输出：\"c\"\n解释：列表 [\"a\", \"b\", \"c\"] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 \"c\" 。\n```\n\n**示例 2：**\n\n```java\n输入：n = 1, k = 4\n输出：\"\"\n解释：长度为 1 的开心字符串只有 3 个。\n```\n\n**示例 3：**\n\n```java\n输入：n = 3, k = 9\n输出：\"cab\"\n解释：长度为 3 的开心字符串总共有 12 个 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"] 。第 9 个字符串为 \"cab\"\n```\n\n**示例 4：**\n\n```java\n输入：n = 2, k = 7\n输出：\"\"\n```\n\n**示例 5：**\n\n```java\n输入：n = 10, k = 100\n输出：\"abacbabacb\"\n```\n\n**提示：**\n\n- `1 <= n <= 10`\n- `1 <= k <= 100`\n\n**解法一**\n\n补下 24th 双周赛 T3，和上面一题很类似，直接暴力回溯了\n\n```java\npublic String getHappyString(int n, int k) {\n    dfs(\"a\",n,k);\n    dfs(\"b\",n,k);\n    dfs(\"c\",n,k);\n    return res;\n}\n\nprivate int count=0;\n\nprivate String res=\"\";\n\npublic void dfs(String cur,int n,int k){\n    if(!\"\".equals(res)) return;\n    if(cur.length()==n){\n        count++;\n        if(count==k){\n            res=cur;\n        }\n        return;\n    }\n    char last=cur.charAt(cur.length()-1);\n    if(last=='a'){\n        dfs(cur+'b',n,k);\n        dfs(cur+'c',n,k);\n    }\n    if(last=='b'){\n        dfs(cur+'a',n,k);\n        dfs(cur+'c',n,k);\n    }\n    if(last=='c'){\n        dfs(cur+'a',n,k);\n        dfs(cur+'b',n,k);\n    }\n}\n```\n其实直接队列模拟也是可以的，模拟的效率应该会更高一些，好像也可以直接构造出来\n\n## [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)\n\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n**示例：**\n\n```java\n输入：[1,1,2]\n输出：\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n**解法一**\n\n开始我很纠结这题，后来想通了，其实就是去重，遇到已经存在于结果中相同的元素就直接跳过就行了\n\n```java\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return res;\n    }\n    //Arrays.sort(nums); 解法二需要先排序\n    boolean[] visit=new boolean[nums.length];\n    permuteUnique(nums,new ArrayList(),visit);\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic void permuteUnique(int[] nums,List<Integer> lis,boolean[] visit){\n    HashSet<Integer> set=new HashSet<>();\n    if (lis.size()==nums.length) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=0;i<nums.length;i++) {\n        if (!visit[i] && !set.contains(nums[i])) {\n            lis.add(nums[i]);\n            visit[i]=true;\n            set.add(nums[i]);\n            permuteUnique(nums,lis,visit);\n            visit[i]=false;\n            lis.remove(lis.size()-1);\n        }\n    }\n}\n\n//需要排序\npublic void permuteUnique2(int[] nums,List<Integer> lis,boolean[] visit){\n    if (lis.size()==nums.length) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=0;i<nums.length;i++) {\n        //剪枝去重，和前一个元素比较\n        //Bug 警告，应该写！visit[i-1]\n        if (i>0&&nums[i]==nums[i-1] && !visit[i-1]) \n            continue;\n        if (!visit[i]) {\n            lis.add(nums[i]);\n            visit[i]=true;\n            permuteUnique2(nums,lis,visit);\n            visit[i]=false;\n            lis.remove(lis.size()-1);\n        }\n    }\n}\n```\n关于去重的方式，其实我们可以从回溯的**根节点**来考虑，也就是我们考虑最顶层的【**1，1，2**】的遍历情况，每一次遍历实际上都是在找**以当前元素开头的排列**，当第一次已经遍历完 1 开头的所以排列后，后面的循环再碰到 1 自然就可以直接跳过了，所以我们可以在一次遍历中用 HashMap 来去重，来保证一次循环中不会有重复的元素被选取，其实也只有这题可以用 HashSet，因为这里排列是讲究顺序的，循序完全一样才是重复，后面的题都是不讲究顺序的，都需要排序才能去重，具体后面再分析\n\n> 我首先想到的就是 Hash 表，这里翻了下评论区好像都是用的第二种方式去重的，难道用 HashSet 不好么😂，第二种必须要先排序，保证相同的元素都聚在一起，方便判断，这种题在纸上画一画递归树其实就很清楚了\n\n### Bug 警告\n\n这里 `!visit[i-1]`和 `visit[i-1]`对于这题来说并不影响正确性，但是你如果将生成的过程打印出来对比下就知道为啥了，具体的请看下面 [1079. 活字印刷](#1079-活字印刷) 的解释\n\n## [1286. 字母组合迭代器](https://leetcode-cn.com/problems/iterator-for-combination/)\n\n请你设计一个迭代器类，包括以下内容：\n\n- 一个构造函数，输入参数包括：一个 有序且字符唯一 的字符串 characters（该字符串只包含小写英文字母）和一个数字 combinationLength 。\n- 函数 next() ，按 字典序 返回长度为 combinationLength 的下一个字母组合。\n- 函数 hasNext() ，只有存在长度为 combinationLength 的下一个字母组合时，才返回 True；否则，返回 False。\n\n**示例：**\n\n```java\nCombinationIterator iterator = new CombinationIterator(\"abc\", 2); // 创建迭代器 iterator\n\niterator.next(); // 返回 \"ab\"\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 \"ac\"\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 \"bc\"\niterator.hasNext(); // 返回 false\n```\n\n**提示：**\n\n- 1 <= combinationLength <= characters.length <= 15\n- 每组测试数据最多包含 10^4 次函数调用。\n- 题目保证每次调用函数 next 时都存在下一个字母组合。\n\n**解法一**\n\n唉，真的菜，好久没写回溯了，又給忘了，这题开始被别人误导了，以为是下一个排列，然后就一直在想怎么去求 next，其实根本就不用这样。..\n\n```java\nprivate LinkedList<String> res=new LinkedList<>();\n\n//abc\npublic CombinationIterator(String characters, int combinationLength) {\n    dfs(\"\",combinationLength,0,0,characters);\n}\n\npublic String next() {\n    return res.pollFirst();\n}\n\npublic void dfs(String cur,int len,int index,int count,String source) {\n    if (count == len) {\n        res.add(cur); //直接根据 cur 得长度判断就 ok 了\n        return;\n    }\n    for (int i=index;i<source.length();i++) {\n        dfs(cur+source.charAt(i),len,i+1,count+1,source);\n    }\n}\n\npublic boolean hasNext() {\n    return !res.isEmpty();\n}\n```\n\n> 回头开了下之前的代码，发现都写得不好，很喜欢加个 count 统计数量，其实直接根据 cur 得长度判断就可以了\n\n## [77. 组合](https://leetcode-cn.com/problems/combinations/)\n\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n**示例：**\n\n```java\n输入：n = 4, k = 2\n输出：\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n```\n\n**解法一**\n\n其实一开始没写出剪枝的代码，看了一点提示后才写出了下面的的第一种剪枝的方法\n\n```java\npublic List<List<Integer>> combine(int n, int k) {\n    if (k>n || n<=0 ||k<=0) {\n        return res;\n    }\n    //boolean[] visit=new boolean[n+1];\n    combine(n,k,1,new ArrayList(),0);\n    return res;\n}   \n\nprivate List<List<Integer>> res=new ArrayList<>();\n\n//剪枝优化 1\npublic void combine(int n, int k,int index,List<Integer> lis,int count) {\n    if (count==k) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    //1 2 3 4 | 3\n    //index = 3 k=3  n=4 count=0 (3 为头，显然是不行的，肯定会和前面重复） --> 3<=3\n    //index = 3 k=3  n=4 count=1 (3 为第二个，是可行的） --> 3 <= 2\n    if (n-index+2<=k-count) {\n        return;\n    }\n    for (int i=index;i<=n;i++) {\n        lis.add(i);\n        combine(n,k,i+1,lis,count+1);\n        //回溯的关键\n        lis.remove(lis.size()-1);\n    }\n}\n\n//剪枝优化 2\npublic void combine4(int n, int k,int index,List<Integer> lis,int count) {\n    if (count==k) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    //循环的区间至少要有 k-count 个元素 也就是 [i,N] 之间至少要有 k-count 个元素\n    //N-i+1>=k-count --> i<=n-(k-count)+1\n    for (int i=index;i<=n-(k-count)+1;i++) {\n        lis.add(i);\n        combine4(n,k,i+1,lis,count+1);\n        //回溯的关键\n        lis.remove(lis.size()-1);\n    }\n}\n```\n举个例子`1，2，3，4 k=3`  其实在循环 n=3 的时候就可以结束了，因为后面已经没有那么多元素可以和 3 构成组合了\n\n## [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 ，`candidates` 中的数字可以无限制重复被选取\n\n说明：\n\n- 所有数字（包括 target）都是正整数。\n\n- 解集不能包含重复的组合。 \n\n**示例 1:**\n\n```java\n输入：candidates = [2,3,6,7], target = 7,\n所求解集为：\n[\n  [7],\n  [2,2,3]\n]\n```\n\n**示例 2:**\n\n```java\n输入：candidates = [2,3,5], target = 8,\n所求解集为：\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n**解法一**\n\n没有任何剪枝处理的回溯，感觉一开始就想好怎么剪枝还是不太容易，这题其实和上面的组合很类似，值得注意的就是子递归调用的时候传递的 index 参数\n\n```java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    if (candidates==null || candidates.length<=0) {\n        return res;\n    }\n    combinationSum(candidates,target,0,0,new ArrayList());\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic void combinationSum(int[] candidates, int target,int index,int sum,List<Integer> lis) {\n    if (sum>target) {\n        return;\n    }\n    if (target==sum) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    //这里一次循环其实就确定了包含 i 的所有可能解，所以起点是 index 不是 0\n    for (int i=index;i<candidates.length;i++) {\n        //跳过比 target 大的\n        if (candidates[i]>target) continue;\n        sum+=candidates[i];\n        lis.add(candidates[i]);\n\t\t//其实主要就是搞清楚每次从哪里开始，以及每次循环的作用\n        //可以重复选取自己，所以子递归也从 i 开始而不是 i+1\n        combinationSum(candidates,target,i,sum,lis);\n        sum-=candidates[i];\n        lis.remove(lis.size()-1);\n    }\n}\n```\n**解法二**\n\n剪枝优化，主要是要先排个序，这样如果在循环过程中，累加和已经大于 target 了就直接 return，如果不排序就不能 return，因为无法确保后面会不会更小的元素\n\n```java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    if (candidates==null || candidates.length<=0) {\n        return res;\n    }\n    //排序，方便剪枝\n    Arrays.sort(candidates);\n    combinationSum(candidates,target,0,0,new ArrayList());\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\n//剪枝优化 2\npublic void combinationSum(int[] candidates, int target,int index,int sum,List<Integer> lis) {\n    if (sum>target) {\n        return;\n    }\n    if (target==sum) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=index;i<candidates.length;i++) {\n        if (sum+candidates[i]>target) return;\n        sum+=candidates[i];\n        lis.add(candidates[i]);\n        //注意这里传递进去的 index 是 i\n        combinationSum(candidates,target,i,sum,lis);\n        sum-=candidates[i];\n        lis.remove(lis.size()-1);\n    }\n}\n```\n这两天状态还可以啊，好多题都可以完全独立的写出来了😁\n\n## [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)\n\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n**说明：**\n\n- 所有数字（包括目标数）都是正整数。\n- 解集不能包含重复的组合。 \n\n**示例 1:**\n\n```java\n输入：candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为：\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n```\n\n**示例 2:**\n\n```java\n输入：candidates = [2,5,2,1,2], target = 5,\n所求解集为：\n[\n  [1,2,2],\n  [5]\n]\n```\n\n**解法一**\n\n```java\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    if (candidates ==null || candidates.length<=0) {\n        return res;\n    }\n    Arrays.sort(candidates);\n    combinationSum2(candidates,target,0,new ArrayList());\n    return res;\n}\n\npublic void combinationSum2(int[] candidates, int target,int index,List<Integer> lis) {\n    /*if (target<0) {\n            return;\n        }*/\n    if (target==0) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n\n    for (int i=index;i<candidates.length;i++) {\n        //注意这里 i>index\n        if (i>index && candidates[i]==candidates[i-1]  ) continue;\n        //排过序的，可以直接 return\n        if (target-candidates[i]<0) return;\n        lis.add(candidates[i]);\n        combinationSum2(candidates,target-candidates[i],i+1,lis);\n        lis.remove(lis.size()-1);\n    }\n}\n```\n回溯其实值得注意的就那几个点，循环的起点，下次递归的起点，回溯，出口，这几个点都搞清楚了其实就很简单了，关键的地方就是如何去重\n\n这题如果参照上面 [全排列 2](## 47. 全排列 II) 的第一种 HashSet 的去重方式的话，明显是有问题的，HashSet 的去重方式只能保证**每一次循环中不会有重复的元素被选取**，但是这题即使循环中没有重复的元素被选取，结果仍然会有重复\n\n比如 `10,1,2,7,6,1,5` 遍历 1 的时候会得到`1 2 5`，后续遍历 2 的时候又会得到一个 `2 1 5` ，但是其实在第一次循环的时候就**已经找到了所有包含 1 的解，后面循环中包含 1 的解其实都重复了**，如果我们排序后就变为 `1 1 2 5 6 7 10` 把相同的元素聚集到一起，一方面可以去重，另一方面还可以剪枝，在第一次循环的时候就已经找到了所有的 带有 1 的解，后面的连着的 1 都可以跳过了，后续就不会再有包含 1 的解了，如果不排序，后面仍然会有包含 1 的解\n\n## [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)\n\n找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n**说明：**\n\n- 所有数字都是正整数。\n- 解集不能包含重复的组合。 \n\n**示例 1:**\n```java\n输入：k = 3, n = 7\n输出：[[1,2,4]]\n```\n\n**示例 2:**\n\n```java\n输入：k = 3, n = 9\n输出：[[1,2,6], [1,3,5], [2,3,4]]\n```\n\n**解法一**\n\n感觉比上面两题还简单一点，可以直接剪枝\n\n```golang\n//UPDATE: 2020.9.11\nfunc combinationSum3(k int, n int) [][]int {\n    var res [][]int\n    var dfs func(idx int, sum int, lis []int)\n    dfs = func(idx int, sum int, lis []int) {\n        if len(lis) > k {\n            return\n        }\n        if sum == n && len(lis) == k {\n            dest := make([]int, len(lis))\n            copy(dest, lis)\n            res = append(res, dest)\n            return\n        }\n        for i := idx; i <= 9; i++ {\n            if sum + i > n {\n                return\n            }\n            dfs(i+1, sum+i, append(lis, i))\n        }\n    }\n    dfs(1, 0, []int{})\n    return res\n}\n```\n\n**解法二（UPDATE：2020.9.11）**\n\n学了下二进制枚举子集的方法，很简洁\n```golang\nfunc combinationSum3(k int, n int) [][]int {\n    var res [][]int\n    for i := 0; i < (1<<9); i++ {\n        var sum, cnt = 0, 0\n        var lis []int\n        for j := 0; j < 9; j++ {\n            if i & (1<<j) != 0 {\n                sum += j+1\n                cnt++\n                lis = append(lis, j+1)\n            }\n        }\n        if sum == n && cnt == k {\n            res = append(res, lis)   \n        }\n    }\n    return res\n}\n```\n\n## [78. 子集](https://leetcode-cn.com/problems/subsets/)\n\n给定一组**不含重复元素**的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n**说明：**解集不能包含重复的子集。\n\n**示例：**\n\n```java\n输入：nums = [1,2,3]\n输出：\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n**解法一**\n\n```java\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic List<List<Integer>> subsets(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return res;\n    }\n    subsets(nums,0,new ArrayList());\n    return res;\n}\n\npublic void subsets(int[] nums,int index,List<Integer> lis) {\n    //if (index<=nums.length) {\n        res.add(new ArrayList(lis));\n    //}\n    for (int i=index; i<nums.length;i++) {\n        lis.add(nums[i]);\n        subsets(nums,i+1,lis);\n        lis.remove(lis.size()-1);\n    }\n}\n```\n简单的回溯，注意收集结果的时机就行\n\n**Update: 2020.6.20**\n\n增加一个 go 的写法\n```golang\nfunc subsets(nums []int) [][]int {\n    var res [][]int\n    var lis []int\n    var dfs func(index int)\n    dfs = func(index int){\n        dest:=make([]int,len(lis))\n        copy(dest,lis)\n        res=append(res,dest)\n        for i:=index;i<len(nums);i++{\n            lis=append(lis,nums[i])\n            dfs(i+1)\n            lis=lis[:len(lis)-1]\n        }\n    }\n    dfs(0)\n    return res\n}\n```\n\n**解法二**\n\nBFS，类似于二叉树层次遍历，首先初始化一个空的 list，后面每次迭代都将 list 中的所有元素都取出来加上当前元素，再重新加入到 list 中\n\n```java\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> queue=new ArrayList<>();\n    if (nums==null || nums.length<=0) {\n        return queue;\n    }\n    queue.add(new ArrayList());\n    for (int i=0;i<nums.length;i++) {\n        int next=queue.size();\n        for (int j=0;j<next;j++) {\n            List<Integer> temp=new ArrayList(queue.get(j));\n            temp.add(nums[i]);\n            queue.add(temp);\n        }\n    }\n    return queue;\n}\n```\n**解法三（UPDATE: 2020.9.11）**\n\n二进制枚举子集\n```golang\nfunc subsets(nums []int) [][]int {\n    var n = len(nums)\n    var res [][]int\n    for i := 0; i < (1<<n); i++ {\n        var lis []int\n        for j := 0; j < n; j++ {\n            if i & (1<<j) != 0 {\n                lis = append(lis, nums[j])\n            }\n        }\n        res = append(res, lis)\n    }\n    return res\n}\n```\n## [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)\n\n给定一个**可能包含重复元素**的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n**说明：**解集不能包含重复的子集。\n\n**示例：**\n\n```java\n输入：[1,2,2]\n输出：\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n```\n\n**解法一**\n\n和 40 题很类似，主要就是这个去重的操作，比如题目给的 case，`[1,2,2]` 已经有序了，在选择第一个 2 的时候其实就已经将所有包含 2 的子集都求出来了，后面的 2 就可以直接跳过，当然这里 1，2，2 本身就是有序的，试想如果是`2,1,2` 遍历第一个 2 会将所有包含 2 的子集求出来，但是遍历到 1 的时候会将第三个 2 包含进来，也就是`1，2` 这个解，但是前面已经求出了`[2,1]` 这就重复了，排序就是为了将相同的元素聚合到一起，这样遇到相同的元素就跳过，后面的元素就不会再包含已经遍历过的元素了\n\n```java\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return res;\n    }\n    //需要先排序，便于跳过相同的元素\n    Arrays.sort(nums);\n    subsets(nums,0,new ArrayList());\n    return res;\n}\n\nprivate  List<List<Integer>> res=new ArrayList<>();\n\npublic void subsets(int[] nums,int index,List<Integer> lis) {\n    res.add(new ArrayList(lis));\n    for (int i=index;i<nums.length;i++) {\n        if (i>index && nums[i] == nums[i-1]) {\n            continue;\n        }\n        lis.add(nums[i]);\n        subsets(nums,i+1,lis);\n        lis.remove(lis.size()-1);\n    }\n}\n```\n\n**Update: 2020.6.20**\n\n用 go 重写了一遍，复习下\n```golang\nfunc subsetsWithDup(nums []int) [][]int {\n    sort.Ints(nums)\n    var res [][]int\n    var lis []int\n    var dfs func(index int)\n    dfs = func(index int){\n        dest:=make([]int,len(lis))\n        copy(dest,lis)\n        res=append(res,dest)\n        for i:=index;i<len(nums);i++{\n            if i>index && nums[i]==nums[i-1]{\n                continue\n            }\n            lis=append(lis,nums[i])\n            dfs(i+1)\n            lis=lis[:len(lis)-1]\n        }\n    }\n    dfs(0)\n    return res\n}\n```\n\n## [357. 计算各个位数不同的数字个数](https://leetcode-cn.com/problems/count-numbers-with-unique-digits/)\n\n给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。\n\n**示例：**\n\n```java\n输入：2\n输出：91 \n解释：答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。\n```\n\n**解法一**\n\n> 这里要存个疑问，这里的回溯记忆化应该是错的，可能是数据太少了，没测试出来，但是居然真的提高了效率。这就很诡异\n\n```java\n//这种可以做记忆化，0ms\nInteger[] cache=null;\n\npublic int countNumbersWithUniqueDigits2(int n) {\n    boolean[] visit=new boolean[10];\n    cache=new Integer[n+1];\n    int res=0;\n    if (n==0) return 1;\n    for (int i=1;i<=9;i++) { //不考虑 0 开头的\n        visit[i]=true;\n        res+=countNumbersWithUniqueDigits2(n,visit,1);\n        visit[i]=false;\n    }\n    return res+1; //加的是 0 这种情况\n}\n\n//[index,n](位数)区间内，能构成最多的不重复数字\npublic int countNumbersWithUniqueDigits2(int n,boolean[] visit,int index){\n    if (index==n) { //没得选，只有一种\n        return 1;\n    }\n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    int count=1;\n    for (int i=0;i<=9;i++) {\n        if (!visit[i]) {\n            visit[i]=true;\n            count+=countNumbersWithUniqueDigits2(n,visit,index+1);\n            visit[i]=false;\n        }\n    }\n    return cache[index]=count;\n}\n```\n我都不好意思放到回溯专题中，开始写了个贼脑残的回溯 451ms，实在不好意思放上来\n\n**解法二**\n\n```java\n//数学方法（初中数学）\npublic int countNumbersWithUniqueDigits3(int n){\n    if (n==0) return 1;\n    if (n>10) return 0;\n    int res=10,count=9; //i=1 的情况\n    for (int i=2;i<=n;i++) {\n        count*=(11-i); //9*9*8*7*6*5.....\n        res+=count;\n    }\n    return res;\n}\n```\n说实话，这种方法我一开始写第一种很脑残的回溯的时候推出来了的，但是我居然没意识到。\n\n## 89. 格雷编码\n\n格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。\n\n给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。\n\n**示例 1:**\n\n```java\n输入：2\n输出：[0,1,3,2]\n解释：\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\n对于给定的 n，其格雷编码序列并不唯一。\n例如，[0,2,3,1] 也是一个有效的格雷编码序列。\n\n00 - 0\n10 - 2\n11 - 3\n01 - 1\n```\n\n**示例 2:**\n\n```java\n输入：0\n输出：[0]\n解释：我们定义格雷编码序列必须以 0 开头。\n     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。\n     因此，当 n = 0 时，其格雷编码序列为 [0]。\n```\n\n**解法一**\n\n又一个脑残做法。\n\n```java\npublic List<Integer> grayCode3(int n) {\n    List<Integer> res=new ArrayList<>();\n    res.add(0);\n    int max=(1<<n)-1; //注意优先级\n    boolean[] visit=new boolean[max+1];\n    grayCode3(max,res,visit);\n    return res;\n}\n\npublic boolean grayCode3(int max,List<Integer> lis,boolean[] visit) {\n    if (lis.size()>max) { // list.size()==max+1 eg. when max=3 the list.size()=4\n        return true;\n    }\n    int last=lis.get(lis.size()-1);\n    for (int i=1;i<=max;i++) {\n        if (!visit[i] && Integer.bitCount(i^last)==1) {\n            lis.add(i);\n            visit[i]=true;\n            if(grayCode3(max,lis,visit)){\n                return true;\n            }\n            lis.remove(lis.size()-1);\n            visit[i]=false;\n        }\n    }\n    return false;\n}\n```\n\n**解法二**\n\n正常的回溯，每次修改一位，**直接生成下一个可能的格雷码**，而不是向上面一样一个个遍历。\n\n```java\n//常规回溯\npublic List<Integer> grayCode2(int n) {\n    List<Integer> res=new ArrayList<>();\n    boolean[] visit=new boolean[1<<n];\n    res.add(0);\n    visit[0]=true;\n    grayCode2(n,res,visit,0);\n    return res;\n}\n\npublic boolean grayCode2(int n,List<Integer> lis,boolean[] visit,int last) {\n    if (lis.size()>=(1<<n)) { // list.size()==max+1 eg. when max=3 the list.size()=4\n        return true;\n    }\n    for (int i=0;i<n;i++) {\n        //直接生成下一个\n        int next=last^(1<<i); //这一步其实就是从后往前，依次改变 last 一位\n        if (!visit[next]) {\n            lis.add(next);\n            visit[next]=true;\n            if(grayCode2(n,lis,visit,next)){\n                return true;\n            }\n            lis.remove(lis.size()-1);\n            visit[next]=false;\n        }\n    }\n    return false;\n}\n```\n**解法三**\n\n不停的和自己右移一位的值做异或，最终就可以的到完整的格雷码，至于原理并不想去研究😂，先记住再说\n\n```java\n//最优解，规律\npublic List<Integer> grayCode(int n) {\n    List<Integer> res=new ArrayList<>();\n    for (int i=0;i<1<<n;i++) {\n        res.add(i^(i>>1));\n    }\n    return res;\n}\n```\n看了评论区发现还有个规律，每一层的格雷码都是上一层前面加 0 和逆序上一层在前面加 1，感觉可能和上面的规律是一样的，一图以蔽之\n\n![leetCode 题解](http://static.imlgw.top/blog/20191219/7rzdkpDvA4IN.png?imageslim)\n\n## [526. 优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)\n\n假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：\n\n1. 第 i 位的数字能被 i 整除\n2. i 能被第 i 位上的数字整除\n\n现在给定一个整数 N，请问可以构造多少个优美的排列？\n\n**解法一**\n\n回溯法\n\n```java\npublic int countArrangement(int N) {\n    boolean[] visit=new boolean[N+1];\n    return countArrangement(N,visit,1);\n}\n\npublic int countArrangement(int N,boolean[] visit,int index) {\n    if (index > N) {\n        return 1;\n    }\n    int res=0;\n    for (int i=1;i<=N;i++) {\n        if (!visit[i] && (index%i==0 || i%index==0)) {\n            visit[i]=true;\n            res+=countArrangement(N,visit,index+1);\n            visit[i]=false;\n        }\n    }\n    return res;\n}\n```\n\n其实我是想改成记忆化递归的，不然我也不会这样写，但是后面改的时候居然出了 bug，这也算是打醒了我，我一直以为这样的回溯都能改成记忆化递归。这里很明显无法做记忆化，因为你每次回溯的时候 index 相同，但是 visit 数组的状态是不一样的，直接记忆化肯定就错了。但是说到这里我发现上面的 [357. 各个位数不同数字个数](##) 居然这样过了，并且还真的提高了效率。\n\n## [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)\n\n给定一个字符串 S，通过将字符串 S 中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。\n\n**示例：**\n\n```java\n输入：S = \"a1b2\"\n输出：[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]\n\n输入：S = \"3z4\"\n输出：[\"3z4\", \"3Z4\"]\n\n输入：S = \"12345\"\n输出：[\"12345\"]\n```\n\n**注意：**\n\n- S 的长度不超过 12。\n- S 仅由数字和字母组成。 \n\n**解法一**\n\n一看是简单题，屁颠屁颠就开始搞，结果发现没想象中简单（主要是我太菜了）\n\n```java\nprivate List<String> res=new ArrayList<>();\n\npublic List<String> letterCasePermutation(String S) {\n    letterCasePermutation(S,0,new StringBuilder(S));\n    return res;\n}\n\npublic void letterCasePermutation(String S,int index,StringBuilder cur) {\n    res.add(cur.toString()); //变化一次就添加一次\n    for (int i=index;i<S.length();i++) {\n        char c=S.charAt(i);\n        if (c>='0' && c<='9') {\n            continue;\n        }\n        cur.replace(i,i+1,letterCase(c));\n        letterCasePermutation(S,i+1,cur);\n        cur.replace(i,i+1,letterCase(cur.charAt(i))); //状态重置\n    }\n}\n\n//这里其实有一个小技巧：c^(1<<5) 就可以使大写变小写，小写变大写\npublic String letterCase(char c){\n    if (c>='a' && c<='z') { //65:A 97:a\n        c-=32;\n    }else if (c>='A' && c<='Z') {\n        c+=32;\n    }\n    return c+\"\";\n}\n```\n这里的状态重置和之前的不太一样，不过整体还是很好想的，其实也可以完全不用循环的形式\n\n## [1079. 活字印刷](https://leetcode-cn.com/problems/letter-tile-possibilities/)\n\n你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。\n\n**示例 1：**\n\n```java\n输入：\"AAB\"\n输出：8\n解释：可能的序列为 \"A\", \"B\", \"AA\", \"AB\", \"BA\", \"AAB\", \"ABA\", \"BAA\"。\n```\n\n**示例 2：**\n\n```java\n输入：\"AAABBC\"\n输出：188\n```\n\n**提示：**\n\n1. `1 <= tiles.length <= 7`\n2. `tiles` 由大写英文字母组成\n\n**解法一**\n\n这道题还是挺有意思的，有点结合全排列和子集的意思，\n\n```java\npublic int numTilePossibilities(String tiles) {\n    boolean[] visit=new boolean[tiles.length()];\n    char[] cs=tiles.toCharArray();\n    Arrays.sort(cs);\n    numTilePossibilities(cs,visit);\n    return count;\n}\n\nint count=-1;\n\n//排序去重\npublic void numTilePossibilities(char[]cs,boolean[] visit) {\n    count++;\n    for (int i=0;i<cs.length;i++) {\n        //想清楚这里为啥必须是！visit[i-1]\n        if(i>0 && cs[i]==cs[i-1] && !visit[i-1]){ \n            continue;\n        }\n        if (!visit[i]) {\n            visit[i]=true;\n            numTilePossibilities(cs,visit);\n            visit[i]=false;\n        }\n    }\n}\n```\n这题收获比较大，对排列组合类型的题目又多了一层理解，同时也纠正了之前的错误观点\n\n### Bug 警告！！！\n\n看一下最开始写的错误解法，唯一的区别就在这个`!visit[i-1]`上！\n\n```java\n if (i>0 && cs[i]==cs[i-1] && visit[i-1])\n```\n\n这里我之前一直理解成了保留第一个分支，上一个元素已经访问过了，后面就直接跳过，做了这一题写出问题了才知道原来这里完全理解反了😂，当时没有仔细想，其实这里细想一下就很容易发现问题，visit 数组其实保证的是当前这一条**自上而下的纵向分支内不会有重复位置的元素被选取**，而这里我们**要确保的其实是横向的不重复，也就是同一层内不重复**，所以这里使用`visit[i-1]` 其实从语义上来说就是有问题的，画个图来说明下为啥会有问题\n\n![mark](http://static.imlgw.top/blog/20200625/HekOxo1dFTYw.png?imageslim)\n\n画个递归树，然后模拟一下，其实就明白了，使用`visit[i-1]`的方式，生成的第一个分支其实就不完整了，只有后面的第二个分支才会是完整的，所以**可以理解为保留最后一个分支，将前面的分支剪掉**，在全排列中因为有长度限制，第一个分支并没有达到给定的长度，所以并不会加入结果集，对结果没有影响，（其实是会影响效率的，会重复的遍历分支，这个打印一下生成全排列过程的结果集就能看出来）\n\n但是在这一题，并没有长度的限制，所以 count 会将第一个不完整的分支也当作结果集算进去，而后面第二个分支的时候（完整分支）又会计算一遍，结果就错了\n\n**那为什么`!visit[i-1]` 就可以呢？**\n\n其实也很好理解，visit 虽然保证的是纵向的不重复，但是每遍历完一个分支后，都会回溯状态，而我们又是**按照顺序来遍历元素**的，所以如果上一个元素的 visit[i] 是 false，那就说明上一个元素的分支已经遍历完了！以它开头的所有排列都找完了，这个时候我们判断是否相等然后跳过，才是真正的保留了第一个分支！后面的直接跳过，减少了多余的操作，同时也不会出现 bug，所以你明白以后要用那个了吧😉\n\n## [1291. 顺次数](https://leetcode-cn.com/problems/sequential-digits/)\n\n我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。\n\n请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。\n\n**示例 1：**\n\n```java\n输出：low = 100, high = 300\n输出：[123,234]\n```\n\n**示例 2：**\n\n```java\n输出：low = 1000, high = 13000\n输出：[1234,2345,3456,4567,5678,6789,12345]\n```\n\n**提示：**\n\n- 10 <= low <= high <= 10^9 \n\n**解法一**\n\n回溯 tag 下的，某一次周赛的题，我写的已经不像回溯了，尾递归，有点鸡肋\n\n```java\npublic List<Integer> sequentialDigits(int low, int high) {\n    String slow=String.valueOf(low);\n    int slen=slow.length();\n    int first=Integer.valueOf(slow.charAt(0))-'0'-1;\n    List<Integer> res=new ArrayList<>();\n    int start=first,len=slen;\n    if(first+len>9){\n        start=0;\n        len++;\n    }\n    sequentialDigits(low,high,start,len,res);\n    return res;\n}\n\nprivate String str=\"123456789\";\n\npublic void sequentialDigits(int low,int high,int start,int len,List<Integer> list) {\n    if(start+len>9) return;\n    int cur=Integer.valueOf(str.substring(start,start+len));\n    if(cur>high){\n        return;\n    }\n    if(cur>=low){\n        list.add(cur);\n    }\n    if(start+len==9){\n        sequentialDigits(low,high,0,len+1,list);    \n    }else{\n        sequentialDigits(low,high,start+1,len,list);\n    }\n}\n```\n\n其实直接暴力枚举`1~9`的所有顺序组合然后判断在不在`low~high` 之间就 ok 了，最再排个序就 ok，一共也只有 36 个，个人感觉我上面的还是比单纯的暴力会好一点，首先不用排序，其次也不会从头开始遍历，会根据 low 的值来选取从哪里开始截取，但是这题数据量有限，体现不出来差异\n\n## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)\n\n给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n\n例如，给出 `n = 3`，生成结果为：\n\n```java\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n```\n\n**解法一**\n\n哎，知道是回溯还是没做出来，还是太菜了啊\n\n```java\npublic List<String> generateParenthesis(int n) {\n    dfs(n,\"\",0,0);\n    return res;\n}\n\nprivate List<String> res=new LinkedList<>();\n\npublic void dfs(int n,String sb,int left,int right) {\n    if (left>n /*|| right>n*/ || right>left) {\n        return;\n    }\n    if (left==n && right ==n) {\n        res.add(sb.toString());   \n        return;\n    }\n    dfs(n,sb+\"(\",left+1,right);\n    dfs(n,sb+\")\",left,right+1);\n}\n```\n关键还是没想明白这题的递归条件，我知道是先生成 \"(“ 再生成 \")\" 但是终止条件一直没想清楚，其实我们需要给左右括号加一个计数器`left 和 right`，用来记录已经生成的左右括号的数量，然后我们思考终止条件是啥，首先很容易想到的就是左右括号数量 `left==right` 的时候，这是合法的终止条件，但是这样就够了么？很明显不够，`()))((` 类似这样的就并不是合法的，所以我们还需要保证生成括号的合法性，所以这种时候若是不太清楚的就可以来画一画递归树\n\n![mark](http://static.imlgw.top/blog/20191024/9uvjEQzjtKtf.png?imageslim)\n\n图画的比较魔性，但是还是很容易看懂的，通过这个递归树我还发现了上面代码的一点小问题，`right>n` 是个冗余条件，合法条件 `right< left < n`，right 肯定不会超过 n，正如上面三个画 ❌的地方就是对应的三个不合法的终止条件，有了这个就可以很容易的写出回溯代码，下面的是用的`StringBuilder`的，需要回溯字符串，更符合回溯的思想，上面的 String 是不可变对象，所以不需要手动回溯\n\n```java\npublic List<String> generateParenthesis(int n) {\n    dfs(n,new StringBuilder(),0,0);\n    return res;\n}\n\nprivate List<String> res=new LinkedList<>();\n\npublic void dfs(int n,StringBuilder sb,int left,int right) {\n    if (left>n || right>n || right>left) {\n        return;\n    }\n    if (left==n && right ==n) {\n        res.add(sb.toString());\n        return;\n    }\n    dfs(n,sb.append(\"(\"),left+1,right);\n    sb.delete(sb.length()-1,sb.length());\n    dfs(n,sb.append(\")\"),left,right+1);\n    sb.delete(sb.length()-1,sb.length());\n}\n```\n\n## [306. 累加数](https://leetcode-cn.com/problems/additive-number/)\n\n累加数是一个字符串，组成它的数字可以形成累加序列。\n\n一个有效的累加序列必须**至少**包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。\n\n给定一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是累加数。\n\n**说明：** 累加序列里的数不会以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。\n\n**示例 1:**\n\n```java\n输入：\"112358\"\n输出：true \n解释：累加序列为：1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n```\n\n**示例 2:**\n\n```java\n输入：\"199100199\"\n输出：true \n解释：累加序列为：1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199\n```\n\n**进阶：**\n\n- 你如何处理一个溢出的过大的整数输入？\n\n**解法一**\n\n在回溯专题里翻到的，说实话，case 有点恶心\n\n```java\npublic boolean isAdditiveNumber(String num) {\n    LinkedList<String> list=new LinkedList<>();\n    list.add(\"-1\");\n    return dfs(num,0,list);\n}\n\npublic boolean dfs(String num,int index,List<String> list) {\n    //System.out.println(list);\n    if (index==num.length() && list.size()>4) {\n        return true;\n    }\n    for(int i=index+1;i<=num.length();i++){\n        //0 开头应该直接 break, 除非是单独的 0....\n        if (num.charAt(index)=='0' && i>index+1) { //\"101\" .....\n            break;\n        }\n        //剪枝\n        if (i-index>num.length()/2) {\n            return false;\n        }\n        String sub=num.substring(index,i);\n        String a=list.get(list.size()-1);\n        String b=list.get(list.size()-2);\n        list.add(sub);\n        if ((\"-1\".equals(a)||\"-1\".equals(b) || addTwoStr(a,b).equals(sub)) && dfs(num,i,list)) {\n            return true;\n        }\n        list.remove(list.size()-1);\n    }\n    return false;\n}\n\n//大数相加\nprivate String addTwoStr(String a,String b){\n    StringBuilder res=new StringBuilder();\n    int aIdx=a.length()-1;\n    int bIdx=b.length()-1;\n    int temp=0; //进位\n    while(aIdx>=0 || bIdx>=0) {\n        int as=aIdx>=0?a.charAt(aIdx)-48:0;\n        int bs=bIdx>=0?b.charAt(bIdx)-48:0;\n        int sum=as+bs+temp;\n        temp=(sum)/10;\n        res.append(sum%10);\n        aIdx--;bIdx--;\n    }\n    if (temp==1) {\n        res.append(1);\n    }\n    return res.reverse().toString();\n}\n```\n\n回溯不难想到，这一类回溯咋说呢，属于 “一镜到底” 的那种，可以看看解数独的哪个解法，也是这样的（其实就是参考的那个）带一个 boolean 返回值，走到结尾走不通才会回溯，N 皇后这种就不太一样，不管是否成功都会回溯，反正目前大致的感觉就是这样，后面遇到更多题型再来总结\n\n不过感觉这题的关键不是回溯，而是边界的处理，首先是溢出的问题，我看见有进阶的就没考虑溢出，结果还是溢出了，而且溢出了两次！！！最后没办法，也不想用`BigInteger`就自己写了大数相加的逻辑\n\n除了溢出的问题，这题需要注意 `0 ` 在这个`0` 上也 WA 了一发，因为回溯还是在分割字符串，但是如果有 0 的话就不能随便的分割了，具体看代码就懂了\n\n## [842. 将数组拆分成斐波那契序列](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/)\n\n给定一个数字字符串 S，比如 S = \"123456579\"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。\n\n形式上，斐波那契式序列是一个非负整数列表 F，且满足：\n\n- 0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；\n- F.length >= 3；\n- 对于所有的 0 <= i < F.length - 2，都有 `F[i] + F[i+1] = F[i+2]` 成立。\n\n另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。\n\n返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 `[]`。\n\n**示例 1：**\n\n```java\n输入：\"123456579\"\n输出：[123,456,579]\n```\n\n**示例 2：**\n\n```java\n输入：\"11235813\"\n输出：[1,1,2,3,5,8,13]\n```\n\n**示例 3：**\n\n```jsvs\n输入：\"112358130\"\n输出：[]\n解释：这项任务无法完成。\n```\n\n**示例 4：**\n\n```java\n输入：\"0123\"\n输出：[]\n解释：每个块的数字不能以零开头，因此 \"01\"，\"2\"，\"3\" 不是有效答案。\n```\n\n**示例 5：**\n\n```java\n输入：\"1101111\"\n输出：[110, 1, 111]\n解释：输出 [11,0,11,11] 也同样被接受。\n```\n\n**提示：**\n\n- `1 <= S.length <= 200`\n- 字符串 S 中只含有数字。\n\n**解法一**\n\n和上面那题一样，但是这题会简单一点，不用处理大数相加的情况，同时限定了数字的范围就是 32 位 int，所以只要范围超过了 int32 就直接 break\n\n```java\npublic List<Integer> splitIntoFibonacci(String S) {\n    LinkedList<Integer> res=new LinkedList<>();\n    dfs(S,0,res);\n    return res;\n}\n\npublic boolean dfs(String S,int index,List<Integer> lis){\n    if (index == S.length()) {\n        return lis.size()>2;\n    }\n    for (int i=index+1;i<=S.length();i++) {\n        String temp=S.substring(index,i);\n        //长度大于 10, 或者 Long 解析出来大于 INT_MAX 了就直接 break\n        if (S.charAt(index) == '0' && i>index+1 || temp.length()>10 || Long.valueOf(temp)>Integer.MAX_VALUE) {\n            break;\n        }\n        int str=Integer.valueOf(temp);\n        int one=lis.size()>=2 ? lis.get(lis.size()-1):-1;\n        int two=lis.size()>=2 ? lis.get(lis.size()-2):-1;\n        lis.add(str);\n        if ((one==-1 || two==-1 || one+two==str) && dfs(S,i,lis)) {\n            return true;\n        }\n        lis.remove(lis.size()-1);\n    }\n    return false;\n}\n```\n\n## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n**说明：**\n\n- 拆分时可以重复使用字典中的单词。\n- 你可以假设字典中没有重复的单词。\n\n**示例 1：**\n\n```java\n输入：s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出：true\n解释：返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出：true\n解释：返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出：false\n```\n\n**解法一**\n\n回溯 DFS+记忆化\n\n```java\nBoolean[] cache=null;\n\npublic boolean wordBreak(String s, List<String> wordDict) {\n    if (s==null || s.length()<=0) {\n        return false;\n    }\n    cache=new Boolean[s.length()];\n    HashSet<String> set=new HashSet<>(wordDict);\n    return dfs(s,set,0);\n}\n\n//判断【index,s.len】中的字符是否能拆分\npublic boolean dfs(String s, HashSet<String> dict,int index) {\n    //这里的终止条件还是有点迷惑的，这里 index 只有在字典中存在当前元素的时候才会向后移动\n    //所以当 index 移动到 s==length 的是偶就说明前面的单词都匹配上了\n    if (index==s.length()) {\n        return true;\n    }\n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    for (int i=index+1;i<=s.length();i++) {\n        //System.out.println(s.substring(index,i));\n        if (dict.contains(s.substring(index,i)) && dfs(s,dict,i)){\n            return cache[index]=true;\n        }\n    }\n    return cache[index]=false;\n}\n```\n\n很久之前做的题目，在做这题进阶版的时候发现这一题做了但是没有记录。可能是忘了\n\n这里回溯记忆化没啥好说的，也是属于那种 “一镜到底” 类型的\n\n**解法二**\n\nBFS\n\n```java\n//BFS, 需要一个 visit 保证不会重复访问\npublic boolean wordBreak(String s, List<String> wordDict) {\n    if (s==null || s.length()<=0) {\n        return false;\n    }\n    HashSet<String> dict=new HashSet<>(wordDict);\n    //queue 中存 index\n    LinkedList<Integer> queue=new LinkedList<>();\n    boolean[] visit=new boolean[s.length()];\n    queue.add(0);\n    while(!queue.isEmpty()){\n        int index=queue.poll();\n        if (!visit[index]) {\n            for (int i=index+1;i<=s.length();i++) {\n                if(dict.contains(s.substring(index,i))){\n                    if (i==s.length()) {\n                        return true;\n                    }\n                    queue.add(i);\n                }\n            }\n            visit[index]=true;\n        }\n    }\n    return false;\n}\n```\n\n自己写的居然一点印象都没有，BFS 感觉也没啥好说的\n\n**解法三**\n\n动态规划，这个当时没有写出来，今天重新看的时候发现有 dp 的 tag 就写了一下，还是挺简单的\n\n```java\npublic boolean wordBreak(String s, List<String> wordDict) {\n    if (s==null || s.length()<=0) {\n        return false;\n    }\n    HashSet<String> dict=new HashSet<>(wordDict);\n    boolean[] dp=new boolean[s.length()+1];\n    dp[0]=true;\n    for (int i=1;i<=s.length();i++) {\n        for (int j=0;j<=i;j++) {\n            if (dp[j] && dict.contains(s.substring(j,i))) {\n               dp[i]=true; //相比上面的可以 break\n               break;\n            }\n        }\n    }\n    return dp[s.length()];\n}\n```\n## [140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)\n\n给定一个**非空**字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。\n\n**说明：**\n\n- 分隔时可以重复使用字典中的单词。\n- 你可以假设字典中没有重复的单词。\n\n**示例 1：**\n\n```java\n输入：\ns = \"catsanddog\"\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\n输出：\n[\n  \"cats and dog\",\n  \"cat sand dog\"\n]\n```\n\n**示例 2：**\n\n```java\n输入：\ns = \"pineapplepenapple\"\nwordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\n输出：\n[\n  \"pine apple pen apple\",\n  \"pineapple pen apple\",\n  \"pine applepen apple\"\n]\n解释：注意你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```java\n输入：\ns = \"catsandog\"\nwordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出：\n[]\n```\n\n**解法一**\n\n这题要求出所有的序列，所以 dp 肯定是不好整了，直接上回溯\n\n```java\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict=new HashSet<>(wordDict);\n    dfs(s,0,\"\",dict);\n    return res;\n}\n\nprivate List<String> res=new ArrayList<>();\n\npublic void dfs(String s,int index,String word,HashSet<String> dict){\n    if (index==s.length()) {\n        res.add(word.substring(0,word.length()-1));\n        return;\n    }\n    for (int i=index+1;i<=s.length();i++) {\n        String str=s.substring(index,i);\n        if (dict.contains(str)) {\n            //word.append(str+\" \"); // app#pa# \n            dfs(s,i,word+str+\" \",dict);\n            //word.delete(word.length()-(i-),i);\n        }\n    }\n}\n```\n\n很可惜，超时了，卡在了 aaaaaaaa.... 那个 case 上，翻了评论区，发现很多人借用了上一题的解法，先对整个 s 做可行性分析，也就是看能不能拆分，能拆分然后再进行回溯，这样就刚好跳过了那个 case，好像确实是可以过，但是我感觉有点面向 case 编程了。\n\n**解法二**\n\n记忆化回溯，上面的过程分析一下会发现其实有很多的重复计算，所以我们可以有针对性的做记忆化，加快搜索速度\n\n```java\n//做记忆化\nHashMap<String,List<String>> cache=new HashMap<>();\n\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict=new HashSet<>(wordDict);\n    return dfs(s,dict);\n}\n\npublic List<String> dfs(String s,HashSet<String> dict){\n    if (cache.containsKey(s)) {\n        return cache.get(s);\n    }\n    List<String> res=new ArrayList<>();\n    if (s.length()==0) {\n        return res;\n    }\n    for (int i=0;i<=s.length();i++) {\n        String word=s.substring(0,i);\n        if (dict.contains(word)) {\n            if (i==s.length()) {\n                res.add(word);\n            }else{\n                //剩余字符\n                List<String> temp=dfs(s.substring(i,s.length()),dict);\n                for (String tmp:temp) {\n                    res.add(word+\" \"+tmp);\n                }\n            }\n        }\n    }\n    cache.put(s,res);\n    return res;\n}\n```\n\n其实我这里也是参考了评论区的解法，我上面的那种回溯的方式要改成记忆化有点不好搞，有两个变量，另外我感觉这种**回溯分割**的方式感觉更加的直观易懂 get\n\n**UPDATE: 2020.7.8**\n\n偶然看到这个题，重写了一下，直接记忆化\n```golang\n//记忆化递归\nfunc wordBreak(s string, wordDict []string) []string {\n    var set = make(map[string]bool)\n    var cache = make(map[string][]string)\n    for i := 0; i < len(wordDict); i++ {\n        set[wordDict[i]] = true\n    }\n    return dfs(s, set, cache)\n}\n\nfunc dfs(s string, set map[string]bool, cache map[string][]string) []string {\n    if _, ok := cache[s]; ok {\n        return cache[s]\n    }\n    var res []string\n    for i := 1; i <= len(s); i++ {\n        if set[s[:i]] {\n            if i == len(s) {\n                res = append(res, s[:i])\n            } else {\n                temp := dfs(s[i:], set, cache)\n                for _, w := range temp {\n                    res = append(res, s[:i]+\" \"+w)\n                }\n            }\n        }\n    }\n    cache[s] = res\n    return res\n}\n\n```\n\n## [473. 火柴拼正方形](https://leetcode-cn.com/problems/matchsticks-to-square/)\n\n还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。\n\n输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。\n\n**示例 1:**\n\n```java\n输入：[1,1,2,2,2]\n输出：true\n\n解释：能拼成一个边长为 2 的正方形，每边两根火柴。\n```\n\n**示例 2:**\n\n```java\n输入：[3,3,3,3,4]\n输出：false\n\n解释：不能用所有火柴拼成一个正方形。\n```\n\n**注意：**\n\n1. 给定的火柴长度和在 `0` 到 `10^9`之间。\n2. 火柴数组的长度不超过 15。\n\n**解法一**\n\n```java\n//等价于能否将 nums 分为 4 等分\npublic boolean makesquare(int[] nums) {\n    if(nums==null || nums.length<4){\n        return false;\n    }\n    int N=nums.length;\n    int sum=0;\n    for(int i=0;i<N;i++){\n        sum+=nums[i];\n    }\n    if(sum%4!=0) return false;\n    int[] side=new int[4];\n    Arrays.sort(nums);\n    return dfs(nums,N-1,side,sum/4);\n}\n\npublic boolean dfs(int[] nums,int index,int[] side,int avg){\n    if(index==-1){\n        return true;\n    }\n    for(int i=0;i<side.length;i++){\n        //if(side[i]+nums[index]<=avg){\n        int rest=avg-side[i]-nums[index];\n        if(rest==0 || rest>=nums[0]){ //改进剪枝方式\n            side[i]+=nums[index];\n            if(dfs(nums,index-1,side,avg)){\n                return true;\n            }\n            side[i]-=nums[index];\n        }\n    }\n    return false;\n}\n```\n一开始没想到分桶的做法，只想着这么搜索 4 等分，看了一眼评论区就明白了，抽象出 4 条边，然后遍历所有火柴，尝试将火柴放入所有的盒子，看有没有一种可能是 4 等分的，说白了其实就是暴力搜索，然后加上一点剪枝优化，这题就不细说了，关键看下面这题\n\n## [698. 划分为 k 个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/)\n\n给定一个整数数组  `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。\n\n**示例 1：**\n\n```java\n输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4\n输出： True\n说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。\n```\n\n**注意：**\n\n- `1 <= k <= len(nums) <= 16`\n- `0 < nums[i] < 10000`\n\n**解法一**\n\n[473. 火柴拼正方形](#473-火柴拼正方形)其实只是这道题的一个子问题，关键搞懂这题就行了\n\n```java\npublic boolean canPartitionKSubsets(int[] nums, int k) {\n    if(nums==null || nums.length<=0){\n        return false;\n    }\n    int sum=0;\n    for(int i=0;i<nums.length;i++){\n        sum+=nums[i];\n    }\n    if(sum%k!=0) return false;\n    Arrays.sort(nums);\n    return dfs(nums,nums.length-1,new int[k],sum);\n}\n\npublic boolean dfs(int[] nums,int index,int[] bucket,int sum){\n    //sum(bucket)==sum\n    //if 条件：bucket[i]<=sum/bucket.len => bucket[i]<=sum(bucket)/bucket.len\n    //所以不用单独去判断是否都相等，直接 retuen true\n    if(index==-1){\n        return true;\n    }\n    for(int i=0;i<bucket.length;i++){\n        //普通的剪枝 60ms，只判断了是否小于平均值\n        //if(bucket[i]+nums[index]<=sum/bucket.length){\n        //更好的剪枝方式 1ms，判断剩余空间不为 0 的时候还能不能填其他元素\n        int rest=sum/bucket.length-bucket[i]-nums[index];\n        if(rest==0 || rest>=nums[0]){ //小于 nums[0] 就啥也填不了了\n            bucket[i]+=nums[index];\n            if(dfs(nums,index-1,bucket,sum)){\n                return true;\n            }\n            bucket[i]-=nums[index];\n        }\n    }\n    return false;\n}\n```\n\n其实总体上来说还是暴力的搜索，然后加上一些剪枝优化的手段，首先能想到的是**约束桶内元素和要小于等于`sum/k`**，这样就能减去很多无效搜索，但是仅仅这样还是无法 AC 这题，还有一步很关键的优化点是**排序**，排序后我们从大往小搜索，也就是优先将大的元素放入桶中，尽快满足 if 条件，经过上面的优化就可以成功的 AC 了，耗时 60ms 左右，但是看了评论区的大佬的解法后发现还有一种更好的剪枝方式，就是考虑放下当前元素后还能不能放下其他的元素，如果刚好放下就直接放，如果放下后还有剩余空间，且这个剩余空间很小，连`nums[0]`都放不下（前面排序了）那么这种情况也是可以直接剪掉的，时间优化到 1ms\n\n> `index==-1`为什么就直接返回 true 了？简单推一下就行了\n>\n> 首先`index==-1`说明所有元素都已经放入`bucket`中了，所以`sum(bucket)=sum(nums)`\n>\n> 再来看我们的 if 条件：约束桶内元素小于等于`sum/k`，也就是`bucket[i]<=sum(nums)/k` 借助上面的结论，转换一下就是 `bucket[i]<=sum(bucket)/k`也就是`bucket[i]<=avg(bucket)`很明显，只有在每个桶内元素都相等的时候才成立，故这里可以直接返回 true\n\n**解法二**\n\n官方提供了一个状压的方法，但是没看懂，自己试着压了下没过，懒得去研究了\n\n## [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)\n\nDifficulty: **中等**\n\n给定一个整型数组，你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2。\n\n**示例：**\n\n```\n输入：[4, 6, 7, 7]\n输出：[[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n```\n\n**说明：**\n\n1.  给定数组的长度不会超过 15。\n2.  数组中的整数范围是 [-100,100]。\n3.  给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。\n\n**解法一**\n\n感觉今天晚上状态不太好，好久没写回溯了，写了几发思路都有问题，最后瞄了一眼评论区才反应过来，和上面 [842-将数组拆分成斐波那契序列](#842-将数组拆分成斐波那契序列)很类似，都是利用 lis 数组上次存值判断，当时这题还是我独立写出来的，写完发的 code 评论还是个热评，今天写这题居然没反应过来，太菜了😥\n```golang\nfunc findSubsequences(nums []int) [][]int {\n    var n = len(nums)\n    var res [][]int\n    var dfs func(int, []int)\n    dfs = func(index int, lis []int){\n        if len(lis) >= 2{\n            dest := make([]int, len(lis))\n            copy(dest, lis)\n            res = append(res, dest)\n        }\n        //保证一次 for 循环中没有重复的就行了，根据取值范围做下偏移\n        var visit = make([]bool, 201)\n        for i := index; i < n; i++{\n            if !visit[nums[i]+100] && (len(lis) == 0 || nums[i] >= lis[len(lis)-1]) {\n                visit[nums[i]+100] = true\n                lis = append(lis, nums[i])\n                dfs(i+1, lis)\n                lis = lis[:len(lis)-1]\n            }\n        }\n    }\n    dfs(0, make([]int, 0))\n    return res\n}\n```\n\n## [679. 24 点游戏](https://leetcode-cn.com/problems/24-game/)\n\nDifficulty: **困难**\n\n你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 `*`，`/`，`+`，`-`，`(`，`)` 的运算得到 24。\n\n**示例 1:**\n\n```go\n输入：[4, 1, 8, 7]\n输出：True\n解释：(8-4) * (7-1) = 24\n```\n\n**示例 2:**\n\n```go\n输入：[1, 2, 1, 2]\n输出：False\n```\n\n**注意：**\n\n1.  除法运算符 `/` 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。\n2.  每个运算符对两个数进行运算。特别是我们不能用 `-` 作为一元运算符。例如，`[1, 1, 1, 1]` 作为输入时，表达式 `-1 - 1 - 1 - 1` 是不允许的。\n3.  你不能将数字连接在一起。例如，输入为 `[1, 2, 1, 2]` 时，不能写成 12 + 12 。\n\n**解法一**\n\n代码有点长，不过思路还是很清楚，一共 4 个数字，从里面任意选 2 个，然后做各种运算后和剩下的数字构成新的数组，然后重复该过程直到数组只剩下一个然后判断值是否是 24（注意精度）\n```golang\nfunc judgePoint24(nums []int) bool {\n    var eps float32 = 1e-5\n    var Abs = func(a float32) float32 {\n        if a < 0 {\n            return -a\n        }\n        return a\n    }\n    //计数+-*/\n    var compute = func(a, b float32) []float32 {\n        return []float32{a + b, a * b, a - b, a / b}\n    }\n    var dfs func([]float32) bool\n    dfs = func(nums []float32) bool {\n        if len(nums) == 0 {\n            return false\n        }\n        if len(nums) == 1 {\n            return Abs(nums[0]-24) < eps\n        }\n        var n = len(nums)\n        //从 nums 中选取 2 个数\n        for i := 0; i < n; i++ {\n            for j := 0; j < n; j++ {\n                if i == j {\n                    continue\n                }\n                //收集剩下的数字\n                var rest []float32\n                for k := 0; k < n; k++ {\n                    if k != i && k != j {\n                        rest = append(rest, nums[k])\n                    }\n                }\n                //尝试做各种运算\n                for _, v := range compute(nums[i], nums[j]) {\n                    if dfs(append(rest, v)) {\n                        return true\n                    }\n                }\n            }\n        }\n        return false\n    }\n    var temp = make([]float32, len(nums))\n    for i := 0; i < len(nums); i++ {\n        temp[i] = float32(nums[i])\n    }\n    return dfs(temp)\n}\n```\n\n## [5526. 最多可达成的换楼请求数目](https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/)\n\nDifficulty: **困难**\n\n我们有 `n` 栋楼，编号从 `0` 到 `n - 1` 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。\n\n给你一个数组 `requests` ，其中 requests[i] = [from<sub style=\"display: inline;\">i</sub>, to<sub style=\"display: inline;\">i</sub>] ，表示一个员工请求从编号为 from<sub style=\"display: inline;\">i</sub> 的楼搬到编号为 to<sub style=\"display: inline;\">i</sub>的楼。\n\n一开始 **所有楼都是满的**，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 **离开** 的员工数目 **等于** 该楼 **搬入** 的员工数数目。比方说 `n = 3` 且两个员工要离开楼 `0` ，一个员工要离开楼 `1` ，一个员工要离开楼 `2` ，如果该请求列表可行，应该要有两个员工搬入楼 `0` ，一个员工搬入楼 `1` ，一个员工搬入楼 `2` 。\n\n请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。\n\n**示例 1：**\n\n![0AZHr8.png](https://s1.ax1x.com/2020/09/27/0AZHr8.png)\n\n```go\n输入：n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n输出：5\n解释：请求列表如下：\n从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。\n从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 0 。\n从楼 3 离开的员工为 c ，且他想要搬到楼 4 。\n没有员工从楼 4 离开。\n我们可以让 x 和 b 交换他们的楼，以满足他们的请求。\n我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。\n所以最多可以满足 5 个请求。\n```\n\n**示例 2：**\n\n![0AZLVg.png](https://s1.ax1x.com/2020/09/27/0AZLVg.png)\n\n```go\n输入：n = 3, requests = [[0,0],[1,2],[2,1]]\n输出：3\n解释：请求列表如下：\n从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。\n从楼 1 离开的员工为 y ，且他想要搬到楼 2 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 1 。\n我们可以满足所有的请求。\n```\n\n**示例 3：**\n\n```go\n输入：n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n输出：4\n```\n\n**提示：**\n\n*   1 <= n <= 20\n*   1 <= requests.length <= 16\n*   requests[i].length == 2\n*   0 <= from<sub style=\"display: inline;\">i</sub>, to<sub style=\"display: inline;\">i</sub> < n\n\n**解法一**\n\n208 周赛 T4，有点白给，想好怎么处理就很简单（好不容易 T4 这么简单，被 T2，T3 给干懵了）\n```java\nclass Solution {\n    public int maximumRequests(int n, int[][] requests) {\n        int[] nums = new int[n+1];\n        dfs(nums, 0, requests, 0);\n        return res;\n    }\n    \n    int res = 0;\n    \n    public void dfs(int[] nums, int idx, int[][] requests, int count){\n        if (check(nums)) {\n            res = Math.max(res, count);\n        }\n        for (int i = idx; i < requests.length; i++) {\n            nums[requests[i][0]]--;\n            nums[requests[i][1]]++;\n            dfs(nums, i+1, requests, count+1);\n            nums[requests[i][0]]++;\n            nums[requests[i][1]]--;\n        }\n    }\n    \n    public boolean check(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n## _二维平面上的回溯_\n\n## [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)\n\n给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n**示例：**\n\n```java\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n\n给定 word = \"ABCCED\", 返回 true.\n给定 word = \"SEE\", 返回 true.\n给定 word = \"ABCB\", 返回 false.\n```\n\n**解法一**\n\n这题其实并不难，但是我一开始就钻到死胡里去了，我直接拿起来就想的是暴力 dfs 从（0，0）开始遍历每种情况，直到找到一个相等的。我真是个 hapi\n\n```java\n/*\n    board =\n    [\n      ['A','B','C','E'],\n      ['S','F','C','S'],\n      ['A','D','E','E']\n    ]\n     */\n\n//方向：右，下，左，上\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic boolean exist(char[][] board, String word) {\n    if (board==null || word==null) {\n        return false;\n    }\n    char[] words=word.toCharArray();\n    boolean[][] visit=new boolean[board.length][board[0].length];\n    for (int i=0;i<board.length;i++) {\n        for (int j=0;j<board[0].length;j++) {\n            //遍历 board 每个元素，以为个元素为起点都试一下\n            if(dfs(board,words,0,i,j,visit)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\npublic boolean dfs(char[][] board, char[] word,int index,int x,int y,boolean[][] visit) {\n    //遍历到 word 的最后一个字符了，直接比较就可以得出结果\n    if (index == word.length-1) {\n        return word[index] == board[x][y];\n    }\n    /*\n     这样写如果 board 只有一个元素就会错了，后面的 isValid 会直接 false, 但是有可能 word 就是这个 board\n     if (index == word.length) {\n            return true;\n     }*/\n    \n    //当元素相等的时候才有继续的必要\n    if (board[x][y]==word[index]) {\n        visit[x][y]=true;\n        for (int i=0;i<direction.length;i++) {\n            int nx=x+direction[i][0];\n            int ny=y+direction[i][1];\n            //保证合法性\n            if (isValid(board,nx,ny)&&!visit[nx][ny]&&dfs(board,word,index+1,nx,ny,visit)) {\n                return true;\n            }\n        }\n        visit[x][y]=false;\n    }\n    return false;\n}\n\npublic boolean isValid(char[][] cs,int x,int y){\n    return x>=0 && x<cs.length && y >=0 && y< cs[0].length;\n}\n```\n## [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)\n\n给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围\n\n**示例 1:**\n\n```java\n输入：\n11110\n11010\n11000\n00000\n\n输出：1\n```\n\n**示例 2:**\n\n```java\n输入：\n11000\n00100\n00011\n\n输出：3\n```\n\n**解法一**\n\n和上面一题类似，很惭愧，一开始也没写出来，写了个大概，细节没有捋清楚\n\n```java\n//方向：右，下，左，上\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic int numIslands(char[][] grid) {\n    if (grid==null||grid.length<=0) {\n        return 0;\n    }\n    boolean[][] visit=new boolean[grid.length][grid[0].length];\n    for (int i=0;i<grid.length;i++) {\n        for (int j=0;j<grid[0].length;j++) {\n            if (grid[i][j]=='1'&&!visit[i][j]) {\n                dfs(grid,i,j,visit);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nprivate int res=0;\n\npublic void dfs(char[][] grid,int x,int y,boolean[][] visit) {\n    //其实整个 dfs 做的就是对 visit[x][y] 标记，标记为 true 代表访问过\n    visit[x][y]=true;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(grid,nx,ny) && !visit[nx][ny] && grid[nx][ny]=='1') {\n            dfs(grid,nx,ny,visit);\n            //无需回溯 visit 状态\n        }\n    }\n}\n\npublic boolean isValid(final char[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n} \n```\n## [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)\n\n给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。\n\n找到所有被 'X' 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。\n\n**示例：**\n\n```java\nX X X X\nX O O X\nX X O X\nX O X X\n```\n\n运行你的函数后，矩阵变为：\n\n```java\nX X X X\nX O X X\n```\n\n**解释：**\n\n被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的\n\n**解法一**\n\n这题在很久以前（看了提交记录是一年前的）开始学 dfs 的时候，在 leetcode 搜索到了这一题，当时也做出来了，只不过效率感人，放上来看看是个啥玩意\n\n```java\n// 定义 4 个方向（顺时针 右。..）\nprivate static int[][] direction = { { 1, 0 }, { 0, 1 }, { -1, 0 }, { 0, -1 } };\n\nprivate static int[][] mark = null;\n\npublic static void solve(char[][] board) {\n    if(board.length==0) { return; }\n    // 根据传进来的 board 给 mark 初始化\n    mark = new int[board.length][board[0].length];\n    // 遍历边缘找出边缘的 O 的坐标\n    for (int i = 0; i < board.length; i++) {\n        if (board[i][0] == 'O') {\n            dfs(0, i, board);\n            //执行完之后再赋值当前位置的 O 避免在边缘角落的问题\n            mark[i][0] = 1;\n        }\n        if (board[i][board[0].length - 1] == 'O') {\n            dfs(board[0].length, i, board);\n            mark[i][board[0].length - 1] = 1;\n        }\n    }\n    // 上边缘\n    for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == 'O') {\n            dfs(i, 0, board);\n            mark[0][i] = 1;\n        }\n    }\n    // 下边缘\n    for (int i = 0; i < board[0].length; i++) {\n        if (board[board.length - 1][i] == 'O') {\n            dfs(i, board.length - 1, board);\n            mark[board.length - 1][i] = 1;\n        }\n    }\n\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (board[i][j] == 'O' && mark[i][j] == 0) {\n                board[i][j] = 'X';\n            }\n        }\n    }\n\n}\n\n// 实现函数\npublic static void dfs(int x, int y, char[][] board) {\n    int tx, ty;\n    // 首先判断边缘上有没有 O 有的话将与他联通的 O 都加上标记\n    for (int i = 0; i <= 3; i++) {\n        // x=x+direction[i][0]; 这样写每个点向 4 个方向扩展如果这样写 点的走向就有问题了\n        tx = x + direction[i][0];\n        ty = y + direction[i][1];\n        // System.out.println(tx+\" \"+ty);\n        if (tx < board[0].length && tx >= 0 && ty < board.length && ty >= 0 && board[ty][tx] == 'O'\n            && mark[ty][tx] == 0) {\n            // 代表走过了\n            mark[ty][tx] = 1;\n            // 这里没有处理好，我的 dfs 函数的参数是坐标但是对应到 mark 里面和 board 里面就不是坐标了就颠倒了\n            // 比如按照坐标来 2 , 1 ---->对应到数组里面就是 1 ，2\n            dfs(tx, ty, board);\n        }\n    }\n    return;\n}\n```\n21ms，8% 乍一看好像没啥问题，但是为啥这么慢呢？看看今天下午重新做的解\n\n**解法二**\n\n```java\n//方向：右，下，左，上\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic void solve(char[][] board) {\n    if (board==null || board.length<=0) {\n        return;\n    }\n    boolean[][] visit=new boolean[board.length][board[0].length];\n    int lx=0,ly=0;\n\n    //遍历 4 条边的'O', 将与相连的'O'都标记为 true\n    while(lx<board.length) { \n        if (board[lx][0]=='O') { //左\n            dfs(board,lx,0,visit);\n        }\n        if (board[lx][board[0].length-1] == 'O') { //右\n            dfs(board,lx,board[0].length-1,visit);\n        }\n        lx++;\n    }\n\n    while(ly<board[0].length) { \n        if (board[0][ly]=='O') { //上\n            dfs(board,0,ly,visit);\n        }\n        if (board[board.length-1][ly] == 'O') { //下\n            dfs(board,board.length-1,ly,visit);   \n        }\n        ly++;\n    }\n\n    //遍历将所有 visit=false 的 O 变为 X\n    for (int i=0;i<board.length;i++) {\n        for (int j=0;j<board[0].length;j++) {\n            if (board[i][j]=='O' && !visit[i][j]) {\n                board[i][j]='X';\n            }\n        }\n    }\n}\n\npublic void dfs(char[][] board,int x,int y,boolean[][] visit) {\n    visit[x][y]=true;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(board,nx,ny) && board[nx][ny]=='O' && !visit[nx][ny]) {\n            dfs(board,nx,ny,visit);\n        }\n    }\n}\n\n//是否合法\npublic boolean isValid(final char[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n2ms，比较明显的区别就是 dfs 给 visit 数组赋值的时机不同，一个是在循环里面，一个是在函数开头，也就是说第一种解法并不会立即给边缘的`'O'` 标记，这样导致的问题就是它后续的节点仍然会搜索到这个边缘的 `'O'` 这样就会造成重复的计算，所以说，一定要捋清楚这个过程，不能乱写\n\n## [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)\n\n给定一个 `m x n` 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。\n\n规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。\n\n请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标\n\n**提示：**\n\n1. 输出坐标的顺序不重要\n\n2. m 和 n 都小于 150\n\n**示例：**\n\n```java\n给定下面的 5x5 矩阵：\n\n  太平洋 ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * 大西洋\n\n返回：\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] （上图中带括号的单元）.\n```\n\n**解法一**\n\n其实和上面也是如出一辙，只不过最开始没想到两个 visit 数组来做\n\n```java\n//方向键\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic List<List<Integer>> pacificAtlantic(int[][] matrix) {\n    List<List<Integer>> res=new ArrayList<>();\n    //leetcode 老是喜欢搞些幺蛾子\n    if (matrix==null || matrix.length<=0) {\n        return res;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    //太平洋\n    boolean[][] pacific=new boolean[m][n];\n    //大西洋\n    boolean[][] atlantic=new boolean[m][n];\n\n    for (int i=0;i<m;i++) {\n        dfs(matrix,i,0,pacific);\n        dfs(matrix,i,n-1,atlantic);\n    }\n\n    for (int i=0;i<n;i++) {\n        dfs(matrix,0,i,pacific);\n        dfs(matrix,m-1,i,atlantic);\n    }\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            //同时为 true 的就是解\n            if (pacific[i][j] && atlantic[i][j]) {\n                res.add(Arrays.asList(i,j));\n            }\n        }\n    }\n    return res;\n}\n\npublic void dfs(int[][] matrix,int x,int y,boolean[][] visit) {\n    visit[x][y]=true;\n    //向 4 个方向 floodfill\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(matrix,nx,ny) && matrix[nx][ny]>= matrix[x][y] && !visit[nx][ny]) {\n            dfs(matrix,nx,ny,visit);\n        }\n    }\n}\n\npublic boolean isValid(final int[][] matrix,int x,int y){\n    return x>=0 && x<matrix.length && y>=0 && y<matrix[0].length;\n}\n```\n6ms，96%，还是比较 ok 的\n\n## [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)\n\n*n* 皇后问题研究的是如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击\n\n![mark](http://static.imlgw.top/blog/20191011/ac4lTcAFesSc.png?imageslim)\n\n上图为 8 皇后问题的一种解法。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 ' . ' 分别代表了皇后和空位。\n\n**示例：**\n\n```java\n输入：4\n输出：[\n [\".Q..\",  // 解法 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // 解法 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n解释：4 皇后问题存在两个不同的解法\n```\n\n**解法一**\n\nHard 题，N 皇后问题可以说是很经典的问题了，之前有看过，但是都是一脸懵逼，无从下手，这一次看了下提示还是自己给做出来了\n\n```java\nprivate List<List<String>> res=new ArrayList<>();\n\nprivate boolean[] col;\n//private boolean[] row;\n//两条对角线\nprivate boolean[] dia1;\nprivate boolean[] dia2;\n\npublic List<List<String>> solveNQueens(int n) {\n    if (n<=0) return res;\n    col=new boolean[n];\n    //row=new boolean[n];\n    dia1=new boolean[2*n-1];\n    dia2=new boolean[2*n-1];\n    dfs(n,0,new ArrayList());\n    return res;\n}\n\n//dfs\npublic void dfs(int n,int index,List<Integer> lis) {\n    if (index==n) {\n        res.add(generateRes(lis));\n        return;\n    }\n    //检测第 index 行第 i 列\n    for (int i=0;i<n;i++) {\n        //注意对角线的下标\n        if (!col[i] && !dia1[index-i+n-1] && !dia2[i+index]) {\n            col[i]=true;\n            dia1[index-i+n-1]=true;\n            dia2[index+i]=true;\n            //尝试添加\n            lis.add(i);\n            dfs(n,index+1,lis);\n            //回溯\n            lis.remove(lis.size()-1);\n            col[i]=false;\n            dia1[index-i+n-1]=false;\n            dia2[index+i]=false;\n        }\n    }\n}\n\n//根据 lis 生成解\npublic List<String> generateRes(List<Integer> lis){\n    List<String> res=new ArrayList<>();\n    for (int i=0;i<lis.size();i++) {\n        int index = lis.get(i);\n        StringBuilder sb=new StringBuilder();\n        for (int j=0;j<lis.size();j++) {\n            if (j!=index){\n                sb.append(\".\");\n            }else{\n                sb.append(\"Q\");\n            }\n        }\n        res.add(sb.toString());\n    }\n    return res;\n}\n```\n核心思路就是：一行行遍历，然后 dfs 尝试在每个位置放置皇后，我觉得主要的难点在于如何判断各个列，对角线是否已经有皇后，这一点需要细致的观察，有一条对角线的横纵坐标之和为常数，另一条横纵坐标之差是个常数，借此便可以唯一确定一条对角线\n\n## [52. N 皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)\n\n和上面一题不同的地方是这题只需要求解的个数，感觉这题才应该是`Ⅰ`，不用求所有的解，貌似更加简单了？\n\n**解法一**\n\n直接套用上面的代码，没啥好说的\n\n```java\npublic int totalNQueens(int n) {\n    res=0;\n    if (n<=0) return 0;\n    col=new boolean[n];\n    //row=new boolean[n];\n    dia1=new boolean[2*n-1];\n    dia2=new boolean[2*n-1];\n    dfs(n,0,new ArrayList());\n    return res;\n}\n\nprivate int res=0;\n\nprivate boolean[] col;\nprivate boolean[] dia1;\nprivate boolean[] dia2;\n\n//dfs\npublic void dfs(int n,int index,List<Integer> lis) {\n    if (index==n) {\n        res++;\n        return;\n    }\n    //检测第 index 行第 i 列\n    for (int i=0;i<n;i++) {\n        if (!col[i] && !dia1[index-i+n-1] && !dia2[i+index]) {\n            col[i]=true;\n            dia1[index-i+n-1]=true;\n            dia2[index+i]=true;\n            //不用添加到 lis 中\n            dfs(n,index+1,lis);\n            //回溯\n            col[i]=false;\n            dia1[index-i+n-1]=false;\n            dia2[index+i]=false;\n        }\n    }\n}\n```\n虽然提交了也是 1ms，主要是这两题 case 都比较少，最大的 case 好像只到 11，所以差距不是很明显，我这样做肯定不是这题的最优解，这题的最优解是利用`位图（bitmap）`作位运算，反正我不可能写出来就是了😂 [参考](http://www.ic-net.or.jp/home/takaken/e/queen/)\n\n## [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)\n\n编写一个程序，通过已填充的空格来解决数独问题。\n\n一个数独的解法需遵循如下规则：\n\n数字 `1-9` 在每一行只能出现一次。\n数字 `1-9` 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。\n空白格用 `'.'` 表示。\n\n![mark](http://static.imlgw.top/blog/20191012/jvSukv6RnXFL.png?imageslim)\n\n一个数独\n\n![mark](http://static.imlgw.top/blog/20191012/XgTokVUgo5Yy.png?imageslim)\n\n答案被标成红色。\n\n**Note:**\n\n- 给定的数独序列只包含数字 `1-9` 和字符 `'.'` \n- 你可以假设给定的数独只有唯一解。\n- 给定数独永远是 `9x9` 形式的。\n\n**解法一**\n\n嗯，又是一道 hard 题，自己摸了半天没做出来，看了评论区做出来的\n```java\n//三个约束规则\nprivate boolean[][] col=new boolean[9][9];\nprivate boolean[][] row=new boolean[9][9];\nprivate boolean[][] block=new boolean[9][9];\n\npublic void solveSudoku(char[][] board) {\n    if (board==null || board.length<=0) {\n        return;\n    }\n    for (int i=0;i<9;i++) {\n        for (int j=0;j<9;j++) {\n            if (board[i][j]!='.') {\n                col[i][board[i][j]-48-1]=true;\n                row[j][board[i][j]-48-1]=true;\n                //块号为 i/3*3+j/3\n                block[i/3*3+j/3][board[i][j]-48-1]=true;\n            }\n        }\n    }\n    dfs(board,0,0);\n}\n\n//private  static char[][] res=new char[9][9];\n\npublic boolean dfs(char[][] board,int i,int j) {\n    //从，i,j 位置向后寻找'.', i>=9 说明全部填充完了\n    while(board[i][j]!='.') {\n        j++;\n        if (j==9) {\n            i++;\n            j=0;\n        }\n        //over\n        if (i==9) {\n            return true;\n        }\n    }\n    //System.out.println(i+\",\"+j);\n    for (int val=0;val<9;val++) {\n        if (!col[i][val] && !row[j][val] && !block[i/3*3+j/3][val]) {\n            col[i][val]=true;\n            row[j][val]=true;\n            block[i/3*3+j/3][val]=true;\n            //尝试填充为 val+1\n            board[i][j]=(char)(val+1+48);\n            //尝试后面的'.', 这里传进去还是 i,j\n            //大脑模拟下其实这个 dfs 过程也挺简单\n            if(dfs(board,i,j)){//这里会尝试所有解，失败后回溯\n                return true;\n            }else{\n                //回溯\n                board[i][j]='.';\n                col[i][val]=false;\n                row[j][val]=false;\n                block[i/3*3+j/3][val]=false;\n            }\n        }\n    }\n    return false;\n}\n```\n\n比上面的 N 皇后要更复杂，同样也是带有约束的 dfs 回溯，我一开始写的方法主要是思路都错了，我想的和上面 n 皇后一样，一层一层的搜索最后 n==9 就结束，但是没考虑到一层其实不只有一个`空位`，同时还要注意回溯的时机，并不是 dfs 之后就回溯，用大脑模拟下这个递归其实就明白了，我觉得核心还是`找'.'那一步`，这一步确实没想到\n\n> 这题有一个简单版，[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/) 挺简单的，懒得做了\n\n## [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)\n\n让我们一起来玩扫雷游戏！\n\n给定一个代表游戏板的二维字符矩阵。 'M' 代表一个未挖出的地雷，'E' 代表一个未挖出的空方块，'B' 代表没有相邻（上，下，左，右，和所有 4 个对角线）地雷的已挖出的空白方块，数字（'1' 到 '8'）表示有多少地雷与这块已挖出的方块相邻，'X' 则表示一个已挖出的地雷。\n\n现在给出在所有未挖出的方块中（'M'或者'E'）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：\n\n1. 如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X'。\n2. 如果一个没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的方块都应该被递归地揭露。\n3. 如果一个至少与一个地雷相邻的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。\n4. 如果在此次点击中，若无更多方块可被揭露，则返回面板。\n\n**示例一**\n\n```java\nInput: \n\n[['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'M', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E']]\n\nClick : [3,0]\n\nOutput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\n```\n\n**Explanation:**\n\n![扫雷](https://i.loli.net/2019/11/18/B26DWk8CrhPFtHI.png)\n\n**示例二**\n\n```java\nInput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nClick : [1,2]\n\nOutput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'X', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n```\n\n**Explanation:**\n\n![扫雷](https://s2.ax1x.com/2019/11/18/MyccWT.png)\n\n**解法一**\n\n标准的 DFS，还是挺有意思的，向 8 个方向扩展，遇到周围有地雷的就计数并且停止，会玩扫雷就会做😉\n\n```java\nprivate int[][] direction={{0,1},{1,0},{-1,1},{1,-1},{-1,0},{0,-1},{-1,-1},{1,1}};\n\npublic char[][] updateBoard(char[][] board, int[] click) {\n    int x=click[0];\n    int y=click[1];\n    if (board[x][y]=='M') {\n        board[x][y]='X';\n        return board;\n    }\n    boolean[][] visit=new boolean[board.length][board[0].length];\n    dfs(board,x,y,visit);\n    return board;\n}\n\npublic void dfs(char[][] board,int x,int y,boolean[][] visit){\n    visit[x][y]=true;\n    int count=getRoundBoom(board,x,y);\n    if(count!=0){\n        board[x][y]=(char)(count+'0');\n        return;\n    }\n    board[x][y]='B';\n    for (int i=0;i<8;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(board,nx,ny) && !visit[nx][ny] && board[nx][ny]!='M') {\n            dfs(board,nx,ny,visit);\n        }\n    }\n}\n\npublic int getRoundBoom(char[][] board,int x,int y){\n    int count=0;\n    for (int i=0;i<8;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(board,nx,ny) && board[nx][ny]=='M') {\n            count++;\n        }   \n    }\n    return count;\n}\n\npublic boolean isValid(final char[][] board,int x,int y){\n    return x>=0 && x<board.length && y>=0 && y<board[0].length;\n}\n```\n## [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)\n\n给定一个包含了一些 0 和 1 的非空二维数组 `grid` , 一个 `岛屿` 是由四个方向 （水平或垂直） 的 1 （代表土地） 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。\n\n找到给定的二维数组中最大的岛屿面积。（如果没有岛屿，则返回面积为 0)\n\n**示例 1:**\n\n```java\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n```\n\n对于上面这个给定矩阵应返回 6。注意答案不应该是 11，因为岛屿只能包含水平或垂直的四个方向的 `‘1’`。\n\n**示例 2:**\n\n```java\n[[0,0,0,0,0,0,0,0]]\n```\n\n对于上面这个给定的矩阵，返回 0\n\n**注意：** 给定的矩阵 grid 的长度和宽度都不超过 50。\n\n**解法一**\n\n和上面 [200 题岛屿的数量](#200-岛屿数量)很类似，不过还是有所不同，这里要计算的是最大的面积\n\n```java\nprivate int[][] direction={{0,1},{0,-1},{1,0},{-1,0}};\n\npublic int maxAreaOfIsland(int[][] grid) {\n    if (grid==null || grid.length<=0) {\n        return max;\n    }\n    boolean[][] visit=new boolean[grid.length][grid[0].length];\n    for (int i=0;i<grid.length;i++) {\n        for (int j=0;j<grid[0].length;j++) {\n            if (grid[i][j]==1 &&!visit[i][j]) {\n                int t=dfs(grid,i,j,visit);\n                max=max>t?max:t;\n            }\n        }\n    }\n    return max;\n}\n\nprivate int max=0;\n\npublic int dfs(int[][] grid,int x,int y,boolean[][] visit) {\n    int temp=1;\n    visit[x][y]=true;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(grid,nx,ny) && grid[nx][ny]==1 && !visit[nx][ny]) {\n            //将 4 个方向的符合条件的数量加起来\n            temp+=dfs(grid,nx,ny,visit);\n        }\n    }\n    return temp;\n}\n\npublic boolean isValid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n最开始直接在 dfs 函数里面用 count 计数，居然还过了 600 多个 case..... 惊了，那种做法完全是错的，说实话有点不太习惯写有返回值的递归\n\n## [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)\n\n班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。\n\n给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果 M[i] [j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。\n\n**示例 1:**\n\n```java\n输入：\n[[1,1,0],\n [1,1,0],\n [0,0,1]]\n输出：2 \n说明：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。\n第 2 个学生自己在一个朋友圈。所以返回 2。\n```\n\n**示例 2:**\n\n```java\n输入：\n[[1,1,0],\n [1,1,1],\n [0,1,1]]\n输出：1\n说明：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1。\n```\n\n**注意：**\n\n- N 在 [1,200] 的范围内。\n- 对于所有学生，有 M[i] [i] = 1。\n- 如果有 M[i] [j] = 1，则有 M[j] [i] = 1。\n\n**解法一**\n\n```java\npublic int findCircleNum(int[][] M) {\n    if (M==null || M.length<=0) {\n        return 0;\n    }\n    boolean[] visit=new boolean[M.length];\n    int count=0;\n    for (int i=0;i<M.length;i++) {\n        if (!visit[i]) {\n            dfs(M,visit,i);\n            count++;\n        }\n    }\n    return count;\n}\n\n//一共 m.length 个人\npublic void dfs(int[][] M,boolean[] visit,int index) {\n    //标记 index 号学生已经访问过\n    visit[index]=true;\n    for (int i=0;i<M.length;i++) {\n        //index 和 i 是好朋友\n        if (M[index][i]==1 && !visit[i]) {\n            //递归标记 i 的好朋友，形成朋友圈\n            dfs(M,visit,i);\n        }\n    }\n}\n```\n这题不知道为啥，一开始题目没搞明白。去纠结那个矩阵去了，没理解好题目的意思，其实跟那个 N*N 的矩阵没啥关系，主要是 N 个人，对每个人进行 dfs 找到与他们相关的人，做好统计就 ok，和上面的 200 题也很类似\n\n## [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)\n\n你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。\n\n为了使收益最大化，矿工需要按以下规则来开采黄金：\n\n- 每当矿工进入一个单元，就会收集该单元格中的所有黄金。\n- 矿工每次可以从当前位置向上下左右四个方向走。\n- 每个单元格**只能被开采（进入）一次**。\n- **不得开采**（进入）黄金数目为 0 的单元格。\n- 矿工可以从网格中 **任意一个** 有黄金的单元格出发或者是停止。  \n\n**示例 1：**\n\n```java\n输入：grid = [[0,6,0],[5,8,7],[0,9,0]]\n输出：24\n解释：\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\n一种收集最多黄金的路线是：9 -> 8 -> 7。\n```\n\n**示例 2：**\n\n```java\n输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\n输出：28\n解释：\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\n一种收集最多黄金的路线是：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7。\n```\n\n**提示：**\n\n- -`1 <= grid.length, grid[i].length <= 15`\n- `0 <= grid[i][j] <= 100`\n- 最多 25 个单元格中有黄金。 \n\n**解法一**\n\n这题还是挺有意思的，填补了我一点二维平面回溯的空缺，其实也很简单（改了好几个小时还好意思说这种话😂）\n\n```java\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic int getMaximumGold(int[][] grid) {\n    int max=0;\n    boolean[][] visit=new boolean[grid.length][grid[0].length];\n    for (int i=0;i<grid.length;i++) {\n        for (int j=0;j<grid[0].length;j++) {\n            if (grid[i][j]>0) {\n                max=Math.max(dfs(grid,i,j,visit),max);\n            }\n        }\n    }\n    return max;\n}\n\n//求出从 x,y 开始所能获得的最大的收益，记得回溯状态，后面的节点还需要遍历\npublic int dfs(int[][] grid,int x,int y,boolean[][] visit){\n    int maxGlod=grid[x][y]; //一开始这里写的 0... 排了半天的错\n    visit[x][y]=true;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(grid,nx,ny) && !visit[nx][ny] && grid[nx][ny]>0) {\n            //求向 4 个方向扩展的最大值\n            maxGlod=Math.max(dfs(grid,nx,ny,visit)+grid[x][y],maxGlod);\n        }\n    }\n    visit[x][y]=false;\n    return maxGlod;\n}\n\npublic boolean isValid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n\n思路其实也很简单，对每个有金矿的点进行 dfs 计算路径上的金矿和就 ok 了，但是这题有一个很关键的条件，不能回头，下过的金矿是不能第二次再进入的，不然这题就和前面的 [695. 岛屿最大面积](##695. 岛屿的最大面积)一样了，所以很显然这题是需要状态的回溯的，访问过的节点，后面的节点还是可能需要遍历的，最开始写的一个 bug 就是代码中提到的，那里一开始写的 0... 然后排错排了好长时间。菜啊\n\n## [面试题 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)\n\n地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n**示例 1：**\n\n```java\n输入：m = 2, n = 3, k = 1\n输出：3\n```\n\n**示例 1：**\n\n```java\n输入：m = 3, n = 1, k = 0\n输出：1\n```\n\n**提示：**\n\n- `1 <= n,m <= 100`\n- `0 <= k <= 20`\n\n**解法一**\n\n一开始没认真看例子，以为是求不能回头一次能走的最多的格子，原基础上稍微改一下就可以了\n\n```java\nprivate int[][] direction={{1,0},{0,1},{0,-1},{-1,0}};\n\npublic int movingCount(int m, int n, int k) {\n    return dfs(m,n,0,0,k,new boolean[m][n]);   \n}\n\npublic int dfs(int m,int n,int x,int y,int k,boolean[][] visit){\n    visit[x][y]=true;\n    int res=1;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if(valid(m,n,nx,ny,k) && !visit[nx][ny]){\n            //以为是求最长的距离。....\n            //res=Math.max(dfs(m,n,nx,ny,k,visit)+1,res);\n            res+=dfs(m,n,nx,ny,k,visit);\n        }\n    }\n    //visit[x][y]=false;\n    return res;\n}\n\npublic boolean valid(int m,int n,int x,int y,int k){\n    if(x<0 || x>=m || y<0 || y>=n){\n        return false;\n    }\n    int res=0;\n    //35 37\n    while(x!=0){\n        res+=(x%10);\n        x/=10;\n    }\n    while(y!=0){\n        res+=(y%10);\n        y/=10;\n    }\n    return res<=k;\n}\n```\n\n## [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)\n\n给出一个二维数组 `A`，每个单元格为 0（代表海）或 1（代表陆地）。\n\n移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。\n\n返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。\n\n**示例 1：**\n\n```java\n输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n输出：3\n解释： \n有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。\n```\n\n**示例 2：**\n\n```java\n输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n输出：0\n解释：\n所有 1 都在边界上或可以到达边界。\n```\n\n**提示：**\n\n1. `1 <= A.length <= 500`\n2. `1 <= A[i].length <= 500`\n3. `0 <= A[i][j] <= 1`\n4. 所有行的大小都相同\n\n**解法一**\n\ndfs 搜索就完事儿了，水题\n\n```java\n//DFS\nint[][] dir={{1,0},{0,1},{-1,0},{0,-1}};\n\npublic int numEnclaves(int[][] A) {\n    if(A==null || A.length<=0) return 0;\n    int N=A.length;\n    int M=A[0].length;\n    boolean[][] visit=new boolean[N][M];\n    int a=0,b=0;\n    while(a<N){ //左右边界\n        if(A[a][0]==1 && !visit[a][0]) dfs(A,a,0,visit);\n        if(A[a][M-1]==1 && !visit[a][M-1]) dfs(A,a,M-1,visit);\n        a++;\n    }\n    while(b<M){ //上下边界\n        if(A[0][b]==1&& !visit[0][b]) dfs(A,0,b,visit);\n        if(A[N-1][b]==1&& !visit[N-1][b]) dfs(A,N-1,b,visit);\n        b++;\n    }\n    int res=0;\n    for (int i=0;i<N;i++) {\n        for (int j=0;j<M;j++) {\n            if(A[i][j]==1 && !visit[i][j]){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\npublic void dfs(int[][] A,int x,int y,boolean[][] visit){\n    visit[x][y]=true;\n    for (int i=0;i<dir.length;i++) {\n        int nx=x+dir[i][0];\n        int ny=y+dir[i][1];\n        if(valid(A,nx,ny) && !visit[nx][ny] && A[nx][ny]==1){\n            dfs(A,nx,ny,visit);\n        }\n    }\n}\n\npublic boolean valid(final int[][] A,int x,int y){\n    return x>=0 && x<A.length && y>=0 && y<A[0].length;\n}\n```\n\n并查集的解法放在 [并查集专题](http://imlgw.top/2020/02/02/bing-cha-ji/) 中\n\n## [934. 最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)\n\n在给定的二维二进制数组 `A` 中，存在两座岛。（岛是由四面相连的 `1` 形成的一个最大组。）\n\n现在，我们可以将 `0` 变为 `1`，以使两座岛连接起来，变成一座岛。\n\n返回必须翻转的 `0` 的最小数目。（可以保证答案至少是 1。）\n\n**示例 1：**\n\n```java\n输入：[[0,1],[1,0]]\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：[[0,1,0],[0,0,0],[0,0,1]]\n输出：2\n```\n\n**示例 3：**\n\n```java\n输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\n输出：1\n```\n\n**提示：**\n\n1. `1 <= A.length = A[0].length <= 100`\n2. `A[i][j] == 0` 或 `A[i][j] == 1`\n\n**解法一**\n\n这题还挺有意思的，dfs+bfs 都要用，单纯的深搜和广搜很难搞，先 dfs 给一个岛做标记，然后多源 bfs 找距离最近的另一个岛\n\n```java\nint[] dir = {0, 1, 0, -1, 0};\n\npublic int shortestBridge(int[][] A) {\n    boolean[][] mark = new boolean[A.length][A[0].length];\n    lable:\n    for (int i = 0; i < A.length; i++) {\n        for (int j = 0; j < A[0].length; j++) {\n            if (A[i][j] == 1) {\n                dfs(A, i, j, mark);\n                break lable;\n            }\n        }\n    }\n    Queue<Pair> queue = new LinkedList<>();\n    for (int i = 0; i < A.length; i++) {\n        for (int j = 0; j < A[0].length; j++) {\n            if (A[i][j] == 1 && mark[i][j]) {\n                queue.add(new Pair(i, j, 0));\n            }\n        }\n    }\n    while (!queue.isEmpty()) {\n        Pair pair = queue.poll();\n        for (int i = 0; i < 4; i++) {\n            int nx = pair.x + dir[i];\n            int ny = pair.y + dir[i + 1];\n            if (valid(A, nx, ny) && !mark[nx][ny]) {\n                if (A[nx][ny] == 1) {\n                    return pair.step;\n                }\n                mark[nx][ny] = true;\n                queue.add(new Pair(nx, ny, pair.step + 1));\n            }\n        }\n    }\n    return 1;\n}\n\npublic void dfs(int[][] A, int x, int y, boolean[][] mark) {\n    mark[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dir[i];\n        int ny = y + dir[i + 1];\n        if (valid(A, nx, ny) && A[nx][ny] == 1 && !mark[nx][ny]) {\n            dfs(A, nx, ny, mark);\n        }\n    }\n}\n\npublic boolean valid(int[][] A, int x, int y) {\n    return x >= 0 && x < A.length && y >= 0 && y < A[0].length;\n}\n\nclass Pair {\n    int x, y;\n    int step;\n    public Pair(int x, int y, int step) {\n        this.x = x;\n        this.y = y;\n        this.step = step;\n    }\n}\n```\n\n## [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)\n\nDifficulty: **简单**\n\n有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。\n\n给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。\n\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n\n最后返回经过上色渲染后的图像。\n\n**示例 1:**\n\n```go\n输入：\nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n输出：[[2,2,2],[2,2,0],[2,0,1]]\n解析：\n在图像的正中间，（坐标 (sr,sc)=(1,1)),\n在路径上所有符合条件的像素点的颜色都被更改成 2。\n注意，右下角的像素没有更改为 2，\n因为它不是在上下左右四个方向上与初始点相连的像素点。\n```\n\n**注意：**\n\n*   `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。\n*   给出的初始点将满足 `0 <= sr < image.length` 和 `0 <= sc < image[0].length`。\n*   `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。\n\n**解法一**\n\n经典搜索，没啥好说的\n```golang\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\n    var m = len(image)\n    var n = len(image[0])\n    var dir = []int{1, 0, -1, 0, 1}\n    var visit = make([][]bool, m)\n    for i := 0; i < m; i++ {\n        visit[i] = make([]bool, n)\n    }\n    var src = image[sr][sc]\n    var valid = func(x int, y int) bool {\n        return x >= 0 && x < m && y >= 0 && y < n\n    }\n    var dfs func(x int, y int)\n    dfs = func(x int, y int) {\n        visit[x][y] = true\n        image[x][y] = newColor\n        for i := 0; i < 4; i++ {\n            var nx = x + dir[i]\n            var ny = y + dir[i+1]\n            if valid(nx, ny) && !visit[nx][ny] && image[nx][ny] == src {\n                dfs(nx, ny)\n            } \n        }\n    }\n    dfs(sr, sc)\n    return image\n}\n```\n通过染色的情况判断是否遍历过节点，节省 visit 数组\n```golang\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\n    var m = len(image)\n    var n = len(image[0])\n    var dir = []int{1, 0, -1, 0, 1}\n    var src = image[sr][sc]\n    var valid = func(x int, y int) bool {\n        return x >= 0 && x < m && y >= 0 && y < n\n    }\n    var dfs func(x int, y int)\n    dfs = func(x int, y int) {\n        image[x][y] = newColor\n        for i := 0; i < 4; i++ {\n            var nx = x + dir[i]\n            var ny = y + dir[i+1]\n            if valid(nx, ny) && image[nx][ny]!=newColor && image[nx][ny] == src {\n                dfs(nx, ny)\n            } \n        }\n    }\n    dfs(sr, sc)\n    return image\n}\n```\n\n## [1559. 二维网格图中探测环](https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/)\n\nDifficulty: **困难**\n\n给你一个二维字符网格数组 `grid` ，大小为 `m x n` ，你需要检查 `grid` 中是否存在 **相同值** 形成的环。\n\n一个环是一条开始和结束于同一个格子的长度 **大于等于 4** 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 **相同的值 **。\n\n同时，你也不能回到上一次移动时所在的格子。比方说，环  `(1, 1) -> (1, 2) -> (1, 1)` 是不合法的，因为从 `(1, 2)` 移动到 `(1, 1)` 回到了上一次移动时的格子。\n\n如果 `grid` 中有相同值形成的环，请你返回 `true` ，否则返回 `false` 。\n\n**示例 1：**\n\n![](https://i.loli.net/2020/12/16/IF9PVSHoOXtZwRr.png)\n\n```golang\n输入：grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\n输出：true\n解释：如下图所示，有 2 个用不同颜色标出来的环：\n```\n![](https://i.loli.net/2020/12/16/8EJDuUPc2xMilBm.png)\n\n**示例 2：**\n\n![](https://i.loli.net/2020/12/16/eljrFPCzf4pgd6s.png)\n\n```golang\n输入：grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\n输出：true\n解释：如下图所示，只有高亮所示的一个合法环：\n```\n![](https://i.loli.net/2020/12/16/9FfYxP7DSUBXEaG.png)\n\n**示例 3：**\n\n![](https://i.loli.net/2020/12/16/fAr1TEQNpumaXck.png)\n\n```golang\n输入：grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\n输出：false\n```\n\n**提示：**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m <= 500`\n*   `1 <= n <= 500`\n*   `grid` 只包含小写英文字母。\n\n**解法一**\n\n33 双周赛的 T4，总体不是很难，dfs 或者并查集都可以\n```golang\nfunc containsCycle(grid [][]byte) bool {\n    var m, n = len(grid), len(grid[0])\n    var dir = [4][2]int{{0,1},{1,0},{-1,0},{0,-1}}\n    var visit = make([][]bool, m)\n    for i := 0; i < m; i++ {\n        visit[i] = make([]bool, n)\n    }\n    var valid = func(x, y int) bool { return x >= 0 && x < m && y >= 0 && y < n}\n    var dfs func (int, int, int, int)\n    var res = false\n    dfs = func(preX int, preY int, x int, y int) {\n        if visit[x][y] || res{\n            res = true\n            return\n        }\n        visit[x][y] = true\n        for i := 0; i < len(dir); i++ {\n            nx := x + dir[i][0]\n            ny := y + dir[i][1]\n            //不走回头路\n            if nx == preX && ny == preY {\n                continue\n            }\n            if valid(nx, ny) && grid[nx][ny] == grid[x][y] {\n                dfs(x, y, nx, ny)\n            }\n        }\n    }\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if !visit[i][j] {\n                dfs(i,j,i,j)\n            }\n        }\n    }\n    return res\n}\n```\n**解法二**\n\n并查集的解法，留着以后再来写\n\n## [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)\n\nDifficulty: **中等**\n\n给定一个机票的字符串二维数组 `[from, to]`，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。\n\n**提示：**\n\n1.  如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前\n2.  所有的机场都用三个大写字母表示（机场代码）。\n3.  假定所有机票至少存在一种合理的行程。\n4.  所有的机票必须都用一次 且 只能用一次。\n\n**示例 1：**\n\n```go\n输入：[[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\n输出：[\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]\n```\n\n**示例 2：**\n\n```go\n输入：[[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n输出：[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n解释：另一种有效的行程是 [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]。但是它自然排序更大更靠后。\n```\n\n**解法一**\n\n欧拉回路，一笔画，后序遍历，先尝试完所有的子节点最后在添加当前节点，确保死胡同会被首先加入，这样 res 中就保持了答案的逆序\n```golang\n//欧拉回路，一笔画问题\nfunc findItinerary(tickets [][]string) []string {\n    var adj = make(map[string][]string)\n    for _, tick := range tickets {\n        adj[tick[0]] = append(adj[tick[0]], tick[1])\n    }\n    for _, toList := range adj {\n        sort.Strings(toList)\n    }\n    var res []string\n    var dfs func (cur string) \n    dfs = func (cur string) {\n        for len(adj[cur]) != 0 {\n            //删除节点，避免重复访问\n            to := adj[cur][0]\n            adj[cur] = adj[cur][1:]\n            dfs(to)\n        }\n        //后序遍历，最后将路径添加进去，保证死胡同会首先加入\n        res = append(res, cur)\n    }\n    dfs(\"JFK\")\n    //翻转下\n    for i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {\n        res[i], res[j] = res[j], res[i]\n    }\n    return res\n}\n```\n\n## [841. 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)\n\nDifficulty: **中等**\n\n有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。\n\n在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。\n\n最初，除 `0` 号房间外的其余所有房间都被锁住。\n\n你可以自由地在房间之间来回走动。\n\n如果能进入每个房间返回 `true`，否则返回 `false`。\n\n**示例 1：**\n\n```go\n输入：[[1],[2],[3],[]]\n输出：true\n解释：\n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n```\n\n**示例 2：**\n\n```go\n输入：[[1,3],[3,0,1],[2],[0]]\n输出：false\n解释：我们不能进入 2 号房间。\n```\n\n**提示：**\n\n1.  `1 <= rooms.length <= 1000`\n2.  `0 <= rooms[i].length <= 1000`\n3.  所有房间中的钥匙数量总计不超过 `3000`。\n\n**解法一**\n\n没啥好说的\n```golang\nfunc canVisitAllRooms(rooms [][]int) bool {\n    var n = len(rooms)\n    var visit = make([]bool, n)\n    var dfs func(int)\n    var count = 0\n    dfs = func(idx int) {\n        visit[idx] = true\n        count++\n        for i := 0; i < len(rooms[idx]); i++ {\n            if !visit[rooms[idx][i]] {\n                dfs(rooms[idx][i])   \n            }\n        }\n    }\n    dfs(0)\n    return count == n\n}\n```\n\n## _分治_\n\n开个新坑，其实分治这个 tag 挺大的，很多题的做法都属于分治，而且涉及到分治的题目一般都还是有点难度的，不容易直接想出来\n\n## [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**示例 1:**\n\n```java\n输入：\"2-1-1\"\n输出：[0, 2]\n解释：\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n```\n\n**示例 2:**\n\n```java\n输入：\"2*3-4*5\"\n输出：[-34, -14, -10, -10, 10]\n解释：\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n```\n\n**解法一**\n\n这题咋说呢，应该不算是回溯，是在分治 tag 中找的一题，还是挺有意思的\n\n```java\nprivate Map<String,List<Integer>> map=new HashMap<>();\n\n//分治\npublic List<Integer> diffWaysToCompute(String input) {\n    if (input==null || input.length()<=0) {\n        return new LinkedList<>();\n    }\n    return diffWaysToCompute(input,0,input.length()-1);\n}\n\npublic List<Integer> diffWaysToCompute(String input,int left,int right) {\n    List<Integer> res=new LinkedList<>();\n    /*if (left==right) { //这一步可以去掉，最开始没考虑多位数的情况（考虑到了不知道怎么处理）\n            res.add(Integer.valueOf(input.charAt(left))-48);\n            return res;\n        }*/\n    String key=input.substring(left,right+1);\n    if (map.containsKey(key)) {\n        return map.get(key);\n    }\n    for (int i=left;i<=right;i++) { //大意了，这里一开始写成了 input.length...\n        char c=input.charAt(i);\n        if (c<'0') {\n            List<Integer> leftCompute=diffWaysToCompute(input,left,i-1);\n            List<Integer> rightCompute=diffWaysToCompute(input,i+1,right);\n            for (int lc:leftCompute) {\n                for (int rc:rightCompute) {\n                    if (c=='+') \n                        res.add(lc+rc);\n                    if (c=='-') \n                        res.add(lc-rc);\n                    if (c=='*') \n                        res.add(lc*rc);\n                }\n            }\n        }\n    }\n    if (res.isEmpty()) {\n        res.add(Integer.valueOf(key));\n    }\n    map.put(key,res);\n    return res;\n}\n```\n\n第一天看了这道题，没想到思路，然后瞄了一眼评论区，看到了关键点，找到运算符，然后左右分别递归，没看到细节，第二天回忆了下思路写出了解，其实这题可以参考 [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) 我在我的 [二叉树专题](http://imlgw.top/2019/11/06/leetcode-er-cha-shu/) 中也加了这道题，两者解法极为相似\n\n## [395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)\n\nDifficulty: **中等**\n\n找到给定字符串（由小写字符组成）中的最长子串`T`， 要求 `T` 中的每一字符出现次数都不少于 `k` 。输出 `T`的长度。\n\n**示例 1:**\n\n```go\n输入：\ns = \"aaabb\", k = 3\n\n输出：\n3\n\n最长子串为 \"aaa\" ，其中 'a' 重复了 3 次。\n```\n\n**示例 2:**\n\n```go\n输入：\ns = \"ababbc\", k = 2\n\n输出：\n5\n\n最长子串为 \"ababb\" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。\n```\n\n**解法一**\n\n以出现次数最少的字符为中点分治，但是效率感人，380ms+\n```java\npublic int longestSubstring(String s, int k) {\n    if (s == null || s.length() == 0){\n        return 0;\n    }\n    int[] count = new int[26];\n    for(int i = 0; i < s.length(); i++){\n        count[s.charAt(i)-'a']++;\n    }\n    int min = 0; //记录 count 最小的 index\n    for(int i = 0;i < s.length(); i++){\n        min = count[s.charAt(i)-'a'] < count[s.charAt(min)-'a'] ? i : min;\n    }\n    if (count[s.charAt(min)-'a'] >= k) {\n        return s.length();\n    }\n    return Math.max(longestSubstring(s.substring(0,min),k),longestSubstring(s.substring(min+1),k));\n}\n```\n\n**解法二**\n\n参考了题解区大佬们的剪枝和优化方法，循环以每个小于 k 的字符为结尾，分割字符，多路分治，大大降低分治递归树的高度\n```java\n//1ms 多路分治，虽然过了，但是感觉还是有点不流畅\n//主要就是最后那个当以大于 k 的字符结尾的时候的额外处理，如果不 wa 一发不容易发现\npublic int longestSubstring(String s, int k) {\n    if (s == null || s.length() == 0){\n        return 0;\n    }\n    int[] count = new int[26];\n    for(int i = 0; i < s.length(); i++){\n        count[s.charAt(i)-'a']++;\n    }\n    int res = 0;\n    int left = 0; //分治左端点\n    boolean flag = false;\n    for(int i = 0; i < s.length(); i++){\n        if(count[s.charAt(i)-'a'] < k){\n            flag = true;\n            if(i - left >= res){ //剪枝优化\n                res = Math.max(longestSubstring(s.substring(left,i),k),res);\n            }\n            left = i+1;\n        }\n    }\n    if(!flag) return s.length();\n    //上面分治的逻辑是以 left 到小于 k 的字母 i 进行分治，但是如果字符不是以小于 k 的字母结尾就无法计算\n    //eg: aabbb k=3\n    return Math.max(res,longestSubstring(s.substring(left),k));\n}\n```\n其实还要很多分治的方法，但是感觉都大同小异","tags":["LeetCode","回溯"],"categories":["算法"]},{"title":"LeetCode 栈&队列","url":"/2019/10/01/627d9e22/","content":"\n## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\nGiven a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n**Example 1:**\n\n```java\nInput: \"()\"\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: \"()[]{}\"\nOutput: true\n```\n\n**Example 3:**\n\n```java\nInput: \"(]\"\nOutput: false\n```\n\n**Example 4:**\n\n```java\nInput: \"([)]\"\nOutput: false\n```\n\n**Example 5:**\n\n```java\nInput: \"{[]}\"\nOutput: true\n```\n\n**解法一**\n\n这道题只要学过数据结构的肯定会做，典型的利用栈的题\n\n```java\npublic boolean isValid2(String s) {\n    if(s.length()<=0){\n        return true;\n    }\n    Stack<Character> stack=new Stack();\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)=='(' || s.charAt(i)=='{' || s.charAt(i)=='['){\n            stack.push(s.charAt(i));\n        }else{\n            //注意这种情况，一开始就是])}\n            if(stack.isEmpty()){\n                return false;\n            }\n            char p=s.charAt(i);\n            if( (p==')' && stack.pop()!='(') || (p==']' && stack.pop()!='[') || (p=='}' && stack.pop()!='{')){\n                return false;\n            }\n        }\n    }\n    return stack.isEmpty();\n}\n```\n**解法二**\n\n其实和上面的解法是一样的，只不过是用的 stack 是自己用数组简单封装的栈\n\n```java\npublic class MyStack<T>{\n\n    T [] objValues=null;\n\n    int top=-1;\n\n    public MyStack(int size){\n        objValues= (T[]) new Object[size];\n    }\n\n    public void push(T obj){\n        objValues[++top]=obj;\n    }\n\n    public T peek(){\n        if (top<0) {\n            throw new RuntimeException(\"stack is isEmpty\");\n        }\n        return objValues[top];\n    }\n\n    public T pop(){\n        if (top<0) {\n            throw new RuntimeException(\"stack is isEmpty\");\n        }\n        //覆盖\n        return objValues[top--];\n    }\n\n    public boolean isEmpty(){\n        return top<0;\n    }\n}\n```\n\n3ms，94%，比之前快了一点，去看了下 Stack 的源码，它的 pop 是真的删除，我的只是移动了指针，所以效率会高很多\n\n> 后面的题可能还会利用这个`MyStack`\n\n**解法三**\n\n今天看面筋看到一个写这道题，要求 O(1) 的空间复杂度\n\n```java\npublic boolean isValid(String s) {\n    if(s.length()<=0){\n        return true;\n    }\n    while(true){\n        int len=s.length();\n        s=s.replace(\"{}\",\"\");\n        s=s.replace(\"()\",\"\");\n        s=s.replace(\"[]\",\"\");\n        if (len==s.length()) {\n            break;\n        }\n    }\n    return \"\".equals(s);\n}\n```\n100ms，效率感人，感觉应该说的是这种做法吧，当然还可以写正则表达式来匹配，但是我不太会写。\n\n## [678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/)\n\n给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：\n\n1. 任何左括号 `(` 必须有相应的右括号 `)`。\n2. 任何右括号 `)` 必须有相应的左括号 `(` 。\n3. 左括号 `(` 必须在对应的右括号之前 `)`。\n4. `*` 可以被视为单个右括号 `)` ，或单个左括号 `(` ，或一个空字符串。\n5. 一个空字符串也被视为有效字符串。\n\n**示例 1:**\n\n```java\n输入：\"()\"\n输出：True\n```\n\n**示例 2:**\n\n```java\n输入：\"(*)\"\n输出：True\n```\n\n**示例 3:**\n\n```java\n输入：\"(*))\"\n输出：True\n```\n\n**注意：**\n\n1. 字符串大小将在 [1，100] 范围内。\n\n**解法一**\n\n看面筋看到的这一题，还是挺有意思的，评论区有人说了双栈，然后今天来试了下\n\n```java\npublic boolean checkValidString(String s) {\n    Stack<Integer> bracketStack=new Stack<>();\n    Stack<Integer> starStack=new Stack<>();\n    for (int i=0;i<s.length();i++) {\n        if (s.charAt(i)=='(') {\n            bracketStack.push(i);\n        }else if(s.charAt(i)=='*'){\n            starStack.push(i);\n        }else{\n            if (bracketStack.isEmpty()) {\n                if (starStack.isEmpty()) {\n                    return false;\n                }\n                starStack.pop();\n            }else{\n                bracketStack.pop();\n            }\n        }\n    }\n    //消除左括号\n    while(!starStack.isEmpty() && !bracketStack.isEmpty()){\n        if(starStack.peek()>bracketStack.peek()){ //这里的逻辑不太好，其实可以很简单\n            bracketStack.pop();\n        }\n        starStack.pop();\n    }\n    return bracketStack.isEmpty();\n}\n```\n\n很可惜没有`bugfree`，最后对左括号的判断改了好几次，一开始写的`bracketStack.size()<=starStack().size()`  然后提交后才意识到还要 `\"*(\"` 这样的情况，然后要消除这种情况也简单，一开始我再栈中存的就是 index，从 star 栈里面取比 bracket 栈 index 大的，然后消除，最后再看括号栈是不是空\n\n```java\n//2020.4.10 重写一下\npublic boolean checkValidString(String s) {\n    Deque<Integer> stack=new ArrayDeque<>();\n    Deque<Integer> helpStack=new ArrayDeque<>();\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)=='('){\n            stack.push(i);\n        }else if(s.charAt(i)==')'){\n            if(!stack.isEmpty()){\n                stack.pop();\n            }else{\n                if(helpStack.isEmpty()){\n                    return false;\n                }\n                helpStack.pop();\n            }\n        }else{\n            helpStack.push(i);\n        }\n    }\n    while(!stack.isEmpty() && !helpStack.isEmpty()){\n        if(stack.pop()>helpStack.pop()){\n            return false;\n        }\n    }\n    return stack.isEmpty();\n}\n```\n## [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)\n\n给定一个由 `'('` 和 `')'` 括号组成的字符串 `S`，我们需要添加最少的括号（ `'('` 或是 `')'`，可以在任何位置），以使得到的括号字符串有效。\n\n从形式上讲，只有满足下面几点之一，括号字符串才是有效的：\n\n- 它是一个空字符串，或者\n- 它可以被写成 `AB` （`A` 与 `B` 连接）, 其中 `A` 和 `B` 都是有效字符串，或者\n- 它可以被写作 `(A)`，其中 `A` 是有效字符串。\n\n给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。\n\n**示例 1：**\n\n```java\n输入：\"())\"\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：\"(((\"\n输出：3\n```\n\n**示例 3：**\n\n```java\n输入：\"()\"\n输出：0\n```\n\n**示例 4：**\n\n```java\n输入：\"()))((\"\n输出：4\n```\n\n**提示：**\n\n1. `S.length <= 1000`\n2. `S` 只包含 `'('` 和 `')'` 字符。\n\n**解法一**\n\n没啥好说的，easy 题\n\n```java\npublic int minAddToMakeValid(String S) {\n    int left=0,right=0;\n    int wa=0;\n    for(int i=0;i<S.length();i++){\n        if(S.charAt(i)=='('){\n            left++;\n        }else{\n            if(left>0){\n                left--;\n            }else{\n                wa++;\n            }\n        }\n    }\n    return wa+left;\n}\n```\n\n## [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为：`k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n**示例：**\n\n```java\ns = \"3[a]2[bc]\", 返回 \"aaabcbc\".\ns = \"3[a2[c]]\", 返回 \"accaccacc\".\ns = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\".\n```\n\n**解法一**\n\n借助栈直接在原字符上做改动\n\n```java\npublic String decodeString(String s) {\n    if (s==null || s.length()<=0) {\n        return \"\";\n    }\n    //转换为 StringBuilder 比较好处理，且效率较高\n    StringBuilder sb=new StringBuilder(s);\n    Stack<Integer>  stack=new Stack<>();\n    int i=0;//遍历索引\n    while(i<sb.length()) {\n        if (sb.charAt(i)=='[') {\n            stack.push(i);\n        }else if(sb.charAt(i)==']'){\n            int left=stack.pop();//对应左括号索引\n            String temp=sb.substring(left+1,i);//相邻括号中的字符\n            int preInt=left;\n            //'['前的数字，一开始以为只是个位数，还是挺麻烦的\n            while(preInt-1>=0 && sb.charAt(preInt-1)>='0' && sb.charAt(preInt-1) <='9'){\n                preInt--;\n            }\n            //repeat 次数\n            int repeat=Integer.valueOf(sb.substring(preInt,left));\n            //删除 k[encoded_string] \n            sb.delete(preInt,Math.min(i+1,sb.length()));\n            for (int j=0;j<repeat;j++) {\n                //从 k 位置重新插入字符\n                sb.insert(preInt,temp);\n            }\n            //重新定位索引到尾部\n            i=preInt+(repeat*temp.length())-1;\n        }\n        i++;\n    }\n    return sb.toString();\n}\n```\n一开始是想用一个额外的 String 来保存结果，结果发现比较麻烦，索性直接将原字符转换为 StringBuilder，然后借助 api 直接在原字符上做改动，因为是在原字符上做改动，所以索引的变化需要额外的注意，这也是最麻烦的一点，需要停下来稍微思考下才能确定，其他的还好，正常的思路，最初 WA 了一发是因为忽略了前面的数字可能是多位数😂\n\n**解法二**\n\n递归的方式，改成`StringBuilder`应该会好一点😂\n\n```java\nprivate int index=0; //字符索引下标\n\npublic String decodeString(String s) {\n    if (s==null || s.length()<=0) {\n        return \"\";\n    }\n    String sb=\"\";\n    while(index<s.length()){\n        if (s.charAt(index)==']') { //遇到右括号就结束\n            index++;//index 定位到右括号下一个\n            return sb;\n        }else if(s.charAt(index)>='0' && s.charAt(index)<='9'){\n            int temp=index;\n            while(index<s.length() && s.charAt(index)!='['){\n                index++;\n            }\n            int repeat=Integer.valueOf(s.substring(temp,index));\n            index++;//跳过'['\n            String rs=decodeString(s);//从左括号开始\n            for (int i=0;i<repeat;i++) {\n                sb+=rs;\n            }\n        }else{\n            sb+=s.charAt(index++);\n        }\n    }\n    return sb;\n}\n```\n\n## [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n **示例 1：**\n\n```java\n输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n```\n\n**示例 2：**\n\n```java\n输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n```\n\n**解法一**\n\n很久之前做的了，本来是想单独搞一个递归专题，感觉没啥必要就直接加到一起了\n\n```java\npublic void reverseString(char[] s) {\n    if(s==null||s.length<=1)return;\n    reverseString(s,0,s.length-1);\n}\n\npublic void reverseString(char[] s,int l,int r) {\n    if(l>=r){\n        return;\n    }\n    char temp=s[l];\n    s[l]=s[r];\n    s[r]=temp;\n    reverseString(s,++l,--r);\n}\n```\n\n## [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n\n根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。\n\n有效的运算符包括 `+, -, *, /` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式\n\n说明：\n\n- 整数除法只保留整数部分。\n- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n**示例 1：**\n\n```java\n输入：[\"2\", \"1\", \"+\", \"3\", \"*\"]\n输出：9\n解释：((2 + 1) * 3) = 9\n```\n\n**示例 2：**\n\n```java\n输入：[\"4\", \"13\", \"5\", \"/\", \"+\"]\n输出：6\n解释：(4 + (13 / 5)) = 6\n```\n\n**示例 3：**\n\n```java\n输入：[\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\n输出：22\n解释：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n```\n\n**解法一**\n\n```java\npublic static int evalRPN(String[] tokens) {\n    //上面自己封装的 Stack\n    MyStack<Integer> stack=new MyStack<>(tokens.length);\n    for (int i=0;i<tokens.length;i++) {\n        if(\"+\".equals(tokens[i])){\n            stack.push(stack.pop()+stack.pop());\n        } else if(\"-\".equals(tokens[i])){\n            int rd1=stack.pop();\n            int rd2=stack.pop();\n            stack.push(rd2-rd1);\n        }else if(\"*\".equals(tokens[i])){\n            stack.push(stack.pop()*stack.pop());\n        }else if(\"/\".equals(tokens[i])){\n            int div1=stack.pop();\n            int div2=stack.pop();\n            stack.push(div2/div1);\n        }else{\n            stack.push(Integer.valueOf(tokens[i]));\n        }\n    }\n    return stack.peek();\n}\n```\n12ms，90%，其实一开始看到这个题我是拒绝的，我以为又是啥数学题，然后仔细看了下发现挺简单的，思路就是利用栈，每次遇到符号就 pop 两个出来进行运算，然后再入栈，值得注意的地方就是减法和除法的顺序\n\n## [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)\n\n以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。\n\n在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：[Linux / Unix 中的绝对路径 vs 相对路径](https://blog.csdn.net/u011327334/article/details/50355600)\n\n请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）**不能**以 / 结尾。此外，规范路径必须是表示绝对路径的**最短**字符串\n\n**示例 1：**\n\n```java\n输入：\"/home/\"\n输出：\"/home\"\n解释：注意，最后一个目录名后面没有斜杠。\n```\n\n**示例 2：**\n\n```java\n输入：\"/../\"\n输出：\"/\"\n解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。\n```\n\n**示例 3：**\n\n```java\n输入：\"/home//foo/\"\n输出：\"/home/foo\"\n解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n```\n\n**示例 4：**\n\n```java\n输入：\"/a/./b/../../c/\"\n输出：\"/c\"\n```\n\n**示例 5：**\n\n```java\n输入：\"/a/../../b/../c//.//\"\n输出：\"/c\"\n```\n\n**示例 6：**\n\n```java\n输入：\"/a//b////c/d//././/..\"\n输出：\"/a/b/c\"\n```\n\n**解法一**\n\n```java\npublic static String simplifyPath(String path) {\n    MyStack<String> stack=new MyStack<>(path.length());\n    StringBuilder str=new StringBuilder(path);\n    //这里划分出来有一部分是空的 \"\"\n    String[] s=path.split(\"/\");\n    for (int i=0;i<s.length;i++) {\n        if (!stack.isEmpty() && s[i].equals(\"..\")) {\n            //.. 回溯\n            stack.pop();\n        }else if (!\".\".equals(s[i]) && !\"\".equals(s[i]) && !s[i].equals(\"..\") ) {\n            //普通的英文字符 abcd\n            stack.push(s[i]);\n        }\n    }\n    if (stack.isEmpty()) {\n        return \"/\";\n    }\n    StringBuilder res=new StringBuilder();\n    for (int i=0;i<stack.size(); i++) {\n        res.append(\"/\"+stack.get(i));   \n    }\n    return res.toString();\n}\n\n//自己封装的 stack\npublic class MyStack<T>{\n\n    T [] objValues=null;\n\n    int top=-1;\n\n    public MyStack(int size){\n        objValues= (T[]) new Object[size];\n    }\n\n    public void push(T obj){\n        objValues[++top]=obj;\n    }\n\n    public T peek(){\n        if (top<0) {\n            throw new RuntimeException(\"stack is isEmpty\");\n        }\n        return objValues[top];\n    }\n\n    public T pop(){\n        if (top<0) {\n            throw new RuntimeException(\"stack is isEmpty\");\n        }\n        //覆盖\n        return objValues[top--];\n    }\n\n    public T get(int index){\n        if (index>top || index < 0) {\n            throw new RuntimeException(\"index is wrong\");\n        }\n        return objValues[index];\n    }\n\n    public boolean isEmpty(){\n        return top<0;\n    }\n\n    public int size(){\n        return top+1;\n    }\n}\n```\n这题本来是很简单的，但是我钻到牛角尖去了，一直想着怎么在遍历过程中处理，写了一堆 ifelse。还是太菜了啊，其实直接按照`\"/\"` 划分 split 字符串然后处理那个数组就可以了\n\n## [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\nImplement the following operations of a stack using queues.\n\n- push(x) -- Push element x onto stack.\n- pop() -- Removes the element on top of the stack.\n- top() -- Get the top element.\n- empty() -- Return whether the stack is empty.\n\n**Example:**\n\n```java\nMyStack stack = new MyStack();\n\nstack.push(1);\nstack.push(2);  \nstack.top();   // returns 2\nstack.pop();   // returns 2\nstack.empty(); // returns false\n```\n\n**Notes:**\n\n- You must use *only* standard operations of a queue -- which means only `push to back`, `peek/pop from front`, `size`, and `is empty` operations are valid.\n- Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.\n- You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).\n\n**解法一**\n\n很经典的题\n\n```java\nclass MyStack {\n\n    private ArrayDeque<Integer> queue=null;\n\n    /** Initialize your data structure here. */\n    public MyStack() {\n        queue=new ArrayDeque();\n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        queue.add(x);\n        int size=queue.size();\n        //除了新加入的元素，其他的元素都出队再入队，将新加入的元素推置队列头\n        while(size-- >1){\n            queue.add(queue.pop());\n        }\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n       return  queue.pop();\n    }\n    \n    /** Get the top element. */\n    public int top() {\n        return queue.peek();\n    }\n\n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n```\n\n很巧妙的做法，将元素前 n-1 个出队后再重新入队，`1 2 --> 2 1` 直接将堆顶推置队列头 ，将每次新加入的元素都放置队列头而不是队尾，这样实际上就完成了逆序的操作\n\n这样 push 压栈时间复杂度`O(N)` ，`pop/peek` 时间复杂度`O(1)`\n\n**解法二**\n\n适用于 push 频繁的 stack\n\n```java\npublic class MyStack{\n   //形式上 q1 是负责进栈 q2 负责出栈\n    private LinkedList inQueue=new LinkedList(); \n    private LinkedList outQueue=new LinkedList();\n\n    private  void  add(Object obj){\n        inQueue.add(obj);\n    }\n\n    private Object pop(){\n        // q1 ----> q2 留一个\n        while(inQueue.size()>1){\n            outQueue.add(inQueue.poll());\n        }\n        //交换 q1,q2 的引用\n        LinkedList temp;\n        temp=inQueue;\n        inQueue=outQueue;\n        outQueue=temp;\n        return outQueue.poll();\n    }\n\n    private Object peek(){\n        //q1 --->q2 留一个，最后一个不 poll, 最后 poll\n        while(inQueue.size()>1){\n            outQueue.add(inQueue.poll());\n            if(inQueue.size()==1){\n                outQueue.add(inQueue.peek());\n            }\n        }\n        //交换 q1,q2 的引用\n        LinkedList temp;\n        temp=inQueue;\n        inQueue=outQueue;\n        outQueue=temp;\n        return outQueue.poll();\n    }\n}\n```\n\n两个队列，push 压栈时间复杂度`O(1)`，pop/push 出栈时间复杂度`O(N)` ，出栈的时候将一个队列的前 n-1 个元素全部加入到另一个队列中作为缓存，然后将最后一个元素出栈，最后别忘了交换两个队列的引用，不然 push 的时候就会出问题，要保证`inQueue` 一直是入栈的队列，其中存放着所有的元素\n\n## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\nImplement the following operations of a queue using stacks.\n\n- push(x) -- Push element x to the back of queue.\n- pop() -- Removes the element from in front of queue.\n- peek() -- Get the front element.\n- empty() -- Return whether the queue is empty.\n\n**Example:**\n\n```java\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);  \nqueue.peek();  // returns 1\nqueue.pop();   // returns 1\nqueue.empty(); // returns false\n```\n\n**Notes:**\n\n- You must use *only* standard operations of a stack -- which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.\n- Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.\n- You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).\n\n**解法一**\n\n```java\nclass MyQueue {\n\n    Stack<Integer> inStack=null;\n\n    Stack<Integer> outStack=null;\n    /** Initialize your data structure here. */\n    public Stack2Queue232() {\n        inStack=new Stack<>();\n        outStack=new Stack<>();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        s2s();\n        return outStack.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        s2s();\n        return outStack.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return outStack.isEmpty() && inStack.isEmpty();\n    }\n\n    private void s2s(){\n        if (outStack.isEmpty()) {\n            while(!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }     \n    }\n}\n```\n\n很上面一题是姊妹题，需要注意的地方就是`s2s`的时候要确保 stack2 栈是空的才能 push\n\n## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)\n\n设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。\n\n- push(x) -- 将元素 x 推入栈中。\n\n- pop() -- 删除栈顶的元素。\n\n- top() -- 获取栈顶元素。\n\n- getMin() -- 检索栈中的最小元素。\n\n**示例：**\n\n```java\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.getMin();   --> 返回 -2.\n```\n\n**解法一**\n\n利用辅助栈，同步的 push 和 pop\n\n```java\nclass MinStack {\n\n    /** initialize your data structure here. */\n    private Stack<Integer> stack=null;\n\n    private Stack<Integer> helpStack=null;\n\n    public MinStack() {\n        stack=new Stack<>();\n        helpStack=new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack.push(x);\n        if (helpStack.isEmpty()) {\n            helpStack.push(x);\n        }else{\n            if (helpStack.peek()>x) {\n                helpStack.push(x);\n            }else{\n                helpStack.push(helpStack.peek());\n            }\n        }\n    }\n    \n    public void pop() {\n        stack.pop();\n        helpStack.pop();\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return helpStack.peek();\n    }\n}\n```\n\n**解法二**\n\n在上面的基础上进行空间的优化\n\n```java\nclass MinStack {\n\n    /** initialize your data structure here. */\n    private Stack<Integer> stack=null;\n\n    private Stack<Integer> helpStack=null;\n\n    public MinStack() {\n        stack=new Stack<>();\n        helpStack=new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n        if (helpStack.isEmpty()) {\n            helpStack.push(x);\n        }else if (x<=helpStack.peek()) {\n            //相等的也要入栈，不然不好控制后面出栈\n            helpStack.push(x);\n        }\n    }\n    \n    public void pop() {\n        int top=stack.pop();\n        //和辅助栈栈顶相同就出栈\n        if(top==helpStack.peek()){\n            helpStack.pop();\n        }\n        /*\n        if(stack.pop()==helpStack.peek()){\n            helpStack.pop();\n        }*/\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return helpStack.peek();\n    }\n}\n```\n\n其实这里有一个地方把我卡了一会儿，就是出栈的时候，我开始为了简洁 if 的条件写的\n\n`stack.pop()==helpStack.peek()` 然后卡在了一个 case 上，想了半天才意识到是`Integer`的问题，这里弹出来的是两个`Integer`并不会自动拆箱，而且值是不在 -128~127 之间的，所以就 false 了\n\n**解法三**\n\n帅地上看见的解法，在栈中存一个 diff 差值，代表当前元素和入栈前的 min 的差值，空间复杂度为 O(1)，但是这种做法限制比较多，比如数据的大小会有限制，同时貌似也无法做`peek()`操作\n\n```java\npublic class MinStack155_2{\n    /** initialize your data structure here. */\n    private Stack<Integer> stack=null;\n\n    private int min=0;\n\n    public MinStack155_2() {\n        stack=new Stack<>();\n    }\n    \n    public void push(int x) {\n        if (stack.isEmpty()) {\n            min=x;\n            stack.push(0);\n        }else{\n            int diff=x-min;\n            min=diff>0?min:x;\n            stack.push(diff);\n        }\n    }\n    \n    public void pop() {\n        int diff=stack.pop();\n        //小于等于 0 说明 min 就是当前真实的栈顶元素，也就是说 min-minPre=diff\n        min=diff<=0?min-diff:min;\n    }\n    \n    /*public int top() {\n        int diff=stack.peek();\n        return diff<=0?min:diff-min;\n    }*/\n    \n    public int getMin() {\n        return min;\n    }\n}\n```\n\n## [779. 第 K 个语法符号](https://leetcode-cn.com/problems/k-th-symbol-in-grammar/)\n\nOn the first row, we write a `0`. Now in every subsequent row, we look at the previous row and replace each occurrence of `0` with `01`, and each occurrence of `1` with `10`.\n\nGiven row `N` and index `K`, return the `K`-th indexed symbol in row `N`. (The values of `K` are 1-indexed.) (1 indexed).\n\n```java\nExamples:\nInput: N = 1, K = 1\nOutput: 0\n\nInput: N = 2, K = 1\nOutput: 0\n\nInput: N = 2, K = 2\nOutput: 1\n\nInput: N = 4, K = 5\nOutput: 1\n\nExplanation:\nrow 1: 0\nrow 2: 01\nrow 3: 0110\nrow 4: 01101001\n```\n\n**Note:**\n\n1. `N` will be an integer in the range `[1, 30]`.\n2. `K` will be an integer in the range `[1, 2^(N-1)]`.\n\n**解法一**\n\n找规律，前半部分和后半部分是有一定规律的，把前六行都写出来\n\n```java\n  第一行：0\n  第二行：01\n  第三行：01|10\n  第四行：01 10|10 01\n  第五行：01 10 10 01|10 01 01 10\n  第六行：01 10 10 01 10 01 01 10 | 10 01 01 10 01 10 10 01\n```\n\n  N%2!=0 对称，第 K 个等于 2^(N-1)-K+1\n  N%2==0 互补对称\n\n```java\npublic int kthGrammar(int N, int K) {\n    if(K==1 || N==1){\n        return 0;\n    }\n    if(K==2){\n        return 1;\n    }\n    int len=1<<(N-1); //当前行长度\n    if(K>len/2){ //大于 1/2\n        //结合上面的规律，找前半部分和自己等价的位置\n        if(N%2!=0){ \n            K=len-K+1;\n        }else{\n            if(K%2==0){\n                K=len-K+2;  \n            }else{\n                K=len-K;\n            }\n        }\n    }\n    //去上一行继续\n    return kthGrammar(N-1,K);\n}\n```\n\n时间复杂第 O(N)，思路还算清晰，最开始没想到用`位运算`来算长度，用的`pow()`最后效率差不多，可能是底层做了优化。\n\n**解法二**\n\n这种解法实际上就是把整个序列看作一颗满二叉树，每个节点的值和父节点其实是有对应关系的，如果 K 是偶数那么就和父节点的值相反，否则就相同，所以我们可以递归的去找父节点对应的 index 的值。\n\n```java\n//01 排列\n//              0\n//          /        \\   \n//      0                1\n//    /   \\            /    \\\n//  0       1        1       0\n// / \\     /  \\     /  \\    / \\ \n//0   1   1    0   1    0  0   1\n\npublic int kthGrammar(int N, int K) {\n    if (K==1) return 0;\n    //(K+1)/2 是对应父节点的 index\n    int parent=kthGrammar(N-1,(K+1)/2);\n    //取反\n    int f_parent=-(parent-1);\n    if (K%2==0) {\n        return f_parent;\n    }\n    return parent;\n}\n```\n时间复杂度依然是`O(N)` 但是比上面那种要更清晰明了\n\n**解法三**\n\n这个解法其实和上面的思路是一样的，都是利用父节点和 K 的奇偶来判断，其实仔细看上面的代码你会发现 N 其实并没有实际的意义，具体 K 的值只和 K 本身有关，下面的解法就没有用到 N.\n\n```java\npublic static int kthGrammar3(int N, int K) {\n    boolean r=false;\n    while(K>1){\n        if (K%2==0) {\n            K=K/2;\n            r=!r;\n        }else{\n            K=(K+1)/2;\n        }\n    }\n    return r?1:0;\n}\n```\n这题其实还有一种解法，利用二进制，对 K 做奇偶检验，貌似时间复杂度是 O(1)。\n\n## [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)\n\n实现 pow(*x*, *n*) ，即计算 x 的 n 次幂函数。\n\n**解法一**\n\n这里就要介绍一种快速幂算法了\n\n```java\npublic static double fastPow(double x,int n){\n    if(n==0){\n        return 1;\n    }\n    if(n<0){\n        x=1/x;\n        n=-n;\n    }\n    double res=fastPow(x,n/2);\n    if(n%2==0){\n        return res*res;\n    }\n    return res*res*x;\n}\n```\n\n核心思想就是 `x^n=(x^2/n)^2`，常规累乘的方式计算时间复杂度是 O(N) 因为要遍历所有的元素，但是其实知道了`x^n/2`之后 `x^n`就可以直接平方得到了不用继续遍历，整体时间复杂度为 O(logN) \n\n2019.8.20，又写了一遍，提交然后没过。看了下给的测试用例，最后一个给的 n 是 `-2^31` 也就是 int 整数的最小值，int 类型的取值范围是 `-2^31 ~ 2^31-1` 而这个负值在这里取反之后会直接溢出最后得到的还是 `-2^31` ，所以这里这样写 if 会执行两次，x 就又会变回来，所以结果直接就是`Infinity`无穷大了，所以为了保证 if 只会执行一次可以将其封装一下\n\n```java\npublic static double myPow(double x, int n) {\n    if(n<0){\n        x=1/x;\n        n=-n;\n    }\n    return fastPow(x,n);\n} \n\npublic static double fastPow(double x,int n){\n    if(n==0){\n        return 1.0;\n    }\n    double  half=fastPow(x,n/2);\n    if(n%2==0)\n        return half*half;\n    return half*half*x;\n}\n```\n\n## 5222. 分割平衡字符串\n\n在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。\n\n给出一个平衡字符串 `s`，请你将它分割成尽可能多的平衡字符串。\n\n返回可以通过分割得到的平衡字符串的最大数量\n\n**示例 1：**\n\n```java\n输入：s = \"RLRRLLRLRL\"\n输出：4\n解释：s 可以分割为 \"RL\", \"RRLL\", \"RL\", \"RL\", 每个子字符串中都包含相同数量的 'L' 和 'R'。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"RLLLLRRRLR\"\n输出：3\n解释：s 可以分割为 \"RL\", \"LLLRRR\", \"LR\", 每个子字符串中都包含相同数量的 'L' 和 'R'。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"LLLLRRRR\"\n输出：1\n解释：s 只能保持原样 \"LLLLRRRR\".\n```\n\n**提示：**\n\n- `1 <= s.length <= 1000`\n- `s[i] = 'L' 或 'R'`\n\n**解法一**\n\n19.10.13 的周赛的第 1 题，果然比赛和刷题还是不一样，差点没做出来。\n\n```java\npublic static int balancedStringSplit(String s) {\n    if (s.length()%2==1) {\n        return 0;\n    }\n    Stack<Character> stack=new Stack<>();\n    int count=0;\n    for(int i=0;i<s.length();i++){\n        if (!stack.isEmpty() ){\n            if(s.charAt(i)==stack.peek()) {\n                stack.push(s.charAt(i));    \n            }else{\n                stack.pop();\n                if (stack.isEmpty()) {\n                    count++;\n                }\n            }\n        }else{\n            stack.push(s.charAt(i));\n        }\n    }\n    return count;\n}\n```\n\n## [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)\n\n给你一个由 '('、')' 和小写字母组成的字符串 s。\n\n你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号），使得剩下的「括号字符串」有效。\n\n请返回任意一个合法字符串。\n\n有效「括号字符串」应当符合以下 **任意一条** 要求：\n\n- 空字符串或只包含小写字母的字符串\n- 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」\n- 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」\n\n**示例 1：**\n\n```java\n输入：s = \"lee(t(c)o)de)\"\n输出：\"lee(t(c)o)de\"\n解释：\"lee(t(co)de)\" , \"lee(t(c)ode)\" 也是一个可行答案。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"a)b(c)d\"\n输出：\"ab(c)d\"\n```\n\n**示例 3：**\n\n```java\n输入：s = \"))((\"\n输出：\"\"\n解释：空字符串也是有效的\n```\n\n**示例 4：**\n\n```java\n输入：s = \"(a(b(c)d)\"\n输出：\"a(b(c)d)\"\n```\n\n**提示：**\n\n- `1 <= s.length <= 10^5`\n- `s[i]` 可能是 `'('`、`')'` 或英文小写字母 \n\n**解法一**\n\n11.3 周赛第三题，这题倒是没什么障碍，用栈就 ok，不过我这里实现的不太好，replace 时间复杂度略高，应该用一个数组做 mark 最后用 StringBuilder 做 append 应该效率会高很多\n\n```java\npublic String minRemoveToMakeValid(String s) {\n    StringBuilder sb=new StringBuilder(s);\n    Stack<Integer> stack=new Stack<>();\n    for (int i=0;i<s.length();i++) {\n        if (s.charAt(i)>='a' && s.charAt(i)<='z') {\n            continue;\n        }\n        if (s.charAt(i)==')') {\n            if (stack.isEmpty()) {\n                sb.replace(i,i+1,\"*\");    \n            }else{\n                stack.pop();\n            }\n        }\n        if (s.charAt(i)=='(') {\n            stack.push(i);\n        }\n    }\n    while (!stack.isEmpty()) {\n        int temp=stack.pop();\n        sb.replace(temp,temp+1,\"*\");\n    }\n    String res=sb.toString().replace(\"*\",\"\");\n    return res;\n}\n```\n\n## [856. 括号的分数](https://leetcode-cn.com/problems/score-of-parentheses/)\n\n给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：\n\n- () 得 1 分。\n- AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。\n- (A) 得 2 * A 分，其中 A 是平衡括号字符串。\n\n**示例 1：**\n\n```java\n输入： \"()\"\n输出： 1\n```\n\n**示例 2：**\n\n```java\n输入： \"(())\"\n输出： 2\n```\n\n**示例 3：**\n\n```java\n输入： \"()()\"\n输出： 2\n```\n\n**示例 4：**\n\n```java\n输入： \"(()(()))\"\n输出： 6\n```\n\n**提示：**\n\n1. S 是平衡括号字符串，且只含有 ( 和 ) 。\n2. 2 <= S.length <= 50\n\n**解法一**\n\n```java\npublic int scoreOfParentheses(String S) {\n    Stack<Integer> stack=new Stack<>();\n    for(int i=0;i<S.length();i++){\n        if(S.charAt(i)=='('){\n            stack.push(-11111);\n        }else{\n            //遇到右括号，下面的分支都是处理 \")\"\n            int top=stack.peek();\n            if(top == -11111){ //栈顶是左括号，将 ( --> 1\n                stack.pop();\n                stack.push(1);\n            }else{\n                int sum=0; //遇到数值了\n                while(!stack.isEmpty()){\n                    int temp=stack.pop();\n                    //弹出去，直到遇到 \"(\"就* 2, 其实就是把\"(1\"-->2\n                    if(temp==-11111){ \n                        sum*=2;\n                        break;\n                    }\n                    sum+=temp;\n                }\n                stack.push(sum);\n            }\n        }\n    }\n    int res=0;\n    while(!stack.isEmpty()) res+=stack.pop();\n    return res;\n}\n```\n这种解法一开始也没想出来，其实这种就类似于消消乐游戏一样，就按照题目的逻辑来写，从左向右，栈中存标识左括号的数值，这里我用的`-11111` 表示`（` ，然后向右移动，一边移动一边将`（）`给消除掉，其实上面的逻辑自己走一边就通了\n\n**解法二**\n\n这个解法就带有点技巧性了，看懂上面的注释，下面的代码就很简单了\n\n```java\n// (()(())) = 2*()+2*(())= (())+((()))\npublic int scoreOfParentheses(String S) {\n    int k=0,res=1;\n    for (int i=0;i<S.length();i++) {\n        if (S.charAt(i)=='(') {\n            k++; //k 用来计算括号的深度\n        }else{\n            k--;\n            if (S.charAt(i-1)=='(') {\n                //\"()\"闭合的时候计算一波\n                res+= 1<<k; //2^k\n            }\n        }\n    }\n    return res;\n}\n```\n\n## [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)\n\n给定 `pushed` 和 `popped` 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 `push` 和弹出 pop 操作序列的结果时，返回 `true` 否则，返回 `false` \n\n**示例 1：**\n\n```java\n输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出：true\n解释：我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n```\n\n**示例 2：**\n\n```java\n输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出：false\n解释：1 不能在 2 之前弹出。\n```\n\n**提示：**\n\n1. `0 <= pushed.length == popped.length <= 1000`\n2. `0 <= pushed[i], popped[i] < 1000`\n3. `pushed` 是 `popped` 的排列\n\n**解法一**\n\n直接用栈模拟，可惜没有 bugfree...\n\n```java\npublic boolean validateStackSequences(int[] pushed, int[] popped) {\n    if(pushed==null || pushed.length<=0) return true;\n    Deque<Integer> stack=new ArrayDeque<>();\n    int popIndex=0;\n    int pushIndex=0;\n    //pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n    //[1,2,3,4,5]      [4,3,5,1,2]\n    //[1,0] [1,0]\n    while(pushIndex<pushed.length){\n        stack.push(pushed[pushIndex++]);\n        while(!stack.isEmpty()&&popped[popIndex]==stack.peek()){\n            stack.pop();\n            popIndex++;\n        }\n    }\n    return stack.isEmpty();\n}\n```\n每进一个元素就判断栈顶和出栈顺序的头是否相等，然后出栈，最后看栈中是否为空就 ok\n\n## [NC560. 打字](https://www.nowcoder.com/practice/7819ebf1369044e5bee2f9848d9c6c72)\n\n牛妹在练习打字，现在按照时间顺序给出牛妹按下的键（以字符串形式给出，'<'代表回退 backspace，其余字符均是牛妹打的字符，字符只包含小写字母与'<'），牛妹想知道最后在屏幕上显示的文本内容是什么。\n在文本内容为空的时候也可以按回退 backspace（在这种情况下没有任何效果）。\n**示例 1**\n```go\n输入：\"acv<\"\n输出：\"ac\"\n说明：\n牛妹在打完\"acv\"之后按了回退，所以最后是\"ac\"\n```\n**解法一**\n\n也可以直接数组模拟\n```java\npublic String Typing (String s) {\n    // write code here\n    Deque<Integer> stack = new ArrayDeque<>();\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == '<') {\n            if (stack.isEmpty()) {\n                continue;\n            }\n            stack.pop();\n        }else{\n            stack.push(i);\n        }\n    }\n    StringBuilder sb = new StringBuilder();\n    while(!stack.isEmpty()){\n        sb.append(s.charAt(stack.pop()));\n    }\n    return sb.reverse().toString();\n}\n```\n\n## _BFS 广搜_\n\n## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)\n\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少\n\n**示例 1:**\n\n```java\n输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4.\n```\n\n**示例 2:**\n\n```java\n输入：n = 13\n输出：2\n解释：13 = 4 + 9.\n```\n\n**解法一**\n\n这题在上一篇 [dp 专题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/) 中有讲过，不过是 dp 的解法，这里主要记录 BFS 的解法\n\n```java\npublic static int numSquares2(int n) {\n    Queue<Pair> queue=new LinkedList<>();\n    boolean[] visit=new boolean[n+1];\n    queue.add(new Pair(n,0));\n    visit[n]=true;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        int num=pair.num;\n        int step=pair.step;\n        //nums=0 说明找到了，并且一定是最短的\n        if (num==0) {\n            return step;\n        }\n        for (int i=1;i*i<=num;i++) {\n            int temp=num-i*i;\n            //注意不要添加重复的元素\n            if (!visit[temp]) {\n                queue.add(new Pair(temp,step+1));\n                visit[temp]=true;\n            }\n        }\n    }\n    return -1;\n}\n\nstatic class Pair{\n    public int step;\n    public int num;\n    public Pair(int num,int step){\n        this.num=num;\n        this.step=step;\n    }\n}\n```\n30ms 90%，比 dp 的方式会快很多，思路就是将这个问题转换为求图的最短路径的问题，找到一个最短的从 n 到 0 的以平方数为差的路径\n\n## [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)\n\nGiven two words (*beginWord* and *endWord*), and a dictionary's word list, find the length of shortest transformation sequence from *beginWord* to *endWord*, such that:\n\n1. Only one letter can be changed at a time.\n2. Each transformed word must exist in the word list. Note that *beginWord* is *not* a transformed word.\n\n**Note:**\n\n- Return 0 if there is no such transformation sequence.\n- All words have the same length.\n- All words contain only lowercase alphabetic characters.\n- You may assume no duplicates in the word list.\n- You may assume *beginWord* and *endWord* are non-empty and are not the same.\n\n**Example 1:**\n\n```java\nInput:\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput: 5\n\nExplanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n```\n\n**Example 2:**\n\n```java\nInput:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput: 0\n\nExplanation: The endWord \"cog\" is not in wordList, therefore no possible transformation.\n```\n\n**解法一**\n\n这题其实很久以前就写过了，当时是看了啊哈算法的一些 BFS 算法然后仿照书上的写的，书上是 C 语言写的，所以最后我写的时候也按照 C 的格式去写了😅，写的贼啰嗦，现在又用\"Java\"的方式又重新写了一遍\n\n```java\nprivate static int[] mark;\n\nint min = Integer.MAX_VALUE;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList)     {\n    // 不存在\n    mark = new int[wordList.size() + 1];\n    if (!wordList.contains(endWord)) {\n        return 0;\n    }\n    // BFS\n    int head = 0, tail = 0;\n    // 初始化队列\n    Que[] que = new Que[wordList.size() + 1];\n    // 循环促使话述祖\n    for (int i = 0; i < que.length; i++) {\n        que[i] = new Que();\n    }\n    que[tail].word = beginWord;\n    que[tail].step = 1;\n    tail++;\n    int flag=0;\n    while (head < tail) {\n        // 遍历字典\n        for (int i = 0; i < wordList.size(); i++) {\n            if (mark[i] == 0 && cmp(wordList.get(i), que[head].word)) {\n                que[tail].word = wordList.get(i);\n                //这里是从 head 开始的，所以应该是 head 的步数+1\n                que[tail].step=que[head].step+1;\n                // 标记为已经走过\n                mark[i] = 1;\n                // 统计最小步数\n               if (que[tail].word.equals(endWord)) {\n                //跳出循环\n                    flag=1;\n                   break;\n                }\n                tail++;\n            }\n        }\n        if(flag==1){\n            break;\n        }\n        // 每次检查完一个单词就将其出队列\n        head++;\n    }\n    return que[tail].step;\n}\n\n// 写一个函数判段没吃是否只变化了一个字母\nprivate boolean cmp(String s1, String s2) {\n    int count = 0;\n    for (int i = 0; i < s1.length(); i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            count++;\n        }\n    }\n    return count == 1;\n}\n\n// 内部类\nclass Que {\n    String word;\n    int step;\n}\n```\n这就是当时写的解法，思路就是 BFS，只不过写的复杂了\n\n**解法二**\n\n```java\npublic int ladderLength(String beginWord, String endWord, List<String> wordList)     {\n    //visit 数组\n    boolean[] visit=new boolean[wordList.size()];\n    if (!wordList.contains(endWord)) {\n        return 0;\n    }\n\n    Queue<Pair> queue=new LinkedList<>();\n    queue.add(new Pair(beginWord,1));\n    //int flag=0;\n    while (!queue.isEmpty()) {\n        Pair pair=queue.poll();\n        // 统计最小步数，放在内循环中会快一点\n        /*if (pair.word.equals(endWord)) {\n            return pair.step;\n        }*/\n        // 遍历字典\n        for (int i = 0; i < wordList.size(); i++) {\n            if (!visit[i] && cmp(wordList.get(i),pair.word)) {\n                if (wordList.get(i).equals(endWord)) {\n                    //这里加 1 是因为取的是 pair 的 step\n                    //到当前这个单词还要多走一步\n                    return pair.step+1;\n                }\n                queue.add(new Pair(wordList.get(i),pair.step+1));\n                //标记为已经走过\n                visit[i] = true;\n            }\n        }\n    }\n    return 0;\n}\n\n//是否只变化了一个字符\nprivate boolean cmp(String s1, String s2) {\n    int count = 0;\n    for (int i = 0; i < s1.length(); i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            count++;\n            if (count>1) {\n                return false;\n            }\n        }\n    }\n    return count == 1;\n}\n\n//Pair\nclass Pair {\n    String word;\n    int step;\n    public Pair(String word,int step){\n        this.word=word;\n        this.step=step;\n    }\n}\n```\n273ms，47%中规中矩的做法，连续写了好几题 BFS 的，总算是对 BFS 的板子有点熟悉了，这题还有两个可以优化的点 ① _双端 BFS_ ② _寻找下一个字符串的方式_，只不过我没咋看懂，等看懂了再来补充，那种方式时间好像可以缩减到 20ms 内。....\n\n> 这题有个困难版本，需要打印出所有的最短序列，这个在我很久之前的一篇文章中也有讲，但是至今我也还没有 AC，一直是 TLE，现在回头看我之前的代码已经看不懂了。写了 100 多行，略复杂 BFS+DFS 的做法，可能是没处理好所以 TLE 了，感兴趣可以看看 [那篇文章](http://imlgw.top/2018/10/31/yi-dao-leetcode-yin-fa-de-can-an/#2-%E5%8A%A0%E5%BC%BA%E7%89%88-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-2)\n\n## [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)\n\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 \n\n**示例 1:**\n输入：\n\n```java\n0 0 0\n0 1 0\n0 0 0\n```\n\n输出：\n\n```java\n0 0 0\n0 1 0\n0 0 0\n```\n\n**示例 2:**\n输入：\n\n```java\n0 0 0\n0 1 0\n1 1 1\n```\n\n输出：\n\n```java\n0 0 0\n0 1 0\n1 2 1\n```\n\n**注意：**\n\n- 给定矩阵的元素个数不超过 10000\n- 给定矩阵中至少有一个元素是 0\n- 矩阵中的元素只在四个方向上相邻：上、下、左、右\n\n**解法一**\n\n憨憨的 BFS 解法\n\n```java\n//遍历每一个 1,BFS 寻找离他最近的 0, 一次只能确定一个 1, 效率略低\npublic int[][] updateMatrix(int[][] matrix) {\n    if (matrix == null || matrix.length <=0 || matrix[0].length <=0) {\n        return new int[][]{};\n    }\n    for (int i=0;i<matrix.length;i++) {\n        for (int j=0;j<matrix[0].length;j++) {\n            if (matrix[i][j] == 1) {\n                matrix[i][j]=findMinDis(matrix,i,j);   \n            }\n        }\n    }\n    return matrix;\n}\n\nprivate int[][] direction={{1,0},{0,1},{-1,0},{0,-1}};\n\npublic int findMinDis(int[][] matrix,int x,int y){\n    Queue<Pair> queue=new LinkedList<>();\n    //boolean[][] visit=new boolean[matrix.length][matrix[0].length];\n    queue.add(new Pair(x,y,0));\n    //visit[x][y]=true;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        for (int i=0;i<direction.length;i++) {\n            int nx=pair.x + direction[i][0];\n            int ny=pair.y + direction[i][1];\n            if (isValid(matrix,nx,ny) /*&& !visit[nx][ny]*/) {\n                //visit[nx][ny]=true;\n                if (matrix[nx][ny] == 0) {\n                    return pair.step+1;\n                }\n                queue.add(new Pair(nx,ny,pair.step+1));\n            }\n        }\n    }\n    return -1; //题目说了一定有 0, 所以不会走到这里\n}\n\npublic boolean isValid(int[][] matrix,int x,int y){\n    return x>=0 && x<matrix.length && y>=0 && y<matrix[0].length;\n}\n\nclass Pair{\n    int x;\n    int y;\n    int step;\n    public Pair(int x,int y,int step){\n        this.x=x;\n        this.y=y;\n        this.step=step;\n    }\n}\n```\n可以看到代码中有很明显的改动痕迹，最开始是用 visit 数组保证每一个元素只会进队列一次，不会重复的进队列，但是这里为什么我去掉了呢？\n\n其实主要是一开始提交的解法超时了，把 visit 数组去掉就过了，在数组过大的时候每次 BFS 都要开辟一个 matrix 大小的 boolean 数组，这无疑会极其耗费时间，但是为什么不加 visit 数组不会死循环呢？\n\n确实，如果不加 visit 数组那么确实是有可能会导致死循环的，两个节点互相重复添加对方，但是这一题有个很关键的地方，题目说明了一定会有 0，也就是说一定会解，那么就不会死循环，举一个很简单的例子\n\n`【0，1，1】` 这里我们先考虑中间的 1，然后我们按照下右上左的顺序去添加周围的节点，那么队列中就为末尾的`[1]` ，当遍历到右的时候发现是 0，直接 return，然后我们考虑下一个 1，转了一圈队列中只有一个中间的`[1]` ， 然后我们又重复刚刚的步骤会将末尾的 1 又加入队列，但是下一次遍历就会找到最左边的 0，然后返回，所以并不会死循环，当然这样做的前提是一定要有解！\n\n**解法二**\n\n另一种更好的做法，以 0 作为源，向四周 BFS，同时更新周围的 1 的值\n\n```java\n//update: 2020.4.15\nprivate int[][] dir={{1,0},{0,1},{-1,0},{0,-1}};\n\npublic int[][] updateMatrix(int[][] matrix) {\n    if(matrix==null || matrix.length<=0) return matrix;\n    boolean[][] visit=new boolean[matrix.length][matrix[0].length];\n    Queue<Pair> queue=new LinkedList<>();\n    for(int i=0;i<matrix.length;i++){\n        for(int j=0;j<matrix[0].length;j++){\n            if(matrix[i][j]==0){\n                queue.add(new Pair(i,j,0));\n                visit[i][j]=true;\n            }else{\n                matrix[i][j]=Integer.MAX_VALUE;\n            }\n        }\n    }\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        for(int i=0;i<dir.length;i++){\n            int nx=pair.x+dir[i][0];\n            int ny=pair.y+dir[i][1];\n            if(valid(matrix,nx,ny) && !visit[nx][ny]){\n                queue.add(new Pair(nx,ny,pair.step+1));\n                matrix[nx][ny]=pair.step+1; //这里不用判断是不是变小，第一次遇到的就是最近的\n                visit[nx][ny]=true;\n            }\n        }\n    }\n    return matrix;\n}\n\npublic boolean valid(final int[][] matrix,int x,int y){\n    return x>=0 && x<matrix.length && y>=0 && y<matrix[0].length;\n}\n\nclass Pair{\n    int x,y;\n    int step;\n    public Pair(int x,int y,int step){\n        this.x=x;\n        this.y=y;\n        this.step=step;\n    }\n}\n```\n\n核心思想就是 把所有 1 都置为最大值，把所有为 0 的位置加入队列中，每次从队列中 poll 一个节点，更新其四周的节点，~~如果被更新的节点距离变小了就将其也加入队列准备更新其邻接点~~ step 是递增的，第一次遇到的一定是最近的\n\n多源 BFS，参考下面的 [994. 腐烂的橘子]()  和 [1162. 地图分析]()\n\n**解法三**\n\n> 这题的最优解应该是动态规划的解法，我实在是懒得写（菜），其实和哪个 不同路径有点类似，每个 1 离他最近的 0 的距离其实就是它周围的元素离 0 最近的距离+1\n>\n> 也就是 `matrix[i][j] =min(dp[i][j-1],dp[i-1][j],dp[i+1][j],dp[i][j+1]) + 1` 但是我们不可能同时求出是个方向的最小值，所以我们需要两次遍历，第一遍从左上到右下，第二遍从右下到左上，两次遍历就可以确定每个节点的值，代码以后有时间再来写\n\n## [1306. 跳跃游戏 III](https://leetcode-cn.com/problems/jump-game-iii/)\n\n这里有一个非负整数数组 `arr`，你最开始位于该数组的起始下标 `start` 处。当你位于下标 i 处时，你可以跳到 `i + arr[i]` 或者 `i - arr[i]`。\n\n请你判断自己是否能够跳到对应元素值为 0 的 `任意` 下标处。\n\n注意，不管是什么情况下，你都无法跳到数组之外\n\n**示例 1：**\n\n```java\n输入：arr = [4,2,3,0,3,1,2], start = 5\n输出：true\n解释：\n到达值为 0 的下标 3 有以下可能方案： \n下标 5 -> 下标 4 -> 下标 1 -> 下标 3 \n下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 \n```\n\n**示例 2：**\n\n```java\n输入：arr = [4,2,3,0,3,1,2], start = 0\n输出：true \n解释：\n到达值为 0 的下标 3 有以下可能方案： \n下标 0 -> 下标 4 -> 下标 1 -> 下标 3\n```\n\n**示例 3：**\n\n```java\n输入：arr = [3,0,2,1,2], start = 2\n输出：false\n解释：无法到达值为 0 的下标 1 处。 \n```\n\n**提示：**\n\n- `1 <= arr.length <= 5 * 10^4`\n- `0 <= arr[i] < arr.length`\n- `0 <= start < arr.length`\n\n**解法一**\n\nBFS，某次周赛的第 3 题，还是挺简单的，可惜那次没参加\n\n```java\npublic boolean canReach(int[] arr, int start) {\n    boolean[] visit=new boolean[arr.length];\n    Queue<Integer> queue=new LinkedList<>();\n    queue.add(start);\n    visit[start]=true;\n    while(!queue.isEmpty()){\n        int cur=queue.poll();\n        if (arr[cur] == 0) {\n            return true;\n        }\n        if (cur-arr[cur]>=0 && !visit[cur-arr[cur]]) {\n            queue.add(cur-arr[cur]);\n            visit[cur-arr[cur]]=true;\n        }\n        if (cur+arr[cur]<arr.length && !visit[cur+arr[cur]]) {\n            queue.add(cur+arr[cur]);\n            visit[cur+arr[cur]]=true;\n        }\n    }\n    return false;\n}\n```\n\n**解法二**\n\nDFS 解法，没啥好说的\n\n```java\npublic boolean canReach(int[] arr,int start){\n    boolean[] visit=new boolean[arr.length];\n    return dfs(arr,start,visit);\n}\n\npublic boolean dfs(int[] arr,int index,boolean[] visit){\n    if (arr[index] == 0) {\n        return true;\n    }\n    visit[index]=true;\n    boolean b=false;\n    if (index-arr[index] >=0 && !visit[index-arr[index]]) {\n        b=dfs(arr,index-arr[index],visit);\n    }\n    if (index+arr[index] <arr.length && !visit[index+arr[index]]) {\n        return b|dfs(arr,index+arr[index],visit);\n    }\n    return b;\n}\n```\n## [5314. 跳跃游戏 IV](https://leetcode-cn.com/problems/jump-game-iv/)\n\n给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。\n\n每一步，你可以从下标 i 跳到下标：\n\n- i + 1 满足：i + 1 < arr.length\n- i - 1 满足：i - 1 >= 0\n- j 满足：arr[i] == arr[j] 且 i != j\n\n请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。 \n注意：任何时候你都不能跳到数组外面。\n\n**示例 1：**\n\n```java\n输入：arr = [100,-23,-23,404,100,23,23,23,3,404]\n输出：3\n解释：那你需要跳跃 3 次，下标依次为 0 --> 4 --> 3 --> 9 。下标 9 为数组的最后一个元素的下标。\n```\n\n**示例 2：**\n\n```java\n输入：arr = [7]\n输出：0\n解释：一开始就在最后一个元素处，所以你不需要跳跃。\n```\n\n**示例 3：**\n\n```java\n输入：arr = [7,6,9,6,9,6,9,7]\n输出：1\n解释：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。\n```\n\n**示例 4：**\n\n```java\n输入：arr = [6,1,9]\n输出：2\n```\n\n**示例 5：**\n\n```java\n输入：arr = [11,22,7,7,7,7,7,7,7,22,13]\n输出：3\n```\n\n**提示：**\n\n- `1 <= arr.length <= 5 * 10^4`\n- `-10^8 <= arr[i] <= 10^8`\n\n**解法一**\n\n19 双周赛的最后一题，讲道理挺简单的（可我还是 TLE 了好长时间）\n\n```java\npublic int minJumps(int[] arr) {\n    Queue<Pair> queue=new LinkedList<>();\n    boolean[] visit=new boolean[arr.length];\n    HashMap<Integer,List<Integer>> map=new HashMap<>();\n    //构建等值的索引 连续相同的只保留头尾\n    for (int i=0;i<arr.length;i++) {\n        List<Integer> lis=map.computeIfAbsent(arr[i],k->new ArrayList<>());\n        if (!((i-1>=0&&arr[i-1]==arr[i]) && (i+1<arr.length&&arr[i+1]==arr[i]))){\n            lis.add(i);\n        }\n    }\n    queue.add(new Pair(0,0));\n    visit[0]=true;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        if (pair.index==arr.length-1) {\n            return pair.step;\n        }\n        if(pair.index+1<arr.length && !visit[pair.index+1]){\n            queue.add(new Pair(pair.index+1,pair.step+1));\n            visit[pair.index+1]=true;\n        }\n        if (pair.index-1>=0 && !visit[pair.index-1]) {\n            queue.add(new Pair(pair.index-1,pair.step+1));\n            visit[pair.index-1]=true;\n        }\n        List<Integer> list=map.get(arr[pair.index]);\n        for (int i=list.size()-1;i>=0;i--) {\n            int idx=list.get(i);\n            if (!visit[idx]) {\n                queue.add(new Pair(idx,pair.step+1));\n                visit[idx]=true;\n            }\n        }\n    }\n    return -1;\n}\n\nclass Pair{\n    int index;\n    int step;\n    public Pair(int index,int step){\n        this.index=index;\n        this.step=step;\n    }\n}\n```\n\n看一下数据范围，直接 BFS 遍历跳同值的肯定不行，所以想到了用 map 预处理同值的索引，结果还是 TLE 了，后面一个 case 有 50000 个 7，这里即使做了 map 索引但是无奈太多了，依然会超时，这里其实这么多 7，只有头和尾的 7 是用的，其他位置的 7 都是无用的，可以直接忽略，所以构建索引的时候可以跳过这些中间位置，这样可以节省很多时间\n\n## [690. 员工的重要性](https://leetcode-cn.com/problems/employee-importance/)\n\n给定一个保存员工信息的数据结构，它包含了员工唯一的 id，重要度 和 直系下属的 id。\n\n比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15, 10, 5。那么员工 1 的数据结构是 [1, 15, [2]]，员工 2 的数据结构是 [2, 10, [3]]，员工 3 的数据结构是 [3, 5, []]。注意虽然员工 3 也是员工 1 的一个下属，但是由于并不是直系下属，因此没有体现在员工 1 的数据结构中。\n\n现在输入一个公司的所有员工信息，以及单个员工 id，返回这个员工和他所有下属的重要度之和。\n\n**示例 1:**\n\n```java\n输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n输出：11\n解释：\n员工 1 自身的重要度是 5，他有两个直系下属 2 和 3，而且 2 和 3 的重要度均为 3。因此员工 1 的总重要度是 5 + 3 + 3 = 11。\n```\n\n**注意：**\n\n1. 一个员工最多有一个直系领导，但是可以有多个直系下属\n2. 员工数量不超过 2000。\n\n**解法一**\n\nBFS，没啥好说的，憨憨题直接 bugfree\n\n```java\npublic int getImportance(List<Employee> employees, int id) {\n    HashMap<Integer,Employee> map=new HashMap<>();\n    for (Employee e:employees) {\n        map.put(e.id,e);\n    }\n    Queue<Integer> queue=new LinkedList<>();\n    queue.add(id);\n    int res=0;\n    while(!queue.isEmpty()){\n        Employee cur=map.get(queue.poll());\n        res+=cur.importance;\n        List<Integer> subordinates=cur.subordinates;\n        if (!subordinates.isEmpty()) {\n            for (int eid:subordinates) {\n                queue.add(eid);\n            }\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\nDFS，本来不想写的，这类题其实都是树的题变了个说法而已\n\n```java\npublic int getImportance(List<Employee> employees, int id) {\n    HashMap<Integer,Employee> map=new HashMap<>();\n    for (Employee e:employees) {\n        map.put(e.id,e);\n    }\n    return dfs(map,id);\n}\n\npublic int dfs(HashMap<Integer,Employee> map,int id){\n    Employee cur=map.get(id);\n    int res=cur.importance;\n    for (int eid:cur.subordinates) {\n        res+=dfs(map,eid);\n    }\n    return res;\n}\n```\n## [1311. 获取你好友已观看的视频](https://leetcode-cn.com/problems/get-watched-videos-by-your-friends/)\n\n有 n 个人，每个人都有一个  0 到 n-1 的唯一 id 。\n\n给你数组 `watchedVideos`  和 `friends` ，其中 `watchedVideos[i]`  和 friends[i] 分别表示 id = i 的人观看过的视频列表和他的好友列表。\n\nLevel 1 的视频包含所有你好友观看过的视频，level 2 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 k 的视频包含所有从你出发，最短距离为 k 的好友观看过的视频。\n\n给定你的 `id`  和一个 `level` 值，请你找出所有指定 level 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按名字字典序从小到大排列。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/01/I5XJKQg3WwvaeB1.png)\n\n```java\n输入：watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n输出：[\"B\",\"C\"] \n解释：\n你的 id 为 0 ，你的朋友包括：\nid 为 1 -> watchedVideos = [\"C\"] \nid 为 2 -> watchedVideos = [\"B\",\"C\"] \n你朋友观看过视频的频率为：\nB -> 1 \nC -> 2\n```\n\n**示例 2：**\n\n![image.png](https://i.loli.net/2020/02/01/qhDZvr3sbJkgIuw.png)\n\n```java\n输入：watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n输出：[\"D\"]\n解释：\n你的 id 为 0 ，你朋友的朋友只有一个人，他的 id 为 3 。\n```\n\n**提示：**\n\n- n == watchedVideos.length == friends.length\n- 2 <= n <= 100\n- 1 <= watchedVideos[i].length <= 100\n- 1 <= watchedVideos[i][j].length <= 8\n- 0 <= friends[i].length < n\n- 0 <= friends[i][j] < n\n- 0 <= id < n\n- 1 <= level < n\n- 如果 friends[i] 包含 j ，那么 friends[j] 包含 i\n\n**解法一**\n\n170 周赛的第三题，其实是一道水题，题目意思搞清楚就很简单了\n\n```java\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\n    Queue<Integer> queue=new LinkedList<>();\n    int[] levels=new int[friends.length]; //这里没必要，这里用一个变量就 ok 了\n    boolean[] visit=new boolean[friends.length];\n    HashMap<String,Integer> map=new HashMap<>();\n    List<Integer> flist=new ArrayList<>(); //level 层的朋友\n    queue.add(id);\n    visit[id]=true;\n    while(!queue.isEmpty()){\n        int cur=queue.poll();\n        int[] cfs=friends[cur];\n        for (int i=0;i<cfs.length;i++) {\n            if (!visit[cfs[i]]) {\n                queue.add(cfs[i]);\n                levels[cfs[i]]=levels[cur]+1;   \n                visit[cfs[i]]=true;\n                if (levels[cfs[i]] == level) {\n                    flist.add(cfs[i]);\n                }\n            }\n        }\n    }\n    for (int i=0;i<flist.size();i++) {\n        List<String> videos=watchedVideos.get(flist.get(i));\n        for (String v:videos) {\n            map.put(v,map.getOrDefault(v,0)+1); //map 记录 videos 出现的次数\n        }\n    }\n    //下面几步还是挺老道的\n    List<String> res=new ArrayList(map.keySet());\n    res.sort((v1,v2)->{\n        int c1=map.get(v1);\n        int c2=map.get(v2);\n        return c1==c2?v1.compareTo(v2):c1-c2; //相等的时候按照字典序列排序\n    });\n    return res;\n}\n```\n\n## [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)\n\n给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。\n\n示例 :\n\n```java\n给定 a / b = 2.0, b / c = 3.0\n问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \n返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]\n```\n\n输入为：`vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries（方程式，方程式结果，问题方程式）`， 其中 `equations.size() == values.size()`，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回`vector<double>`类型。\n\n基于上述例子，输入如下：\n\n```java\nequations（方程式） = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\nvalues（方程式结果） = [2.0, 3.0],\nqueries（问题方程式） = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \n```\n\n输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。\n\n**解法一**\n\n建立图，然后 BFS，这样就简单多了，比并茶集的方法直白多了，随便也学了一下如何建图\n\n```java\n//构造图 + BFS/DFS\nprivate Map<String,Map<String,Double>> graph = new HashMap<>();\n\npublic void buildGraph(List<List<String>> equations, double[] values){\n    for (int i = 0; i < values.length; i++) {\n        graph.computeIfAbsent(equations.get(i).get(0), k -> new HashMap<>()).put(equations.get(i).get(1), values[i]);\n        graph.computeIfAbsent(equations.get(i).get(1), k -> new HashMap<>()).put(equations.get(i).get(0), 1 / values[i]);\n    }\n}\n\nclass Pair{\n    String key;\n    double val;\n    public Pair(String key,double val){\n        this.key=key;\n        this.val=val;\n    }\n}\n\npublic double bfs(String a,String b){\n    //讲道理，不管 a,b 是否在 graph 中，只要想等都应该返回 1 吧，这里是考虑了 0 的情况？\n    if (!graph.containsKey(a) || !graph.containsKey(b)) {\n        return -1.0;\n    }\n    if (a.equals(b)) {\n        return 1.0;\n    }\n    Queue<Pair> queue=new LinkedList<>();\n    queue.add(new Pair(a,1.0));\n    HashSet<String> visit=new HashSet<>();\n    while(!queue.isEmpty()){\n        Pair cur=queue.poll();\n        if (!visit.contains(cur.key)) {\n            visit.add(cur.key);\n            Map<String,Double> map=graph.get(cur.key);\n            for (String next:map.keySet()) {\n                if (b.equals(next)) {\n                    return cur.val*map.get(next);\n                }\n                queue.add(new Pair(next,cur.val*map.get(next)));\n            }\n        }\n    }\n    return -1.0;\n}\n\npublic double dfs(String a,String b,HashSet<String> visit){\n    if (!graph.containsKey(a)) {\n        return -1;\n    }\n    if (a.equals(b)) {\n        return 1;\n    }\n    visit.add(a);\n    Map<String,Double> nextMap=graph.get(a);\n    for (String next:nextMap.keySet()) {\n        if (!visit.contains(next)) {\n            double subres=dfs(next,b,visit);\n            if (subres!=-1) {\n                return subres*nextMap.get(next);\n            }\n        }\n    }\n    return -1;\n}\n\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n    buildGraph(equations,values);\n    double[] res=new double[queries.size()];\n    int index=0;\n    for (List<String> query:queries) {\n        HashSet<String> visit=new HashSet<>();\n        //res[index++]=bfs(query.get(0),query.get(1),visit); \n        res[index++]=bfs(query.get(0),query.get(1));\n    }\n    return res;\n}\n```\n\n## [301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)\n\n删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。\n\n**说明：** 输入可能包含了除 ( 和 ) 以外的字符。\n\n**示例 1:**\n\n```java\n输入：\"()())()\"\n输出：[\"()()()\", \"(())()\"]\n```\n\n**示例 2:**\n\n```java\n输入：\"(a)())()\"\n输出：[\"(a)()()\", \"(a())()\"]\n```\n\n**示例 3:**\n\n```java\n输入：\")(\"\n输出：[\"\"]\n```\n\n**解法一**\n\nBFS 解法\n\n```java\npublic List<String> removeInvalidParentheses(String s) {\n    List<String> res=new ArrayList<>();\n    Queue<String> queue=new LinkedList<>();\n    HashSet<String> visit=new HashSet<>();\n    visit.add(s);\n    queue.add(s);\n    boolean flag=false;\n    while(!queue.isEmpty()){\n        String cur=queue.poll();\n        if (isValid(cur)) {\n            res.add(cur);\n            flag=true;\n        }\n        if (flag) {\n            continue;\n        }\n        for (int i=0;i<cur.length();i++) {\n            if (cur.charAt(i)=='(' || cur.charAt(i)==')') {\n                String temp=cur.substring(0,i)+cur.substring(i+1,cur.length());\n                if (!visit.contains(temp)) {\n                    queue.add(temp);\n                    visit.add(temp);\n                }\n            }\n        }\n    }\n    if(res.isEmpty()) res.add(\"\");\n    return res;\n}\n\npublic boolean isValid(String s){\n    int left=0,right=0;\n    for (int i=0;i<s.length();i++) {\n        if (s.charAt(i)=='(') {\n            left++;\n        }else if (s.charAt(i)==')') {\n            if (left>0) {\n                left--;\n            }else{\n                return false;\n            }\n        }\n    }\n    return left==0;\n}\n```\n\n还是比较简单，dfs 的解法比较难搞，容易 TLE，这里懒得写了\n\n## [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)\n\n在给定的网格中，每个单元格可以有以下三个值之一：\n\n- 值 0 代表空单元格；\n- 值 1 代表新鲜橘子；\n- 值 2 代表腐烂的橘子。\n\n每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。\n\n返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。\n\n**示例 1：**\n\n![mark](http://static.imlgw.top/blog/20200304/YGBajce2liDs.png?imageslim)\n\n```java\n输入：[[2,1,1],[1,1,0],[0,1,1]]\n输出：4\n```\n\n**示例 2：**\n\n```java\n输入：[[2,1,1],[0,1,1],[1,0,1]]\n输出：-1\n解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\n```\n\n**示例 3：**\n\n```java\n输入：[[0,2]]\n输出：0\n解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n```\n\n**提示：**\n\n1. `1 <= grid.length <= 10`\n2. `1 <= grid[0].length <= 10`\n3. `grid[i][j]` 仅为 `0`、`1` 或 `2`\n\n**解法一**\n\nBFS 打卡题，这种解法应该算是比较好的了，2ms\n\n```java\nprivate int[][] diretion={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic int orangesRotting(int[][] grid) {\n    Queue<Pair> queue=new LinkedList<>();\n    int time=0;\n    int count=0;\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]==1) count++; //统计好橘子的数量\n            if(grid[i][j]==2){\n                queue.add(new Pair(i,j));\n            }\n        }\n    }\n    if(count==0) return 0;\n    while(!queue.isEmpty()){\n        //每一轮的坏橘子数量\n        int size=queue.size();\n        time++;\n        while(size-- >0){\n            Pair pair=queue.poll();\n            for (int i=0;i<4;i++) {\n                int nx=pair.x+diretion[i][0];\n                int ny=pair.y+diretion[i][1];\n                if(valid(grid,nx,ny) && grid[nx][ny]==1){\n                    grid[nx][ny]=2;\n                    count--;//好橘子--\n                    queue.add(new Pair(nx,ny));\n                }\n            }\n            if(count==0) return time;\n        }\n    }\n    return -1;\n}\n\nclass Pair{\n    int x,y;\n    public Pair(int x,int y){\n        this.x=x;\n        this.y=y;\n    }\n}\n\npublic boolean valid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n**解法二**\n\n一开始的解法，虽然效率稍微低一点点 4ms，但是 bugfree 了\n\n```java\nprivate int[][] diretion={{0,1},{1,0},{0,-1},{-1,0}};\n\nclass Pair{\n    int x,y;\n    int step;\n    public Pair(int x,int y,int step){\n        this.x=x;\n        this.y=y;\n        this.step=step;\n    }\n}\n\npublic int orangesRotting(int[][] grid) {\n    Queue<Pair> queue=new LinkedList<>();\n    int max=0;\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]==2){\n                queue.add(new Pair(i,j,0));\n            }\n        }\n    }\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        //统计一个最大的步数作为结果\n        //max=Math.max(max,pair.step);\n        max=pair.step; //最后弹出的哪个就是最大的，这是个递增（非单调）的过程\n        for (int i=0;i<4;i++) {\n            int nx=pair.x+diretion[i][0];\n            int ny=pair.y+diretion[i][1];\n            if(valid(grid,nx,ny) && grid[nx][ny]==1){\n                grid[nx][ny]=2;\n                queue.add(new Pair(nx,ny,pair.step+1));\n            }\n        }\n    }\n    return check(grid)?max:-1;\n}\n\npublic boolean check(int[][] grid){\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]==1){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\npublic boolean valid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n经过勘误，发现有一处地方有点小问题，已经修改，`pair.step` 在队列中是一个递增（不单调，会相等）的过程，所以最后弹出的就是最大的\n\n## [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)\n\n你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。\n\n我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。\n\n如果我们的地图上只有陆地或者海洋，请返回 -1。\n\n**示例 1：**\n\n![GVuO3Q.png](https://s1.ax1x.com/2020/03/29/GVuO3Q.png)\n\n```java\n输入：[[1,0,1],[0,0,0],[1,0,1]]\n输出：2\n解释： \n海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。\n```\n\n**示例 2：**\n\n![GVKSH0.png](https://s1.ax1x.com/2020/03/29/GVKSH0.png)\n\n```java\n输入：[[1,0,0],[0,0,0],[0,0,0]]\n输出：4\n解释： \n海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。\n```\n\n**提示：**\n\n1. `1 <= grid.length == grid[0].length <= 100`\n2. `grid[i][j]` 不是 `0` 就是 `1`\n\n**解法一**\n\n这题的意思其实求**离陆地最远的海洋是那一块，然后返回这个最远的距离**，这个题目描述的确实让人迷惑，一会儿最远，一会儿最近，其实题目意思搞懂了就很简单了，其实和上面腐烂的橘子是一样的。多源的 BFS，曼哈顿距离其实就是上下左右走的 step\n\n```java\nprivate int[][] diretion={{1,0},{-1,0},{0,1},{0,-1}};\n\npublic int maxDistance(int[][] grid) {\n    int maxDis=-1;\n    int m=grid.length,n=grid[0].length;\n    boolean[][] visit=new boolean[m][n];\n    Queue<Pair> queue=new LinkedList<>();\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if(grid[i][j]==1){\n                queue.add(new Pair(i,j,0));\n                visit[i][j]=true;\n            }\n        }\n    }\n    if(queue.size()==0 || queue.size()==m*n)return -1;\n    int step=0;\n    int res=-1;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        res=pair.step;\n        for (int i=0;i<4;i++) {\n            int nx=pair.x+diretion[i][0];\n            int ny=pair.y+diretion[i][1];\n            if(valid(grid,nx,ny) && !visit[nx][ny] && grid[nx][ny]==0){\n                queue.add(new Pair(nx,ny,pair.step+1));\n                visit[nx][ny]=true;\n            }\n        }\n    }\n    return res;\n}\n\nclass Pair{\n    int x,y;\n    int step;\n    public Pair(int x,int y,int step){\n        this.x=x;\n        this.y=y;\n        this.step=step;\n    }\n}\n\npublic boolean valid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n## [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)\n\n你这个学期必须选修 `numCourse` 门课程，记为 0 到 `numCourse-1` 。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：`[0,1]`\n\n给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？\n\n**示例 1:**\n\n```java\n输入：2, [[1,0]] \n输出：true\n解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。\n```\n\n**示例 2:**\n\n```java\n输入：2, [[1,0],[0,1]]\n输出：false\n解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。\n```\n\n**提示：**\n\n1. 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。\n2. 你可以假定输入的先决条件中没有重复的边。\n3. `1 <= numCourses <= 10^5`\n\n**解法二**\n\n学习下拓扑排序，其实核心在于邻接表的构建\n\n```java\npublic boolean canFinish(int numCourses, int[][] prerequisites) {\n    int[] indegree=new int[numCourses];\n    List<List<Integer>> adjacency=new ArrayList<>();\n    for(int i=0;i<numCourses;i++){\n        adjacency.add(new ArrayList<>());\n    }\n    for(int[] p:prerequisites){\n        indegree[p[0]]++; //每个节点的入度值\n        //邻接表，注意这里别搞反了，这里记录的是 p[1] 所有的出度节点\n        adjacency.get(p[1]).add(p[0]); \n    }\n    //课程 id\n    Queue<Integer> queue=new LinkedList<>();\n    for(int i=0;i<numCourses;i++){\n        if(indegree[i]==0){\n            queue.add(i);\n        }\n    }\n    while(!queue.isEmpty()){\n        int cid=queue.poll();\n        numCourses--;\n        for (int id:adjacency.get(cid)) { //cid --> id\n            //该节点的所有邻接节点入度--\n            indegree[id]--;\n            if(indegree[id]==0){\n                queue.add(id);\n            }\n        }\n    }\n    return numCourses==0;\n}\n```\n## [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)\n\n现在你总共有 *n* 门课需要选，记为 `0` 到 `n-1`。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：`[0,1]`\n\n给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。\n\n可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。\n\n**示例 1:**\n\n```java\n输入：2, [[1,0]] \n输出：[0,1]\n解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。\n```\n\n**示例 2:**\n\n```java\n输入：4, [[1,0],[2,0],[3,1],[3,2]]\n输出：[0,1,2,3] or [0,2,1,3]\n解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n```\n\n**说明：**\n\n1. 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见 [图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。\n2. 你可以假定输入的先决条件中没有重复的边。\n\n**提示：**\n\n1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。\n2. [通过 DFS 进行拓扑排序](https://www.coursera.org/specializations/algorithms) - 一个关于 Coursera 的精彩视频教程（21 分钟），介绍拓扑排序的基本概念。\n3. 拓扑排序也可以通过 [BFS](https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fr=aladdin&fromid=2148012&fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2) 完成。\n\n**解法一**\n\nBFS 做法，和上面一样\n\n```java\n//BFS 拓扑排序\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\n    int[] indegree=new int[numCourses]; //入度数\n    List<List<Integer>> adjacency=new ArrayList<>();\n    for(int i=0;i<numCourses;i++){\n        adjacency.add(new ArrayList<>());\n    }\n    for(int[] pre:prerequisites){\n        indegree[pre[0]]++;\n        adjacency.get(pre[1]).add(pre[0]);\n    }\n    int k=0;\n    int[] res=new int[numCourses];\n    Queue<Integer> queue=new LinkedList<>();\n    for(int i=0;i<numCourses;i++){\n        if(indegree[i]==0){\n            queue.add(i);\n        }\n    }\n    while(!queue.isEmpty()){\n        int cur=queue.poll();\n        res[k++]=cur;\n        for(int c:adjacency.get(cur)){\n            indegree[c]--;\n            if(indegree[c]==0){\n                queue.add(c);\n            }\n        }\n    }\n    return k==numCourses?res:new int[0];\n}\n```\n\n**解法二**\n\nDFS 的做法，比 BFS 更有意思一点，其实就是个不断判环的过程，图相关的还是不太熟悉啊\n\n```java\n//DFS 的解法\nint k=0;\n\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> adjacency=new ArrayList<>();\n    for(int i=0;i<numCourses;i++){\n        adjacency.add(new ArrayList<>());\n    }\n    int[] mark=new int[numCourses];\n    int[] res=new int[numCourses];\n    for(int[] pre:prerequisites){\n        adjacency.get(pre[0]).add(pre[1]); //注意这个区别\n    }\n    for (int i=0;i<numCourses;i++) {\n        if(dfs(adjacency,i,mark,res)) return new int[0];\n    }\n    return res;\n}\n\npublic boolean dfs(List<List<Integer>> adj,int cur,int[] mark,int[] res){\n    if(mark[cur]==1) return true;  //正在访问\n    if(mark[cur]==2) return false; //节点已经访问完（之前已经学了）\n    mark[cur]=1;\n    for(int c:adj.get(cur)){\n        if(dfs(adj,c,mark,res)){\n            return true;\n        }\n    }\n    mark[cur]=2;\n    //cur 的先决课程是没环的，所以可以学 cur\n    res[k++]=cur; \n    return false;\n}\n```\n\n## [365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)\n\nDifficulty: **中等**\n\n有两个容量分别为 _x_升 和 _y_升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 _z_升 的水？\n\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 _z 升 _水。\n\n你允许：\n\n*   装满任意一个水壶\n*   清空任意一个水壶\n*   从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n**示例 1:** (From the famous )\n\n```go\n输入：x = 3, y = 5, z = 4\n输出：True\n```\n\n**示例 2:**\n\n```go\n输入：x = 2, y = 6, z = 5\n输出：False\n```\n\n**解法一**\n\n暴力 BFS 的解法\n```java\npublic boolean canMeasureWater(int x, int y, int z) {\n    Queue<int[]> queue = new LinkedList<>();\n    int capX = x;\n    int capY = y;\n    queue.add(new int[]{x, y});\n    while(!queue.isEmpty()) {\n        int[] cur = queue.poll();\n        int cx = cur[0];\n        int cy = cur[1];\n        if (cx==z || cy==z || cx+cy==z) {\n            return true;\n        }\n        //清空 x\n        addQueue(0, cy, queue);\n        //清空 y\n        addQueue(cx, 0, queue);\n        //装满 x\n        addQueue(capX, cy, queue);\n        //装满 y\n        addQueue(cx, capY, queue);\n        //x-->y\n        addQueue(Math.max(0, cx-capY+cy), Math.min(capY, cy+cx), queue);\n        //y-->x\n        addQueue(Math.min(capX, cy+cx), Math.max(0, cy-capY+cx), queue);\n    }\n    return false;\n}\n\npublic void addQueue(int x, int y, Queue<int[]> queue){\n    long hashCode = x * (long)1e9+7 + y;\n    if (!visit.contains(hashCode)) {\n        queue.add(new int[]{x, y});\n        visit.add(hashCode);\n    }\n}\n```\n**解法二**\n数学解法，涉及到一些数学定理（贝祖定理），我也不是很懂（就是搞懂过两天也忘了）\n```java\npublic boolean canMeasureWater(int x, int y, int z) {\n    if(x+y<z) return false;\n    if(x==0 || y==0) return z==0 || x+y==z;\n    return z%gcd(x,y)==0;\n}\n\npublic int gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n```\n\n## _单调栈_\n\n> 单独开辟出新的专题 [LeetCode 单调栈](http://imlgw.top/2020/08/28/leetcode-dan-diao-zhan/)","tags":["LeetCode"],"categories":["算法"]},{"title":"AQS 源码解析（上）","url":"/2019/09/24/c279d77a/","content":"\n## AbstractQueuedSynchronized\n\n`AbstractQueuedSynchronized` 简称 AQS，这个类是整个并发包的基础工具类， ReentrantLock、CountDownLatch、Semaphore、FutureTask 等并发工具类底层都是通过它来实现的\n\nAQS 定义了两种资源共享的方式：\n\n- Exclusive：独占式，只有一个线程能获取资源并执行，比如 ReentrantLock。\n- Share：共享式，多个线程获取资源，多个线程可以同时执行，比如 CountDownLatch，ReentrantReadWriteLock 的 ReadLock 等\n\n### AQS 结构\n\n#### 属性\n\n主要的就是这三个 volatile 修饰的 Node 对象，还有一些对应的偏移量（用于 CAS 的）\n\n```java\n/**\n * Head of the wait queue, lazily initialized.  Except for\n * initialization, it is modified only via method setHead.  Note:\n * If head exists, its waitStatus is guaranteed not to be\n * CANCELLED.\n * 头节点，可以理解为当前持有锁的节点\n * 在分析的过程中不要将它算作队列的一部分！它只是一个空节点\n */\nprivate transient volatile Node head;\n\n/**\n * Tail of the wait queue, lazily initialized.  Modified only via\n * method enq to add new wait node.\n * 尾节点\n */\nprivate transient volatile Node tail;\n\n/**\n * The synchronization state.\n * 同步状态，0 代表没有被占用，1 代表被一个线程占用，>1 代表被同一个线程多次占用（可重入）\n */\nprivate volatile int state;\n```\n\n#### Node 节点\n\n```java\nstatic final class Node {\n    /** Marker to indicate a node is waiting in shared mode */\n    //共享模式\n    static final Node SHARED = new Node();\n    /** Marker to indicate a node is waiting in exclusive mode */\n    //独占模式\n    static final Node EXCLUSIVE = null;\n\n    /** waitStatus value to indicate thread has cancelled */\n    //取消抢锁\n    static final int CANCELLED =  1;\n    \n    /** waitStatus value to indicate successor's thread needs unparking */\n    //代表当前节点的后续节点需要被 unparking，也就是说后继节点状态是 parking\n    static final int SIGNAL    = -1;\n    \n    /** waitStatus value to indicate thread is waiting on condition */\n    //在 condition 上等待\n    static final int CONDITION = -2;\n    \n    /**\n     * waitStatus value to indicate the next acquireShared should\n     * unconditionally propagate\n     */\n    static final int PROPAGATE = -3;\n\n\t//上面的那些状态\n    volatile int waitStatus;\n\n    //前驱节点    \n    volatile Node prev;\n    //后继节点\n    volatile Node next;\n\n    /**\n     * The thread that enqueued this node.  Initialized on\n     * construction and nulled out after use.\n     */\n    volatile Thread thread;\n\n    /**\n     * Link to next node waiting on condition, or the special\n     * value SHARED.  Because condition queues are accessed only\n     * when holding in exclusive mode, we just need a simple\n     * linked queue to hold nodes while they are waiting on\n     * conditions. They are then transferred to the queue to\n     * re-acquire. And because conditions can only be exclusive,\n     * we save a field by using special value to indicate shared\n     * mode.\n     */\n    Node nextWaiter;\n\n    /**\n     * Returns true if node is waiting in shared mode.\n     */\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n\n    //返回前驱节点\n    final Node predecessor() throws NullPointerException {\n        Node p = prev;\n        if (p == null)\n            throw new NullPointerException();\n        else\n            return p;\n    }\n\n    Node() {    // Used to establish initial head or SHARED marker\n    }\n\n    Node(Thread thread, Node mode) {     // Used by addWaiter\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n\n    Node(Thread thread, int waitStatus) { // Used by Condition\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n```\n\n## ReentrantLock 分析\n\n我们知道 ReentrantLock 内部有两个锁，一个是公平锁 (FairSync)🔒，一个是非公平锁 (NonFairSync)🔒，这两个锁都是独占锁，两者实现的差异其实并不大，我们先从`公平锁`开始说起。\n\n```java\nstatic final class FairSync extends Sync {\n    private static final long serialVersionUID = -3000897897090466540L;\n\n    final void lock() {\n        acquire(1);\n    }\n    \n    /**\n     * Fair version of tryAcquire.  Don't grant access unless\n     * recursive call or no waiters or is first.\n     */\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n### Lock()\n\n🔔 **这里我们为了模拟真实的情况，我们假设有两个线程`Thread0` 和`Thread1` 过来执行了`Lock()` 方法，且`Thread0` 比`Thread1` 要先执行。**\n\n`Lock()`方法中调用了父类的`acquire(1)`\n\n#### acquire()\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n首先尝试 tryAcquire(1)，这个 tryLock() 在 AQS 中没有具体实现是交给子类去实现的，所以这里就会调用 FairSync 的，tryAquire(1)\n\n#### tryAquire()\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取同步状态\n    int c = getState();\n    if (c == 0) { //0 代表还没有线程占用\n        //判断有没有前驱节点（除 head 节点外），没有则进行 CAS 设置同步状态获取锁\n        if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { \n            //设置当前线程为独占线程\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //到这里就说明已经有线程占用了，所以下面是为了重入\n    else if (current == getExclusiveOwnerThread()) {\n        //这里不用担心并发的问题，因为是独占锁，同时只有一个线程会到达这里\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n#### hasQueuedPredecessors()\n\n公平锁和非公平锁的 tryAcquire 方法区别就在这里，这个方法就是判断有没有前驱节点（不包含头节点 head，也就是）存在，有的话为了保证公平性就是需要等待，返回 true。\n\n```java\npublic final boolean hasQueuedPredecessors() {\n    // The correctness of this depends on head being initialized\n    // before tail and on head.next being accurate if the current\n    // thread is first in queue.\n    Node t = tail; // Read fields in reverse initialization order\n    Node h = head;\n    Node s;\n    // 头不等于尾，并且队列的第一个节点所持有线程非当前线程返回 true\n    return h != t &&\n        ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n```\n\n💡 到这里我们分析下`Thread0` 和`Thread1` 的执行情况\n\n🔸 首先`Thread0`先执行了`tryAcquire(1)`  没有任何阻碍，执行成功直接 retrurn\n\n🔸 `Thread1` 此时有多种情况：\n\n- 还没有获取 state ，`Thread0`执行完后获取 State==1 ，由于是独占锁直接 return false ，获取锁失败。\n\n-  已经`getState()==0`了，执行`hasQueuedPredecessors` 方法，注意，此时 head 和 tail 都还没有初始化，都还是 null（官方的注释中也提到 head 和 tail 是 lazily initialized ）所以这里会直接 return false，然后继续执行 CAS，由于前面`Thread0` 已经将 state 设置为了 1 ，所以这里 CAS 肯定失败了，最终`Thread1`的 tryAcquire 失败返回 false。\n\n🔸 既然`tryAcquire()` 失败了，那`Thread1` 就会转头继续执行后面的方法\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n首先执行的就是`AddWaiter()` \n\n#### addWaiter()\n\n这个方法的作用就是将 Thread 和 mode 包装成 Node 然后添加到链表尾部然后返回这个 Node\n\n```java\nprivate Node addWaiter(Node mode) {\n    //将当前线程和模式封装进 Node\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    //如果尾节点不为空\n    if (pred != null) {\n        //将 node 连接在当前 tail 后面\n        node.prev = pred;\n        //cas 设置当前 tail 为 node\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    // 其实前面看似会有并发的问题其实并没有\n    // 上面抢锁失败的线程会直接进入 enq 方法自旋重新设置，直到成功\n    enq(node);\n    return node;\n}\n```\n\n💡 根据前面分析 head 和 tail 都还没有初始化都还是 null，所以这里会直接进入 `enq()`方法\n\n####  enq()\n\n```java\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // Must initialize\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n🔸 可以看到这里是一个循环，因为 head 和 tail 都还是空的所以这里进入第一个循环，CAS 设置一个空的 Node() 为头节点 head，然后将 tail 也指向这个 head，到这里 head 和 tail 才算是初始化完成了 (lazily initialized )。\n\n🔸 循环，进入 else，这里就将当前 node 连接到 tail 后面并且利用 CAS 自旋设置 tail 为当前 node 也就是包含`Thread1` 的 node，然后 return 当前节点的前驱节点（这里返回值并没有用到）。\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n下一步就是执行`acquireQueued()`\n\n❓ **为什么不直接在构造器里面就初始化头节点 head？而要采用懒加载的方式？**\n\n> CLH queues need a dummy header node to get started. Butwe don't create them on **construction**, because it would be wasted  effort if there is **never contention**. Instead, the nodeis constructed and head and tail pointers are set up **on first contention**.\n\n以上摘自** Doug Lea** 大师的注释解释，根据我们的上面的分析，其实我们也看到了，第一个线程`Thread0` 过来的时候并没有去初始化 head，后面的线程`Thread1`过来的时候 有了竞争才初始化了这个头节点 head，如果直接初始化这个 head，然后又没有锁竞争，这个 head 节点就被浪费了。 大师就是大师，太强了 😮\n\n#### acquireQueued()\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            //获取当前节点的前置节点\n            final Node p = node.predecessor();\n            //如果前置节点是 head 就尝试去获取锁\n            if (p == head && tryAcquire(arg)) {\n                //设置头节点为当前节点\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        //发生异常取消抢锁\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n💡 因为前置节点是 head，所以这里作为队列第一个可以去尝试获取锁，可以看到这里是个死循环，会一直尝试获取锁，其实类似与 CAS 的自旋，但是相比 CAS 自旋又有很大不同，它并不会一直自旋，详细可以继续往下看。\n\n🔸 前面传递过来的 node 前继节点正好就是 head，所以执行 tryAcquire() 但是由于`Thread0` 还没有释放锁所以这里仍然失败。\n\n🔸 进入第二个 if 执行 `shouldParkAfterFailedAcquire(p,node)`\n\n#### shouldParkAfterFailedAcquire()\n\n看名字就知道是干啥的了，获取失败是否 Park？\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    //前置节点的状态\n    int ws = pred.waitStatus;\n    \n    if (ws == Node.SIGNAL)\n        //前置节点状态为-1，代表当前节点的后续节点需要被挂起\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) {\n        // 前驱节点 waitStatus 大于 0，说明前驱节点取消了排队。\n        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。\n        // 所以下面这块代码说的是将当前节点的 prev 指向 waitStatus<=0 的节点，\n        // 简单说，就是为了找个正常的前驱节点，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，就无法唤醒你了\n        // 同时这个操作也会将那些 ws>0 的节点移除掉\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        //设置前驱节点状态为 -1\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n```\n\n注意这个里面回剔除不正常的节点，为下面的唤醒操作考虑\n\n💡 分析`Thread1`，我们先看看当前队列的状态\n\n![mark](http://static.imlgw.top/blog/20190809/jOs2WA3R7lGR.png?imageslim)\n\n🔸 因为前面的操作并没有对 state 进行操作，所以这里会直接进入最后的 else，设置前驱节点的状态为 `SIGNAL`\n\n然后 renturn  false 回到 acquireQueued 的内循环\n\n🔸 再次尝试获取锁，`Thread0` 仍然没有释放锁，失败，再次进入 shouldParkAfterFailedAcquire，这一次由于已经将前继节点的状态设置为`SIGNAL` 所以直接 return true，进入后面的 `parkAndCheckInterrupt()` 方法\n\n**此时状态变为**\n\n![mark](http://static.imlgw.top/blog/20190809/pQ5NOkN5mQTY.png?imageslim)\n\n#### parkAndCheckInterrupt()\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n```\n\n到这里我们的线程`Thread1`就会被阻塞住，也不会继续自旋获取锁了。\n\n> LockSupport.park() 实际上调用的是 Unsafe 提供的指令属于`线程阻塞原语`，可以理解为二元信号量（只有一个 permit），这个方法也会响应 Interrupt  [参考](https://segmentfault.com/a/1190000008420938)\n\n🔔 **假设此时又有一个线程`Thread2`过来了，并且`Thread0` 依然没有释放锁**\n\n🔸 tryAcquire 失败\n\n🔸addWaiter()， 将`Thread2`和模式包装成 Node 添加到队尾（这个时候就不会进入 enq 了，因为 tail 此时为`Thread1`已经不为空了）然后返回包含`Thread2`的节点，队列状态变为：\n\n![mark](http://static.imlgw.top/blog/20190809/yniIvx1sgpXa.png?imageslim)\n\n🔸acquireQueued()，根据上面的状态图，这里前置节点并不是 head，直接进入 shouldParkAfterFailedAcquire()\n\n🔸shouldParkAfterFailedAcquire()，明显前驱节点状态并不是`SIGNAL` 而是 0，所以直接利用 CAS 设置前驱节点为`SIGNAL`  状态变为：\n\n![mark](http://static.imlgw.top/blog/20190809/R7GmOQ4V8ESm.png?imageslim)\n\n回到 `acquireQueued()` 继续自旋\n\n🔸 前置节点不是 head，调用 shouldParkAfterFailedAcquire(NodeT1，mode)，成功，调用 parkAndCheckInterrupt 阻塞，至此，`Thread1`，`Thread2` 都在这里 park 住了。\n\n### unLock()\n\n🔔 继续上面的模拟，此时`Thread0`释放锁 ，调用`unlock()` 方法，unlock() 会调用 AQS 中的`release(1)`方法\n\n#### release()\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        //获取头节点\n        Node h = head;\n        //头节点不为空，并且头节点的 waitStatus 不是 0\n        if (h != null && h.waitStatus != 0)\n            //unpark 后继节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n首先执行`tryRelease(1)` ，和`tryAcquire()` 一样，这个方法最后是交给子类去实现的\n\n#### tryRelease()\n\n```java\nprotected final boolean tryRelease(int releases) {\n    //同步状态减 1\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        //解锁线程不是当前线程，解铃还须系铃人\n        throw new IllegalMonitorStateException();\n    //和上面一样这里不用担心并发的问题，因为是独占锁，同时只有一个线程会到达这里\n    boolean free = false;\n    //不为 0 则代表被重入了，需要多次 release 直到 0 才会释放锁\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\ntryRelease() 成功继续执行后面的语句，看一下当前 AQS 队列的状态\n\n![mark](http://static.imlgw.top/blog/20190809/R7GmOQ4V8ESm.png?imageslim)\n\n🔸 头节点 head ! =null 并且 head.waitState 不是 0，执行 unparkSuccessor().\n\n#### unparkSuccessor()\n\n```java\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus;\n    if (ws < 0)\n        //如果当前节点的 ws 小于 0 就设置为 0，允许失败\n        //其实是独占锁的话这里肯定不会失败，因为只有一个线程\n        //release 执行完之后，这个节点就会被移除掉。然后被 GC\n        compareAndSetWaitStatus(node, ws, 0);\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    //获取后继节点\n    Node s = node.next;\n    //后继节点为空，或者已经撤销了，取消抢锁（1>0）\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        //从后往前遍历找到正数第一个 waitStatus<0 的\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n        //然后释放它\n        LockSupport.unpark(s.thread);\n}\n```\n\n🔸 `Thread1` 被`unpark()` 继续执行。\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n```\n\n返回`Thread1`的 中断标志位，并复原为 false，结束`parkAndCheckInterrupt()`方法，再次回到`acquireQueued()` 的循环中执行第一个 if\n\n```java\nfor (;;) {\n    final Node p = node.predecessor();\n    if (p == head && tryAcquire(arg)) {\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n        return interrupted; //返回中断状态\n    }\n    if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n        interrupted = true;\n}\n```\n\n🔸 由于`Thread0` 已经释放锁，同步状态已经变为 0，`Thread1` 可以直接`tryAcquire`获取到锁，然后设置头节点为当前节点，将之前的 head 节点**移除**，返回中断状态，由于之前 park 期间没有被中断直接`return false`，acquire 成功！！！ `Thread1` 获得锁！！！\n\n❓ **为什么要从后往前遍历？**\n\n> 这里看了一些博客介绍，大概有两个说法，一个是在`enq()` 方法里面，先设置的`node.prev = pred;`再执行的 CAS 最后执行的`t.next = node;` CAS 成功后 next 也许还没有设置成功，从前往后遍历有可能找不到这个刚加入的节点；其次，在`cancelAcquire(node);` 的最后一步有一个`node.next=node`的操作，如果这个时候从前往后遍历会导致死循环。\n\n❓ **从后往前遍历找到最前面第一个 waitStatus<0 的节点，这个操作如果返回的是个中间节点怎么办？**\n\n> 不要怕，我们继续执行，首先它是个中间节点而且是公平锁，它有前驱节点，unpark 后肯定获取不到锁（公平锁需要检测是否有前驱节点），然后执行`shouldParkAfterFailedAcquire()`，还记得这个方法里面的一个操作么？？如果前驱节点状态>0，他就会清除这些不正常的节点，返回 false，不 park 自旋，下一次循环这个节点在获取锁就可以获取到了，妙哉！！！\n\n注意** setHead **是这样的\n\n```java\nprivate void setHead(Node node) {\n    head = node;\n    node.thread = null; //设置线程为 null\n    node.prev = null; //设置前驱为空\n}\n```\n\n此时队列状态变为：\n\n![mark](http://static.imlgw.top/blog/20190809/wFDlbQTu417I.png?imageslim)\n\n再往后就是重复前面的过程啦。\n\n### 非公平锁公平锁区别\n\n上面是介绍的公平锁，所谓的公平就是先来后到 FIFO。\n\n我们来看一下非公平锁的 lock 和 nonfairTryAcquire() 的实现，这两个锁的区别其实就是这两个方法。\n\n#### lock()\n\n```java\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n```\n\n可以看到非公平锁`lock()`的时候，不管三七二十一先 CAS 试一下能不能获取到锁，获取到就直接返回\n\n#### nonfairTryAcquire()\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n对比公平锁的实现，会发现少了`hasQueuedPredecessors()` 这个方法，所以如果前面`lock()` 的时候没有 CAS 成功，到这里后如果之前持有锁的线程释放了锁，它又会再次尝试 CAS 获取锁，这里其实就体现了非公平锁的特点，**先等待锁的线程不一定能先获取到锁，中间允许有人`\"插队\"`**，如果这一次还是失败了，就会和公平锁一样老老实实去等待队列中排队\n\n一般而言，非公平锁的性能会比公平锁好，而非公平锁可能会导致排在后面的线程饥饿\n\n### 流程图\n\n![mark](http://static.imlgw.top/blog/20190810/6FEWGydOmVzm.png?imageslim)\n\n## 参考\n\n**《Java 并发编程之美》**\n\n[一行一行源码分析清楚 AbstractQueuedSynchronizer](https://javadoop.com/2017/06/16/AbstractQueuedSynchronizer/)\n\n[AbstractQueuedSynchronizer 源码剖析（六）- 深刻解析与模拟线程竞争资源](https://blog.csdn.net/pfnie/article/details/53191892)\n\n[[浅谈 Java 并发编程系列（八）—— LockSupport 原理剖析]](https://segmentfault.com/a/1190000008420938)\n\n[Java 同步器——AQS 学习](https://brightloong.github.io/2018/06/21/Java%E5%90%8C%E6%AD%A5%E5%99%A8%E2%80%94%E2%80%94AQS%E5%AD%A6%E4%B9%A0/)\n","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"LeetCode 查找","url":"/2019/09/15/ae50c318/","content":"\n## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例：**\n\n```java\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n> 平生不识** TwoSum**，做遍 LeetCode 也枉然\n\n**解法一**\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    int length = nums.length;\n    for (int i = 0; i < length - 1; i++) {\n        for (int j = 1; j < length - i; j++) {\n            int result = nums[i] + nums[i + j];\n            if (result == target) {\n                return new int[] { i, i + j };\n            }\n        }\n    }\n    return null;\n}\n```\n\n最开始的做法，直接暴力求解，简单，但是效率很低，50ms，41% beats，其实在笔试或者其它对效率要求没那么严格的地方用暴力法也没毛病节约很多时间，能直接写出最优解肯定好，但是实在没办法了暴力法也不失为一种好方法，最优解可以下来后再研究。\n\n**解法二**\n\nhash 查找\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    //第一遍把所有的元素和索引存到 hashMap 中\n    for (int i=0;i<nums.length;i++) {\n        map.put(nums[i],i);\n    }\n    //再查找 hash\n    for (int i=0;i<nums.length;i++) {\n        //不能重复所以 下标需要限制下\n        if(map.containsKey(target-nums[i]) && map.get(target-nums[i])!=i){\n            return new int[]{i,map.get(target-nums[i])};\n        }\n    }\n    return new int[]{};\n}\n```\n\n其实可以只 hash 一遍，hash 两遍主要考虑顺序的问题。直接利用 hashMap 查找，效率很高。\n\n```java\npublic int[] twoSum2(int[] nums, int target) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        //不能重复所以 下标需要限制下\n        if(map.containsKey(target-nums[i]) && map.get(target-nums[i])!=i){\n            return new int[]{i,map.get(target-nums[i])};\n        }\n        map.put(nums[i],i);\n    }\n\n    return new int[]{};\n}\n```\n\n提交记录上最快的做法\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    int index;\n    int indexArrayMax=2047;\n    int[] indexArrays=new int[indexArrayMax+1];\n    int diff;\n    for(int i=1;i<nums.length;i++){\n        diff=target-nums[i];\n        //i=0 时索引无效，所以单独处理\n        if(diff==nums[0]){\n            return new int[]{0,i};\n        }\n        index=diff&indexArrayMax;\n        if(indexArrays[index]!=0){\n            return new int[]{indexArrays[index],i};\n        }\n        indexArrays[nums[i]&indexArrayMax]=i;   \n    }   \n    return new int[2];\n}\n```\n\n没看懂。群里问了下，手动 hash。以后再来研究吧。\n\n## [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n**示例 1:**\n\n```java\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2]\n```\n\n**示例 2:**\n\n```java\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[9,4]\n```\n\n**说明：**\n\n- 输出结果中的每个元素一定是唯一的。\n- 我们可以不考虑输出结果的顺序。\n\n**解法一**\n\n```java\npublic int[] intersection(int[] nums1, int[] nums2) {\n    Set<Integer> s1=new HashSet<>();\n    ArrayList<Integer> res=new ArrayList<>();\n    int index=0;\n    for (int a:nums1 ) {\n        s1.add(a);\n    }\n\n    for (int i=0;i<nums2.length;i++) {\n        if(s1.contains(nums2[i])){\n            res.add(nums2[i]);\n            s1.remove(nums2[i]);//别忘了 remove 掉\n        }\n    }\n\n    int [] res2=new int[res.size()];\n    for (int i=0;i<res.size();i++) {\n        res2[i]=res.get(i);\n    }\n    return res2;\n}\n```\n没啥好说的，这种题确实不难，仔细想想就可以\n\n## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n**示例 1:**\n\n```java\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2,2]\n```\n\n**示例 2:**\n\n```java\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[4,9]\n```\n\n**说明：**\n\n- 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n- 我们可以不考虑输出结果的顺序。\n\n**进阶：**\n\n- 如果给定的数组已经排好序呢？你将如何优化你的算法？\n- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？\n- 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n**解法一**\n\n这题和上面的区别就是需要输出所有的交集，重复的也算，所以可以用 map 的结构记录字符出现的次数\n\n```java\npublic int[] intersect(int[] nums1, int[] nums2) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for (int i=0;i<nums1.length;i++) {\n        map.put(nums1[i],map.getOrDefault(nums1[i],0)+1);\n    }\n    ArrayList<Integer> res=new ArrayList<>();\n    for (int i=0;i<nums2.length;i++) {\n        if (map.containsKey(nums2[i])) {\n            if (map.get(nums2[i])!=0) {\n                //有交集\n                res.add(nums2[i]); //添加到结果中\n                map.put(nums2[i],map.get(nums2[i])-1); //map 映射减一\n            }\n        }\n    }\n    int []res2=new int[res.size()];\n    for (int i=0;i<res2.length;i++) {\n        res2[i]=res.get(i);\n    }\n    return res2;\n}\n```\n\n思路也很直白，和上一题的做法类似\n\n**进阶**\n\n**Q1:** 排好序的话就可以直接利用双指针，两个指针分别指向两个数组的头，相等就加入 list，不相等就移动小的哪一个，直到有一个指针走到末尾\n\n**Q2:** 这个就很明显了，肯定先把小的哪一个用 map 映射起来，这样 map 查找的效率会更高 ？\n\n**Q3:** 这个参考英文版的 [讨论区](https://leetcode.com/problems/intersection-of-two-arrays-ii/discuss/82243/Solution-to-3rd-follow-up-question) \n\n## [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)\n\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n**示例 1:**\n\n```java\n输入：s = \"anagram\", t = \"nagaram\"\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：s = \"rat\", t = \"car\"\n输出：false\n```\n\n**说明：**\n\n- 你可以假设字符串只包含小写字母。\n\n**进阶：**\n\n- 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n\n**解法一**\n\n```java\npublic boolean isAnagram(String s, String t) {\n    if (s.length()!=t.length())return false;\n    int[] freq=new int[256];\n    for (int i=0;i<s.length();i++) {\n        freq[s.charAt(i)]++;\n    }\n    int count=0,match=0;\n    for (int a:freq) {\n        if(a!=0){\n            count++;\n        }\n    }\n    for (int i=0;i<t.length();i++) {\n        if(freq[t.charAt(i)]>0){\n            freq[t.charAt(i)]--;\n            if(freq[t.charAt(i)]==0){\n                match++;\n            }\n        }\n    }\n    return match==count;\n}\n```\n\n这里其实空间还可以优化，题目说了字符串只包含小写字符所以只需要 26 个 int 就行了，可以在 freq 操作的时候 `-'A'` 优化空间\n\n**进阶**\n\n字符包含`unicode` 的话如果再使用 int 数组就不合适了，这个范围会变得很大，更加通用的方式是采用`HashMap`\n\n## [1160. 拼写单词](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/)\n\n给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n\n**注意：**每次拼写时，chars 中的每个字母都只能用一次。\n\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n\n**示例 1：**\n\n```java\n输入：words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\n输出：6\n解释： \n可以形成字符串 \"cat\" 和 \"hat\"，所以答案是 3 + 3 = 6。\n```\n\n**示例 2：**\n\n```java\n输入：words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\n输出：10\n解释：\n可以形成字符串 \"hello\" 和 \"world\"，所以答案是 5 + 5 = 10。\n```\n\n**提示：**\n\n- `1 <= words.length <= 1000`\n- `1 <= words[i].length, chars.length <= 100`\n- 所有字符串中都仅包含小写英文字母\n\n**解法一**\n\n大晚上题目都没看清就开始写！！题目说的是每次只能使用一次！！！\n\n```java\npublic int countCharacters(String[] words, String chars) {\n    int[] hash=new int[26];\n    for (int i=0;i<chars.length();i++) {\n        hash[chars.charAt(i)-'a']++;\n    }\n    int res=0;\n    int[] temp=new int[26];\n    for (int i=0;i<words.length;i++) {\n        String word=words[i];\n        Arrays.fill(temp,0);\n        boolean flag=true;\n        for (int j=0;j<word.length();j++) {\n            temp[word.charAt(j)-'a']++;\n            if(temp[word.charAt(j)-'a']>hash[word.charAt(j)-'a']){\n                flag=false;\n                break;\n            }\n        }\n        res+=flag?word.length():0;\n    }\n    return res;\n}\n```\n一开始用的 arraycopy 然后减减，差不多\n\n## [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)\n\n编写一个算法来判断一个数是不是“快乐数”。\n\n一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。\n\n**示例：** \n\n```java\n输入：19\n输出：true\n解释：\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n```\n\n**解法一**\n\n```java\npublic static boolean isHappy(int n) {\n    char[] nums=null;\n    int sum=n;\n    while(true) {\n        nums=String.valueOf(sum).toCharArray();\n        sum=0;\n        for (int i=0;i<nums.length;i++) {\n            sum+=(nums[i]-48)*(nums[i]-48);\n        }\n        if (sum==4) {\n            return false;\n        }else if (sum==1) {\n            return true;\n        }\n    }\n}\n```\n\n找到了规律，所有不快乐的数 (😅，都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环，可以直接在 sum 和这些值相等的时候就 return 我懒得写那么多，比较取巧但是效率还是挺高的\n\n**解法二**\n\n```java\npublic static boolean isHappy(int n) {\n    char[] nums=null;\n    int sum=n;\n    HashSet<Integer> set=new HashSet<>();\n    while(true) {\n        nums=String.valueOf(sum).toCharArray();\n        sum=0;\n        for (int i=0;i<nums.length;i++) {\n            sum+=(nums[i]-48)*(nums[i]-48);\n        }\n        if (sum==1) {\n            return true;\n        }else if (set.contain(sum)){\n            return false;\n        }else{\n            set.add(sum);    \n        }\n    }\n}\n```\n这种做法就比较常规，也是符合这篇主题**查找**的解法，代码比较简单就不啰嗦了\n\n## [290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)\n\n给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。\n\n这里的 **遵循** 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。\n\n**示例 1:**\n\n```java\n输入：pattern = \"abba\", str = \"dog cat cat dog\"\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：pattern = \"abba\", str = \"dog cat cat fish\"\n输出：false\n```\n\n**示例 3:**\n\n```java\n输入：pattern = \"aaaa\", str = \"dog cat cat dog\"\n输出：false\n```\n\n**示例 4:**\n\n```java\n输入：pattern = \"abba\", str = \"dog dog dog dog\"\n输出：false\n```\n\n**说明：**\n你可以假设 `pattern` 只包含小写字母， `str` 包含了由单个空格分隔的小写字母\n\n**解法一**\n\n```java\npublic static boolean wordPattern(String pattern, String str) {\n    HashMap<Character,String> map=new LinkedHashMap<>();\n    String[] strs=str.split(\" \");\n    char[] p=pattern.toCharArray();\n    if (strs.length!=p.length) {\n        return false;\n    }\n    for (int i=0;i<p.length;i++) {\n        if (map.containsKey(p[i])) {\n            if (!map.get(p[i]).equals(strs[i])) {\n                return false;\n            }\n        }else{\n            //这里直接和前一个比较的，正确做法是用 map.containsValue 判断是否已经添加\n            /*if (strs[i].equals(strs[i-1])) {\n                return false;\n            }*/\n            if (map.containsValue(strs[i])) {\n                return false;           \n            }\n            map.put(p[i],strs[i]);\n        }\n    }\n    return true;\n}\n```\n很简单的题，需要对两个字符串的模式进行匹配，借助 Hash 表直接将两个 String 进行一对一的映射，既然要匹配那么`同一个 key 字符对应的 value 字符肯定是一样的`，还有一点需要注意的是在遇到一个新的 key 字符的时候，需要判断对应位置的 value 字符出现过没有，出现过就直接 return false，这一点第一遍的时候没考虑到，`不同的 key 字符对应的 value 字符肯定是不一样的`\n\n> 因为第一次没考虑到第二种情况，提交后竟然跑过了`31/33` 个 case，然后就感觉这题 case 可能有点问题，然后自己写了个错的算法居然也跑过了，具体的代码在上面的注释中，感兴趣的可以去试试，我已经提交 case 了但是还没回应我\n\n## [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)\n\n给定两个字符串 s 和 t，判断它们是否是同构的。\n\n如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n**示例 1:**\n\n```java\n输入：s = \"egg\", t = \"add\"\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：s = \"foo\", t = \"bar\"\n输出：false\n```\n\n**示例 3:**\n\n```java\n输入：s = \"paper\", t = \"title\"\n输出：true\n```\n\n**说明：**\n\n- 你可以假设 s 和 t 具有相同的长度。\n\n**解法一**\n\n这题和上面一模一样，Hash 表的解法就不写了，这题都是单个的字符，可以不用 Hash 表，可以用数组优化\n\n```java\npublic boolean isIsomorphic2(String s, String t) {\n    if (s.length()!=t.length()) {\n        return false;\n    }\n    int[] key=new int[256];\n    int[] value=new int[256];\n\n    for (int i=0;i<s.length();i++) {\n        int cs=s.charAt(i);\n        int ct=t.charAt(i);\n        if(key[cs]!=0){ //cs 出现过\n            if (key[cs]!=ct) {\n                return false;\n            }\n        }else{//cs 没出现过\n            if (value[ct]!=0) {\n                return false;\n            }\n            key[cs]=ct;\n            value[ct]=cs;\n        }\n    }\n    return true;\n}\n```\n\n💬 同样的，这题和上面的 290 一样，case 也有问题，直接和前一个字符比较就可以过\n\n## [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)\n\n给定四个包含整数的数组列表 A , B , C , D , 计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 `0 ≤ N ≤ 500` 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n\n**例如：**\n\n```java\n输入：\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\n输出：\n2\n\n解释：\n两个元组如下：\n\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n```\n\n**解法一**\n\n这题其实看数据规模就知道应该写一个什么样复杂度的算法了`0~500`，暴力的话会很恐怖`O(N^4)`，这里可以考虑将其中一个放到 hash 表中，然后遍历其他的 3 个，时间复杂度优化到了`O(N^3)`，但是时间复杂度还是很恐怖，所以可以考虑将两个数组的和放到 hash 表中，这样就可以将时间复杂度优化到`O(N^2)`\n\n```java\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for (int i=0;i<C.length;i++) {\n        for (int j=0;j<D.length;j++) {\n            int key=C[i]+D[j];\n            map.put(key,map.getOrDefault(key,0)+1);\n        }\n    }\n    int res=0;\n    for (int i=0;i<A.length;i++) {\n        for (int j=0;j<B.length;j++) {\n            int key=A[i]+B[j];\n            if(map.containsKey(-key)){\n                res+=map.get(-key);\n            }\n        }\n    }\n    return res;\n}\n```\n\n## [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)\n\n给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n\n**示例 1:**\n\n```java\n输入：\n\"tree\"\n\n输出：\n\"eert\"\n\n解释：\n'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n```\n\n**示例 2:**\n\n```java\n输入：\n\"cccaaa\"\n\n输出：\n\"cccaaa\"\n\n解释：\n'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n```\n\n**示例 3:**\n\n```java\n输入：\n\"Aabb\"\n\n输出：\n\"bbAa\"\n\n解释：\n此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。\n```\n\n**解法一**\n\n```java\npublic static String frequencySort(String s) {\n    if (s==null || s.length()<1) {\n        return s;\n    }\n    HashMap<Character,Integer> map=new HashMap<>();\n    for (int i=0;i<s.length();i++) {\n        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\n    }\n    ArrayList<HashMap.Entry> list=new ArrayList<>();\n    for(HashMap.Entry entry:map.entrySet()){\n        list.add(entry);\n    }\n    list.sort((e1,e2)->(Integer)e2.getValue()-(Integer)e1.getValue());\n    StringBuilder res=new StringBuilder();\n    for (int i = 0; i < list.size(); i++) {\n        Integer value = (Integer)list.get(i).getValue();\n        while (value>0){\n            res.append(list.get(i).getKey());\n            value--;\n        }\n    }\n    return res.toString();\n}\n```\n这题其实也是 TopK 问题，直接的想法就是用 hashMap 统计各个字符出现的个数，然后排序再拼接为结果，其实这题一开始是 TLE 了的，一开始没注意直接用的 String 拼接的，效率很低，改用 StringBuilder 后就过了，虽然效率还是很低 138ms，垫底\n\n**解法二**\n\n```java\npublic  static String frequencySort2(String s) {\n    if (s==null || s.length()<1) {\n        return s;\n    }\n    int[] freq=new int[256];\n    for (int i=0;i<s.length();i++) {\n        freq[s.charAt(i)]++;\n    }\n    int[] freq_bak=freq.clone();\n    Arrays.sort(freq);\n    StringBuilder res=new StringBuilder();\n    //从大到小\n    for (int i = 255; i>=0 && freq[i]!=0; i--) {\n        for (int j=0;j<255;j++) {\n            //找到原数组中对应的字符\n            //只要出现次数一样的就行了\n            if(freq_bak[j]==freq[i]){\n                //根据 freq_bak[j] 构造结果\n                while(freq_bak[j]>0){\n                    res.append((char)j);\n                    freq_bak[j]--;\n                }\n                break;\n            }\n        }\n    }\n    return res.toString();\n}\n```\n15ms，90% 其实思路和上面是一样的，都是统计数量后进行排序，然后重建字符串，但是用数组的方式明显会比 HashMap 效率会更高的多，后面的两层循环都是在常数时间内，主要是重建字符串和排序消耗时间，时间复杂度应该是`O(NlogN)`\n\n**解法三**\n\n```java\npublic  static String frequencySort3(String s) {\n    if (s==null || s.length()<1) {\n        return s;\n    }\n    ArrayList<Character> [] bucket=new ArrayList[s.length()+1];\n\n    int[] freq=new int[256];\n\n    for (int i=0;i<s.length();i++) {\n        freq[s.charAt(i)]++;\n    }\n\n    for (int i=0;i<s.length();i++) {\n        if (bucket[freq[s.charAt(i)]]==null) {\n            bucket[freq[s.charAt(i)]]=new ArrayList<>();\n        }\n        //每个元素只进入一次\n        if (!bucket[freq[s.charAt(i)]].contains(s.charAt(i))) {\n            bucket[freq[s.charAt(i)]].add(s.charAt(i));\n        }\n    } \n    //printArray(bucket);\n    StringBuilder res=new StringBuilder();\n    for (int i=bucket.length-1;i>=0;i--) {\n        //过滤 0\n        if (bucket[i]==null) {\n            continue;\n        }\n        //出现 i 次的字符 list\n        ArrayList<Character> temp=bucket[i];\n        //遍历出现次数相同的 list()\n        for (int j=0;j<temp.size();j++) { \n            //遍历出现的次数\n            for (int count=0;count<i;count++) {\n                res.append(temp.get(j));\n            }\n        }\n    }\n    return res.toString();\n}\n```\n50ms，50% 这个是根据 [前 k 个高频元素](http://imlgw.top/2019/05/04/leetcode-shu-zu-tag/#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0) 中桶排序的解法来的，当然这里并不是最优解，只是一种思路，其实写起来还是挺麻烦的，时间复杂度略高，主要是在桶排序的时候添加元素做不到 O(N) 需要判断元素是否添加，一个元素只能在 list 中添加一次，否则后面重建字符串的时候就会有问题\n\n## [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n**示例：**\n\n```java\n输入：[\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n输出：\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\n\n**说明：**\n\n- 所有输入均为小写字母\n- 不考虑答案输出的顺序\n\n**解法一**\n\n算是暴力法了，借助上面的同构题思路来遍历判断\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    ArrayList<List<String>> res=new ArrayList<>();\n    for (int i=0;i<strs.length;i++) {\n        if (\"7\"==strs[i]) {\n            continue;\n        }\n        ArrayList<String> group=new ArrayList<String>();\n        group.add(strs[i]);\n        for (int j=i+1;j<strs.length;j++) {\n            if (\"7\"==strs[j]) {\n                continue;\n            }\n            if(isAnagram(strs[i],strs[j])){\n                group.add(strs[j]);\n                //有分组了\n                strs[j]=\"7\";\n            }\n        }\n        res.add(group);\n    }\n    return res;\n}\n\npublic boolean isAnagram(String str1,String str2){\n    if(str1.length()!=str2.length()){\n        return false;\n    }\n    int[] freq=new int[26];\n    for (int i=0;i<str1.length();i++) {\n        freq[str1.charAt(i)-'a']++;\n    }\n    for (int i=0;i<str2.length();i++) {\n        freq[str2.charAt(i)-'a']--;\n    }\n    for (int i=0;i<freq.length;i++) {\n        if (freq[i]!=0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n可以看到里面有一个`7` 其实没什么含义就是为了表示这个字符已经有分组了，这里一开始我是用的 equals 来比较的这个 7 结果超时了，然后换成了==勉强跑过了，可能是个例，因为我后来用 boolean 数组也没跑过。\n\n> 这里用==可以比较的原因可能是 strs 和字面量 \"7\"都在字符常量池中，但是这里并不建议这样比较，这里可以说是个反例了，比较字符串请用`equals` ！！！\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    ArrayList<List<String>> res=new ArrayList<>();\n    boolean[] flag=new boolean[strs.length()];\n    for (int i=0;i<strs.length;i++) {\n        if (flag[i]) continue;\n        ArrayList<String> group=new ArrayList<String>();\n        group.add(strs[i]);\n        for (int j=i+1;j<strs.length;j++) {\n            if(flag[j])continue;\n            if(isAnagram(strs[i],strs[j])){\n                group.add(strs[j]);\n                flag[j]=true;\n            }\n        }\n        res.add(group);\n    }\n    return res;\n}\n```\n**解法二**\n\n利用排序结果来作为 key，将排序结果相同的 str 映射到一起\n\n```java\n//排序解法\npublic List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<String,List<String>> map=new HashMap<>();\n    for (int i=0;i<strs.length;i++) {\n        char[] strs_i=strs[i].toCharArray();\n        //排序，将结果作为 key\n        Arrays.sort(strs_i);\n        String key=String.valueOf(strs_i);\n\n        if(map.containsKey(key)){\n            //存在同构的 key，直接添加进去\n            map.get(key).add(strs[i]);\n        }else{\n            //不存在就创建一个，然后将自己添加进去\n            map.put(key,new ArrayList<>());\n            map.get(key).add(strs[i]);\n        }\n    }\n    return new ArrayList(map.values());\n}\n```\n时间复杂度`O(NKlogK)`，K 为字符数组中最长的字符串，`O(KlogK)` 是给这个字符串排序的结果\n\n**解法三**\n\n根据出现频次构成的字符串作为 key，比如`aba`以及所有的异位词都会被映射为`2#1#` \n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<String,List<String>> map=new HashMap<>();\n    int[] freq=new int[26];\n    for (int i=0;i<strs.length;i++) {\n        //Arrays.fill(freq,0);\n        //统计字符出现的频次\n        for (int j=0;j<strs[i].length();j++) {\n            freq[strs[i].charAt(j)-'a']++;\n        }\n        //构建唯一映射的 key\n        StringBuilder key=new StringBuilder();\n        //这个其实类似桶排序，依次取 abcde...\n        for (int j=0;j<26;j++) {\n            key.append(freq[j]);\n            //这个#很关键，为了防止重复，因为有的字符可能出现两位数的次数，仅仅对比数字是无法确定的\n            key.append(\"#\");\n            //重置为 0 方便后面重复使用\n            freq[j]=0;\n        }\n        String skey=key.toString();\n        if(map.containsKey(skey)){\n            map.get(skey).add(strs[i]);\n        }else{\n            map.put(skey,new ArrayList());\n            map.get(skey).add(strs[i]);\n        }\n    }\n    return new ArrayList(map.values());\n}\n```\n45ms，21% 时间复杂度`O(NK)` K 为字符数组中最长的字符串的长度，很玄学，讲道理应该不会这么慢，看了 leetcode 上前几名跟我的差不多，开始做的时候直接用 `StringBuilder` 对象作为了 key 结果肯定不对，StringBuilder 没有覆盖 equals 方法，key 永远不会相等，每次都是新的 key\n\n**解法四**\n\n**算术基本定理**，又称为正整数的唯一分解定理，即：每个大于 1 的自然数，要么本身就是质数，要么可以写为 2 个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<Integer, List<String>> hash = new HashMap<>();\n    //每个字母对应一个质数\n    int[] prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103 };\n    for (int i = 0; i < strs.length; i++) {\n        int key = 1;\n        //累乘得到 key\n        for (int j = 0; j < strs[i].length(); j++) {\n            key *= prime[strs[i].charAt(j) - 'a'];\n        } \n        if (hash.containsKey(key)) {\n            hash.get(key).add(strs[i]);\n        } else {\n            List<String> temp = new ArrayList<String>();\n            temp.add(strs[i]);\n            hash.put(key, temp);\n        }\n    }\n    return new ArrayList<List<String>>(hash.values());\n}\n```\n\n时间复杂度`O(NK)`，强的 8 行\n\n> 分析完上面三种解法后其实很同意得出这题的关键：`给同组的异位词找到一个相同的映射 key`，尽量的缩短求这个映射的时间就可优化整个算法\n\n## [447. 回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)\n\n给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 `(i, j, k)` ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（**需要考虑元组的顺序**）\n\n找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 `[-10000, 10000]` 中。\n\n**示例：**\n\n```java\n输入：\n[[0,0],[1,0],[2,0]]\n\n输出：\n2\n\n解释：\n两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n```\n\n**解法一**\n\n```java\npublic static int numberOfBoomerangs(int[][] points) {\n    int res=0;\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for (int i=0;i<points.length;i++) {\n        for (int j=0;j<points.length;j++) {\n            if (i!=j){\n                int dis=dis(points[i],points[j]);\n                map.put(dis,map.getOrDefault(dis,0)+1);\n            }\n        }\n        //C2m 组合问题\n        for (Integer count:map.values()) {\n            if (count>1) {\n                res+=count*(count-1);\n            }\n        }\n        map.clear();\n    }\n    return res;\n}\n\npublic static int dis(int[] a,int[] b){\n    return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\n}\n```\n看一下给的数据量`500`就知道复杂度只能是`O(N^2)` 的，用 Hash 表统计到当前点的距离相同的点有多少个，然后利用组合数求多少种组合，一开始并没有想到这种方法，我想的是利用坐标系的对称来做，太菜了\n\n这里还有个小细节，一开始将 HashMap 的创建放在内循环中，发现效率很低，300ms 左右，然后将创建 HashMap 移出去后用 clear 清空，瞬间快了 100ms 左右，创建 HashMap 的成本果然还是挺大的\n\n这题其实还可以减少内循环的数量，\n\n## [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)\n\n给定一个整数数组，判断是否存在重复元素。\n\n如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n\n**示例 1:**\n\n```java\n输入：[1,2,3,1]\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：[1,2,3,4]\n输出：false\n```\n\n**示例 3:**\n\n```java\n输入：[1,1,1,3,3,4,3,2,4,2]\n输出：true\n```\n\n**解法一**\n\n借助 Hash 表，很简单的题\n\n```java\npublic static boolean containsDuplicate(int[] nums) {\n    if (nums==null) return false;\n    HashSet<Integer> set=new HashSet<>();\n    for (int i=0;i<nums.length;i++) {\n        if (set.contains(nums[i])) {\n            return true;\n        }\n        set.add(nums[i]);\n    }\n    return false;\n}\n```\n其实还可以优化下\n\n```java\npublic static boolean containsDuplicate(int[] nums) {\n    if (nums==null) return false;\n    HashSet<Integer> set=new HashSet<>();\n    for (int i=0;i<nums.length;i++) {\n        if (!set.add(nums[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n`set.add()` 本身就带有返回值，可以减少很多判断，这题还有一个进阶版 [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/) 也不难，我放到 [滑动窗口专题](http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou-tag/#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2) 中去了\n\n## [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)\n\n给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 `nums [i]` 和 `nums [j]` 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 k\n\n**示例 1:**\n\n```java\n输入：nums = [1,2,3,1], k = 3, t = 0\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：nums = [1,0,1,1], k = 1, t = 2\n输出：true\n```\n\n**示例 3:**\n\n```java\n输入：nums = [1,5,9,1,5,9], k = 2, t = 3\n输出：false\n```\n\n**解法一**\n\n这里其实可以算难题了，通过率只有 20%，利用 Java 中提供的 TreeMap，有顺序而且插入和删除等操作效率都很高（logN），然后查找指定范围的元素，看符不符合题目要求\n\n```java\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    TreeSet<Integer> set=new TreeSet<>();\n    for (int i=0;i<nums.length;i++) {\n        //大于 nums[i] 的最小元素\n        Integer ceiling=set.ceiling(nums[i]);\n        //小于 nums[i] 的最大元素\n        Integer floor=set.floor(nums[i]);\n        //防止溢出\n        long temp1=Long.valueOf(nums[i])+Long.valueOf(t);\n        long temp2=Long.valueOf(nums[i])-Long.valueOf(t);\n        if((ceiling!=null && ceiling<=temp1) || (floor!=null && floor>=temp2)) {\n            return true;\n        }\n        set.add(nums[i]);\n        if (set.size()>k) {\n            //移除左边界\n            set.remove(nums[i-k]);\n        }\n    }\n    return false;\n}\n```\n72ms，5%左右，整体时间复杂度`O(NlogN)` \n\n**解法二**\n\n看了下评论区，发现其实可以直接和两个边界`[u-t,u+t]`比较，只要两个数都在这个范围内就一定符合条件，这样可以少一次查找的操作，效率有很大提升\n\n```java\npublic boolean containsNearbyAlmostDuplicate2(int[] nums, int k, int t) {\n    TreeSet<Long> set=new TreeSet<>();\n    for (int i=0;i<nums.length;i++) {\n        //大于 nums[i]-t 的最小元素\n        Long ceil=set.ceiling((long)nums[i]-(long)t);\n        if(ceil!=null && ceil<=(long)nums[i]+(long)t) {\n            return true;\n        }\n        set.add((long)nums[i]);\n        if (set.size()>k) {\n            set.remove((long)nums[i-k]);\n        }\n    }\n    return false;\n}\n```\n43ms，56%左右，依然要注意溢出的问题\n\n## [1282. 用户分组](https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to/)\n\n有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。\n\n你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。\n\n**示例 1：**\n\n```java\n输入：groupSizes = [3,3,3,3,3,1,3]\n输出：[[5],[0,1,2],[3,4,6]]\n解释： \n其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。\n```\n\n**示例 2：**\n\n```java\n输入：groupSizes = [2,1,3,3,3,2]\n输出：[[1],[0,5],[2,3,4]]\n```\n\n**提示：**\n\n- `groupSizes.length == n`\n- `1 <= n <= 500`\n- `1 <= groupSizes[i] <= n`\n\n**解法一**\n\n12.8 周赛的题，我是模拟做的，看了别人的做法还是感觉这种比较优雅\n\n```java\npublic List<List<Integer>> groupThePeople(int[] groupSizes) {\n    HashMap<Integer,List<Integer>> map=new HashMap<>();\n    List<List<Integer>> res=new LinkedList<>();\n    for (int i=0;i<groupSizes.length;i++) {\n        if (!map.containsKey(groupSizes[i])) {\n            List<Integer> list=new LinkedList();\n            map.put(groupSizes[i],list);\n        }\n        List<Integer> gl=map.get(groupSizes[i]);\n        gl.add(i);\n        if (gl.size()==groupSizes[i]) {\n            res.add(gl);\n            map.remove(groupSizes[i]);\n        }\n    }\n    return res;\n}\n```\n时间复杂度`O(N)`\n\n**解法二**\n\n模拟的解法，时间复杂度`O(N^2)`\n\n```java\npublic List<List<Integer>> groupThePeople(int[] groupSizes) {\n    boolean[] visit=new boolean[groupSizes.length];\n    List<List<Integer>> res=new LinkedList<>();\n    for (int i=0;i<groupSizes.length;i++) {\n        if (visit[i]) {\n            continue;\n        }\n        List<Integer> list= new LinkedList<>();\n        list.add(i);\n        for (int j=i+1;j<groupSizes.length;j++) {\n            if (visit[j]) {\n                continue;\n            }\n            if (list.size()==groupSizes[i]) {\n                break;\n            }\n            if (groupSizes[j]==groupSizes[i]) {\n                list.add(j);\n                visit[j]=true;\n            }\n        }\n        res.add(list);\n    }\n    return res;\n}\n```\n\n## [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n给定一个未排序的整数数组，找出最长连续序列的长度。\n\n要求算法的时间复杂度为 `O(n)`。\n\n**示例：**\n\n```java\n输入：[100, 4, 200, 1, 3, 2]\n输出：4\n解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。\n```\n\n**解法一**\n\n借助 Hash 表的暴力解法\n\n```java\npublic int longestConsecutive(int[] nums) {\n    if (nums ==null || nums.length<=0) {\n        return 0;\n    }\n    HashSet<Integer> set=new HashSet();\n    for (int n:nums) {\n        set.add(n);\n    }\n    int max=0;\n    for (int i=0;i<nums.length;i++) {\n        int num=nums[i];\n        int res=1;\n        while(set.contains(num+1)){\n            res++;\n            num++;\n        }\n        max=Math.max(max,res);\n    }\n    return max;\n}\n```\n\n对于每个元素在 Hash 表中查找它的下一个连续的元素`num+1` 有没有，有的话就继续往下找，最后求的以每个元素开头的最长子序列长度，时间复杂度`O(N^2)`不符合题目的要求\n\n所以我们需要优化我们的算法，其实上面的过程我们很容易就看出啦里面会有重复的计算\n\n`eg. 5，4，6，7，8`  我们在第一个 5 的时候计算了以 5 开头的 5，6，7，8 这条路径，然后转而计算第二个 4，计算了以 4 开头的 4，5，6，7，8 这里其实就发生了重复的计算，那么我们这里求的是最长的序列，所以我们需要舍弃第一个，也就是说我们遍历第一个 5 的时候直接跳过，跳过的依据就是判断 5-1 在不在集合中，如果在那么以它开头的序列一定不是不会是最长的，反之则有可能是最长的，我们统计所有这样的序列长度，最后求一个最大值就可以了\n\n**解法二**\n\n每个元素最多遍历 2 次，所以时间复杂度为 O(N) 符合要求\n\n```java\npublic int longestConsecutive(int[] nums) {\n    if (nums ==null || nums.length<=0) {\n        return 0;\n    }\n    HashSet<Integer> set=new HashSet();\n    for (int n:nums) {\n        set.add(n);\n    }\n    int max=0;\n    for (int i=0;i<nums.length;i++) {\n        int num=nums[i];\n        if (!set.contains(num-1)) {\n            int res=1;\n            while(set.contains(num+1)){\n                res++;\n                num++;\n            }\n            max=Math.max(max,res);\n        }\n    }\n    return max;\n}\n```\n\n**解法三**\n\n并查集的解法，略微麻烦点，但是毕竟这题的 tag 就是并查集，还是实现一下\n\n```java\n//并查集\nHashMap<Integer,Integer> parent;\n\nHashMap<Integer,Integer> size;\n\nint max=1;\n\npublic int find(int index){\n    while(parent.get(index)!=index){\n        //parent[index]=parent[parent[index]];\n        parent.put(index,parent.get(index));\n        index=parent.get(index);\n    }\n    return index;\n}\n\npublic void union(int p,int q){\n    int pID=find(p);\n    int qID=find(q);\n    if (pID==qID) {\n        return;\n    }\n    int pSize=size.get(pID);\n    int qSize=size.get(qID);\n    if (pSize > qSize) {\n        //parent[qID]=pID;\n        parent.put(qID,pID);\n        //size[pID]+=size[qID];\n        size.put(pID,pSize+qSize);\n    }else{\n        //parent[pID]=qID;\n        parent.put(pID,qID);\n        //size[qID]+=size[pID];\n        size.put(qID,pSize+qSize);\n    }\n    max=Math.max(max,pSize+qSize); //统计最大值\n}\n\npublic void initUnionFind(int[]nums){\n    parent=new HashMap<>();\n    size=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        parent.put(nums[i],nums[i]);\n        size.put(nums[i],1);\n    }\n}\n\npublic int longestConsecutive(int[] nums) {\n    if (nums ==null || nums.length<=0) {\n        return 0;\n    }\n    HashSet<Integer> set=new HashSet();\n    for (int i=0;i<nums.length;i++) {\n        set.add(nums[i]);\n    }\n    initUnionFind(nums);\n    for (int i=0;i<nums.length;i++) {\n        if (set.contains(nums[i]-1)) { //判断-1 或者+1 都可以\n            union(nums[i],nums[i]-1);\n        }\n    }\n    return max;\n}\n```\n\n## [1002. 查找常用字符](https://leetcode-cn.com/problems/find-common-characters/)\n\nDifficulty: **简单**\n\n给定仅有小写字母组成的字符串数组 `A`，返回列表中的每个字符串中都显示的全部字符（**包括重复字符**）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。\n\n你可以按任意顺序返回答案。\n\n**示例 1：**\n\n```\n输入：[\"bella\",\"label\",\"roller\"]\n输出：[\"e\",\"l\",\"l\"]\n```\n\n**示例 2：**\n\n```\n输入：[\"cool\",\"lock\",\"cook\"]\n输出：[\"c\",\"o\"]\n```\n\n**提示：**\n\n1.  `1 <= A.length <= 100`\n2.  `1 <= A[i].length <= 100`\n3.  `A[i][j]` 是小写字母\n\n**解法一**\n\n范围小，随便搞\n```golang\nfunc commonChars(A []string) []string {\n    var m = make(map[int]map[byte]int)\n    \n    var max = 0\n    for i := 0; i < len(A); i++ {\n        m[i] = make(map[byte]int)\n        for j := 0; j < len(A[i]); j++ {\n            m[i][A[i][j]]++\n        }\n        if len(A[i]) > len(A[max]) {\n            max = i\n        }\n    }\n    var res []string\n    for i := 0; i < len(A[max]); i++ {\n        var flag = true\n        for j := 0; j < len(A); j++ {\n            if j == max {\n                continue\n            }\n            if m[j][A[max][i]] == 0 {\n                flag = false\n                break\n            }\n            m[j][A[max][i]]--\n        }\n        if flag {\n            res = append(res, string(A[max][i]))\n        }\n    }\n    return res\n}\n```\n\n## _前缀和相关_\n\n## [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)\n\n给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。\n\n**示例 1 :**\n\n```java\n输入：nums = [1,1,1], k = 2\n输出：2 , [1,1] 与 [1,1] 为两种不同的情况。\n```\n\n**说明 :**\n\n- 数组的长度为 [1, 20,000]。\n- 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。\n\n**解法一**\n\n前缀和 + hash 表\n\n```java\npublic int subarraySum(int[] nums, int k) {\n    HashMap<Integer,Integer> map = new HashMap<>();\n    map.put(0,1);//初始化头哨兵，避免下标转换\n    int sum=0,res=0;\n    for (int i=0;i<nums.length;i++) {\n        sum+=nums[i];\n        //-1 -1 1 | 0\n        if (/*sum>=k && */map.containsKey(sum-k)) {\n            res+=map.get(sum-k);\n        }\n        map.put(sum,map.getOrDefault(sum,0)+1);\n    }\n    return res;\n}\n```\n我们将各个位置的前缀和作为键，这个前缀和在**当前位置之前出现的次数作为键** （这一点保证了连续，不会找到后面去）\n\n然后我们的目标就是找到和为 k 区间有多少个，区间和利用前缀和可以直接算出，也就是 \n\n`sum[i~j] = sum[j] -sum[i]= k` 然后这个问题就可以转换为，当我们遍历到某个元素的时候，我们在 map 中查找前缀和为`sum[j] - k`的元素有几个，这样就可以得到区间和为 k 的区间有多少个！\n\n值得注意的地方就是，需要添加一个初始的`sum=0`的值，避免下标的转换\n\n画个图就像下面这样：\n\n![img](http://static.imlgw.top/blog/20191104/ECiyYqso8i2K.png?imageslim)\n\n## [1248. 统计「优美子数组」](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)\n\n给你一个整数数组 nums 和一个整数 k。\n\n如果某个子数组中恰好有 k 个奇数数字，我们就认为这个子数组是**「优美子数组」**。\n\n请返回这个数组中「优美子数组」的数目。\n\n**示例 1：**\n\n```java\n输入：nums = [1,1,2,1,1], k = 3\n输出：2\n解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [2,4,6], k = 1\n输出：0\n解释：数列中不包含任何奇数，所以不存在优美子数组。\n```\n\n**示例 3：**\n\n```java\n输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2\n输出：16\n```\n\n**提示：**\n\n- `1 <= nums.length <= 50000`\n- `1 <= nums[i] <= 10^5`\n- `1 <= k <= nums.length`\n\n**解法一**\n\n11.3 周赛第二题，没做出来，以为是滑动窗口，滑了半天没滑出来，后来看了解答知道了是利用前缀和 + Hash，其实和上面一题是类似的，相当于上一题的进阶\n\n```java\npublic int numberOfSubarrays(int[] nums, int k) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    int sum=0,res=0;\n    map.put(0,1);\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]%2==1) {\n            sum++;\n        }\n        //题目说了都是正数，所以可以优化下\n        if (sum>=k && map.containsKey(sum-k)) {\n            res+=map.get(sum-k);\n        }\n        map.put(sum,map.getOrDefault(sum,0)+1);\n    }\n    return res;\n}\n```\n其实这里就是把奇数都看作 1，偶数都看作 0，这样问题就变成了求和为 k 的区间个数有多少个，然后在根据上面的前缀和+Hash 表，就可以很容易的得到答案，还有一点就是题目说了数据都是正数，所以在判断的时候可以加一个`sum>=k` 来减少一点判断，当然这题题目指定了数据的范围，所以还可以直接用数组做 map 映射\n\n```java\n//update: 2020.4.21 之前的数组开大了，开了 10w。\npublic int numberOfSubarrays(int[] nums, int k) {\n    int[] map=new int[50001];  \n    map[0]=1;\n    int sum=0;\n    int res=0;\n    for(int i=0;i<nums.length;i++){\n        sum+=nums[i]&1;\n        map[sum]++;\n        //sum-x=k\n        if(sum-k >=0 && map[sum-k]!=0){\n            res+=map[sum-k];\n        }\n    }\n    return res;\n}\n```\n\n> 这题还有其他的数学解法，暂时不太想写，后面有时间再写吧，大致思路就是\n>\n> [2，2，1，1，2，2，2] res=3*4=12\n\n## [1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)\n\n给你一个字符串 `s` ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。\n\n**示例 1：**\n\n```java\n输入：s = \"eleetminicoworoep\"\n输出：13\n解释：最长子字符串是 \"leetminicowor\" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"leetcodeisgreat\"\n输出：5\n解释：最长子字符串是 \"leetc\" ，其中包含 2 个 e 。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"bcbcbc\"\n输出：6\n解释：这个示例中，字符串 \"bcbcbc\" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。\n```\n\n**提示：**\n\n- `1 <= s.length <= 5 x 10^5`\n- `s` 只包含小写英文字母。\n\n**解法一**\n\n这题挺好的，反正我是想不出来这样的解法，一开始以为是滑动窗口，写了几行代码发现行不通，数据范围这么大，感觉不是很简单，然后就直接看答案了，涉及到**前缀和**以及**状态压缩**，前缀和维护元音字符出现的奇偶性，并压缩成一个整数，核心思想就是`奇数-奇数=偶数`，`偶数-偶数=偶数`，所以如果两个不同位置的状态相同，那么中间的部分出现次数一定是偶数，具体的不想多解释了看看 [官方题解](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-z-2/) 就行了\n\n```java\npublic int findTheLongestSubstring(String s) {\n    //a e i o u\n    //32 种状态\n    int[] pre=new int[1<<5];\n    Arrays.fill(pre,-1);\n    pre[0]=0;\n    int res=0;\n    int state=0;\n    for (int i=0;i<s.length();i++) {\n        if(s.charAt(i)=='a') state^=16;\n        if(s.charAt(i)=='e') state^=8;\n        if(s.charAt(i)=='i') state^=4;\n        if(s.charAt(i)=='o') state^=2;\n        if(s.charAt(i)=='u') state^=1;\n        if(pre[state]!=-1){\n            res=Math.max(res,i+1-pre[state]);\n        }else{\n            pre[state]=i+1; //前 i 个字符的状态\n        }\n    }\n    return res;\n}\n```\n\n## [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)\n\n给定一个整数数组 `A`，返回其中元素之和可被 `K` 整除的（连续、非空）子数组的数目。\n\n**示例：**\n\n```java\n输入：A = [4,5,0,-2,-3,1], K = 5\n输出：7\n解释：\n有 7 个子数组满足其元素之和可被 K = 5 整除：\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n```\n\n**提示：**\n\n1. `1 <= A.length <= 30000`\n2. `-10000 <= A[i] <= 10000`\n3. `2 <= K <= 10000`\n\n**解法一**\n\n```java\n//同余定义 (b-a)%k=0 => b%k==a%k\npublic int subarraysDivByK(int[] A, int K) {\n    int[] pre=new int[K];\n    int sum=0;\n    pre[sum]=1;\n    int res=0;\n    for(int a:A){\n        sum=(sum+a)%K;\n        //Java 被除数为负数的时候取模也是负数\n        //这里应该纠正，避免负数的模\n        if(sum<0) sum+=K;\n        res+=pre[sum];\n        pre[sum]++;\n    }\n    return res;\n}\n```","tags":["LeetCode","查找"],"categories":["算法"]},{"title":"深入理解 Java 虚拟机（三）","url":"/2019/09/05/18643927/","content":"\n> 这一篇主要记录 JVM 相关的 Class 文件结构\n\n## Class 类文件的结构\n\n Class 文件是一组以** 8 个字节**为基础单位的二进制流，根据 Java 虚拟机规范，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号数和表** \n\n**无符号数**\n\n无符号数属于基本的数据类型，以 u1，u2，u4，u8 来分别表示 1，2，4，8 个字节大小的无符号数，无符号数用来描述数字，索引引用，数量值，或者按照 UTF-8 编码构成字符串值\n\n**表（数组）**\n\n表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性的以`_info` 结尾，表用于描述有程池关系的复合结构的数据，整个 Class 文件本质上就是一张表\n\n### Class 文件整体结构\n\n```java\nClassFile{\n    u4                  magic（魔数 0xCAFFBABE)\n    u2                  minor_version（次版本号）\n    u2                  major_version（主版本号）\n    u2                  constant_pool_count（常量池个数）\n    cp_info             constant_pool（常量池表）\n    u2                  access_flags（类或接口的访问权限）\n    u2                  this_class（类名）\n    u2                  super_class（父类名）\n    u2                  interfaces_count（接口个数）\n    u2                  interfaces（接口名）\n    u2                  fields_count（字段个数）\n    field_info          fields（字段表）\n    u2                  methods_count（方法数）\n    method_info         methods（方法表）\n    u2                  attributes_count（附加属性个数）\n    attribute_info      attributes（附加属性表）\n}\n```\n\n> 在网上看了 [国外的大佬](https://www.infoq.cn/article/Secrets-of-the-Bytecode-Ninjas) 的一张图，挺有意思的！[mark](http://static.imlgw.top/blog/20190902/4JDgENgQ9eIo.png?imageslim)\n\n**魔数和 Class 文件的版本**\n\n每个 Class 文件的**头 4 个字节**称为魔数，他唯一的作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件，这个值为`0xCAFFBABE` ，紧跟着魔数的** 4 个字节**存储的是 Class 文件的版本号，高版本的 JDK 能兼容低版本的字节码，而低版本 JVM 的无法兼容高版本的 Class 文件\n\n## 常量池\n\n紧跟着版本号之后的就是常量池入口，一个 Java 类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看作 Class 文件的资源仓库，比如说 Java 类中定义的方法和变量信息，都是存储在常量池中，常量池中主要存储的两类常量：\n\n- **字面量：** 文本字符串，Java 中声明为 final 的常量值等\n- **符号引用：**类和接口的全限定名，字段的名称和描述符，方法的名称和描述符等\n\n> 关于符号引用，其实在之前的文章中有介绍过，Java 代码在编译的时候并不像 C++/C 一样有连接的步骤，而是在虚拟机加载 Class 文件的时候进行**动态链接**，也就是说，在 Class 文件中不会保存各个方法，字段的最终内存布局信息，因此这些字段，方法的符号引用无法直接被虚拟机使用，当虚拟机运行的时候，需要从常量池中获得对应得符号引用，在类创建或运行得时候解析，翻译到具体的内存地址中。\n\n### 常量池项目类型\n\n常量池的每一项都是一个表，JDK1.7 之前一共有 11 种**结构不同**的表结构，也就是下面的 11 种，JDK1.7 之后为了更好的支持动态语言的调用，又额外的增加了 3 种（CONSTANT_MethodHandle_info，CONSTANT_MethodType_info，CONSTANT_InvokeDynamic_info）这些表结构都有一个共同的特点，**表开始的第一位都是一个`u1`类型的标志位`tag`，目的就是区分这个常量属于那种类型的常量**，后面的内容都各有各的结构，`index`代表的是常量池中的对应的常量索引，`bytes`代表的就是字节数据\n\n### cp_info\n\n![常量池表结构](http://static.imlgw.top/blog/20190829/vjjWxwvrt0qg.png)\n\n这张表上的数据不用记住，用的时候知道去哪里查就行了（虽然用的机会很少😂），下面我们编译一段代码，看一下字节码长啥样\n\n```java\npublic class Test1 {\n    \n    private int a=1;\n    \n    public int getA(){\n        return a;\n    }\n    public void setA(int a){\n        this.a=a;\n    }\n}\n```\n\n🎯**编译完成后用 16 进制的编译器 (winHex) 打开 Class 文件**\n\n![mark](http://static.imlgw.top/blog/20190901/EOnrpm9sx8wE.png?imageslim)\n\n⚡ 这里前面的 4 个字节`0xCAFEBABE` 代表的就是魔数，后面的 4 个字节`0x00000034`代表的就是版本号，再往后 2 个字节`0x0018`就是常量池的入口，对应的就是常量池的大小（constant_pool_count），转换为 10 进制就是 24，但是实际上并不是 24 个，常量池计数是从 1 而不是 0 开始的，设计者将 0 位置的项空出来目的是为了表示后面某些指向常量池的索引值的数据在特定情况下表示**不引用任何一个常量池项目**（大师就是大师，各种细节都能考虑到）\n\n⚡ 再往后看，`0x0A`，这个就是我们前面说的`tag`标志位，转换为 10 进制就是`10` ，查一下表对应的常量类型是`CONSTANT_Methodref_info`，紧跟着的两个字节`0x0004`是一个`index`类型的数据，指向声明方法描述符`CONSTANT_Class_info` 的索引项，也就是常量池的第 4 项，再往后两个字节`0x0014`代表的就是指向类型描述符`CONSTANT_NameAndType`的索引项，也就是常量池的第 20 项\n\n这里我们就不一一的去分析了，我们借助`javap` 来看看反编译的结果和我们分析的是不是一致的\n\n```java\nLast modified 2019-9-1; size 485 bytes\n  MD5 checksum e8148a01ff25087c42827d62a9b827b0\n  Compiled from \"Test1.java\"\npublic class jvmstudy.classfile_stu.Test1\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#20         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #3.#21         // jvmstudy/classfile_stu/Test1.a:I\n   #3 = Class              #22            // jvmstudy/classfile_stu/Test1\n   #4 = Class              #23            // java/lang/Object\n   #5 = Utf8               a\n   #6 = Utf8               I\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               LocalVariableTable\n  #12 = Utf8               this\n  #13 = Utf8               Ljvmstudy/classfile_stu/Test1;\n  #14 = Utf8               getA\n  #15 = Utf8               ()I\n  #16 = Utf8               setA\n  #17 = Utf8               (I)V\n  #18 = Utf8               SourceFile\n  #19 = Utf8               Test1.java\n  #20 = NameAndType        #7:#8          // \"<init>\":()V\n  #21 = NameAndType        #5:#6          // a:I\n  #22 = Utf8               jvmstudy/classfile_stu/Test1\n  #23 = Utf8               java/lang/Object\n{\n  public jvmstudy.classfile_stu.Test1();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: aload_0\n         5: iconst_1\n         6: putfield      #2                  // Field a:I\n         9: return\n      LineNumberTable:\n        line 7: 0\n        line 9: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      10     0  this   Ljvmstudy/classfile_stu/Test1;\n\n  public int getA();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field a:I\n         4: ireturn\n      LineNumberTable:\n        line 12: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Ljvmstudy/classfile_stu/Test1;\n\n  public void setA(int);\n    descriptor: (I)V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=2\n         0: aload_0\n         1: iload_1\n         2: putfield      #2                  // Field a:I\n         5: return\n      LineNumberTable:\n        line 16: 0\n        line 17: 5\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       6     0  this   Ljvmstudy/classfile_stu/Test1;\n            0       6     1     a   I\n}\nSourceFile: \"Test1.java\"\n\n```\n\n可以看到和我们分析结果是一致的，那这个`Methodref`是表示的那个方法呢？其实根据反编译的结果也可以看出来，这个方法是我们默认的无参构造方法\n\n## 访问标志\n\n| 标志名称       | 标志值   | 含义                                                         |\n| -------------- | -------- | ------------------------------------------------------------ |\n| ACC_PUBLIC     | 0x00 01  | 是否为 Public 类型                                             |\n| ACC_FINAL      | 0x00 10  | 是否被声明为 final，只有类可以设置                            |\n| ACC_SUPER      | 0x00 20  | 是否允许使用 invokespecial 字节码指令的新语义．jdk1.0.2 之后都为真 |\n| ACC_INTERFACE  | 0x02 00  | 标志这是一个接口                                             |\n| ACC_ABSTRACT   | 0x04 00  | 是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 |\n| ACC_SYNTHETIC  | 0x10 00  | 标志这个类并非由用户代码产生                                 |\n| ACC_ANNOTATION | 0x20 00  | 标志这是一个注解                                             |\n| ACC_ENUM       | ０x40 00 | 标志这是一个枚举                                             |\n\n在常量池结束之后，紧接着的**两个字节**代表访问标志（`access_flags`），这个标志用于识别类或接口层次的访问信息，包括：这个 Class 是接口还是方法？是否定义为 public 类型？是否定义为 abstract？等，两个字节 16 个标志位，可以表示 2^16 种状态，但是当前只定义了 8 个标志位没有使用到的一律要求为 0\n\n还是参考上面的字节码，常量池是图中从`0A~74` 的紫色部分，紧跟着后面的两个字节`0x0021`对应的就是访问标志位，也就是 `ACC_PUBLIC | ACC_SUPER` 的值\n\n## 类索引，父类索引接口索引集合\n\n类索引 (`this_class`) 和父类索引 (`super_class`) 都是一个 u2 类型的数据，而接口索引集合 (`interfaces`) 是一组`u2` 类型的**数据的集合**，Class 文件中由这三项数据来表示这个类的继承关系\n\n类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。\n\n类索引、父类索引和接日索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为`CONSTANT_Class_info`的类描述符常量，通过`CONSTANT_Class_info`类型的常量中的索引值以找到定义在`CONSTANT_Utf8_info`类型的常量中的全限定名字符串\n\n我们接着上面的字节码文件分析，紧接着访问标志符后面的 u2 是`0x0003` 也就是`this_class`在常量池中的索引，再往后的`0x0004`对应的就是`super_class`在常量池的索引`0x0000` 说明没有父接口，后面的集合也就没有了\n\n```java\nConstant pool:\n   #1 = Methodref          #4.#20         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #3.#21         // jvmstudy/classfile_stu/Test1.a:I\n   #3 = Class              #22            // jvmstudy/classfile_stu/Test1\n   #4 = Class              #23            // java/lang/Object\n   #5 = Utf8               a\n   #6 = Utf8               I\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               LocalVariableTable\n  #12 = Utf8               this\n  #13 = Utf8               Ljvmstudy/classfile_stu/Test1;\n  #14 = Utf8               getA\n  #15 = Utf8               ()I\n  #16 = Utf8               setA\n  #17 = Utf8               (I)V\n  #18 = Utf8               SourceFile\n  #19 = Utf8               Test1.java\n  #20 = NameAndType        #7:#8          // \"<init>\":()V\n  #21 = NameAndType        #5:#6          // a:I\n  #22 = Utf8               jvmstudy/classfile_stu/Test1\n  #23 = Utf8               java/lang/Object\n```\n\n结合反编译的结果，常量池第三项和第四项都对应了一个`CONSTANT_Class_info`的索引常量，其最终指向了一个`CONSTANT_Utf8_info` 的常量，这个常量的值就是我们的`this_class`和`super_class` 的全限定名\n\n## 字段表集合\n\n紧跟着上面类索引等信息后面的`u2`类型的数据`0x0001`就是代表的`fields_count`，这里只有一个字段 a 所以这里是`1`\n\n### field_info\n\n字段表（`field_info`）用于描述接口或者类中声明的变量。字段（`field`）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量\n\n字段的各种修饰符其实都是个布尔值，要么有要么没有，所以很好表示适合用标志位来表示，但是字段的类型，名字这些就很难固定\n\n| 类型           | 名称             | 数量             |\n| -------------- | ---------------- | ---------------- |\n| u2             | access_flags     | 1                |\n| u2             | name_index       | 1                |\n| u2             | descriptor_index | 1                |\n| u2             | attributes_count | 1                |\n| attribute_info | attributes       | attributes_count |\n\n前三项分别代表，访问修饰符，名字的索引以及_描述符_（**对字段来说就是字段的类型**）的索引，这三项就可以构成一个字段的完整的信息了，这里我们重点看的也是前三项的信息，字段修饰符`access_flags`其实和类中的`access_flags` 类似，只不过可以设置的修饰符不太一样\n\n**字段访问标志**\n\n| 标志名称      | 标志值 | 含义                       |\n| ------------- | ------ | -------------------------- |\n| ACC_PUBLIC    | 0x0001 | 字段是否 public             |\n| ACC_PRIVATE   | 0x0002 | 字段是否 private            |\n| ACC_PROTECTED | 0x0004 | 字段是否 protected          |\n| ACC_STATIC    | 0x0008 | 字段是否 static             |\n| ACC_FINAL     | 0x0010 | 字段是否 final              |\n| ACC_VOLATILE  | 0x0040 | 字段是否 volatile           |\n| ACC_TRANSIENT | 0x0080 | 字段是否 transient          |\n| ACC_SYNTHETIC | 0x1000 | 字段是否由编译器自动产生的 |\n| ACC_ENUM      | 0x4000 | 字段是否 enum               |\n\n🎯**继续接着上面的类索引分析**\n\n![mark](http://static.imlgw.top/blog/20190902/s5dWhYXNIuxq.png?imageslim)\n\n⚡`0x0001` 对应`fields_count`，值为 1 字段的数量为 1，后面的`field_info`数量为 1\n\n⚡`0x0002` 对应字段的`access_flags`，为`ACC_PRIVATE`\n\n⚡`0x0005` 对应字段的名字的索引，在常量池中的第 5 项，结合上面反编译的结果第 5 项为  `#5 = Utf8    a`\n\n⚡`0x0006` 对应字段的描述符索引，在常量池中第 6 项，为`#6 = Utf8   I`\n\n到这里其实我们就可以推断出这个变量的定义为 `private int a`\n\n> 字段表集合中不会列出从超类或者父接口中继承而来的字段，但是有可能会列出原本 Java 代码中没有的字段，比如内部类中自动添加指向外部类的字段。从所周知，在** Java **中字段是不能重载的，只要两个字段的名字是不能一样的，必须使用不同的名称，注意，这是** Java 的语言规范**，其实在 Class 字节码来讲，只要两个字段的描述符不一样，重名就是合法的。\n\n再往后两个字节`0x0000`代表`attributes_count`，其值为 0 所以后面的属性表就没有了，如果这里将字段改为`static final int a` 那么`attributes_count` 将为 1，后面会多出一条指向常量池`ConstantValue`数据的 index（下文会演示）\n\n## 方法表集合\n\n紧跟着字段表之后的 u2 类型的数据 `0x0003`代表的就是`method_count` ，值为 3 代表有三个方法，这里面包含了 JVM 自动生成的默认无参数构造器方法，所以是 3 个\n\n### method_info\n\n方法表的结构其实和字段表的结构是一样的\n\n| 类型           | 名称             | 数量             |\n| -------------- | ---------------- | ---------------- |\n| u2             | access_flags     | 1                |\n| u2             | name_index       | 1                |\n| u2             | descriptor_index | 1                |\n| u2             | attributes_count | 1                |\n| attribute_info | attributes       | attributes_count |\n\n但是具体的`access_flags` 和`attributes`集合不太一样\n\n**方法访问标志**\n\n| 标志名称          | 标志值  | 含义                             |\n| ----------------- | ------- | -------------------------------- |\n| ACC_PUBLIC        | 0x00 01 | 方法是否为 public                 |\n| ACC_PRIVATE       | 0x00 02 | 方法是否为 private                |\n| ACC_PROTECTED     | 0x00 04 | 方法是否为 protected              |\n| ACC_STATIC        | 0x00 08 | 方法是否为 static                 |\n| ACC_FINAL         | 0x00 10 | 方法是否为 final                  |\n| ACC_SYHCHRONRIZED | 0x00 20 | 方法是否为 synchronized           |\n| ACC_BRIDGE        | 0x00 40 | 方法是否是由编译器产生的桥接方法 |\n| ACC_VARARGS       | 0x00 80 | 方法是否接受参数                 |\n| ACC_NATIVE        | 0x01 00 | 方法是否为 native                 |\n| ACC_ABSTRACT      | 0x04 00 | 方法是否为 abstract               |\n| ACC_STRICTFP      | 0x08 00 | 方法是否为 strictfp               |\n| ACC_SYNTHETIC     | 0x10 00 | 方法是否是有编译器自动产生的     |\n\n🎯**我们继续接着上面的字段表后面分析**\n\n![mark](http://static.imlgw.top/blog/20190902/BuNVfOyD3mJy.png?imageslim)\n\n⚡`0x0003` 方法表的入口，代表`methods_count` 方法的数量，值为 3，有三个方法（包括了编译器自动生成的`<init>`方法）\n\n⚡ `0x0001` 第一个方法的访问标志值，代表`ACC_PUBLIC`\n\n⚡ `0x0007` 方法名的`name_index`，值为 7 代表常量池中第 7 项常量，结合反编译的结果其值为\n\n`#7 = Utf8  <init>`  也就是我们的实例构造方法（编译器自动帮我们生成的）\n\n⚡ `0x0008` 方法描述符的`descriptor_index` ，值为 8 代表常量池中第 8 项常量，其值为\n\n`#8 = Utf8  ()V`  自动生成的无参构造器的描述\n\n⚡ `0x0001` 方法属性表 (`attribute_info`) 的入口，代表`attributes_count` ，值为 1 代表有一个属性表\n\n⚡ `0x0009` 属性名称的索引，常量池中为 `#9 = Utf8   Code`说明此属性是方法的字节码描述，也就是方法中的代码\n\n> 在方法表中，如果子类没有重写父类的方法就不会出现父类的方法信息，但是会出现编译器自动添加的方法，最典型的就是`<clinit>`和`<init>`，这里并没有 静态变量的赋值和静态语句块所以并没有生成`<clinit>` 方法，另外一点和上面字段表的一样，Java 语言中重载是不能以返回值来界定的，但是在 Class 文件格式中，只要描述符不一致，就是可以共存的，而方法的描述符就包括了参数列表和返回值\n\n## 属性表集合\n\n属性表（attribute_info），Class 文件，字段表，方法表中可以携带自己的属性表，说有 attribute_info 的前两项都是 u2 类型的`attribute_name_index`和 u4 类型的`attribute_length`分别代表属性名字的索引和属性值的大小 ，Java 虚拟机中预定义了一些属性，这些属性都各有各的含义和结构\n\n| 属性名称                             | 使用位置           | 含义                                                         |\n| :----------------------------------- | ------------------ | :----------------------------------------------------------- |\n| Code                                 | 方法表             | Java 代码编译成的字节码指令                                  |\n| ConstantValue                        | 字段表             | final 关键字定义的常量值                                     |\n| Deprecated                           | 类、方法表、字段表 | 被声明为 `deprecated` 的方法和字段                           |\n| Exceptions                           | 方法表             | 方法抛出的异常                                               |\n| EnclosingMethod                      | 类文件             | 仅当一个类为局部类或匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 |\n| InnerClasses                         | 类文件             | 内部类列表                                                   |\n| LineNumberTable                      | Code 属性          | Java 源码的行号与字节码指令的对应关系                        |\n| LocalVariableTable                   | Code 属性          | 方法的局部变量描述                                           |\n| StackMapTable                        | Code 属性          | JDK 6 新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配 |\n| Signature                            | 类、方法表、字段表 | JDK 5 新增的属性，用于支持泛型情况下的方法签名，在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。由于 Java 的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息 |\n| SourceFile                           | 类文件             | 记录源文件名称                                               |\n| SourceDebugExtension                 | 类文件             | JDK 6 新增属性，用于存储额外的调试信息。譬如在进行 JSP 文件调试时，无法通过 Java 堆栈来定位到 JSP 文件的行号，JSR-45 规范为这些非 Java 语言编写，却需要编译成字节码并运行在 Java 虚拟机中的程序提供了一个进行调试的标准机制，使用该属性就可以存储这个标准所新加入的调试信息 |\n| Synthetic                            | 类、方法表、字段表 | 表示方法或字段是由编译器自动生成的                           |\n| LocalVariableTypeTable               | 类                 | JDK 5 新增属性，它使用特征签名代替描述符，为了引入泛型语法之后能描述泛型参数化类型而添加 |\n| RuntimeVisibleAnnotations            | 类、方法表、字段表 | JDK 5 新增属性，为动态注解提供支持。该属性指明哪些注解是运行时（实际上运行时就是进行反射调用）可见的 |\n| RuntimeInvisibleAnnotations          | 类、方法表、字段表 | JDK 5 新增属性，与 `RuntimeVisibleAnnotations` 作用相反，用于指明哪些注解运行时不可见 |\n| RuntimeVisibleParameterAnnotations   | 方法表             | JDK 5 新增属性，作用与 `RuntimeVisibleAnnotations` 作用相似，只不过作用对象为方法参数 |\n| RuntimeInvisibleParameterAnnotations | 方法表             | JDK 5 新增属性，作用与 `RuntimeInvisibleAnnotations` 作用相似，只不过作用对象为方法参数 |\n| AnnotationDefault                    | 方法表             | JDK 5 新增属性，用于记录注解类元素的默认值                   |\n| BootstrapMethods                     | 类文件             | JDK 7 新增属性，用于存储 `invokedynamic` 指令引用的引导方法限定符 |\n\n### Code 属性\n\nJava 程序方法体中的代码经过 Javac 编译器处理过后，最终变为字节码指令存储在 Code 属性内\n\nCode 属性出现在**方法表的属性集合**中，但是并非所有的方法表都必须存在这个 Code 属性，**像接口和抽象类中的方法就不存在 Code 属性**\n\n**Code 属性结构**\n\n| 类型            | 名称                   | 数量                   |\n| --------------- | ---------------------- | ---------------------- |\n| u2              | attribute_name_index   | 1                      |\n| u4              | attribute_length       | 1                      |\n| u2              | max_stack              | 1                      |\n| u2              | max_locals             | 1                      |\n| u4              | code_length            | 1                      |\n| u1              | code                   | code_length            |\n| u2              | exception_table_length | 1                      |\n| exception_info  | exception_table        | exception_table_length |\n| u2              | attributes_count       | 1                      |\n| attributes_info | attributes             | attributes_count       |\n\n🎯**紧接着上面的方法表分析**\n\n_这里分析的还是方法表第一个方法（`<init>`）所携带的属性表_\n\n![mark](http://static.imlgw.top/blog/20190904/Gd5cWl6Yr84x.png?imageslim)\n\n⚡ `0x0009` 对应`attribute_name_index`，属性名称的索引，常量池中为 `#9 = Utf8   Code`说明此属性是方法的字节码描述，也就是方法中的代码\n\n⚡ `0x00000038` 代表`attribute_length` 顾名思义就是属性值的长度，这里是 56（不包含 attribute_name_index 和 attribute_length）\n\n⚡`0x0002`代表`max_stack` 操作数栈（Operand Stacks）深度的最大值，虚拟机运行的时候会根据这个值来分配栈帧（StackFrame）中的操作栈深度\n\n⚡`0x0001`代表`max_locals` 代表了**局部变量表**所需的存储空间，这里的内存分配单位是`Slot`\n\n> `Slot`是虚拟机为局部变量分配内存所使用的最小单位，对于 byte，char，float，int，short，boolean 等长度不超过 32 位的数据类型，每个局部变量占用一个`Slot` ，但是对于 double 和 long 等 64 位的数据类型则需要两个`Slot` \n>\n> 方法参数（包括实例方法中的 this 引用），trycatch 语句中 catch 中定义的异常，方法体中定义的局部变量 都需要使用局部变量表来存放，但是最后并不是把所有这些局部变量占用的`Slot`加起来就是`max_locals` 因为**局部变量表中的 Slot 是可以复用的**，当代码执行超过一个局部变量的作用域时，这个变量占用的 Slot 就可以被其他局部变量所使用，所以编译器会根据作用域来分配`Slot` 给各个局部变量使用\n\n⚡`0x0000000A`u4 类型的`code_length` 代表的就是字节码的长度，这里是 10，说明后面有 10 个字节长度的字节码指令流\n\n⚡u1 类型的`code` 就是具体用字节码指令，每个指令都是一个 u1 的单字节指令，也就是说最多有 256 个指令，目前 Java 虚拟机已经定义了其中约 200 条编码值对应的指令，这里有连续的 10 个单字节指令，构成了`<init>`方法的字节码指令\n\n⚡`0x0000`代表`exception_table_length` 异常表的长度，这里`<init>`方法没有异常抛出所以为 0\n\n⚡ `exception_info`类型的`exception_table` 异常表，存放处理异常的信息（try-catch 中的异常），前面的长度为 0 所以这里不存在这一项数据\n\n**异常表结构**\n\n| 类型 | 名称       | 数量 |\n| ---- | ---------- | ---- |\n| u2   | start_pc   | 1    |\n| u2   | end_pc     | 1    |\n| u2   | handler_pc | 1    |\n| u2   | catch_type | 1    |\n\n每个 exception_table 表项由 start_pc，end_pc，handler_pc，catch_type（指向常量池中 CONSTANT_Class_info 类型的常量）组成\n\n当字节码在 start_pc 到 end_pc 之间出现了类型为 catch_type 或者其子类的异常，就转到 handler_pc 行继续执行，当 catch_type 为 0 时表示处理所有的异常\n\n⚡`0x0002` 代表`attributes_count` 是`Code` 属性表的**附加属性**的入口（一层套一层啊😂），值为 2 意味着附加属性表的数量为 2\n\n### LineNumberTable 属性\n\n这个就是上面**`<init>`方法 Code 属性附加的第一个属性**，这个属性用于描述 Java 源代码行号和字节码行号（偏移量）之间的对应关系，他并不是运行的必须属性，但是默认会生成到 Class 文件中，可以使用`-g:none`或`-g:lines`取消生成这个属性，取消之后程序抛异常的时候不会显示出错的行号，并且在调试的时候，也无法按照源码行来设置断点，其结构如下表\n\n| 类型             | 名称                     | 数量                     |\n| ---------------- | ------------------------ | ------------------------ |\n| u2               | attribute_name_index     | 1                        |\n| u4               | attribute_length         | 1                        |\n| u2               | line_number_table_length | 1                        |\n| line_number_info | line_number_table        | line_number_table_length |\n\n🎯**我们再接着上面的 Code 属性的属性表分析，看看 Code 的属性表是啥**\n\n![mark](http://static.imlgw.top/blog/20190904/O7MuBcPXNPKT.png?imageslim)\n\n⚡`0x000A` attributes_info 的第一项，对应的是 atttibute 的名字的索引，常量池中对应第 10 项的索引是 \n\n `#10 = Utf8   LineNumberTable` 说明这个属性是 LineNumberTable 属性，然后根据上面给出的表格继续分析\n\n⚡`0x0000000A` 对应 attribute_length，说明该属性值长度为 10\n\n⚡`0x0002`对应 line_number_table_length，说明有两处对应关系\n\n⚡ 后面紧跟的字节就对应的`line_number_table` 该属性又有两个属性，分别为`start_pc`和`line_number`两个 u2 类型的数据项，前者是字节码行号，后者是源码行号，前面 line_number_table_length 为 2，所以这里后面有两个 line_number_table\n\n### LocalVariableTable 属性\n\n这个就是上面**`<init>` 方法 Code 属性附加的第二个属性**，这个属性主要用于描述**栈帧中局部变量表**中的变量和 Java 源代码中定义的变量之间的关系，没有这项属性当在其他地方使用该方法的时候关于参数的名称都会丢失，最典型的就是 IDE 中有时候反编译一些框架的代码就会看见一些方法参数什么的都是 arg0，arg1 什么的\n\n**LocalVariableTable 属性结构**\n\n| 类型                | 名称                        | 数量                        |\n| ------------------- | --------------------------- | --------------------------- |\n| u2                  | attribute_name_index        | 1                           |\n| u4                  | attribute_length            | 1                           |\n| u2                  | local_variable_table_length | 1                           |\n| local_variable_info | local_variable_table        | local_variable_table_length |\n\n🎯 **我们接着上面的 LineNumberTable 属性分析`LocalVariableTable`**\n\n![mark](http://static.imlgw.top/blog/20190905/TafXz1oMkG4d.png?imageslim)\n\n⚡`0x000B`和之前所有的 attributes_info 一样，这个第一项代表该属性的名字在常量池的索引值，这里对应常量池第 11 项 `#11 = Utf8   LocalVariableTable` \n\n⚡`0x0000000C` 对应 attribute_length，说明该属性值长度为 12\n\n⚡`0x0001`对应 local_variable_table_length，值为 1 说明只有一个局部变量\n\n> 其实到现在我们分析的属性表都还是在分析这个类的第一个方法，JVM 自动生成的`<init>`方法所对应的属性表，而这个`<init>`很明显是没有参数的，是一个无参的空构造器，那么问题来了，这里的局部变量是从哪里来的？为什么不是 0？\n>\n> 其实这很好解释，平常编码的时候大家肯定都使用过`this` 这个关键字，通过这个关键字可以在实例方法中拿到当前的实例对象，这个 1 代表其实就是这个`this`，在 Javac 编译的时候会将对 this 的访问转换为对一个方法参数的访问，而这个方法参数会在运行这个实例方法的时候由 JVM 自动的传入，所以局部变量表中至少会存在一个指向当前实例的局部变量\n\n我们继续分析后面的`local_variable_info` \n\n**local_variable_info 属性结构**\n\n| 类型 | 名称             | 数量 |\n| ---- | ---------------- | ---- |\n| u2   | start_pc         | 1    |\n| u2   | length           | 1    |\n| u2   | name_index       | 1    |\n| u2   | descriptor_index | 1    |\n| u2   | index            | 1    |\n\n⚡`0x0000` 代表`start_pc`，这个局部变量的生命周期开始的字节码偏移量\n\n⚡`0x000A`代表`length`代表这个局部变量其作用范围覆盖的长度\n\n⚡`0x000C`代表`name_index` 是这个局部变量的名字索引，指向常量池中第 12 项常量 `#12 = Utf8   this`符合我们前面的分析\n\n⚡`0x000D`代表`decriptor_index` 局部变量描述符（对变量来说就是变量的类型）的索引，指向常量池第 13 项常量\n\n`#13 = Utf8    Ljvmstudy/classfile_stu/Test1;` 当前实例对象的**全限定名**\n\n⚡`0x0000` 对应`index` 代表这个局部变量在**栈帧局部变量表**中 Slot 的位置\n\n> _**⏳ 到这里我们的方法表的第一个方法`<init>`的 Code 属性就结束了，由于`<init>`方法不包含其他的属性所以`<init>`方法在字节码中也已经结束了**_，后面的方法就不再逐个字节的分析了，都是一样的，主要的是要搞清楚这些属性的层级和包含关系，不要搞混了\n\n### Exceptions 属性\n\n`Exceptions` 属性和上面 Code 属性是平级的，和 Code 属性附带的`exception_table`并不是一个东西，不要搞混了，Exceptions 属性的作用是列举出方法中可能抛出的受检查异常，也就是方法描述时在`throws`关键字后面列举的异常，结构如下\n\n| 类型 | 名称                  | 数量                 |\n| ---- | --------------------- | -------------------- |\n| u2   | attribute_name_index  | 1                    |\n| u4   | attribute_length      | 1                    |\n| u2   | number_of_exceptions  | 1                    |\n| u2   | exception_index_table | number_of_exceptions |\n\n`number_of_exceptions`表示可能抛出多少种受检查异常，每种异常都是一个`exception_index_table` 很明显这个是一个索引，指向常量池中对应的 Exception 的描述符\n\n这里我们的`<init>` 方法并没有抛出异常，所以这一项属性并不存在，那我们找一个有异常的来看看\n\n```java\npublic class Test2 {\n\n    private static int bbbb = 99;\n\n    private final static int aaaa = 99;\n\n    private List<Integer> list=null;\n\n    public Test2(int a) {\n        bbbb = a;\n    }\n\n    public int inc() throws ArithmeticException{\n        int x;\n        try {\n            x=1;\n            return  x;\n        }catch (Exception e){\n            x=2;\n            return x;\n        }finally {\n            x=3;\n        }\n    }\n\n    @Deprecated\n    public void deprecatedMethod(){\n\n    }\n}\n```\n\n![mark](http://static.imlgw.top/blog/20190905/uG5AQrVoHphH.png?imageslim)\n\n可以看到`exception_table` 里面记录了这个方法的异常处理表，也就是`try-catch`里面的异常处理，这也是 Java 代码的一部分，编译器使用了异常处理表去处理异常和 finally 机制，在 jdk1.4 之前使用的是简单的跳转指令来实现，而 Exceptions 属性和 Code 平级，只是列举了一些可能抛出的异常\n\n```java\nExceptions:\n  throws java.lang.ArithmeticException\n```\n## SourceFile 属性\n\n这个属性是属于 Class 文件的属性，很明显是用来记录生成这个 Class 文件的源代码名称，其值指向一个 CONSTANT_Utf8_info 的索引，值就是源文件的名字\n\n## ConstantValue 属性\n\n这个属性在前一篇 [类加载器](http://imlgw.top/2019/08/17/shen-ru-li-jie-java-xu-ni-ji-er/#%E5%87%86%E5%A4%87) 中提到过， `ConstantValue`属性的作用是通知虚拟机自动为静态变量赋值，只有被 static 关键字修饰的变量（类变量）可以使用这项属性\n\n如果**同时使用 final 和 static 来修饰一个变量**，并且这个变量的数据类型是基本类型或者`java.lang.String`的话，就生成`ConstantValue`属性，用于在**准备阶段**给变量赋初始值，如果这个变量没有被 final 修饰或者并非基本类型及字符串，则在准备阶段会被初始化为默认的零值，在`<clinit>`方法中进行真正的初始化\n\n**依然是上面 Exceptions 的 Demo**\n\n![mark](http://static.imlgw.top/blog/20190905/U8zwbs2c0n8a.png?imageslim)\n\n可以看到`aaaa` 这个常量字段附带了 `ConstantValue` 属性其值就是指向常量池中 99 的一个索引\n\n> 🎯 后面还有一些属性就不再详细介绍了\n>\n> Signature 用来记录泛型的信息，StackMapTable 用来验证字节码，BootstarapMethods 用来保存动态调用的引导方法限定符，Deprecated 和 Synthetic 两个 boolean 属性。.....\n\n## Synchnorized 字节码分析\n\n**synchnorized **关键字可以用来修饰方法体，或者方法体内的代码块，修饰方法体的时候同步是隐式的，无需通过字节码指令来控制，它实现在方法调用和返回中，为了看到字节码的变化，这里我们不讨论这种（两种方式的底层实现其实还是一样的）\n\n```java\npublic class Test4 {\n    public static Integer a = 0;\n\n    public void setA(int x) {\n        synchronized (this) {\n            a = x;\n        }\n    }\n}\n```\n\n编译后利用工具查看 setA 方法内生成的字节码指令（省略了次要的一些信息）\n\n```java\n0: aload_0           //对象引用 this 入栈\n1: dup\t             //复制栈顶元素 (this)\n2: astore_2          //将栈顶元素 (this) 存入局部变量表 Slot 索引为 2 的位置\n3: monitorenter      //以栈顶元素 (this) 为锁进入同步块\n4: iload_1\t         //局部变量 Slot 1 位置的元素 (x) 入栈\n5: invokestatic  #2  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n8: putstatic     #3  // Field a:Ljava/lang/Integer; 用 x 给 a 赋值\n11: aload_2          //局部变量表 Slot 2 元素 (this) 入栈\n12: monitorexit      //退出同步\n13: goto          21 //跳转到 21 行结束\n16: astore_3         //到这里说明异常了，将栈顶元素（异常对象）存入局部变量表 Slot 3 位置\n17: aload_2          //局部变量表 Slot 2 元素 (this) 位置入栈\n18: monitorexit      //退出同步\n19: aload_3          //局部变量表 Slot 3 位置元素入栈\n20: athrow           //抛出异常\n21: return           //方法正常返回\nException table:\n    from    to  target type\n       4    13    16   any\n      16    19    16   any\n\n```\n最开始没有学字节码的时候一直很纳闷为啥有两个`monitorexit` ，现在算是明白了，这是为了保证 synchnorized 在方法异常的情况下仍然可以正常的释放锁，而不至于导致锁泄露，这也是比较推荐使用 synchnorized 的原因之一\n\n通过字节码可以看到，编译器为我们自动的生成了一个异常表，也就是前面 Code 属性中携带的 exception_table 属性，如果在指定的程序段内发生异常，会按照异常表指定的 target 进行跳转，无论如何都会释放这个锁\n\n## 总结 & 参考\n\n这一部分主要记录了 Class 字节码的文件结构相关的内容，也算是是逐个字节的分析了一遍，收获还是挺大的，对 JVM 平台的理解又加深了，当然这一篇也是给下一篇**虚拟机节码的执行引擎**做铺垫\n\n**_《深入理解 Java 虚拟机》——周志明_**\n","tags":["Class 结构","JVM"],"categories":["JVM"]},{"title":"LeetCode 动态规划","url":"/2019/09/01/ece53aaa/","content":"\n## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n\nYou are climbing a stair case. It takes *n* steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n**Note:** Given *n* will be a positive integer.\n\n**Example 1:**\n\n```java\nInput: 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n\n1. 1 step + 1 step\n2. 2 steps\n```\n\n**Example 2:**\n\n```java\nInput: 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n```\n\n**解法一**\n\n没啥好说的，可以说是最经典的 dp 题了\n\n```java\npublic static int climbStairsDp(int n){\n    int []dp=new int[n+1];\n    dp[0]=1;\n    dp[1]=1;\n    for (int i=2;i<=n;i++) {\n        dp[i]=dp[i-1]+dp[i-2];\n    }\n    return dp[n];\n}\n```\n\n## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n**Example 1:**\n\n```java\nInput: [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n             Total amount you can rob = 1 + 3 = 4.\n```\n\n**Example 2:**\n\n```java\nInput: [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n             Total amount you can rob = 2 + 9 + 1 = 12.\n```\n\n**解法一**\n\n简单的 dp 题，dp 方程很容易得到，`dp[i]=max(dp[i-2]+nums[i],dp[i-1])` （2020.3.22 更新了代码）\n\n```java\n//  Max[i]=max(nums[i-2]+nums[i],nums[i-1])\npublic int rob(int[] nums) {\n    if(nums==null || nums.length<=0) return 0;\n    int[] dp=new int[nums.length];\n    dp[0]=nums[0];\n    for(int i=1;i<nums.length;i++){\n        dp[i]=Math.max(i>=2?dp[i-2]+nums[i]:nums[i],dp[i-1]);\n    }\n    return dp[nums.length-1];\n}\n```\n\n时间空间都是 O(N)，需要注意边界条件\n\n**解法二**\n\n空间复杂度的优化\n\n```java\n// Max[i]=max(pre+nums[i],cur);  \npublic int rob(int[] nums) {\n    if(nums==null||nums.length<=0){\n        return 0;\n    }\n    int pre= 0; //前一天\n    int cur= 0; //当天，其实就是为了保存前后两天的 dp[i]\n    for (int i=0;i<nums.length;i++) {\n        int temp=cur;\n        cur=Math.max(pre+nums[i],cur);\n        //向后走\n        pre=temp;\n    }\n    return cur;\n}\n```\n\n## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)\n\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈**，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n示例 1:\n\n```java\n输入：[2,3,2]\n输出：3\n解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n```\n\n示例 2:\n\n```java\n输入：[1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n**解法一**\n\n与上一题相比房屋都围成一圈了，其实围成一圈也就说明`nums[0]`和`nums[len-1]`不能同时偷，所以就可以分两种情况分别求最大值，然后求最终的最大值\n\n```java\npublic int rob(int [] nums){\n    if(nums==null||nums.length<=0){\n        return 0;\n    }\n    if(nums.length==1){\n        return nums[0];\n    }\n    if(nums.length==2){\n        return Math.max(nums[0],nums[1]);\n    }\n    int n=nums.length;\n    return Math.max(rob(nums,1,n),rob(nums,0,n-1));\n}\n\npublic int rob(int[] nums,int start,int end) {\n    int pre=0; //前一家最大值\n    int cur=0; //当前最大值\n    for (int i=start;i<end;i++) {\n        int temp=cur;\n        cur=Math.max(pre+nums[i],cur);\n        pre=temp;\n    }\n    return cur;\n}\n```\n\n## [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明**：每次只能向下或者向右移动一步。\n\n**示例**:\n\n```java\n输入：\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n```\n\n很经典的 DP 题。\n\n递推公式：`dp[i][j]  = grid[i][j] + Math.min(dp[i-1][j],dp[i][j-1])`\n\ndp[i] [j] 为每个格子到`左上角`最短路径 ，每个格子到左上角的最小距离等于，左边格子最小值和上边格子最小值的最小值加上当前格子的值。\n\n```java\npublic int minPathSum(int[][] grid) {\n    int[][] dp=new int[grid.length][grid[0].length];\n    for (int i=0;i<grid.length;i++) {\n        for (int j=0;j<grid[0].length;j++) {\n            //第一行\n            if(i==0 && j!=0){\n                dp[i][j]=grid[i][j]+dp[i][j-1];\n            }else if(i!=0 && j==0){\n                dp[i][j]=grid[i][j]+dp[i-1][j];\n            }else if(i!=0 && j!=0){\n                dp[i][j]=grid[i][j]+Math.min(dp[i-1][j],dp[i][j-1]);\n            }else{\n                dp[i][j]=grid[i][j];\n            }\n        }\n    }\n    return dp[grid.length-1][grid[0].length-1];\n}\n```\n\n**UPDATE: 2020.7.20**\n\n写下面的 [path-sum-three-ways](#path-sum-three-ways) 的时候看了这题之前的代码，发现写的不太好，一堆 if-else，重写下\n```golang\nfunc minPathSum(grid [][]int) int {\n    var m = len(grid)\n    var n = len(grid[0])\n    var dp = make([][]int, m)\n    for i := 0; i < m; i++{\n        dp[i] = make([]int, n)\n    }\n    dp[0][0] = grid[0][0]\n    for i := 1; i < m; i++{\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n    for j := 1; j < n; j++{\n        dp[0][j] = dp[0][j-1] + grid[0][j];\n    }\n    for i := 1; i < m; i++{\n        for j := 1; j < n; j++{\n            dp[i][j] = grid[i][j] + Min(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1]\n}\n\nfunc Min(a, b int) int{\n    if a > b{\n        return b\n    }\n    return a\n}\n```\n\n## [Path sum: three ways](https://projecteuler.net/problem=82)\n\nThe minimal path sum in the 5 by 5 matrix below, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down, and right, is indicated in red and bold; the sum is equal to 994.\n\n![UhOJw6.png](https://s1.ax1x.com/2020/07/20/UhOJw6.png)\n\nFind the minimal path sum from the left column to the right column in matrix.txt (right click and \"Save Link/Target As...\"), a 31K text file containing an 80 by 80 matrix.\n\n**解法一**\n\n来源 https://leetcode-cn.com/circle/discuss/BNvWBP/ 从这里看见 qc 大佬贴了出处，所以特地注册了这个网站试了下，这个网站还是挺有意思的，只验证答案，时间复杂度啥的都不管\n\n和上面的最小路径和很类似，但是这里起点和终点都不确定，而且有 3 个方向可以选择，所以这里我们可以遍历 2 次，`dp[i][j]`代表从第一列到当前`matrix[i][j]`的最小路径和，先统计单纯的向上或者向下的最小值，然后再统计相反的方向的值，总之要保证 3 个方向的值都是计算过的\n```java\nimport java.util.*;\nimport java.io.*;\n//https://projecteuler.net/problem=82  answer:260324\npublic class PathSum_threeWays_projecteuler{\n    public static void main(String[] args) throws Exception{\n        BufferedReader reader = new BufferedReader(new FileReader(\"/usr/p082_matrix.txt\"));\n        int index = 0;\n        int m = 80, n = 80;\n        int[][] matrix = new int[m][n];\n        while (index < 80) {\n            String[] line = reader.readLine().split(\",\");\n            for (int j = 0; j < 80; j++) {\n                matrix[index][j] = Integer.valueOf(line[j]);\n            }\n            index++;\n        }\n        int INF = 0x3f3f3f3f;\n        int[][] dp = new int[m][n];\n        for (int j = 0; j < m; j++) {\n            dp[j][0] = matrix[j][0];\n        }\n        for (int j = 1; j < m; j++) {\n            //首先只考虑向右走和向下走\n            for (int i = 0; i < m; i++) {\n                if (i==0){ //第一行，只能从左边转移\n                    dp[i][j] = matrix[i][j] + dp[i][j-1];\n                }else{ //从左边或者上边转移\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\n                }\n            }\n            for (int i = m-1; i >= 0; i--) {\n                //三目写的太长看着挺不舒服。..\n                //dp[i][j] = i==m-1?dp[i][j]:Math.min(dp[i][j], matrix[i][j]+dp[i+1][j]);\n                if (i<m-1) { //从下面转移和从上/左面转移的最小值\n                    dp[i][j] = Math.min(dp[i][j], matrix[i][j]+dp[i+1][j]);\n                }\n                //最后一行，只能从左边或者上面转移，也是就是第一个循环的值\n                //dp[i][j] = dp[i][j]\n            }\n        }\n        int res = INF;\n        for (int i = 0; i < m; i++) {\n            res = Math.min(res, dp[i][m-1]);\n        }\n        System.out.println(res);\n    }\n}\n```\n> 一开始写了个 3 目，改了半天的 bug，发现是 3 目和前面的值混到一起了。\n\n## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n![mark](http://static.imlgw.top/blog/20190818/DfwXk3ObWxX8.png?imageslim)\n\n**说明：**m 和 n 的值均不超过 100。\n\n**示例 1:**\n\n```java\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n```\n\n**示例 2:**\n\n```java\n输入：m = 7, n = 3\n输出：28\n```\n\n**动态规划解法**\n\n这题算是我第一道自己做出来的 DP 题了，虽然和上面的一题一样的思路，但是还是挺开心的\n\n```java\npublic int uniquePaths(int m, int n) {\n    if(m<0||n<0){\n        return 0;\n    }\n    int[][] dp=new int[n][m];\n    for (int i=0;i<n;i++) {\n        for (int j=0;j<m;j++) {\n            if(i==0&&j!=0){\n                dp[i][j]=1;\n            }else if(j==0 && i!=0){\n                dp[i][j]=1;\n            }else if(j!=0&&i!=0){\n                dp[i][j]=dp[i][j-1]+dp[i-1][j];\n            }else{\n                dp[i][j]=1;\n            }\n        }\n    }\n    return dp[n-1][m-1];\n}\n```\n时间复杂度`O(m*n)`，空间复杂度`O(m*n)`可以看出来完全是按照前一题的模板来的，代码写的不好，可以把 if-else 合并起来，这题空间复杂度其实还可以优化成 O(m) 或 O(n) 的，按行来向下走\n\n**空间复杂度优化**\n\n![leetCode 题解](http://static.imlgw.top/blog/20190824/7uacSvsRMaWq.png?imageslim)\n\n```java\npublic static int uniquePaths2(int m, int n) {\n    if(m<0||n<0){\n        return 0;\n    }\n    int[] dp=new int[n]; \n    Arrays.fill(dp,1); //第一行，第一列均为 1\n    for (int i=1;i<m;i++) { //一行一行向下走\n        for (int j=1;j<n;j++) {\n            //这里的 dp[j] 和 dp[j-1] 分别就代表了 上边 和 左边的元素\n            dp[j]=dp[j]+dp[j-1]; //求每一行每个元素的 dp 值\n        }\n    }\n    return dp[n-1]; //最后一行最后一个 dp 值就是结果\n}\n```\n\n**组合数公式**\n\n这题其实就是我们初中还是高中学的排列组合的问题，机器人一共走`m+n-2` 步，向下会走`m-1` 步，向下会走`n-1` 步，所以实际上就是求一个组合数的结果 `C(n-1，m+n-2)` ，\n\n```java\npublic int uniquePaths(int m, int n) {\n    if(m<0||n<0){\n        return 0;\n    }\n    int step=m+n-2;\n    int down=n-1;\n    long res=1;\n    for (int i=1;i<=down;i++) {\n        res=res*(step-down+i)/i; //递推\n    }\n    return (int)res;\n}\n```\n\n## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n![mark](http://static.imlgw.top/blog/20190818/DfwXk3ObWxX8.png?imageslim)\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n**说明：**m 和 n 的值均不超过 100。\n\n**示例 1:**\n\n```java\n输入：\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n输出：2\n解释：\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n```\n\n**解法一**\n\n看到这种路径的题，首先想到的可能是递归回溯\n\n```java\n//dfs 回溯 , TLE\nprivate int[][] direction={{0,1},{1,0}};\n\nprivate int count=0;\n\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    if (obstacleGrid==null || obstacleGrid.length<=0 || obstacleGrid[0][0]==1) {\n        return 0;\n    }\n    boolean[][] visit=new boolean[obstacleGrid.length][obstacleGrid[0].length];\n    dfs(obstacleGrid,visit,0,0);\n    return count;\n}\n\npublic void dfs(int[][] obstacleGrid,boolean[][] visit,int x,int y) {\n    //!=1 是为了 coner case\n    if (x==obstacleGrid.length-1 && y==obstacleGrid[0].length-1 && obstacleGrid[x][y]!=1) {\n        count++;\n        return;\n    }\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (nx<obstacleGrid.length && ny<obstacleGrid[0].length && !visit[nx][ny] && obstacleGrid[nx][ny] !=1) {\n            visit[nx][ny]=true;\n            dfs(obstacleGrid,visit,nx,ny);\n            visit[nx][ny]=false;\n        }\n    }\n}\n```\n结果很惨，TLE 了，只跑了不到一半的 case 就 TLE 了\n\n**解法二**\n\n动态规划的解法，其实和上面一题是一样的，只不过需要注意障碍物位置的 dp 值\n\n```java\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    if (obstacleGrid==null || obstacleGrid.length<=0 || obstacleGrid[0][0]==1) {\n        return 0;\n    }\n    int[][] dp=new int[obstacleGrid.length][obstacleGrid[0].length];\n    for (int i=0;i<obstacleGrid.length;i++) {\n        for (int j=0; j<obstacleGrid[0].length;j++) {\n            if (obstacleGrid[i][j]==1) {\n                dp[i][j]=0;\n            }else if (i==0 && j==0) {\n                dp[0][0]=1;\n            }else if(i==0 && j!=0){\n                dp[0][j]=dp[0][j-1];\n            }else if (j==0 && i!=0) {\n                dp[i][0]=dp[i-1][0];\n            }else{\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\n            }\n        }\n    }\n    return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\n}\n```\n和上面一样也可以进行空间上的优化\n\n```java\n//一维 dp\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    if (obstacleGrid==null || obstacleGrid.length<=0 || obstacleGrid[0][0]==1) {\n        return 0;\n    }\n    //以行为单位向下走\n    int[] dp=new int[obstacleGrid[0].length];\n    dp[0]=1;\n    for (int i=0;i<obstacleGrid.length;i++) {\n        for (int j=0; j<obstacleGrid[0].length;j++) {\n            if (obstacleGrid[i][j]==1) {\n                dp[j]=0;\n            }else if(i==0 && j!=0){ //第一行\n                dp[j]=dp[j-1];\n            }else if(i!=0 && j!=0){ \n                dp[j]=dp[j]+dp[j-1];\n            }\n            //每一行第一列的 dp[j]=dp[j], 和上一行的第一列保持一致就行\n        }\n    }\n    return dp[obstacleGrid[0].length-1];\n}\n```\n**UPDATE: 2020.7.6**\n\n想对简洁的做法\n```golang\nfunc uniquePathsWithObstacles(grid [][]int) int {\n    var m = len(grid)\n    var n = len(grid[0])\n    var dp = make([][]int, m+1)\n    for i := 0; i <= m; i++ {\n        dp[i] = make([]int, n+1)\n    }\n    dp[0][1] = 1 //初始值\n    for i := 1; i <= m; i++ {\n        for j := 1; j <= n; j++ {\n            if grid[i-1][j-1] != 1 {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n    }\n    return dp[m][n]\n}\n\n```\n## [576. 出界的路径数](https://leetcode-cn.com/problems/out-of-boundary-paths/)\n\n给定一个 **m × n** 的网格和一个球。球的起始坐标为 **(i,j)** ，你可以将球移到**相邻**的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你**最多**可以移动 **N** 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109 + 7 的值。\n\n**示例 1：**\n\n```java\n输入：m = 2, n = 2, N = 2, i = 0, j = 0\n输出：6\n解释：\n```\n\n**示例 2：**\n\n```java\n输入：m = 1, n = 3, N = 3, i = 0, j = 1\n输出：12\n解释：\n```\n\n**说明：**\n\n1. 球一旦出界，就不能再被移动回网格内。\n2. 网格的长度和高度在 [1,50] 的范围内。\n3. N 在 [0,50] 的范围内。\n\n**解法一**\n\n首先写出来的解法，自顶向下，记忆化递归\n\n```java\nint[][] dir={{0,1},{1,0},{-1,0},{0,-1}};\n\nint mod=(int)1e9+7;\n\nLong[][][] dp=null;\n\npublic int findPaths(int m, int n, int N, int i, int j) {\n    dp=new Long[m][n][N+1];\n    return (int)(dfs(m,n,i,j,N)%mod);\n}\n\npublic long dfs(int m,int n,int x,int y,int k){\n    if(k==0) return 0;\n    if(dp[x][y][k]!=null){\n        return dp[x][y][k];\n    }\n    long count=0;\n    for(int i=0;i<dir.length;i++){\n        int nx=x+dir[i][0];\n        int ny=y+dir[i][1];\n        if(!valid(m,n,nx,ny)){\n            count++;\n            continue;\n        }\n        count=(count+dfs(m,n,nx,ny,k-1))%mod;\n    }\n    return dp[x][y][k]=(count)%mod;\n}\n\npublic boolean valid(int m,int n,int x,int y){\n    return x>=0 && x<m && y>=0 && y<n;\n}\n```\n\n有一点需要注意，这里不需要 visit，因为有 K 的限制，不用担心死循环，感觉加了 visit 反而会错？\n\n**解法二**\n\n整体上来说还是属于比较简单的动态规划，至少递推方程好想\n\n```java\n//自底向上递推\npublic int findPaths(int m, int n, int N, int i, int j) {\n    int mod=(int)1e9+7;\n    //群里偷学到的\n    int[] dir={0,1,0,-1,0};\n    long[][][] dp=new long[m][n][N+1];\n    for (int k=1;k<=N;k++) { //想想 K 为什么在最外层\n        for (int r=0;r<m;r++) {\n            for (int c=0;c<n;c++) {\n                for (int d=0;d<4;d++) {\n                    int nx=r+dir[d];\n                    int ny=c+dir[d+1];\n                    if(nx<0 || ny<0 || nx>=m ||ny>=n){\n                        dp[r][c][k]++;\n                    }else{\n                        dp[r][c][k]=(dp[r][c][k]+dp[nx][ny][k-1])%mod;\n                    }\n                }\n                //提前结束，只需要 i,j,N 就行了（貌似没有快多少）\n                if(k==N && r==i && c==j){\n                    return (int)(dp[i][j][N]);\n                }\n            }\n        }\n    }\n    //return (int)(dp[m-1][n-1][N]); md 一开始返回错了，看了半天\n    return 0;\n}\n```\nK 放在最外层的原因其实很容易想到，我们求某一个点的时候，我们需要周围 4 个方向的`K-1`的值，这些值必须是已经计算过的，所以 K 肯定是要放在最外层的\n\n## [688. “马”在棋盘上的概率](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)\n\n已知一个 `N`x`N` 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 `(0, 0)`，最右下角的记为 `(N-1, N-1)`。 \n\n现有一个 “马”（也译作 “骑士”）位于 `(r, c)` ，并打算进行 `K` 次移动。 \n\n如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。\n\n![YsAXFS.png](https://s1.ax1x.com/2020/05/15/YsAXFS.png) \n\n现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 `K` 次或跳到了棋盘外面。\n\n求移动结束后，“马” 仍留在棋盘上的概率。\n\n**示例：**\n\n```java\n输入：3, 2, 0, 0\n输出：0.0625\n解释：\n输入的数据依次为 N, K, r, c\n第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第 2 步均有且只有 2 种走法令 “马” 仍然留在棋盘上。\n所以 “马” 在结束后仍在棋盘上的概率为 0.0625。\n```\n\n**注意：**\n\n- `N` 的取值范围为 [1, 25]\n- `K` 的取值范围为 [0, 100]\n- 开始时，“马” 总是位于棋盘上\n\n**错误解法一**\n\n首先采用了和上一题类似做法，明显是不行的\n\n```java\n//小数据可以过，大数据过不了\n//K[0,100] 直接 8^100 就爆了，所以肯定不能像上面那样求，dp 得存概率\npublic double knightProbability(int N, int K, int r, int c) {\n    int[][] dir={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\n    int[][][] dp=new int[N][N][K+1];\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            //这题如果反着求出界路径就错了，得正向求\n            dp[i][j][0]=1; \n        }\n    }\n    for(int k=1;k<=K;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                for(int d=0;d<dir.length;d++){\n                    int nx=i+dir[d][0];\n                    int ny=j+dir[d][1];\n                    if(nx>=0 && nx<N && ny>=0 && ny<N){\n                        dp[i][j][k]+=(dp[nx][ny][k-1]);\n                    }\n                }\n            }\n        }\n    }\n    return dp[r][c][K]/Math.pow(8,K);\n}\n```\n> 多说一点，这里为什么不和上面一样，算出界的路径数，然后用`8^K`减去出界数量，然后除以`8^K`？其实主要是出界的这里并不好算，这里要求的是概率，出界的路径并不能完全包含出界的方式（可以理解为出界后仍然可以走）\n\n**解法二**\n\n标准的 dp 解法，注意概率的计算就行了\n\n```java\n//DP 存概率 AC 解法\npublic double knightProbability(int N, int K, int r, int c) {\n    int[][] dir={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\n    double[][][] dp=new double[N][N][K+1];\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            dp[i][j][0]=1;\n        }\n    }\n    for(int k=1;k<=K;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                for(int d=0;d<dir.length;d++){\n                    int nx=i+dir[d][0];\n                    int ny=j+dir[d][1];\n                    if(nx>=0 && nx<N && ny>=0 && ny<N){\n                        //md，一开始不知道为啥想到求独立事件 P(A U B) 上去了\n                        //但是其实两者并不是独立事件，是互斥事件直接 P(A)+P(B) 就行了\n                        dp[i][j][k]+=(dp[nx][ny][k-1])/8;\n                    }\n                }\n                //提前返回\n                if(i==r && j==c && k==K){\n                    return dp[i][j][k];\n                }\n            }\n        }\n    }\n    return dp[r][c][K];\n}\n```\n\n**解法三**\n\n记忆化的方式，其实会比上面递推的会快一点，上面递推的会有很多无用状态\n\n```java\n//自顶向上\nDouble[][][] dp=null;\n\nint[][] dir={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\n\npublic double knightProbability(int N, int K, int r, int c) {\n    dp=new Double[N][N][K+1];\n    return dfs(N,K,r,c);\n}\n\npublic double dfs(int N,int k,int x,int y){\n    if(k==0) return 1.0;\n    if(dp[x][y][k]!=null){\n        return dp[x][y][k];\n    }\n    double p=0;\n    for (int i=0;i<dir.length;i++) {\n        int nx=x+dir[i][0];\n        int ny=y+dir[i][1];\n        if(nx>=0 && nx<N && ny>=0 && ny<N){\n            p+=dfs(N,k-1,nx,ny)/8;\n        }\n    }\n    return dp[x][y][k]=p;\n}\n```\n\n## [935. 骑士拨号器](https://leetcode-cn.com/problems/knight-dialer/)\n\n国际象棋中的骑士可以按下图所示进行移动：\n\n![YsAXFS.png](https://s1.ax1x.com/2020/05/15/YsAXFS.png) .         ![YcP3o8.png](https://s1.ax1x.com/2020/05/16/YcP3o8.png)\n\n这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。\n\n每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 `N` 位数字。\n\n你能用这种方式拨出多少个不同的号码？\n\n因为答案可能很大，**所以输出答案模 10^9 + 7**。\n\n**示例 1：**\n\n```java\n输入：1\n输出：10\n```\n\n**示例 2：**\n\n```java\n输入：2\n输出：20\n```\n\n**示例 3：**\n\n```java\n输入：3\n输出：46\n```\n\n**提示：**\n\n- `1 <= N <= 5000`\n\n**解法一**\n\n先上一个极其粗糙的解法，也是最开始的解法\n\n```java\nint[][] dir={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\n\nint mod=(int)1e9+7;\n\nInteger[][][] dp=null;\n\npublic int knightDialer(int N) {\n    int[][] grid={{1,2,3},{4,5,6},{7,8,9},{-1,0,-1}};\n    int res=0;\n    dp=new Integer[4][3][N];\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]!=-1){\n                res=(res+dfs(grid,i,j,N-1))%mod;\n            }\n        }\n    }\n    return res;\n}\n\npublic int dfs(int[][] grid,int x,int y,int N){\n    if(N==0) return 1;\n    if(dp[x][y][N]!=null) return dp[x][y][N];\n    int res=0; //一开始赋值成 1 了。从当前位置起跳，所以当前位置不应该有初始值\n    for(int i=0;i<dir.length;i++){\n        int nx=x+dir[i][0];\n        int ny=y+dir[i][1];\n        if(valid(grid,nx,ny)){\n            res=(res+dfs(grid,nx,ny,N-1))%mod;\n        }\n    }\n    return dp[x][y][N]=res;\n}\n\npublic boolean valid(int[][] grid,int x,int y){\n    return x>=0 && y>=0 && x<grid.length && y<grid[0].length && grid[x][y]!=-1;\n}\n```\n\n**解法二**\n\n小巧精致的解法\n\n```java\nint mod=(int)1e9+7;\n\nInteger[][] dp=null;\n\npublic int knightDialer(int N) {\n    //直接看图建立对应关系\n    int[][] next={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\n    int res=0;\n    dp=new Integer[10][N];\n    for(int i=0;i<=9;i++){\n        res=(res+dfs(i,N-1,next))%mod;\n    }\n    return res;\n}\n\npublic int dfs(int num,int N,int[][] next){\n    if(N==0) return 1;\n    if(dp[num][N]!=null) return dp[num][N];\n    int res=0; //注意别写成 1 了\n    for(int i=0;i<next[num].length;i++){\n        res=(res+dfs(next[num][i],N-1,next))%mod;\n    }\n    return dp[num][N]=res;\n}\n```\n\n**解法三**\n\n递推的方式\n\n```java\n//递推的方式\npublic int knightDialer(int N) {\n    //next[i]: i 下一步能跳到的位置\n    int[][] next={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\n    int[][] dp=new int[N][10];\n    Arrays.fill(dp[0],1); //base dp[0]\n    int mod=(int)1e9+7;\n    int res=0;\n    for (int i=1;i<N;i++) {\n        for (int num=0;num<=9;num++) {\n            for (int j=0;j<next[num].length;j++) {\n                dp[i][num]=(dp[i][num]+dp[i-1][next[num][j]])%mod;   \n            }\n        }\n    }\n    for(int i=0;i<=9;i++) res=(res+dp[N-1][i])%mod;\n    return res;\n}\n```\n\n## [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)\n\n给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。\n\n**示例：**\n\n```java\n给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\n```\n\n**说明：**\n\n- 你可以假设数组不可变。\n- 会多次调用 sumRange 方法。\n\n**解法一**\n\n这题其实一开始就是想的缓存一下之前调用产生的值，没有理解到这题的要点。\n\n```java\nclass NumArray {\n\n    private int[] sums=null;\n\n    public NumArray(int[] nums) {\n        if (nums!=null && nums.length>0) {\n            sums=new int[nums.length];\n            sums[0]=nums[0];\n            for (int i=1;i<sums.length;i++) {\n                sums[i]=sums[i-1]+nums[i];\n            }    \n        }\n        \n    }\n    \n    public int sumRange(int i, int j) {\n        if(i==0){\n            return sums[j];\n        }\n        return sums[j]-sums[i-1];\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(i,j);\n */\n```\n\n这题关键有两个地方，一个是 `sumRange(i , j) = sumRange(0, j)-sumRange(0, i-1)` ，另一个关键就是在构造器里面将所有的 `sumRange(0 , i)` 给预先求出来，这样在后面的调用时时间复杂度就是`O(1)`的了。\n\n这里求`sumRange(0, i)`的过程就是一个很简单的 dp.\n\n## [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)\n\n如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。\n\n例如，以下数列为等差数列：\n\n```java\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n```\n\n以下数列不是等差数列。\n\n```java\n1, 1, 2, 5, 7\n```\n\n数组 A 包含 N 个数，且索引从 0 开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。\n\n如果满足以下条件，则称子数组 (P, Q) 为等差数组：\n\n元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。\n\n函数要返回数组 A 中所有为等差数组的子数组个数。\n\n **示例：**\n\n```java\nA = [1, 2, 3, 4]\n\n返回：3, A 中有三个子等差数组：[1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。\n```\n\ndp 的题啊，答案一看就明白，就是自己想不到。\n\n```java\npublic int numberOfArithmeticSlices(int[] A) {\n    if(A.length<3){\n        return 0;\n    }\n    //dp[i]=dp[i-1]+1;\n    int []dp=new int[A.length]; //以 A[i] 结尾的等差数列有多少个\n    for (int i=2;i<A.length;i++) {\n        if(A[i]-A[i-1]==A[i-1]-A[i-2]){\n            dp[i]=dp[i-1]+1;\n        }\n    }\n    int res=0;\n    for (int i=0;i<dp.length;i++) {\n        res+=dp[i];\n    }\n    return res;\n}\n```\n\n就是没想到要对以当前元素结尾的动态数组数量做 dp，当然上面的做法的空间还可以优化成 O(1) 的\n\n```java\npublic int numberOfArithmeticSlices2(int[] A) {\n    if(A.length<3){\n        return 0;\n    }\n    //dp[i]=dp[i-1]+1;\n    int dp=0;\n    int res=0;\n    for (int i=2;i<A.length;i++) {\n        if(A[i]-A[i-1]==A[i-1]-A[i-2]){\n            dp=dp+1;\n            res+=dp;\n        }else{\n            dp=0;\n        }\n    }\n    return res;\n}\n```\n\n只需要根据上一次的 dp 值更新就行，如果 break 等差数列，就置为 0\n\n------\n\n## [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)\n\n给定一个正整数 n，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n\n**示例 1:**\n\n```java\n输入：2\n输出：1\n解释：2 = 1 + 1, 1 × 1 = 1。\n```\n\n**示例 2:**\n\n```java\n输入：10\n输出：36\n解释：10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n```\n\n**说明：** 你可以假设 n 不小于 2 且不大于 58。\n\n**解法一**\n\n别问，问就是暴力\n\n![leetCode 题解 97wgl](http://static.imlgw.top/blog/20190822/BKqmfoXMVq3Q.png?imageslim)\n\n**递推式：** `F(n) = max {i * F(n - i)}，i = 1，2，...，n - 1`  \n\n穷举每一种分解情况，求最大值\n\n```java\npublic static int integerBreak(int n) {\n    //递归出口\n    if (n==2) {\n        return 1;\n    }\n    int res=-1;\n    for (int j=1;j<n;j++) {\n        //第一个 Max 求最大值，第二个 Max 主要是为了考虑 只分两个数就是最大值的情况（<=7 的情况）\n        res=Math.max(res, Math.max((n-j)*j,integerBreak(n-j)*j));\n    }\n    return res;\n}\n```\n\n需要注意的就是第二个 Max 别忘了**只分为两个数就到达最大值**的情况，比如 n<=7 的时候，`integerBreak(n-j)*j)`  至少是三个，下面的 DP 也是一样的要注意别忘了两个数的情况\n\n递归的时间复杂度应该是`O(N!)` ，后面的 case 会超时，其实很明显，递归过程中会有很多的重复计算所以可以采用记忆化递归缓存一下之前的值。\n\n```java\nprivate  Integer[] cache=null;\n//只顶向下，记忆化递归\npublic  int integerBreak(int n) {\n    cache=new Integer[n+1];\n    return breakInteger(n);\n}\npublic  int breakInteger(int n) {\n    if (cache[n]!=null) {\n        return cache[n];\n    }\n    //递归出口\n    if (n==2) {\n        return 1;\n    }\n    int res=-1;\n    for (int j=1;j<n;j++) {\n        res=Math.max(res, Math.max((n-j)*j,breakInteger(n-j)*j));\n    }\n    cache[n]=res;\n    return res;\n}\n```\n这样的解法是可以 AC 的，缓存之前计算的结果，避免了重复的计算\n\n**解法二**\n\n动态规划，结合上面的递归得到`递推方程`\n\n`dp[i] = max(dp[i]，max(dp[ i-j ] * j ，(i-j) * j));`\n\n```java\npublic static int integerBreak2(int n) {\n    if (n==2) {\n        return 1;\n    }\n    int [] dp=new int[n+1];\n    dp[2]=1; //0,1 不考虑\n    for (int i=3;i<=n;i++) {\n        for (int j=1;j<i;j++) {\n            dp[i]=Math.max(dp[i],Math.max(dp[i-j]*j,(i-j)*j));\n        }\n    }\n    return dp[n];\n}\n```\n**解法三**\n\n打板找规律，笔试的时候能直接一眼看出来规律的肯定优先找规律了\n\n```java\npublic static int integerBreak3(int n) {\n    int[] base={1,2,4,6,9,12};\n    if(n<=7){\n        return base[n-2];\n    }\n    int[] dp=new int[n+1];\n    dp[2]=base[0];\n    dp[3]=base[1];\n    dp[4]=base[2];\n    dp[5]=base[3];\n    dp[6]=base[4];\n    dp[7]=base[5];\n    for (int i=8;i<=n;i++) {\n        dp[i]=dp[i-3]*3; //N>7 之后 dp[N]=dp[N-3]*3\n    }\n    return dp[n];\n}\n```\n\n**解法四**\n\n数学分析，其实分析一下会发现，只有 2 和 3 是分解后值比**本身还要小**的，4 分解后相等，这样一分析，从整体上来看其实就清楚了，只要分到 2 或者 3 的时候就不再分就行了，此时的值一定是最大值，如果 2，3 继续分值就会减小\n\n```java\npublic int integerBreak(int n) {\n    int[] base={1,2,4};\n    if(n<=4){\n        return base[n-2];\n    }\n    int res=1;\n    while(n>=5){\n        res*=3;\n        n-=3;\n    }\n    res*=n;\n    return res;\n}\n```\n\n取模写法，这里其实涉及到取模的一个规则，`(a*b)%mod=(a%mid * b%mid) % mod` \n\n```java\npublic int cuttingRope(int n) {\n    if(n<=3) return n-1;\n    long res=1;\n    while(n>=5){\n        n-=3;\n        res=(res*3)%1000000007;\n    }\n    return (int)(res*n%1000000007);\n}\n```\n\n## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)\n\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n**示例 1:**\n\n```java\n输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4.\n```\n\n**示例 2:**\n\n```java\n输入：n = 13\n输出：2\n解释：13 = 4 + 9.\n```\n\n**解法一**\n\n动态规划，不容易啊，自己推出了 DP 方程，没看答案，其实也借鉴了上一题的思路\n\n`dp[i] =min(dp[i]，dp[i-j*j]+1)` \n\n其实也是将整数拆分，不过拆分的时候按照 **完全平方数** 来拆分，完全平方数的肯定是 1 所以最后要加个 1\n\n```java\npublic static int numSquares(int n) {\n    int[] dp=new int[n+1];\n    dp[0]=0;\n    for (int i=1;i<=n;i++) {\n        dp[i]=Integer.MAX_VALUE; //dp[i] 初始化\n        for (int j=1;i>=j*j;++j){\n            dp[i]=Math.min(dp[i],dp[i-j*j]+1);\n        }\n    }\n    return dp[n];\n}\n```\n50%左右，看了下时间复杂度应该是 `O(N^1.5)`  还是挺高的（评论区用 Py 的都超时了）\n\n**解法二**\n\nBFS，将数字按照完全平方数连接为一个图，然后 BFS 求一个从 n 到 0 的最短的路径\n\n```java\npublic static int numSquares(int n) {\n    Queue<Pair> queue=new LinkedList<>();\n    boolean[] visit=new boolean[n+1];\n    queue.add(new Pair(n,0));\n    visit[n]=true;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        int num=pair.num;\n        int step=pair.step;\n        if (num==0) {\n            return step;\n        }\n        for (int i=1;i*i<=num;i++) {\n            int temp=num-i*i;\n            if (!visit[temp]) {\n                queue.add(new Pair(temp,step+1));\n                visit[temp]=true;\n            }\n        }\n    }\n    return -1;\n}\n\nstatic class Pair{\n    public int step;\n    public int num;\n    public Pair(int num,int step){\n        this.num=num;\n        this.step=step;\n    }\n}\n```\n\n这题最快的做法应该是利用 **四平方和定理** 我也不太清楚，所以暂时先不研究这种做法\n\n## [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)\n\n一条包含字母 A-Z 的消息通过以下方式进行了编码：\n\n```java\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n```\n\n给定一个只包含数字的非空字符串，请计算解码方法的总数。\n\n**示例 1:**\n\n```java\n输入：\"12\"\n输出：2\n解释：它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n```\n\n**示例 2:**\n\n```java\n输入：\"226\"\n输出：3\n解释：它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n```\n\n**解法一**\n\n哇，这题我吐了，好不容易看出来了递推公式，被边界给整死了。面向测试用例编程。\n\n```java\npublic static int numDecodings(String s) {\n    if (s.startsWith(\"0\")) {\n        return 0;\n    }\n    int[] s_nums=new int[s.length()];\n    for (int i=0;i<s.length();i++) {\n        s_nums[i]=Integer.valueOf(s.charAt(i)-48);\n    }\n\n    int[] dp =new int[s_nums.length];\n    Arrays.fill(dp,1);\n    dp[0]=1;\n    int res=1;\n    for (int j=1;j<s_nums.length;j++) {\n        if(s_nums[j]==0 && s_nums[j-1]==0 || (s_nums[j]==0 && s_nums[j-1]>2)){\n            //直接 return\n            return 0;\n        }\n        if( s_nums[j]==0 || s_nums[j-1]==0 || (j<s_nums.length-1 &&s_nums[j+1]==0)){\n            //为了处理 12120 这种情况\n            res*=dp[j-1];\n            continue;\n        }\n        if(s_nums[j-1]*10+s_nums[j]<=26){\n            if(j==1){\n                dp[j]=2;\n            }else{\n                dp[j]=dp[j-1]+dp[j-2];    \n            }\n        }else{\n            //划分点。\n            res*=dp[j-1];\n            dp[j-1]=1;\n            dp[j]=1;\n        }\n    }\n    //最后一段\n    res*=dp[s_nums.length-1];\n    return res;\n}\n```\n\n首先要推出这题的递推公式，我也是在纸上画了半天才看出来，如果这个数组前后两个元素之和都是小于 26 的那么这一段的编码方式就是一个**斐波拉契数列** ，也就是 `dp[i]=dp[i-1]+dp[i-2]`\n\n80%左右，这题其实一开始并不是这样做的，我觉得我开始的思路还是挺好的，将字符串分段，当前一个和后一个无法合并的时候就作为一个分界点，最后将每一段的编码方式相乘就是结果了。\n\n但是 ！！！ 我忽略了 0 这个东西了，这题后面给的 case 里面都是带有 0 的！！！！处理这个边界处理了一上午终于跑过了。代码也没什么好说的，写的太烂了，这种代码没啥意义，都是走一步看一步。\n\n**解法二**\n\n```java\npublic static int numDecodings2(String s) {\n    if (s.startsWith(\"0\")) {\n        return 0;\n    }\n    int[] s_nums=new int[s.length()];\n    for (int i=0;i<s.length();i++) {\n        s_nums[i]=Integer.valueOf(s.charAt(i)-48);\n    }\n    int[] dp=new int[s.length()+1];\n    dp[0]=1;\n    dp[1]=1;\n    for (int i=2;i<=s.length();i++) {\n        int a=s_nums[i-1];\n        if(a!=0){\n            //到这里 dp[i]==0, 没有初始化，默认就是 0\n            //其实等价于 dp[i]=dp[i-1], 延续前一个字符的状态\n            dp[i]+=dp[i-1];\n        }\n\n        if(s_nums[i-2]==0){\n            //如果前前一个字符为 0 那么就不用 dp 了，保持 i-1 的状态就 OK\n            continue;\n        }\n\n        //前前一个字符和\n        int b=s_nums[i-2]*10+s_nums[i-1];\n        if(b<=26){\n            dp[i]+=dp[i-2]; //上下这两个 dp 必须执行一个否则最后就 return 0\n        }\n    }\n    return dp[s_nums.length];\n}\n```\n\n这种写法就清晰多了，分析各种情况，dp 代表截至字符的编码方式\n\n💬  `s_num[i-1]!=0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] <=26`  \n\n类似于 **112**  这样的，这就是正常 dp 的情况符合斐波拉契数列\n\n💬  `s_num[i-1]==0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] <=26`\n\n类似于 **102** 这样的，这样就直接`继承 dp[i-2] 的状态`就行了，相当于`dp[i]=dp[i-2]`\n\n💬  `s_num[i-1]!=0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] >26`\n\n类似于 **132** 这样的，这样就直接`继承 dp[i-2] 的状态`就行了，相当于`dp[i]=dp[i-2]`\n\n💬 `s_num[i-1]!=0 && s_num[i-2]==0 && s_num[i-2]+s_num[i-1] <=26`\n\n类似于 **...012 **这样的，`dp[i]=dp[i-1]`\n\n💬 `s_num[i-1]==0 && s_num[i-2]==0` 或者`s_num[i-1]==0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1]>26`\n\n类似于** 00** 和** 30** 这样的， 这样就代表这个字符串无法编码了 **dp[i]=0** 最后返回的就是 0\n\n## [面试题 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)\n\n给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n\n**示例 1:**\n\n```java\n输入：12258\n输出：5\n解释：12258 有 5 种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\"\n```\n\n**提示：**\n\n- `0 <= num < 231`\n\n**解法一**\n\n代码比较丑，逻辑还是比较清晰，其实这题算是上面 [91. 解码方法](#91-解码方法)的弱化没有了 0 的限制，0 是合法的数字，这样就舒服多了，上面解码方法确实做的脑壳疼\n\n```java\npublic int translateNum(int num) {\n    String s=String.valueOf(num);\n    int len=s.length();\n    if(len==0 || len==1) return 1;\n    int[] dp=new int[len];\n    //1 2 2 5 8\n    //1 2 3 5 5\n    dp[0]=1;\n    dp[1]=Integer.valueOf(s.substring(0,2))>25?1:2;\n    for(int i=2;i<len;i++){\n        int pre=Integer.valueOf(s.charAt(i-1))-48;\n        int cur=Integer.valueOf(s.charAt(i))-48;\n        if(pre!=0 && Integer.valueOf(pre*10+cur)<=25){\n            dp[i]=dp[i-1]+dp[i-2];\n        }else{\n            dp[i]=dp[i-1];\n        }\n    }\n    return dp[len-1];\n}\n```\n\n## [5375. 恢复数组](https://leetcode-cn.com/problems/restore-the-array/)\n\n某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。\n\n给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。\n\n按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。\n\n由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。\n\n**示例 1：**\n\n```java\n输入：s = \"1000\", k = 10000\n输出：1\n解释：唯一一种可能的数组方案是 [1000]\n```\n\n**示例 2：**\n\n```java\n输入：s = \"1000\", k = 10\n输出：0\n解释：不存在任何数组方案满足所有整数都 >= 1 且 <= 10 同时输出结果为 s 。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"1317\", k = 2000\n输出：8\n解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]\n```\n\n**示例 4：**\n\n```java\n输入：s = \"2020\", k = 30\n输出：1\n解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 > 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。\n```\n\n**示例 5：**\n\n```java\n输入：s = \"1234567890\", k = 90\n输出：34\n```\n\n**提示：**\n\n- 1 <= s.length <= 10^5.\n- s 只包含数字且不包含前导 0 。\n- 1 <= k <= 10^9.\n\n**解法一**\n\n24th 双周赛的 T4，其实 dp 的状态转换还是想出来了，我想的是从左向右，但是细节没理清楚，瞄了一眼评论区，发现从右往左比较简单\n\n```java\npublic int numberOfArrays(String s, int k) {\n    int mod=1_000_000_000 + 7;\n    int[] dp=new int[s.length()+1];        \n    dp[0]=1;\n    //dp[i]=dp[i-1]+dp[i-2]+...+dp[0];\n    for (int i=1;i<=s.length();i++) {\n        for (int j=i-1;j>=0 && i-j<=9;j--) {\n            if(s.charAt(j)!='0' && valid(s,j,i,k)){ //验证右边是否满足\n                dp[i]=(dp[i]+dp[j])%mod;\n            }\n        }\n    }\n    return dp[s.length()];\n}\n\n//10 0000 0000\npublic boolean valid(String s,int j,int i,int k){\n    long value=Long.valueOf(s.substring(j,i));\n    return value<=k && value>=1;\n}\n```\n我开始以为时间复杂度是`O(N^2)`会 T 掉，后来写出来才发现其实时间复杂度其实是`O(10N)` ，并不难，还是题目写少了啊！！！\n\n**解法二**\n\n一点小优化\n\n```java\npublic int numberOfArrays(String s, int k) {\n    int mod=1_000_000_000 + 7;\n    int[] dp=new int[s.length()+1];        \n    dp[0]=1;\n    for (int i=1;i<=s.length();i++) {\n        for (int j=i-1;j>=0 && i-j<=9;j--) {\n            if(s.charAt(j)=='0') continue;\n            long value=Long.valueOf(s.substring(j,i));\n            if(value>k) break; //这一步其实是对上面解法的优化\n            dp[i]=(dp[i]+dp[j])%mod;\n        }\n    }\n    return dp[s.length()];\n}\n```\n## [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n**示例：**\n\n```java\n输入：[10,9,2,5,3,7,101,18]\n输出：4 \n解释：最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n```\n\n**说明：**\n\n- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n- 你算法的时间复杂度应该为 O(n2) 。\n- 进阶：你能将算法的时间复杂度降低到 O(n log n) 吗？\n\n**解法一**\n\nLIS，这题好像在很多地方见到过了，还是要好好理解下，**dp[i] 表示以当前元素结尾的最长上升子序列的长度**\n\n```java\npublic static int lengthOfLIS(int[] nums) {\n    if (nums==null||nums.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[nums.length];\n    //Arrays.fill(dp,1);\n    dp[0]=1;\n    for (int i=1;i<nums.length;i++) {\n        dp[i]=1; //初始化 dp[i]=1\n        for (int j=0;j<i;j++) {\n            if(nums[i]>nums[j]){\n                //遍历 i 之前的元素，找一个最大的 dp[j]+1\n                dp[i]=Math.max(dp[j]+1,dp[i]);\n            }\n        }\n    }\n    int res=-1;\n    for (int i=0;i<dp.length;i++) {\n        res=res>dp[i]?res:dp[i];\n    }\n    return res;\n}\n```\n\n一开始题目就没看清楚就开始做，以为是连续的，心想这不是 O(N) 的么，为啥要我写 O(N^2) 的🤣 \n\n![mark](http://static.imlgw.top/blog/20190824/86VLMN8VWcpI.png?imageslim)\n\n灵魂画手，其实也是一道很简单的 DP（然而我还是没想出来），但是时间复杂度比较高 O(N^2)，可以优化成 O(NlogN)\n\n**解法二**\n\n`贪心+二分`  这个贪心还是有点骚的，核心思想：\n\n**如果前面的数越小，后面接上一个随机数，就会有更大的可能性构成一个更长的“上升子序列”。**\n\n定义`tail`数组，`tail[i]`中存储长度为 `i + 1` 的最长递增子序列的最后一个元素，所以我们要做的就是维护 tail 数组，使得各个长度的`tail[i]`的尽可能地小，这样后面能接的长度就越长，很明显 tail 是个单调递增的数组（反证）所以我们可以在遍历 nums 的时候在 tail 数组中二分寻找第一个大于 nums[i] 的元素，用 nums[i] 替换该位置的元素，这样就使得`tail[i]`是当前 nums[i] 之前，长度为 i+1 的递增序列最小的结尾元素，当我们遍历完所有的元素，tail 数组的长度就是我们要求的最长递增子序列长度（注意 tail 不一定是合法的最长递增子序列，如果要求出子序列可以在长度增加的时候拷贝一份长度为`i-1`的数组，然后再操作）\n\n2020.3.20\n\n```java\npublic static int lengthOfLIS(int[] nums) {\n    int[] top = new int[nums.length];\n    int len = 0;\n    for (int num : nums) {\n        //寻找左侧最小的堆顶\n        int index=binarySearch(top,len,num);\n        if (index == len) {\n            len++;\n        }\n        top[index] = num;\n    }\n    return len;\n}\n\n//可以搜索\nprivate static int binarySearch(int[] nums, int len, int target) {\n    int left=0,right=len;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]<target){\n            left=mid+1;\n        }else {\n            right=mid;\n        }\n    }\n    return left;\n}\n```\n首先是记住了这个套路，然后优化了二分的写法\n\n![mark](http://static.imlgw.top/blog/20200320/zhcxcxmK4Amt.png?imageslim)\n\n（copy 自从 liweiwei 大佬 [题解](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/)）\n\n## [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)\n\n给定一个未排序的整数数组，找到最长递增子序列的个数。\n\n**示例 1:**\n\n```java\n输入：[1,3,5,4,7]\n输出：2\n解释：有两个最长递增子序列，分别是 [1, 3, 4, 7] 和 [1, 3, 5, 7]。\n```\n\n**示例 2:**\n\n```java\n输入：[2,2,2,2,2]\n输出：5\n解释：最长递增子序列的长度是 1，并且存在 5 个子序列的长度为 1，因此输出 5。\n```\n\n**注意：** 给定的数组长度不超过 2000 并且结果一定是 32 位有符号整数。\n\n**解法一**\n\n一开始还没想到，属实菜鸡\n\n```java\npublic int findNumberOfLIS(int[] nums) {\n    int n=nums.length;\n    //dp[i][0] 结尾的最长递增子序列，dp[i][1] 代表个数\n    int[][] dp=new int[n][2];\n    int max=0;\n    for(int i=0;i<n;i++){\n        dp[i][1]=1;\n        for(int j=0;j<i;j++){\n            if(nums[i]>nums[j]){\n                if(dp[j][0]+1==dp[i][0]){\n                    dp[i][1]+=dp[j][1];\n                }else if(dp[j][0]+1>dp[i][0]){\n                    dp[i][1]=dp[j][1];\n                    dp[i][0]=dp[j][0]+1;\n                }\n            }\n        }\n        max=Math.max(max,dp[i][0]);\n    }\n    int res=0;\n    for(int i=0;i<nums.length;i++) {\n        res+=dp[i][0]==max?dp[i][1]:0;   \n    }\n    return res;\n}\n```\n\n## [1016. 使序列递增的最小交换次数（LintCode）](https://www.lintcode.com/problem/minimum-swaps-to-make-sequences-increasing/description)\n\n有两个具有相同非零长度的整数序列 A 和 B。可以交换它们的一些元素 A[i] 和 B[i]。 注意，两个可交换的元素在它们各自的序列中处于相同的索引位置。进行一些交换之后，A 和 B 需要严格递增。 （当且仅当 A[0] < A[1] < A[2] < ... < A[A.length - 1] 时，序列严格递增。）\n\n给定 A 和 B，返回使两个序列严格递增的最小交换次数。 保证给定的输入经过交换可以满足递增的条件。\n\n**注意**\n- A, B 是长度相同的数组，它们的长度范围为 [1, 1000]。\n- A[i], B[i] 是在 [0, 2000] 范围内的整数。\n\n**样例 1**\n```go\n输入：A = [1,3,5,4], B = [1,2,3,7]\n输出：1\n解释：交换 A[3] and B[3]. 两个序列变为：\n  A = [1,3,5,7] 和 B = [1,2,3,4],\n  此时它们都是严格递增的。\n```\n**样例 2:**\n```go\n输入：A = [2,4,5,7,10], B = [1,3,4,5,9]\n输出：0\n```\n\n**解法一**\n\n直接抄答案，很巧妙的双序列型 dp，不看答案真想不出来\n```java\npublic int minSwap(int[] A, int[] B) {\n    if (A == null || B == null || A.length <=0 || B.length <= 0){\n        return 0;\n    }\n    // Write your code here\n    int n = A.length;\n    int INF = 0x3f3f3f3f;\n    //dp[i][0]: A 和 B 前 i 个字符都保持有序，并且不交换第 i 个元素的最小交换次数\n    //dp[i][1]: A 和 B 前 i 个字符都保持有序，并且交换第 i 个元素的最小交换次数\n    int[][] dp = new int[n][2];\n    for(int i = 0; i < n; i++){\n        Arrays.fill(dp[i], INF);\n    }\n    dp[0][0] = 0; dp[0][1] = 1;\n    for(int i = 1; i < n; i++){\n        //很巧妙的分类讨论\n        if(A[i] > A[i-1] && B[i] > B[i-1]){\n            //前后都不交换\n            dp[i][0] = dp[i-1][0];\n            //前后都交换\n            dp[i][1] = dp[i-1][1]+1; \n        }\n        if(A[i] > B[i-1] && B[i] > A[i-1]){\n            //当前不交换，交换前面的\n            dp[i][0] = Math.min(dp[i][0], dp[i-1][1]);\n            //当前交换，前面不交换\n            dp[i][1] = Math.min(dp[i][1], dp[i-1][0]+1);\n        }\n    }\n    int res = Math.min(dp[n-1][0],dp[n-1][1]);\n    return  res == INF ? 0 : res;\n}\n```\n\n## [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)\n\n给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 `(w, h)` 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。\n\n请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。\n\n**说明：**\n不允许旋转信封。\n\n**示例：**\n\n```java\n输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]\n输出：3 \n解释：最多信封的个数为 3, 组合为：[2,3] => [5,4] => [6,7]。\n```\n\n**解法一**\n\n```java\npublic int maxEnvelopes(int[][] envelopes) {\n    int [] dp=new int[envelopes.length];\n    //lamdba 会比较慢\n    Arrays.sort(envelopes,(a,b)->(a[0]-b[0])); //保证后面的不会被前面的装进去就行了\n    int res=0;\n    for (int i=0;i<envelopes.length;i++) {\n        dp[i]=1;\n        for (int j=0;j<i;j++) {\n            if (envelopes[i][0]>envelopes[j][0] && envelopes[i][1]>envelopes[j][1]){\n                dp[i]=Math.max(dp[j]+1,dp[i]);\n            }\n        }\n        res=Math.max(res,dp[i]);\n    }\n    return res;\n}\n```\n其实和上面的 LIS 是一样的，所以我放在了一起，差点 bugfree，被空输入坑了一发，可惜这个解法并不是最优解，而且也不符合这题的困难 tag，这题的最优解应该是利用上面的贪心+二分的做法，这里实在是能力时间都有限，没法去研究那种解法，暂且先用这个解法吧\n\n**解法二**\n\n2020.3.20 阿里笔试考了这一题，dp 超时了。\n\n```java\npublic int maxEnvelopes(int[][] envelopes) {\n    Arrays.sort(envelopes,(a,b)->a[0]!=b[0]?a[0]-b[0]:b[1]-a[1]); //这个排序很关键\n    int N=envelopes.length;\n    int[] top=new int[N];\n    int len=0;\n    for(int i=0;i<N;i++){\n        int cur=envelopes[i][1];\n        //二分搜索堆顶，找第一个小于当前牌的\n        int index=binarySearch(top,cur,len);\n        if(index==len){ //没找到合适的位置\n            len++; //新建牌堆，牌堆++\n        }\n        top[index]=cur;\n    }\n    return len;\n}\n\npublic int binarySearch(int[] top,int target,int len){\n    int left=0,right=len;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(top[mid]<target){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left;\n}\n```\n\n第一步的排序很关键，如果只按照宽度排好序之后，对高度求一次最长递增子序列就是我们的答案，但是有一个问题就是题目说了：宽度和高度都比当前信封大的时候才能装进去，如果有两个信封是`(1,3) (1,5)`那么前者是不能被后者装进去的，所以我们需要在这里做一下处理，在宽度相同的时候，让高度降序排列，这样在对高度求最递增子序列的时候就不会出现错误了\n\n**UPDATE: 2020.7.13**\n```golang\nfunc maxEnvelopes(env [][]int) int {\n    sort.Slice(env, func(i int, j int) bool {\n        if env[i][0] == env[j][0]{\n            return env[i][1] > env[j][1]\n        }\n        return env[i][0] < env[j][0]\n    })\n    var tail = make([]int, len(env))\n    var tlen = 0\n    for i := 0; i < len(env); i++{\n        idx := search(tail, env[i][1], tlen)\n        if idx == tlen{\n            tlen++\n        }\n        tail[idx] = env[i][1]\n    }\n    return tlen\n}\n\nfunc search(nums []int, target int, tlen int) int {\n    var left = 0\n    var right = tlen-1\n    var res = tlen\n    for left <= right{\n        mid := left+(right-left)/2\n        if nums[mid] >= target{\n            res = mid\n            right = mid - 1\n        }else{\n            left = mid + 1\n        }\n    }\n    return res\n}\n```\n\n## [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)\n\n给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**示例：**\n\n```java\n输入：[-2,1,-3,4,-1,2,1,-5,4],\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n**进阶：**\n\n如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。\n\n**解法一**\n\n动态规划递推的解法，没啥好说的，这题其实还有一道姊妹题，要求出最大子序列，不仅仅是最大值，[我放到了滑动窗口专题中]((http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou-tag/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC)) \n\n```java\n//这次是直接在 Web 上写的\npublic int maxSubArray(int[] nums) {\n    if(nums==null || nums.length==0){\n        return 0;\n    }\n    int[] dp=new int[nums.length];\n    //一开始没处理好 Wa 了一发\n    int max=dp[0]=nums[0];\n    for(int i=1;i<nums.length;i++){\n        if(dp[i-1]<=0){\n            dp[i]=nums[i];\n        }else{\n            dp[i]=dp[i-1]+nums[i];\n        }\n        max=Math.max(max,dp[i]);\n    }\n    return max;\n}\n```\n**解法二**\n\n根据二维改一维\n\n```java\npublic int maxSubArray(int[] nums) {\n    if(nums==null || nums.length==0){\n        return 0;\n    }\n    int dp1=nums[0],dp2=0,max=nums[0];\n    for (int i=1;i<nums.length;i++) {\n        if (dp1<=0) {\n            dp2=nums[i];\n        }else{\n            dp2=dp1+nums[i];\n        }\n        dp1=dp2;\n        max=Math.max(max,dp2);\n    }\n    return max;\n}\n```\n\n感觉一维的不用去理解含义，能根据二维改出来就 ok 了，重点是理解多维的\n\n## [646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)\n\n给出 `n` 个数对。 在每一个数对中，第一个数字总是比第二个数字小。\n\n现在，我们定义一种跟随关系，当且仅当 `b < c` 时，数对`(c, d)` 才可以跟在 `(a, b)` 后面。我们用这种形式来构造一个数对链。\n\n给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。\n\n**示例 :**\n\n```java\n输入：[[1,2], [2,3], [3,4]]\n输出：2\n解释：最长的数对链是 [1,2] -> [3,4]\n```\n\n**注意：**\n\n- 给出数对的个数在 [1, 1000] 范围内。\n\n**解法一**\n\n动态规划\n\n```java\npublic int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs,(a,b)->a[0]-b[0]);\n    int[] dp=new int[pairs.length];\n    int res=0;\n    for (int i=0;i<pairs.length;i++) {\n        dp[i]=1;\n        for (int j=0;j<i;j++) {\n            if (pairs[i][0]>pairs[j][1]) {\n                dp[i]=Math.max(dp[i],dp[j]+1);\n            }\n        }\n        res=res>dp[i]?res:dp[i];\n    }\n    return res;\n}\n```\n注意这里没有要求顺序，所以先给他排个序，然后再进行 DP，如果不排序很难 dp，dp[i] 表示当前数对能构成的最长链，dp 过程和上面的最长上升子序列相同\n\n**解法二**\n\n贪心，也是最优解，同样先排序，不过是按照第二个元素来排序，核心思想\n\n`每次都在列表中找第二个元素最小的数对依次组成链，最后得到的一定是最长的链`\n\n```java\npublic int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs,(a,b)->a[1]-b[1]);\n    int res=1;\n    int tail=pairs[0][1];\n    for (int i=1;i<pairs.length;i++) {\n        if (pairs[i][0]>tail) {\n            res++;\n            tail=pairs[i][1];\n        }\n    }\n    return res;\n}\n```\n**解法三**\n\n也就是上面说的分治法，分治法在这里并不是最优解，时间复杂度`O(NlogN)`，但是思路还是很巧妙，首先也是讲数组一分为二，然后最大序列和就有三种情况\t\n\n1. 全在左边\n2. 全在右边\n3. 跨中点，两边都有\n\n然后统计三个值得最大值，递归子过程求解，代码就不写了，后面想起来有时间再补\n\n## [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。\n\n例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反，`[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n\n**示例 1:**\n\n```java\n输入：[1,7,4,9,2,5]\n输出：6 \n解释：整个序列均为摆动序列。\n```\n\n**示例 2:**\n\n```java\n输入：[1,17,5,10,13,15,10,5,16,8]\n输出：7\n解释：这个序列包含几个长度为 7 摆动序列，其中一个可为 [1,17,10,13,10,16,8]。\n```\n\n**示例 3:**\n\n```java\n输入：[1,2,3,4,5,6,7,8,9]\n输出：2\n```\n\n**进阶：**\n\n- 你能否用 O(n) 时间复杂度完成此题？\n\n**解法一**\n\nO(N^2 ) 动态规划，dp[i] 代表目前为止以 nums[i] 结尾的最长的`上升摇摆序列`，down[i] 代表目前为止以 nums[i] 结尾的最长的`下降摇摆序列`，后面过程就和上面的`LIS`的解法类似了\n\n```java\npublic int wiggleMaxLength(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int []up=new int[nums.length]; \n    int []down=new int[nums.length]; \n    for (int i=0;i<nums.length;i++) {\n        up[i]=1; down[i]=1; //初始化\n        for (int j=0;j<i;j++) {\n            if(nums[i]>nums[j]){\n                //找一个最大的下降沿\n                up[i]=Math.max(up[i],down[j]+1);\n            }else if(nums[i]<nums[j]){\n                //找一个最大的上升沿\n                down[i]=Math.max(down[i],up[j]+1);\n            }\n        }\n    }\n    return Math.max(up[nums.length-1],down[nums.length-1]);\n}\n```\n**解法二**\n\n线性动态规划，其实上面的循环找最大操作有点多余，如果`nums[i]>nums[i-1]` 那么以 nums[i] 为上升沿结尾（摆动上升）的最长摇摆序列 `up[i]=down[i-1]+1`\n\n```java\npublic int wiggleMaxLength2(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int []up=new int[nums.length];\n    int []down=new int[nums.length];\n    up[0]=down[0]=1;\n    for (int i=1;i<nums.length;i++) {\n        if(nums[i]>nums[i-1]){\n            up[i]=down[i-1]+1;\n            down[i]=down[i-1];\n        }else if(nums[i]<nums[i-1]){\n            down[i]=up[i-1]+1;\n            up[i]=up[i-1];\n        }else{\n            //相等的时候别忘了继承前面的状态\n            down[i]=down[i-1];\n            up[i]=up[i-1];\n        }\n    }\n    return Math.max(up[nums.length-1],down[nums.length-1]);\n}\n```\n\n我感觉能写出 O(1) 的前提是先写出 O(N) 的，写出 O(N) 的之后再改成 O(1) 会比较简单\n\n```java\npublic int wiggleMaxLength(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int up=1;\n    int down=1;\n    for (int i=1;i<nums.length;i++) {\n        if (nums[i]>nums[i-1]) {\n            up=down+1;\n        }else if (nums[i]>nums[i-1]){\n            down=up+1;\n        }//else 就是不变\n    }\n    return Math.max(up,down);\n}\n```\n\n## [978. 最长湍流子数组](https://leetcode-cn.com/problems/longest-turbulent-subarray/)\n\n当 `A` 的子数组 `A[i], A[i+1], ..., A[j]` 满足下列条件时，我们称其为*湍流子数组*：\n\n- 若 `i <= k < j`，当 `k` 为奇数时， `A[k] > A[k+1]`，且当 `k` 为偶数时，`A[k] < A[k+1]`；\n- **或** 若 `i <= k < j`，当 `k` 为偶数时，`A[k] > A[k+1]` ，且当 `k` 为奇数时， `A[k] < A[k+1]`。\n\n也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。（上面的是废话）\n\n返回 `A` 的最大湍流子数组的**长度**。\n\n**示例 1：**\n\n```java\n输入：[9,4,2,10,7,8,8,1,9]\n输出：5\n解释：(A[1] > A[2] < A[3] > A[4] < A[5])\n```\n\n**示例 2：**\n\n```java\n输入：[4,8,12,16]\n输出：2\n```\n\n**示例 3：**\n\n```java\n输入：[100]\n输出：1\n```\n\n**提示：**\n\n1. `1 <= A.length <= 40000`\n2. `0 <= A[i] <= 10^9`\n\n**解法一**\n\n在滑窗 tag 里发现的，一直没往 dp 上想，看了评论区才发现😂，这题其实是上面 [376. 摆动序列](#376-摆动序列)的弱化，这里是要求连续的，但是做法还是一样的\n\n```java\n//动态规划，从滑窗 tag 过来的。.. 没往 dp 上想，看了评论区才想起来\npublic int maxTurbulenceSize(int[] A) {\n    if(A==null || A.length<=0){\n        return 0;\n    }\n    int up=1,down=1;\n    int res=1;\n    for (int i=1;i<A.length;i++) {\n        if(A[i]>A[i-1]){\n            up=down+1;\n            down=1;\n        }else if (A[i]<A[i-1]){\n            down=up+1;\n            up=1;\n        }else{\n            up=1;down=1;\n        }\n        res=Math.max(res,Math.max(up,down));\n    }\n    return res;\n}\n```\n\n**解法二**\n\n滑窗，也是一开始的做法，比较简单\n\n```java\n//优化 if 条件\npublic int maxTurbulenceSize(int[] A) {\n    if(A==null || A.length<=0){\n        return 0;\n    }\n    int left=0;\n    int res=1;\n    for(int right=left+1;right<A.length;right++){\n        if(A[right]==A[right-1]){ //跳过相等的\n            left=right;\n            continue;\n        }\n        //优化了 if 条件，之前看别人题解学到的\n        if(right>=2 && (A[right]>A[right-1])==(A[right-1]>A[right-2])){\n            left=right-1; //left 跳到中间值\n        }\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n## [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)\n\nGiven *n*, how many structurally unique **BST's** (binary search trees) that store values 1 ... *n*?\n\n**Example:**\n\n```java\nInput: 3\nOutput: 5\nExplanation:\nGiven n = 3, there are a total of 5 unique BST's:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n```\n\n**解法一**\n\n这个解法实际上来自 [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n```java\npublic static int numTrees(int n) {\n    return generateTree(1,n).size();\n}\n\npublic static List<TreeNode> generateTree(int start,int end){\n    List<TreeNode> res=new ArrayList<>();\n    if (start>end) {\n        res.add(null);\n        return res;\n    }\n    for (int i=start;i<=end;i++) {\n        List<TreeNode> left=generateTree(start,i-1);\n        List<TreeNode> right=generateTree(i+1,end);\n        for (TreeNode l:left) {\n            for (TreeNode r:right) {\n                TreeNode currentNode=new TreeNode(i);\n                currentNode.left=l;\n                currentNode.right=r;\n                res.add(currentNode);\n            }\n        }\n    }\n    return res;\n}\n```\n这种写法很明显过不了这题，时间复杂度太高了，但是这个方法可以求出所有的 BST 集合。\n\n**解法二**\n\n动态规划，`dp[i]`代表长度为 `i` 的递增序列构成的不同的 BST 的数量（序列从`1 到 i` 递增）\n\n递推公式：`dp[i]=dp[i-1]* dp[n-i]`\n\n```java\npublic int numTrees(int n) {\n    if (n<=1) {\n        return 1;\n    }\n    int []dp=new int[n+1];\n    dp[0]=1;\n    dp[1]=1;\n    for (int i=2;i<=n;i++) { //控制序列长度 直到我们求得 n\n        for (int j=1;j<=i;j++) { //控制根的选择\n            //累加和，j 为根节点 dp[j-1] 代表左子树数量，dp[i-j] 代表右子树数量\n            dp[i]+=dp[j-1]*dp[i-j];\n        }\n    }\n    return dp[n];\n}\n```\n\n以 `i` 位置元素为根节点，可以得出可能的 BST 数量为，`[1 ~ i-1]` 可以构成的 BST 数量 乘以  `[i+1，n]`可以构成的 BST 数量，也就是_左子树  *  右子树_  ，再推广到整个序列的 BST 总数，其实也就是 **以每个元素为根节点构成的 BST 的数量之和** ，需要理解的地方就是`dp[i]` 的含义，明确本题中`dp[i]` 其实**只和长度 `i`有关**而和内容无关，比如 1，2，3 和 4，5，6 所能构成的 BST 数量其实是相同的\n\n**解法三**\n\n卡塔兰数，递推式 `Gn+1 =2(2n+1)/ n+2  *  Gn`\n\n```java\npublic int numTrees3(int n) {\n    long C = 1;\n    for(int i = 0; i < n; ++i){\n        C = C * 2 * (2 * i + 1) /(i + 2);\n    }\n    return (int) C;\n}\n```\n\n## [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)\n\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n```java\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n```\n\n自顶向下的最小路径和为 `11`（即，2 + 3 + 5 + 1 = 11）。\n\n**说明：**\n\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分\n\n**解法一**\n\n二维 dp，emmm，一开始写成贪心了。贪心明显是错的\n\n```java\n//dp 做法 O(N^2) 空间\npublic int minimumTotal(List<List<Integer>> triangle) {\n    int rows=triangle.size();\n    //dp[i][j] 代表的是每 i 层第 j 个元素到最底层的最短距离\n    int[][] dp=new int[rows+1][rows+1]; //row+1\n    /*for (int i=0;i<triangle.get(rows-1).size();i++) {\n        //给最后一行赋初始值\n        dp[rows-1][i]=triangle.get(rows-1).get(i);\n    }\n    for (int i=rows-2;i>=0;i--) {\n        for (int j=0;j<triangle.get(i).size();j++) {\n            //核心递推式 dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle(i)(j)\n            dp[i][j]=Math.min(dp[i+1][j],dp[i+1][j+1])+triangle.get(i).get(j);\n        }\n    }*/\n    //直接从最后一行开始，这样就不用手动给最后一行赋初始值了\n    for (int i=rows-1;i>=0;i--) {\n        for (int j=0;j<triangle.get(i).size();j++) {\n            //核心递推式 dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle(i)(j)\n            dp[i][j]=Math.min(dp[i+1][j],dp[i+1][j+1])+triangle.get(i).get(j);\n        }\n    }\n    return dp[0][0];\n}\n```\n**解法二**\n\n记忆化递归，也很快\n\n```java\n//记忆化递归\npublic int minimumTotal2(List<List<Integer>> triangle) {\n    //用 Integer 比较好，方便判空\n    Integer [][] cache=new Integer[triangle.size()][triangle.size()];\n    return minimumTotal(triangle,0,0,cache);\n}\n\npublic int minimumTotal(List<List<Integer>> triangle,int cen,int index,Integer[][]cache) {\n    if (cache[cen][index]!=null) {\n        return cache[cen][index];\n    }\n    if (cen==triangle.size()-1) {\n        return triangle.get(cen).get(index);\n    }\n    int left=minimumTotal(triangle,cen+1,index,cache);\n    int right=minimumTotal(triangle,cen+1,index+1,cache);\n    return cache[cen][index]=triangle.get(cen).get(index)+(left<right?left:right);\n}\n```\n**解法三**\n\n```java\n//dp O(N) 空间\npublic int minimumTotal(List<List<Integer>> triangle) {\n    int rows=triangle.size();\n    //dp[i] 代表的是每一层第 i 个元素到最底层的最短距离\n    //上面二维 dp 实际上也只和下一层的状态有关，所以我们可以重复的使用这个数组保存每一层的状态\n    int[] dp=new int[rows+1];\n    for (int i=rows-1;i>=0;i--) {\n        for (int j=0;j<triangle.get(i).size();j++) {\n            //到这里其实 Math.min() 里面的都是上一次循环的结果\n            //也就是下一层的，对应当前 j 位置左右两个相邻节点的最小距离\n            dp[j]=Math.min(dp[j+1],dp[j])+triangle.get(i).get(j);\n        }\n    }\n    return dp[0];\n}\n```\nO(N) 空间复杂度，只和下面那一层的每一个元素的 dp[i] 有关，所以可以直接改成一维 dp\n\n**UPDATE: 2020.7.14**\n\n今天的打卡题，写了一个从上而下的 dp，需要处理边界会麻烦一点，和之前的反着的，果然刷题主要还是刷一个感觉，想记住题目解法是不可能的，能锻炼一些思考的能力才是关键\n```golang\nfunc minimumTotal(triangle [][]int) int {\n    if len(triangle) <= 0{\n        return 0\n    }\n    var INF = 1<<31\n    var n = len(triangle)\n    var dp = make([]int, n)\n    for i := 0; i < n; i++{\n        dp[i] = INF\n    }\n    dp[0] = triangle[0][0]\n    var res = INF\n    for i := 1; i < n; i++{\n        for j :=i; j >=0; j--{\n            if j == 0{\n                dp[j] = dp[j] + triangle[i][j]\n            }else if j == i{\n                dp[j] = dp[j-1] + triangle[i][j]\n            }else{\n                dp[j] = Min(dp[j], dp[j-1]) + triangle[i][j]\n            }\n            if i == n-1{\n                res = Min(res, dp[j])\n            }\n        }\n    }\n    if res == INF{\n        return triangle[0][0]\n    }\n    return res\n}\n\nfunc Min(a, b int) int {\n    if a < b{\n        return a\n    }\n    return b\n}\n```\n\n## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你**最多只允许完成一笔交易**（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n\n注意你不能在买入股票前卖出股票。\n\n**示例 1:**\n\n```java\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5  ，注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n```\n\n**示例 2:**\n\n```java\n输入：[7,6,4,3,1]\n输出：0\n解释：在这种情况下，没有交易完成，所以最大利润为 0。\n```\n\n**解法一**\n\n非动态规划的思路，还是挺简单的，求个最大的差值就 ok，因为只能买一次\n\n```java\n//非递归的思路\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int min=Integer.MAX_VALUE,max=0;\n    for (int i=0;i<prices.length;i++) {\n        //当天价格减去 *之前* 价格最低的买入时机\n        max=Math.max(max,prices[i]-min);\n        //统计价格最低的买入时机\n        min=Math.min(min,prices[i]);\n    }\n    return max;\n}\n```\n**解法二**\n\n既然是动态规划的题，自然得写个动态规划的版本\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int[][] dp=new int[prices.length][2];\n    dp[0][0]=0;\n    dp[0][1]= -prices[0];\n    for (int i=1;i<prices.length;i++) {\n        dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+[i]);\n        dp[i][1]=Math.max(dp[i-1][1],-prices[i]);\n    }\n    return dp[prices.length-1][0];\n}\n```\n其实改成一维的就和上面的一模一样了\n\n## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。**你可以尽可能地完成更多的交易**（多次买卖一支股票）。\n\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n**示例 1:**\n\n```java\n输入：[7,1,5,3,6,4]\n输出：7\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。\n随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。\n```\n\n**示例 2:**\n\n```java\n输入：[1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n\n**示例 3:**\n\n```java\n输入：[7,6,4,3,1]\n输出：0\n解释：在这种情况下，没有交易完成，所以最大利润为 0。\n```\n\n**解法一**\n\n正常的思路（非动态规划），注意审题，上面的只能买一次，这里是不限制次数的\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int ans=0;\n    for (int i=1;i<prices.length;i++) {\n        if (prices[i]>prices[i-1]) {\n            ans+=prices[i]-prices[i-1];\n        }\n    }\n    return ans;\n}\n```\n这里的代码还是很有迷惑性的，实际上分了三种情况，有两种合并了\n\n>**单独交易日**：明天比今天价格高，今天买，明天卖\n>\n>**连续上涨交易日**：开始的第一天买 , 涨停的最后一天卖最有利，或者也可以转换成说`除了第一天，每天都卖了又买`，也就是`pn-p1 = (p2-p1)+(p3-p2)+....(pn-pn-1)`  很自然的就转换成了单独交易日的情况\n>**连续下降交易日**：不买卖最有利\n\n如果还是不明白可以看看官方的图\n\n![mark](http://static.imlgw.top/blog/20191017/Wpsvs09EmnmF.png?imageslim)\n\nA->D 是一段连续上涨日，`D-A 的差值` 就是 A->D 各个相邻节点差值之和\n\n**解法二**\n\n我们的主角，动态规划\n\n```java\n//dp 的思路\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int[][] dp=new int[prices.length][2];\n    dp[0][0]=0;\n    dp[0][1]=-prices[0];\n    for (int i=1;i<prices.length;i++) {\n        dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);\n        dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);\n    }\n    return dp[prices.length-1][0];\n}\n```\n第一眼看可能觉得看不懂，熟悉了就知道了，其实都是套路，股票题特有的套路，先考虑题目有几种状态，这题说了不限制次数，那么就不考虑次数的问题，然后剩下的状态就是：那一天，和是否持有股票，所以我们用一个二维的数组来表述这两种状态 比如`dp[i][0]` 则代表第 i 天不持有股票的最大收益，`dp[i][1]`则代表第 i 天持有股票的最大收益，然后我们再看看状态转换的过程\n\n![mark](http://static.imlgw.top/blog/20191017/J7tfvKDvqC2b.png?imageslim)\n\n其实无非就是这两个状态之间的转换，然后根据这个状态转换的过程就可以很轻易的写出我们的状态转换方程\n\n```java\ndp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);\ndp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);\n```\n不过这里其实也很容易就可以改成一唯的 dp，空间复杂度变为 O(1)，因为当天的最大收益只和前一天的最大收益相关，两个变量就是足够表示\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int hlod=-prices[0];\n    int empty=0;\n    for (int i=1;i<prices.length;i++) {\n        //保存前一天的状态\n        int temp=empty;\n        empty=Math.max(empty,hlod+prices[i]);\n        hlod=Math.max(hlod,temp-prices[i]);\n    }\n    return empty;\n}\n```\n这里我感觉 leetcode 的 case 有问题，我开始没有缓存前一天的 empty 值，直接将 empty 带到 hold 去了，结果还过了。不过我懒得去想 case 了，反正提交了 leecode 也不会理我😅\n\n## [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)\n\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n\n**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n**示例 1:**\n\n```java\n输入：[3,3,5,0,0,3,1,4]\n输出：6\n解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n```\n\n**示例 2:**\n\n```java\n输入：[1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n\n**示例 3:**\n\n```java\n输入：[7,6,4,3,1] \n输出：0 \n解释：在这个情况下，没有交易完成，所以最大利润为 0\n```\n\n**解法一**\n\n二维动态规划，定义出每个状态，然后转换就可以了\n\n```java\npublic int maxProfit(int[] prices){\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    //状态定义：\n    //j=0 什么都不做\n    //j=1 第一次买入\n    //j=2 第一次卖出\n    //j=3 第二次买入\n    //j=4 第二次卖出\n    int[][] dp=new int[prices.length][5];\n    //这样会溢出\n    //Arrays.fill(dp[0],Integer.MIN_VALUE);\n    //这样可以过，但是感觉还是判断一下好\n    //Arrays.fill(dp[0],-0x3f3f3f3f);\n    int INF=Integer.MIN_VALUE,n=prices.length;\n    Arrays.fill(dp[0],INF); //不可达状态\n    dp[0][0]=0;\n    dp[0][1]=-prices[0];\n    for(int i=1;i<n;i++){\n        dp[i][0]=0;\n        dp[i][1]=Math.max(-prices[i],dp[i-1][1]);\n        dp[i][2]=Math.max(dp[i-1][1]+prices[i],dp[i-1][2]);\n        dp[i][3]=Math.max(dp[i-1][2]!=INF?dp[i-1][2]-prices[i]:INF,dp[i-1][3]);\n        dp[i][4]=Math.max(dp[i-1][3]!=INF?dp[i-1][3]+prices[i]:INF,dp[i-1][4]);\n    }\n    return Math.max(Math.max(dp[n-1][0],dp[n-1][2]),dp[n-1][4]);\n}\n```\n> 因为题目的数据不是特别大，没有超过`10^9` 直接初始化为 `-0x3f3f3f3f` 就不用判断前面的状态是否可达了，\n\n**解法二**\n\n优化成一维的\n\n```java\npublic int maxProfit(int[] prices){\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[5];\n    int n=prices.length;\n    Arrays.fill(dp,-0x3f3f3f3f);\n    dp[0]=0;\n    dp[1]=-prices[0];\n    for(int i=1;i<n;i++){\n        //逆序递推避免覆盖（其实正着写也是对的，这题相邻的状态不会同时更新，但是为了规范最好还是逆序写）\n        dp[4]=Math.max(dp[3]+prices[i],dp[4]);\n        dp[3]=Math.max(dp[2]-prices[i],dp[3]);\n        dp[2]=Math.max(dp[1]+prices[i],dp[2]);\n        dp[1]=Math.max(-prices[i],dp[1]);\n        dp[0]=0;\n    }\n    return Math.max(Math.max(dp[0],dp[2]),dp[4]);\n}\n```\n## [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)\n\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n**示例 1:**\n\n```java\n输入：[2,4,1], k = 2\n输出：2\n解释：在第 1 天 （股票价格 = 2) 的时候买入，在第 2 天 （股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n```\n\n**示例 2:**\n\n```java\n输入：[3,2,6,5,0,3], k = 2\n输出：7\n解释：在第 2 天 （股票价格 = 2) 的时候买入，在第 3 天 （股票价格 = 6) 的时候卖出，这笔交易所能获得利润 = 6-2 = 4 。\n     随后，在第 5 天 （股票价格 = 0) 的时候买入，在第 6 天 （股票价格 = 3) 的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n```\n\n**解法一**\n\n这题其实就是求上面一题的通解，上面的代码规律已经非常明显了，`j`为奇数的时候买入，偶数的时候卖出，我们统计最后偶数的最大值就可以\n\n```java\npublic int maxProfit(int k, int[] prices) {\n    if (prices==null || prices.length<=0 || k<=0) {\n        return 0;\n    }\n    if(k>prices.length/2){\n        return maxProfit(prices);\n    }\n    //k 次交易，2*k+1 种状态\n    int[] dp=new int[2*k+1];\n    int n=prices.length;\n    int res=0;\n    Arrays.fill(dp,-0x3f3f3f3f);\n    dp[0]=0;\n    dp[1]=-prices[0];\n    for(int i=1;i<n;i++){\n        //注意倒推\n        for(int j=2*k;j>0;j--){\n            if((j&1)==1){\n                dp[j]=Math.max(dp[j-1]-prices[i],dp[j]);\n            }else{\n                dp[j]=Math.max(dp[j-1]+prices[i],dp[j]);\n                res=Math.max(dp[j],res);\n            }\n        }\n    }\n    return res;\n}\n\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int ans=0;\n    for (int i=1;i<prices.length;i++) {\n        if (prices[i]>prices[i-1]) {\n            ans+=prices[i]-prices[i-1];\n        }\n    }\n    return ans;\n}\n```\n**解法二**\n\n正常的 DP 通解\n\n```java\n//常规 2 维解法\npublic int maxProfit(int k, int[] prices) {\n    if (prices==null || prices.length<=0 || k<=0) {\n        return 0;\n    }\n    if(k>prices.length/2){\n        return maxProfit(prices);\n    }\n    //第 k 次交易，持股/不持股\n    int[][] dp=new int[k+1][2];\n    int n=prices.length;\n    int res=0;\n    int INF=-0x3f3f3f3f;\n    for(int i=0;i<=k;i++){\n        Arrays.fill(dp[i],INF);\n    }\n    //其实这题难搞的就是对于初始状态的 init\n    //第一天没有交易和第一天有一次交易的初始值\n    dp[0][0]=0;dp[0][1]=INF;\n    dp[1][0]=0;dp[1][1]=-prices[0];\n    for(int i=1;i<n;i++){\n        //注意倒推\n        for(int j=k;j>0;j--){\n            //这里将买入和卖出作为一个状态，所以这里买入新股票，肯定就是属于下一次交易了\n            //所以这里的 j 需要减一，代表上一次交易卖出时候的收益\n            dp[j][0]=Math.max(dp[j][1]+prices[i],dp[j][0]);\n            dp[j][1]=Math.max(dp[j-1][0]-prices[i],dp[j][1]);\n            res=Math.max(dp[j][0],res);\n        }\n    }\n    return res;\n}\n\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int ans=0;\n    for (int i=1;i<prices.length;i++) {\n        if (prices[i]>prices[i-1]) {\n            ans+=prices[i]-prices[i-1];\n        }\n    }\n    return ans;\n}\n```\n## [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\n\n给定一个整数数组 `prices`，其中第 i 个元素代表了第 i 天的股票价格 ，非负整数 fee 代表了交易股票的手续费用\n\n你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n\n**示例 1:**\n\n```java\n输入：prices = [1, 3, 2, 8, 4, 9], fee = 2\n输出：8\n解释：能够达到的最大利润：\n在此处买入 prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润：((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n```\n\n**注意：**\n\n- `0 < prices.length <= 50000.`\n- `0 < prices[i] < 50000.`\n- `0 <= fee < 50000.`\n\n**解法一**\n\n我起了，一枪秒了，有什么好说的？\n\n```java\npublic int maxProfit(int[] prices, int fee) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int[][] dp=new int[prices.length][2];\n    dp[0][0]=0;\n    dp[0][1]=-prices[0];\n    for (int i=1;i<prices.length;i++) {\n        dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]-fee);\n        dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);\n    }\n    return dp[prices.length-1][0];\n}\n```\n改为 O(1) 空间\n\n```java\n//改为 O(1)\npublic int maxProfit(int[] prices, int fee) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int empty=0;\n    int hold=-prices[0];\n    for (int i=1;i<prices.length;i++) {\n        int temp=empty;\n        empty=Math.max(empty,hold+prices[i]-fee);\n        hold=Math.max(hold,temp-prices[i]);\n    }\n    return empty;\n}\n```\n## [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\n\n给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 \n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）\n- 卖出股票后，你无法在第二天买入股票 （即冷冻期为 1 天）\n\n**示例：**\n\n```java\n输入：[1,2,3,0,2]\n输出：3 \n解释：对应的交易状态为：[买入，卖出，冷冻期，买入，卖出]\n```\n\n**解法一**\n\n依然是上面题的升级版，相比上一题又多了个限制条件，加了 cd，买卖一次后有一天的 cd，当天不能再买\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    //dp[i][0] 代表第 i 天不持有股票的最大利润\n    //dp[i][1] 代表第 i 天持有股票的最大利润\n    int[][] dp=new int[prices.length][2];\n    dp[0][0]=0;\n    dp[0][1]=-prices[0];\n    for (int i=1;i<prices.length;i++) {\n        //这些玩意想起还是蛮打脑阔的\n        dp[i][0]=Math.max(dp[i-1][1]+prices[i],dp[i-1][0]);\n        //dp[i][1]=Math.max(i<2?-prices[i]:dp[i-2][0]-prices[i],dp[i-1][1]);\n        //这里 i<2 就是第一次循环，i=1, 也就是第二天持有股票，所以肯定是首次买股票，直接初始化为 -prices[1]\n        //昨天有股票，或者昨天冷冻前天卖出\n        dp[i][1]=Math.max(i<2?-prices[1]:dp[i-2][0]-prices[i],dp[i-1][1]);\n    }\n    return dp[prices.length-1][0];\n}\n```\n评论区很多的解法都是用了三个状态数组，相比这种多了一个 冷冻期的最大值，感觉挺迷惑的。虽然结果是对的，但是总时感觉别扭，所以我们还是按照上面的思路，用两个状态表示，状态转换图和上面是一样的\n\n![mark](http://static.imlgw.top/blog/20191017/J7tfvKDvqC2b.png?imageslim)\n\n当天持有股票的最大收益，就是你当天买股票，或者 rest 啥也不干延续前一天的状态，两者的最大值\n\n这里和上面不同的就是从`不持有股票` 到`持有股票`（也就是买股票）的情况， 因为有冷冻期的存在，**所以你当天买股票的最大值不再是昨天不持有股票的最大值，而是前天不持有股票的最大值**\n\n**解法三**\n\n改为空间复杂度 O(1) 的\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int hold=-prices[0];\n    int empty=0;\n    //前一天买出的最大收益\n    int prePre=0;\n    for (int i=1;i<prices.length;i++) {\n        int temp=empty;\n        empty=Math.max(hold+prices[i],empty);\n        hold=Math.max(i<2?-prices[1]:prePre-prices[i],hold);\n        //到这里 pre 就变成了前一天\n        prePre=temp;\n    }\n    return empty;\n}\n```\n> 看了下评论区还是蛮多争议的，感觉这里根据 dp[i-2] 转换有点不好理解，然后翻了翻评论区看见了大神的回答\n>\n> `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`\n>\n> `dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`\n>\n> 添加 “冷冻期” 条件后，买入的前一天是不能卖的，而`dp[i-1][0] - prices[i]`并不能确保 `i-1 天不卖出`   \n>\n> 所以进一步拆解`dp[i-1][0]`， 套用上面的转换方程可以得到\n>\n> `dp[i-1][0] = max(dp[i-2][0], dp[i-2][1] + prices[i-1])` \n>\n> 再带入原式子，则可以得到\n>\n> `dp[i][1] = max(dp[i-1][1], max(dp[i-2][0], dp[i-2][1] + prices[i-1]) - prices[i])`\n>\n> 其中`dp[i-2][1] + prices[i-1]` 代表着 `“i-1 发生了卖出行为”`，有违题意，应予删除，得下式，最终和上面的状态转换方程一致\n>\n> `dp[i][1] = max(dp[i-1][1], max(dp[i-2][0]) - prices[i])`\n>\n> 这样一证明就很清楚了\n\n## [1269. 停在原地的方案数](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/)\n\n有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。\n\n每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。\n\n给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。\n\n由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。\n\n**示例 1：**\n\n```java\n输入：steps = 3, arrLen = 2\n输出：4\n解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动\n```\n\n**示例  2：**\n\n```java\n输入：steps = 2, arrLen = 4\n输出：2\n解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动\n```\n\n**示例 3：**\n\n```java\n输入：steps = 4, arrLen = 2\n输出：8\n```\n\n**提示：**\n\n- `1 <= steps <= 500`\n- `1 <= arrLen <= 10^6`\n\n**解法一**\n\n11.24 的周赛最后一题，很可惜没做出来。要是把这题放在第三题我可能就做出来了。还是菜啊\n\n```java\npublic int numWays(int steps, int arrLen) {\n    int mod=1_000_000_007;\n    long[][] dp=new long[steps+1][steps+1];\n    dp[0][0]=1; //dp[i][j] 的含义是 i 步之后处于 j 位置的方案数\n    for (int i=1;i<=steps;i++) {\n        //i 步能达到的最大距离就是 i, 所以我们这里取一个最小值\n        int k=Math.min(i,arrLen-1);\n        for (int j=0;j<=k;j++) {\n            if (j==0) {\n                dp[i][j]=(dp[i-1][j+1]+dp[i-1][j])%mod;\n            }else if (j<k) {\n                dp[i][j]=(dp[i-1][j-1]+dp[i-1][j+1]+dp[i-1][j])%mod;\n            }else{ //大于 k 就只能是从右边过来的\n                dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%mod;\n            }\n        }\n    }\n    return (int)dp[steps][0];\n}\n```\n**解法二**\n\n我比较喜欢的记忆化递归😁，10ms 甚至比上面还快一点\n\n```java\nint mod=1_000_000_007;\n\n//cache\nLong[][] cache;\n\npublic int numWays(int steps, int arrLen) {\n    int maxIndex=Math.min(steps,arrLen-1);\n    cache=new Long[steps+1][maxIndex+1];\n    return (int)dfs(steps,0,maxIndex);\n}\n\npublic long dfs(int steps, int index,int maxIndex) {\n    if (steps==0) {\n        return index==0?1:0;\n    }\n    if (index<0 || index > maxIndex )  {\n        return 0;\n    }\n\n    if (cache[steps][index]!=null) {\n        return cache[steps][index];\n    }\n    //steps 一直在递减，steps 最多走到 steps 位置\n    //为了节约时间可以在这里优化下\n    maxIndex=Math.min(steps,maxIndex);\n    //不动\n    long res=dfs(steps-1,index,maxIndex);\n    //向左\n    res+=dfs(steps-1,index-1,maxIndex);\n    //向右\n    res+=dfs(steps-1,index+1,maxIndex);\n    return cache[steps][index]=res%mod;\n}\n```\n\n## [152. 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/)\n\n给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。\n\n**示例 1:**\n\n```java\n输入：[2,3,-2,4]\n输出：6\n解释：子数组 [2,3] 有最大乘积 6。\n```\n\n**示例 2:**\n\n```java\n输入：[-2,0,-1]\n输出：0\n解释：结果不能为 2, 因为 [-2,-1] 不是子数组。\n```\n\n**解法一**\n\n自己最开始自己写出来的脑瘫 dp\n\n```java\npublic static int maxProduct(int[] nums) {\n    int[] dp1=new int[nums.length];\n    int[] dp2=new int[nums.length];\n    //最大值\n    dp1[0]=nums[0]>=0?nums[0]:0;\n    //最小值\n    dp2[0]=nums[0]>=0?0:nums[0];\n    int max=nums[0]>0?dp1[0]:dp2[0];\n    for(int i=1;i<nums.length;i++){\n        if (nums[i]>0) {\n            if (nums[i-1]<0) {\n                dp1[i]=dp1[i-1]!=0?nums[i]*dp1[i-1]:nums[i];\n                dp2[i]=dp2[i-1]*nums[i];\n            }else if(nums[i-1]>0){\n                dp1[i]=dp1[i-1]*nums[i];\n                dp2[i]=dp2[i-1]!=0?nums[i]*dp2[i-1]:0;\n            }else{\n                dp1[i]=nums[i];\n                dp2[i]=0;\n            }\n        }else if (nums[i]<0) {\n            if (nums[i-1]<0) {\n                dp1[i]=dp2[i-1]*nums[i];\n                dp2[i]=dp1[i-1]!=0?dp1[i-1]*nums[i]:nums[i];\n            }else if(nums[i-1]>0){\n                dp1[i]=dp1[i-1]!=0?nums[i]*dp2[i-1]:0;\n                dp2[i]=dp1[i-1]*nums[i];\n            }else{\n                dp1[i]=0;\n                dp2[i]=nums[i];\n            }\n        }else{\n            dp1[i]=0;\n            dp2[i]=0;\n        }\n        //System.out.println(dp1[i]+\",\"+dp2[i]);\n        max=Math.max(max,dp1[i]);\n    }\n    return max;\n}\n\n/**\n    //     -2  2  3   -4        \n    //dp1:  0  2  6   48        \n    //dp2: -2 -4 -12 -24 \n    //\n    // 2 -5   -2  -4   3\n    // 2  0   20   8   24\n    // 0 -10  -2  -80 -240\n*/\n```\n不想解释太多，虽然过了，但是确实有点蠢\n\n**解法二**\n\n`max[i],min[i]` 代表的就是以`nums[i]` 结尾的**最大**乘积和**最小**乘积\n\n```java\npublic static int maxProduct(int[] nums) {\n    int[] min=new int[nums.length];\n    int[] max=new int[nums.length];\n    int res=max[0]=min[0]=nums[0];\n    for (int i=1;i<nums.length;i++) {\n        max[i]=Math.max(nums[i]*min[i-1],Math.max(nums[i],nums[i]*max[i-1]));\n        min[i]=Math.min(nums[i]*min[i-1],Math.min(nums[i],nums[i]*max[i-1]));\n        res=Math.max(res,max[i]);\n    }\n    return res;\n}\n```\n为什么要记录最小乘积相信不需要我多说了吧，其实只要想清楚一点就 ok，每个位置的`max[i]`其实只有三种来源（纸上写写就明白了）\n\n- `nums[i] >= 0` 并且`max[i-1] > 0`，`max[i] = max[i-1] * nums[i]`\n-  `nums[i] >= 0` 并且`max[i-1] < 0`，此时如果和前边的数累乘的话，会变成负数，所以`max[i] = nums[i]`\n-  `nums[i] < 0`，如果是负数就不应该再和前面`max[i]`相乘，而是考虑`min[i]`\n  - `当 min[i-1] < 0，max[i] = min[i-1] * nums[i]`\n  - `当 min[i-1] >= 0，max[i] = nums[i]`\n\n 然后我们直接求这三种情况的最大值就 ok 了，不用考虑那些分支，我上面的第一种解法其实就是考虑了所有分支，结果才写出了那样的 dp， `min[i]` 的过程和上面一样，就不赘述\n\n## [1567. 乘积为正数的最长子数组长度](https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/)\n\nDifficulty: **中等**\n\n给你一个整数数组 `nums` ，请你求出乘积为正数的最长子数组的长度。\n\n一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。\n\n请你返回乘积为正数的最长子数组长度。\n\n**示例  1：**\n\n```go\n输入：nums = [1,-2,-3,4]\n输出：4\n解释：数组本身乘积就是正数，值为 24 。\n```\n\n**示例 2：**\n\n```go\n输入：nums = [0,1,-2,-3,-4]\n输出：3\n解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。\n注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。\n```\n\n**示例 3：**\n\n```go\n输入：nums = [-1,-2,-3,0,1]\n输出：2\n解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。\n```\n\n**示例 4：**\n\n```go\n输入：nums = [-1,2]\n输出：1\n```\n\n**示例 5：**\n\n```go\n输入：nums = [1,2,3,5,-6,4,0,10]\n输出：4\n```\n\n**提示：**\n\n*   `1 <= nums.length <= 10^5`\n*   `-10^9 <= nums[i] <= 10^9`\n\n**解法一**\n\n一开始想歪了，和上面一题最开始一样写了个贼蠢的 dp，好在后面还是自己想出来了，下面的是后面想出来的简单解法\n```golang\nfunc getMaxLen(nums []int) int {\n    var n = len(nums)\n    //dp[i][0]: \n    var dp = make([][2]int, n+1)\n    var res = 0\n    for i := 1; i <= n; i++ {\n        if nums[i-1] > 0 {\n            dp[i][0] = dp[i-1][0] + 1\n            if dp[i-1][1] != 0 {\n                dp[i][1] = dp[i-1][1] + 1   \n            }\n        } else if nums[i-1] < 0 {\n            if dp[i-1][1] != 0 {\n                dp[i][0] = dp[i-1][1] + 1   \n            }\n            dp[i][1] = dp[i-1][0] + 1\n        }\n        if dp[i][0] > res {\n            res = dp[i][0]\n        }\n    }\n    return res\n}\n```\n\n**解法二**\n\n贼蠢的 DP，面向 case 编程\n```golang\n//垃圾 DP，面向 case 编程，没有 case 一辈子改不出来（居然还被我改对了）\n//100+ms 时间复杂度 O(N^2)，lc 的 case 没能卡掉，但是应该是可以构造出一组特殊 case 卡掉的，懒得想了\nfunc getMaxLen(nums []int) int {\n    var n = len(nums)\n    var dp = make([]int, n+1)\n    if nums[0] > 0 {\n        dp[0] = 1\n    }\n    var res = dp[0]\n    for i := 1; i < n; i++ {\n        if nums[i] > 0 {\n            dp[i] = dp[i-1] + 1\n        } else if nums[i] < 0 {\n            if i-dp[i-1]-1 >= 0 && nums[i-dp[i-1]-1] < 0 {\n                dp[i] = dp[i-1] + 2\n                if i-dp[i-1]-2 >= 0 {\n                    dp[i] += dp[i-dp[i-1]-2]\n                }   \n            } else {\n                //从 i-dp[i-1] 开始找负数，然后从这个负数截断\n                var cnt = 0\n                for k := i-dp[i-1]; k < i; k++ {\n                    if nums[k] < 0 {\n                        dp[i] = dp[i-1]-cnt\n                        break\n                    }\n                    cnt++\n                }\n            }\n        }\n        if dp[i] > res {\n            res = dp[i]\n        }\n    }\n    return res\n}\n```\n## [1594. 矩阵的最大非负积](https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/)\n\nDifficulty: **中等**\n\n给你一个大小为 `rows x cols` 的矩阵 `grid` 。最初，你位于左上角 `(0, 0)` ，每一步，你可以在矩阵中 **向右** 或 **向下** 移动。\n\n在从左上角 `(0, 0)` 开始到右下角 `(rows - 1, cols - 1)` 结束的所有路径中，找出具有 **最大非负积** 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。\n\n返回 **最大非负积** 对**`10<sup>9</sup> + 7`** **取余** 的结果。如果最大积为负数，则返回`-1` 。\n\n**注意，**取余是在得到最大积之后执行的。\n\n**示例 1：**\n\n```go\n输入：grid = [[-1,-2,-3],\n             [-2,-3,-3],\n             [-3,-3,-2]]\n输出：-1\n解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1\n```\n\n**示例 2：**\n\n```go\n输入：grid = [[1,-2,1],\n             [1,-2,1],\n             [3,-4,1]]\n输出：8\n解释：最大非负积对应的路径已经用粗体标出 (1 * 1 * -2 * -4 * 1 = 8)\n```\n\n**示例 3：**\n\n```go\n输入：grid = [[1, 3],\n             [0,-4]]\n输出：0\n解释：最大非负积对应的路径已经用粗体标出 (1 * 0 * -4 = 0)\n```\n\n**示例 4：**\n\n```go\n输入：grid = [[ 1, 4,4,0],\n             [-2, 0,0,1],\n             [ 1,-1,1,1]]\n输出：2\n解释：最大非负积对应的路径已经用粗体标出 (1 * -2 * 1 * -1 * 1 * 1 = 2)\n```\n\n**提示：**\n\n*   `1 <= rows, cols <= 15`\n*   `-4 <= grid[i][j] <= 4`\n\n**解法一**\n\n和上面两题一样，非常套路的 DP，但是我一开始想把初始化给省掉，调了半天发现不太好搞。外围的 dp 取值会影响内部的取值，所以还是老老实实手动初始化，老是想偷懒有时候可能会适得其反（好未来笔试）\n```golang\nfunc maxProductPath(grid [][]int) int {\n    var m, n = len(grid), len(grid[0])\n    var MOD = int(1e9+7)\n    var dp = make([][][2]int, m)\n    var Max = func(a, b int) int {if a < b {return b}; return a}\n    var Min = func(a, b int) int {if a > b {return b}; return a}\n    for i := 0; i < m; i++ {\n        dp[i] = make([][2]int, n)\n    }\n    dp[0][0][1] = grid[0][0]\n    dp[0][0][0] = grid[0][0]\n    for i := 1; i < m; i++ {\n        dp[i][0][0] = grid[i][0] * dp[i-1][0][0]\n        dp[i][0][1] = dp[i][0][0]\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j][0] = grid[0][j] * dp[0][j-1][0]\n        dp[0][j][1] = dp[0][j][0]\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            if grid[i][j] > 0 {\n                dp[i][j][0] =  grid[i][j] * Max(dp[i][j-1][0], dp[i-1][j][0])\n                dp[i][j][1] =  grid[i][j] * Min(dp[i][j-1][1], dp[i-1][j][1])\n            }else if grid[i][j] < 0 {\n                dp[i][j][0] =  grid[i][j] * Min(dp[i][j-1][1], dp[i-1][j][1])\n                dp[i][j][1] =  grid[i][j] * Max(dp[i][j-1][0], dp[i-1][j][0])\n            }\n        }\n    }\n    if dp[m-1][n-1][0] < 0 {\n        return -1\n    }\n    return dp[m-1][n-1][0] % MOD\n}\n```\n\n## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)\n\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n\n**示例：**\n\n```java\n输入：\n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出：4\n```\n\n**解法一**\n\n递推公式：`dp[i][j]=1+min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])`  有的类似短板理论，取决于最小的哪一个正方形\n\n```java\npublic int maximalSquare(char[][] matrix) {\n    if (matrix==null || matrix.length<=0) {\n        return 0;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    //这里+1 处理边界\n    int[][] dp=new int[m+1][n+1];\n    int max=0;\n    for (int i=1;i<=m;i++) {\n        for (int j=1;j<=n;j++) {\n            if (matrix[i-1][j-1]=='1') {\n                dp[i][j]=1+Math.min(dp[i-1][j-1],Math.min(dp[i][j-1],dp[i-1][j]));\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n    return max*max;\n}\n```\n\n这题还有个需要注意的地方就是边界的处理，这里实现的代码中`dp[i][j]` 其实表示的是以 `matrix[i-1][j-1]` 作为右下角结尾的正方形的最大边长，这样的话就不用考虑上下两条边的边界 case，相当于在 dp 数组上下边界之外又加了一层 0\n\n> 到这里我也大致明白了一些动态规划的题目的递推写法为都是从 1 开始了，比如上面的编辑距离\n\n## [1277. 统计全为 1 的正方形子矩阵](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)\n\n给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。\n\n示例 1：\n\n```java\n输入：matrix =\n[\n  [0,1,1,1],\n  [1,1,1,1],\n  [0,1,1,1]\n]\n输出：15\n解释： \n边长为 1 的正方形有 10 个。\n边长为 2 的正方形有 4 个。\n边长为 3 的正方形有 1 个。\n正方形的总数 = 10 + 4 + 1 = 15.\n```\n\n**示例 2：**\n\n```java\n输入：matrix = \n[\n  [1,0,1],\n  [1,1,0],\n  [1,1,0]\n]\n输出：7\n解释：\n边长为 1 的正方形有 6 个。 \n边长为 2 的正方形有 1 个。\n正方形的总数 = 6 + 1 = 7.\n```\n\n**提示：**\n\n- `1 <= arr.length <= 300`\n- `1 <= arr[0].length <= 300`\n- `0 <= arr[i][j] <= 1`\n\n**解法一**\n\n12.1 的周赛题目，其实先做的上面的最大正方形，然后发现这一题和上面的一样。\n\n```java\npublic int countSquares(int[][] matrix) {\n    if (matrix==null || matrix.length<=0) {\n        return 0;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    int [][]dp=new int[m+1][n+1];\n    int res=0;\n    for (int i=1;i<=m;i++) {\n        for (int j=1;j<=n;j++) {\n            if (matrix[i-1][j-1]==1) {\n                dp[i][j]=Math.min(dp[i-1][j-1],Math.min(dp[i][j-1],dp[i-1][j]))+1;\n                res+=dp[i][j];\n            }\n        }\n    }\n    return res;\n}\n```\n\n一摸一样，理解一点就 ok，**以`matrix[i][j]` 为右下角的最大正方形的边长，就是以这个点为右下角的正方形的数量！！！**\n\n## [1139. 最大的以 1 为边界的正方形](https://leetcode-cn.com/problems/largest-1-bordered-square/)\n\nDifficulty: **中等**\n\n给你一个由若干 `0` 和 `1` 组成的二维网格 `grid`，请你找出边界全部由 `1` 组成的最大 **正方形** 子网格，并返回该子网格中的元素数量。如果不存在，则返回 `0`。\n\n**示例 1：**\n\n```golang\n输入：grid = [[1,1,1],[1,0,1],[1,1,1]]\n输出：9\n```\n\n**示例 2：**\n\n```golang\n输入：grid = [[1,1,0,0]]\n输出：1\n```\n\n**提示：**\n\n*   `1 <= grid.length <= 100`\n*   `1 <= grid[0].length <= 100`\n*   `grid[i][j]` 为 `0` 或 `1`\n\n**解法一**\n\n这个题目还是挺有意思的，第一次看了以后没啥思路，看了题解对 dp 数组的的定义后就明白了，今天来实现下，WA 了 2 次，都 WA 的有理有据，很舒服，做这种题就很舒服\n\n```java\npublic int largest1BorderedSquare(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    //dp[i][j][0]: i,j 左边连续的 1 的个数\n    //dp[i][j][1]: i,j 上边连续的 1 的个数\n    int[][][] dp = new int[m+1][n+1][2];\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (grid[i-1][j-1] == 1){\n                dp[i][j][0] = 1 + dp[i][j-1][0];\n                dp[i][j][1] = 1 + dp[i-1][j][1];\n            }\n        }\n    }\n    int res = 0;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            //WA 点 2：最短的那条边不一定是边长，可以更短所以需要遍历所有小于最短边长的长度\n            //所以题目的数据范围是不会骗人的，给的 100 那么时间复杂度一定不是 N2 的\n            for (int side = Math.min(dp[i][j][0], dp[i][j][1]); side >= 1; side--){\n                //WA 点 1：大于等于\n                if (dp[i][j-side+1][1] >= side && dp[i-side+1][j][0] >= side){\n                    res = Math.max(res, side);\n                    break; //更短的就没必要考虑了\n                }\n            }\n        }\n    }\n    return res * res;\n}\n```\n其实这个题目的关键就在于状态的定义，如何去构造一个正方形，一图胜千言（PPT 画图还是挺方便）\n![mark](http://static.imlgw.top/blog/20200730/2NpjXbbGcEjQ.png?imageslim)\n（之前的图有点小问题，改了下）\n\n求以某个点为右下角的正方形，首先我们考虑这个点为右下角可能构成的最大正方形边长是多大\n\n很明显应该是该点左边和上边连续 1 个数的最小值，如上图的（6，5）点，最大的可能边长就应该是 6，然后我们枚举所有的小于等于 6 大于等于 1 的边长 side，验证 side 能否构成正方形\n\n验证 side 是否合法也很容易，如上图，我们只需要考虑（6，5）上边距离为 side 的点的左边连续 1 的个数是否大于等于 side（`dp[i-side+1][j][0] >= side`），以及左边距离为 side 的点的上边连续的 1 的个数是否大于等于 side（`dp[i][j-side+1][1] >= side`），如果都大于等于 side 那么该 side 就是合法的，我们统计这些合法的 side 的最大值就 ok 了\n\n> 在 lc 上水了一发 [题解](https://leetcode-cn.com/problems/largest-1-bordered-square/solution/java-dong-tai-gui-hua-by-resolmi/)\n\n## [44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)\n\n给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。\n\n```java\n'?' 可以匹配任何单个字符。\n'*' 可以匹配任意字符串（包括空字符串）。\n```\n\n两个字符串完全匹配才算匹配成功。\n\n**说明：**\n\n- s 可能为空，且只包含从 a-z 的小写字母。\n- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\n\n**示例 1:**\n\n```java\n输入：\ns = \"aa\"\np = \"a\"\n输出：false\n解释：\"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n**示例 2:**\n\n```java\n输入：\ns = \"aa\"\np = \"*\"\n输出：true\n解释：'*' 可以匹配任意字符串。\n```\n\n**示例 3:**\n\n```java\n输入：\ns = \"cb\"\np = \"?a\"\n输出：false\n解释：'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。\n```\n\n**示例 4:**\n\n```java\n输入：\ns = \"adceb\"\np = \"*a*b\"\n输出：true\n解释：第一个 '*' 可以匹配空字符串，第二个 '*' 可以匹配字符串 \"dce\".\n```\n\n**示例 5:**\n\n```java\n输入：\ns = \"acdcb\"\np = \"a*c?b\"\n输入：false\n```\n\n**解法一**\n\n其实这题还有一道类似的题，[10. 正则表达式生成](http://imlgw.top/2019/10/10/leetcode-hui-su/#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D) 我放在回溯里了，因为 dp 的解法暂时还没花时间去看，感觉递归好理解一点，后面有时间再加进来\n\n```java\npublic boolean isMatch(String s, String p) {\n    //dp[i][j] 代表 s[0,i-1](s 的前 i 个字符）,p[0,j-1](p 的前 j 个字符)是否匹配\n    boolean[][] dp=new boolean[s.length()+1][p.length()+1];        \n    //dp[i][0]=false dp[0][j] p[j]==\"*\"|\"?\"\n    dp[0][0]=true;\n    for (int j=1;j<=p.length();j++) {\n        if (p.charAt(j-1)=='*') {\n            dp[0][j]=dp[0][j-1]; //dp[0][j]=true 是错的\n        }\n    }\n    //1. p[i]=p[j] dp[i][j]=dp[i-1][j-1]\n    //2. p[j]=\"?\"  dp[i][j]=dp[i-1][j-1]\n    //3. p[j]=\"*\"  dp[i][j]=dp[i-1][j] | dp[i][j-1]\n    for (int i=1;i<=s.length();i++) {\n        for (int j=1;j<=p.length();j++) {\n            if (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1)=='?') {\n                dp[i][j]=dp[i-1][j-1];\n            }else if (p.charAt(j-1)=='*') { //abcd ab* | ab ab*\n                dp[i][j]=dp[i-1][j]|dp[i][j-1];\n            }\n        }\n    }\n    return dp[s.length()][p.length()];\n}\n```\n\n思路都在注释里面了，比正则那个要简单，比较不好想的一点就是 `dp[i][j]=dp[i-1][j]|dp[i][j-1]`其实分别对应的就是 `*` **匹配任意字符**的情况和**匹配空字符**的情况，匹配任意字符为什么不是`dp[i-1][j-1]`? 因为`*` 不仅仅只可以匹配一个字符，它可以匹配任意个数的任意字符，就比如这样的` abcd，ab* ` 的，这种情况其实最终还是转换成了匹配空字符的情况，这也是动态规划的思想所在。\n\n## [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n\n给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。\n\n```java\n'.' 匹配任意单个字符\n'*' 匹配零个或多个前面的那一个元素\n```\n\n所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。\n\n**说明：**\n\n- s 可能为空，且只包含从 a-z 的小写字母。\n- p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n\n**示例 1:**\n\n```java\n输入：\ns = \"aa\"\np = \"a\"\n输出：false\n解释：\"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n**示例 2:**\n\n```java\n输入：\ns = \"aa\"\np = \"a*\"\n输出：true\n解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素，在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n```\n\n**示例 3:**\n\n```java\n输入：\ns = \"ab\"\np = \".*\"\n输出：true\n解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n```\n\n**示例 4:**\n\n```java\n输入：\ns = \"aab\"\np = \"c*a*b\"\n输出：true\n解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个，'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n```\n\n**示例 5:**\n\n```java\n输入：\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出：false\n```\n\n**解法一**\n\ndfs 回溯，暴力解法，挺难搞\n\n```java\npublic boolean isMatch(String s, String p) {\n    return match(s,0,p,0);\n}\n\npublic boolean match(String s,int sIdx, String p,int pIdx) {\n    if (sIdx>=s.length() && pIdx>=p.length()) {\n        return true;\n    }\n    if (pIdx>=p.length()) {\n        return false;\n    }\n    //这里的判断其实不太对，也不能说不对，会稍微慢一点，因为题目中是不会给**这样的 case 的\n    //可以直接一次跳两步判断是不是*\n    if (sIdx == s.length()) {\n        //后面没有*的情况 aaa aaaa\n        if (pIdx==p.length()-1 && p.charAt(pIdx)!='*') { //p 也到尽头，并且不为*\n            return false;\n        }\n        while(pIdx<p.length()){ //p 没到尽头，检查后面的是否有两个连续的非*\n            if (p.charAt(pIdx) != '*' && (pIdx+1<p.length() && p.charAt(pIdx+1)!='*')) {\n                return false;\n            }\n            pIdx++;\n        }\n        //aaa aaa*c\n        return p.charAt(pIdx-1)=='*';\n    }\n\n    if (pIdx+1 < p.length() && p.charAt(pIdx+1) =='*') { //pIdx 下一个是 *\n        //*匹配至少一个\n        if ((s.charAt(sIdx) == p.charAt(pIdx) || p.charAt(pIdx)=='.') && match(s,sIdx+1,p,pIdx)) {\n            return true;\n        }\n        //*匹配 0 个\n        return match(s,sIdx,p,pIdx+2);\n    }else{\n        //pIdx 下一个不是*\n        if ((p.charAt(pIdx) == s.charAt(sIdx) || p.charAt(pIdx)=='.') && match(s,sIdx+1,p,pIdx+1)) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n这题还是挺麻烦的，毕竟是 hard 题，我也是看了题解才写出来，核心就是要把题目意思理解对，我这里没有做记忆化，懒得写\n\n**解法二**\n\n他来了他来了，他带着 dp 解法来了，终于还是把 dp 的解法补上来了，参考 [题解 ](https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-si-yao-su-by-a380922457-5/) ，注意下标的转换，这里容易被绕进去，详细的都在注释中了\n\n```java\n//update: 2020.4.12\npublic boolean isMatch(String text, String pattern) {\n    //dp[i][j] 代表 text[0,i) 和 pattern[0,j) 是否匹配\n    boolean[][] dp=new boolean[text.length()+1][pattern.length()+1];\n    //都为空的时候肯定是匹配的\n    dp[0][0]=true;\n    //pattern 为空，text 不为空肯定是无法匹配，默认 false, 不用处理\n    //text 为空，pattern 不为空需要额外判断\n    for(int i=2;i<=pattern.length();i++){\n        dp[0][i]=pattern.charAt(i-1)=='*'&&dp[0][i-2];\n    }\n\n    for(int i=1;i<=text.length();i++){\n        for(int j=1;j<=pattern.length();j++){\n            if(singleMatch(text,pattern,i-1,j-1)){\n                dp[i][j]=dp[i-1][j-1];\n            }else if(pattern.charAt(j-1)=='*'){\n                //j 一定是>=2 的，p 如果是*开头就是错误的语法，不过 lc 其实也没有这样的 case\n                if(j<2) return false;\n                //ab abb*    --> '*'匹配 0 个 b\n                //abbbbb ab* --> '*'匹配多个 b\n                //注意 dp[i-1][j] 和 text.charAt(i-1) 的 i-1 含义是不一样的\n                //text.charAt(i-1) 的 i-1 其实指的是当前元素，而 dp[i-1][j] 中的 i-1 是前一个元素\n                //abc ab*\n                dp[i][j]=dp[i][j-2] || (singleMatch(text,pattern,i-1,j-2) && dp[i-1][j]);\n            }\n        }\n    }\n    return dp[text.length()][pattern.length()];\n}\n\npublic boolean singleMatch(String s,String p,int i,int j){\n    return s.charAt(i)==p.charAt(j) || p.charAt(j)=='.';\n}\n```\n\n果然还是动态规划简洁，而且搞懂之后也很好理解~~\n\n## [1326. 灌溉花园的最少水龙头数目](https://leetcode-cn.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/) \n\n在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。\n\n花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。\n\n给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i -  ranges[i], i + ranges[i]] 。\n\n请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/03/kAPc2ELusMa9qJZ.png)\n\n```java\n输入：n = 5, ranges = [3,4,1,1,0,0]\n输出：1\n解释：\n点 0 处的水龙头可以灌溉区间 [-3,3]\n点 1 处的水龙头可以灌溉区间 [-3,5]\n点 2 处的水龙头可以灌溉区间 [1,3]\n点 3 处的水龙头可以灌溉区间 [2,4]\n点 4 处的水龙头可以灌溉区间 [4,4]\n点 5 处的水龙头可以灌溉区间 [5,5]\n只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。\n```\n\n**示例 2：**\n\n```java\n输入：n = 3, ranges = [0,0,0,0]\n输出：-1\n解释：即使打开所有水龙头，你也无法灌溉整个花园。\n```\n\n**示例 3：**\n\n```java\n输入：n = 7, ranges = [1,2,1,0,2,1,0,1]\n输出：3\n```\n\n**示例 4：**\n\n```java\n输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4]\n输出：2\n```\n\n**示例 5：**\n\n```java\n输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4]\n输出：1\n```\n\n**提示：**\n\n- `1 <= n <= 10^4`\n- `ranges.length == n + 1`\n- `0 <= ranges[i] <= 100`\n\n**解法一**\n\n172 周赛的最后一题\n\n```java\npublic int minTaps(int n, int[] ranges) {\n    int[] dp=new int[n+1]; //浇溉 i 位置前需要最少的水龙头\n    Arrays.fill(dp,Integer.MAX_VALUE);\n    dp[0]=0;\n    for (int i=0;i<=n;i++) {\n        int left=Math.max(0,i-ranges[i]);\n        int right=Math.min(n,i+ranges[i]);\n        if (dp[left]==Integer.MAX_VALUE) { //左边界不可达\n            continue;\n        }\n        for (int j=left+1;j<=right;j++) {\n            dp[j]=Math.min(dp[j],dp[left]+1); //范围内的区域 dp 值\n        }\n    }\n    return dp[n]==Integer.MAX_VALUE?-1:dp[n];\n}\n```\n\n动态规划的解法，对每个水龙头所覆盖的区域进行递推，dp[i] 代表浇灌`0 ~ i` 位置区域所需要的最少的水头所以很容易得到递推公式`dp[j]=Math.min(dp[j],dp[left]+1)`  ，整体还是很好理解的\n\n**解法二**\n\n贪心算法，和 [贪心专题](http://imlgw.top/2020/01/21/leetcode-tan-xin/) 中的 [1024. 视频剪辑](http://imlgw.top/2020/01/21/leetcode-tan-xin/#1024-%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5) 是一样的题目\n\n有时间再来补吧\n\n## [1335. 工作计划的最低难度](https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule/)\n\n你需要制定一份 d 天的工作计划表。工作之间存在依赖，要想执行第 i 项工作，你必须完成全部 j 项工作（ `0 <= j < i`）。\n\n你每天 **至少** 需要完成一项任务。工作计划的总难度是这 `d` 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。\n\n给你一个整数数组 `jobDifficulty` 和一个整数 d，分别代表工作难度和需要计划的天数。第 i 项工作的难度是 `jobDifficulty[i]`。\n\n返回整个工作计划的 **最小难度** 。如果无法制定工作计划，则返回 -1 。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/01/27/ipKvNZQASOhVmdI.png)\n\n```java\n输入：jobDifficulty = [6,5,4,3,2,1], d = 2\n输出：7\n解释：第一天，您可以完成前 5 项工作，总难度 = 6.\n第二天，您可以完成最后一项工作，总难度 = 1.\n计划表的难度 = 6 + 1 = 7 \n```\n\n**示例 2：**\n\n```java\n输入：jobDifficulty = [9,9,9], d = 4\n输出：-1\n解释：就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。\n```\n\n**示例 3：**\n\n```java\n输入：jobDifficulty = [1,1,1], d = 3\n输出：3\n解释：工作计划为每天一项工作，总难度为 3 。\n```\n\n**示例 4：**\n\n```java\n输入：jobDifficulty = [7,1,7,1,7,1], d = 3\n输出：15\n```\n\n**解法一**\n\n173 周赛的最后一道 dp 题，事后一个小时左右独立的 ac，还是挺舒服的，希望以后能更快 ac\n\n```java\npublic int minDifficulty(int[] jobDifficulty, int d) {\n    int jlen=jobDifficulty.length;\n    if(jlen<d){\n        return -1;\n    }\n    //dp[i][j]   第 i 天完成前 j 项任务的最低难度\n    int[][] dp=new int[d][jlen];\n    for(int i=0;i<dp.length;i++){\n        Arrays.fill(dp[i],Integer.MAX_VALUE);\n    }\n    int max=0;\n    for(int j=0;j<jlen;j++){\n        max=Math.max(max,jobDifficulty[j]);\n        dp[0][j]=max;\n    }\n    for(int i=1;i<d;i++){\n        for(int j=0;j<jlen;j++){\n            for(int k=j-1;k>=i-1;k--){\n                dp[i][j]=Math.min(dp[i][j], dp[i-1][k]+maxDifficulty(jobDifficulty,k+1,j));\n            }\n        }\n    }\n    return dp[d-1][jlen-1];\n}\n\npublic int maxDifficulty(int[] jobDifficulty,int left,int right){\n    int max=jobDifficulty[left];\n    for(int i=left;i<=right;i++){\n        max=Math.max(max,jobDifficulty[i]);\n    }\n    return max;\n}\n```\n\n核心的递推公式： `dp[i][j]=min(dp[i][j],dp[i-1][0~k]+max(k+1,j))` \n\n其实也不是一开始就想到了这个递推公式，首先需要确定的是用几维数组和递推数组的含义，这个题目两个变量：天数和工作量；所以应该是二维的结构，`dp[i][j]` 然后对应题目所要求的东西，其实就可以确定 dp 数组的含义\n\n`dp[i][j]` 的含义是前`i`天完成前`j`项工作的最低难度，最后返回的结果就是`dp[d-1][jlen-1]`\n\n但是上面这个解法时间复杂度比较高，`O(dN^3)`，其实可以做一下预处理降低时间复杂度\n\n**解法二**\n\n预处理的地方也写成了动态规划 hahaha~ 其实就是求一个**区间和**\n\n```java\npublic int minDifficulty(int[] jobDifficulty, int d) {\n    int jlen=jobDifficulty.length;\n    if(jlen<d){\n        return -1;\n    }\n    //dp[i][j]   前 i 天完成前 j 项任务的最低难度\n    int[][] dp=new int[d][jlen];\n    for(int i=0;i<dp.length;i++){\n        Arrays.fill(dp[i],Integer.MAX_VALUE);\n    }\n    //预处理\n    int[][] maxRange=new int[jlen][jlen];\n    for(int i=0;i<jlen;i++){\n        maxRange[i][i]=jobDifficulty[i];\n        for (int j=i+1;j<jlen;j++) {\n            //这里也是个动态规划 hahaha~\n            maxRange[i][j]=Math.max(maxRange[i][j-1],jobDifficulty[j]);\n        }\n    }\n    for(int j=0;j<jlen;j++){\n        dp[0][j]=maxRange[0][j];\n    }\n    for(int i=1;i<d;i++){\n        for(int j=0;j<jlen;j++){\n            for(int k=j-1;k>=i-1;k--){ //注意这里 k>=i-1 的含义\n                dp[i][j]=Math.min(dp[i][j], dp[i-1][k]+maxRange[k+1][j]);\n            }\n        }\n    }\n    return dp[d-1][jlen-1];\n}\n```\n\n这样时间复杂度就降低为`O(dN^2)` ，当然还是有一点不完美，就是对边界的处理可以通过对 dp 数组+1 来规避，这个问题我之前也说过，这我尝试改了下，没改好，不改了，哈哈哈~\n\n## [5331. 跳跃游戏 V](https://leetcode-cn.com/problems/jump-game-v/)\n\n给你一个整数数组 arr 和一个整数 d 。每一步你可以从下标 i 跳到：\n\n- `i + x` ，其中 `i + x < arr.length 且 0 < x <= d` 。\n- `i - x` ，其中 `i - x >= 0 且 0 < x <= d` 。\n\n除此以外，你从下标 i 跳到下标 j 需要满足：`arr[i] > arr[j] 且 arr[i] > arr[k]` ，其中下标 k 是所有 i 到 j 之间的数字（更正式的，min(i, j) < k < max(i, j)）。\n\n你可以选择数组的任意下标开始跳跃。请你返回你 **最多** 可以访问多少个下标。\n\n请注意，任何时刻你都不能跳到数组的外面\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/02/lroNpJhPkVc46Ya.png)\n\n```java\n输入：arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\n输出：4\n解释：你可以从下标 10 出发，然后如上图依次经过 10 --> 8 --> 6 --> 7 。\n注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 > 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 > 9 。\n类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。\n```\n\n**示例 2：**\n\n```java\n输入：arr = [3,3,3,3,3], d = 3\n输出：1\n解释：你可以从任意下标处开始且你永远无法跳到任何其他坐标。\n```\n\n**示例 3：**\n\n```java\n输入：arr = [7,6,5,4,3,2,1], d = 1\n输出：7\n解释：从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。\n```\n\n**提示：**\n\n- `1 <= arr.length <= 1000`\n- `1 <= arr[i] <= 10^5`\n- `1 <= d <= arr.length`\n\n**解法一**\n\n预处理+回溯+记忆化\n\n```java\nprivate Integer[] cache=null;\n\npublic int maxJumps(int[] arr, int d) {\n    int[][] max=new int[arr.length][arr.length];\n    cache=new Integer[arr.length];\n    for (int i=0;i<arr.length;i++) {\n        max[i][i]=arr[i];\n        for (int j=i+1;j<arr.length;j++) {\n            max[i][j]=Math.max(max[i][j-1],arr[j]);\n        }\n    }\n    int res=0;\n    for (int i=0;i<arr.length;i++) {\n        res=Math.max(jump(arr,d,i,max),res);\n    }\n    return res+1;\n}\n\npublic int jump(int[] arr,int d,int index,int[][] max){ //从 index 起跳能跳多远\n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    int res=0;\n    for (int i=Math.max(index-d,0);i<index;i++) {\n        if (arr[index]>arr[i] && arr[index]>max[i+1][index-1]) {\n            res=Math.max(jump(arr,d,i,max)+1,res);\n        }\n    }\n    //index=0, i=1 , i<=1\n    for (int i=index+1;i<=Math.min(index+d,arr.length-1);i++) {\n        if (arr[index]>arr[i] && arr[index]>max[index+1][i-1]) {\n            res=Math.max(jump(arr,d,i,max)+1,res);\n        }\n    }\n    return cache[index]=res;\n}\n```\n\n其实已经在超时的边缘了。没有必要做预处理，一开始被题括号里面的信息给迷惑了，不然也不会搞个预处理，其实题目的意思就是只能向低处跳，我开始还搞了两个区间值 haha，脑壳有点不亲白\n\n**解法二**\n\n改良后的回溯+记忆化\n\n```java\nprivate Integer[] cache=null;\n\npublic int maxJumps(int[] arr, int d) {\n    cache=new Integer[arr.length];\n    int res=0;\n    for (int i=0;i<arr.length;i++) {\n        res=Math.max(jump(arr,d,i),res);\n    }\n    return res+1;\n}\n\npublic int jump(int[] arr,int d,int index){ \n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    int res=0;\n    //挨个跳，有一个跳不到，后面所有的就都跳不到了\n    for (int i=index-1;i>=Math.max(index-d,0) && arr[index]>arr[i];i--) {\n        res=Math.max(jump(arr,d,i)+1,res);\n    }\n    for (int i=index+1;i<=Math.min(index+d,arr.length-1) && arr[index]>arr[i];i++) {\n        res=Math.max(jump(arr,d,i)+1,res);\n    }\n    return cache[index]=res;\n}\n```\n\n**解法三**\n\n自底向上动态规划\n\n```java\npublic int maxJumps(int[] arr, int d) {\n    int res=0,len=arr.length;\n    Pair[] pair=new Pair[len];\n    int[] dp=new int[len];\n    Arrays.fill(dp,1);\n    for (int i=0;i<len;i++) pair[i]=new Pair(i,arr[i]);\n    Arrays.sort(pair,(p1,p2)->p1.value-p2.value);\n    for (int i=0;i<len;i++) {\n        int index=pair[i].index;\n        //向左\n        for (int j=index-1;j>=Math.max(index-d,0) && arr[index]>arr[j];j--) {\n            dp[index]=Math.max(dp[j]+1,dp[index]);\n        }\n        //向右\n        for (int j=index+1;j<=Math.min(index+d,arr.length-1) && arr[index]>arr[j];j++) {\n            dp[index]=Math.max(dp[j]+1,dp[index]);\n        }\n        res=Math.max(dp[index],res);\n    }\n    return res;\n}\n\nclass Pair{\n    int index;\n    int value;\n    public Pair(int index,int value){\n        this.index=index;\n        this.value=value;\n    }\n}\n```\n\n这里其实动态规划还有麻烦一点，因为需要从高向低跳，所以我们需要先保证低处的 dp 值先计算完成，所以我们需要先排序，同时要保留原索引，所以我们需要建立一个`Pair`数组来辅助，跳的方式和上面回溯的一样\n\n## [1262. 可被三整除的最大和](https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/)\n\n给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。\n\n**示例 1：**\n\n```java\n输入：nums = [3,6,5,1,8]\n输出：18\n解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [4]\n输出：0\n解释：4 不能被 3 整除，所以无法选出数字，返回 0。\n```\n\n**示例 3：**\n\n```java\n输入：nums = [1,2,3,4,4]\n输出：12\n解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。\n```\n\n**提示：**\n\n- `1 <= nums.length <= 4 * 10^4`\n- `1 <= nums[i] <= 10^4`\n\n**解法一**\n\n动态规划的解法，很久之前的一次周赛的题，好像是第一次双周赛的题？\n\n```java\npublic int maxSumDivThree(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    //dp[i][k] 0~i 之间/3 余 k 的最大元素和\n    int[][] dp=new int[nums.length+1][3]; \n    dp[0][0]=0; //初始状态定义\n    dp[0][1]=Integer.MIN_VALUE;\n    dp[0][2]=Integer.MIN_VALUE;\n    for (int i=1;i<=nums.length;i++) {\n        if (nums[i-1]%3==0) {\n            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][0]+nums[i-1]);\n            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][1]+nums[i-1]);\n            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][2]+nums[i-1]);\n        }\n        if (nums[i-1]%3==1) {\n            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2]+nums[i-1]);\n            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+nums[i-1]);\n            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+nums[i-1]);   \n        }\n        if (nums[i-1]%3==2) {\n            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+nums[i-1]);\n            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][2]+nums[i-1]);\n            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][0]+nums[i-1]);   \n        }\n    }\n    return  Math.max(0,dp[nums.length][0]);\n}\n```\n\n看一下数据的范围`40000`，所以时间复杂度肯定是`O(N)` 或`O(NlogN)`的，`O(N^2)`的肯定超时啦\n\n想了很久没想出来，然后瞄了一眼评论区，发现 dp 数组定义的是和余数相关的，然后就反应过来了，余 0 余 1 余 2， 他们的组合就可以得到新的最大余数和，我们最后要求的就是最后`[0,nums.length]` 余数为 0 的最大和\n\n递推公式就不用多说了，看代码就行了，递推公式很容易得到，关键就是初始的状态定义，第一步的递推，我一开始没有设置边界，直接开始 dp 然后后面怎么改都不对，一开始定义的 base dp\n\n```java\ndp[0][0]=nums[0]%3==0?nums[0]:Integer.MIN_VALUE;\ndp[0][1]=nums[0]%3==1?nums[0]:Integer.MIN_VALUE;\ndp[0][2]=nums[0]%3==2?nums[0]:Integer.MIN_VALUE;\n```\n\n然后过了几十后卡在了个 case 上\n\n```java\n[2,19,6,16,5,10,7,4,11,6]\n```\n\n递推到第二个其实就有问题了\n\n```java\n      0     1      2 \n2    MIN   MIN     2 \n19   21    MIN+19  2\n```\n\n这里的 19 的 1 明显应该就是 19，这里直接根据`dp[i-1][1]+19`递推得到的，后面的肯定都不对了，那我们这里将初始值设置为 0 可以么？\n\n```java\ndp[0][0]=nums[0]%3==0?nums[0]:0;\n```\n\n对这个 case 确实可以，但是对于其他的就不对了，这容易想到，你设置为 0 下一层的 dp 值就可以从这个值递推过来，但是这明显是不对的，举个例子： `3，4` 你将第一个 3 的余 2 最大值设置为 0，那么下一个 4 就可以通过上一个余 2 的最大值来更新当前的余 0 最大值，变成 4，这很明显就不对了，4 根本就不能被 3 整除\n\n所以这里我们最好的处理方式是添加一个边界，相当于在数组的最前面添加一个 0，0%3=0\n\n然后我们只需要将`dp[0][0]`设置为 0 就可以了，而 1 和 2 就设置为`INT_MIN`，让下一层不能通它来转移\n\n> dp 边界的处理方式还是要多练啊\n\n**解法二**\n\n优化空间为 O(1)\n\n```java\npublic int maxSumDivThree2(int[] nums) {\n    int[] dp=new int[3];\n    dp[1]=Integer.MIN_VALUE;\n    dp[2]=Integer.MIN_VALUE;\n    for (int i=1;i<=nums.length;i++) {\n        if (nums[i-1]%3==0) {\n            dp[0]=Math.max(dp[0],dp[0]+nums[i-1]);\n            dp[1]=Math.max(dp[1],dp[1]+nums[i-1]);\n            dp[2]=Math.max(dp[2],dp[2]+nums[i-1]);\n        }\n        if (nums[i-1]%3==1) {\n            int temp0=dp[0];\n            dp[0]=Math.max(dp[0],dp[2]+nums[i-1]);\n            dp[2]=Math.max(dp[2],dp[1]+nums[i-1]); //按依赖关系调整顺序，减少变量\n            dp[1]=Math.max(dp[1],temp0+nums[i-1]);\n        }\n        if (nums[i-1]%3==2) {\n            int temp0=dp[0];\n            dp[0]=Math.max(dp[0],dp[1]+nums[i-1]);\n            dp[1]=Math.max(dp[1],dp[2]+nums[i-1]);\n            dp[2]=Math.max(dp[2],temp0+nums[i-1]);\n        }\n    }\n    return dp[0];\n}\n```\n\n可以看出代码还是可以简化的很短的，为了表达的清晰就不改了\n\n**解法三**\n\n贪心，放在 [贪心专题](http://imlgw.top/2020/01/21/leetcode-tan-xin/#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97) 中\n\n## [面试题 60. n 个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)\n\n把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n**示例 1:**\n\n```java\n输入：1\n输出：[0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n```\n\n**示例 2:**\n\n```java\n输入：2\n输出：[0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]\n```\n\n**限制：**\n\n`1 <= n <= 11`\n\n**解法一**\n\n很有意思的题，看返回值还不容易想到用动态规划\n\n```java\npublic double[] twoSum(int n) {\n    //dp[i][j] 代表 i 枚色子和为 j 的概率\n    double[][] dp=new double[n+1][6*n+1];\n    double probability=1.0/6.0;\n    //base 初始化\n    for(int i=1;i<=6;i++) dp[1][i]=probability;\n    for(int i=2;i<=n;i++){ //枚举色子\n        for(int j=i;j<=i*6;j++){ //枚举点数\n            for(int k=1;k<=j && k<=6;k++){ //枚举当前色子的点数\n                dp[i][j]+=(probability*dp[i-1][j-k]);\n            }\n        }\n    }\n    double[] res=new double[5*n+1];//\n    System.arraycopy(dp[n],n,res,0,res.length);\n    return res;\n}\n```\n\n`dp[i][j]`代表** i **枚色子和为** j **的概率 递推公式很容易想到 `dp[i][j]= 1/6(dp[i-1][j-1]+dp[i-1][j-2]+dp[i-1][j-3]...dp[i-1][j-6])` 然后我们枚举各个状态就 ok 了\n\n## [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)\n\n编写一个程序，找出第 n 个丑数。\n\n丑数就是只包含质因数 2, 3, 5 的正整数。\n\n**示例：**\n\n```java\n输入：n = 10\n输出：12\n解释：1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n```\n\n**说明：**  \n\n1. 是丑数。\n2. n 不超过 1690。\n\n**解法一**\n\n小根堆，将 base 每次乘 2 乘 3 乘 5 的结果放入小根堆，然后将堆顶拿出来 base，继续重复这个过程，中间要注意去重\n\n```java\npublic int nthUglyNumber3(int n) {\n    PriorityQueue<Long> queue=new PriorityQueue<>();\n    n-=1;\n    long base=1;\n    while(n-- >0){\n        queue.add(base*2);\n        queue.add(base*3);\n        queue.add(base*5);\n        base=queue.poll();\n        //去重\n        while(!queue.isEmpty()&&base==queue.peek()){\n            queue.poll();\n        }\n    }\n    return (int)base;\n}\n```\n\n用`HashSet`去重\n\n```java\npublic int nthUglyNumber(int n) {\n    PriorityQueue<Long> queue=new PriorityQueue<>();\n    HashSet<Long> set=new HashSet<>();\n    long base=1;\n    long[] ugly={2,3,5};\n    n-=1;\n    set.add(1L);\n    while(n-->0){\n        for(int i=0;i<3;i++){\n            if (!set.contains(ugly[i]*base)) {\n                queue.add(ugly[i]*base);\n                set.add(ugly[i]*base);\n            }\n        }\n        base=queue.poll();\n    }\n    return (int)base;\n}\n```\n\n**解法二**\n\n这个解法还是很有技巧性的，其实就是按顺序生成丑数，一开始观察的时候就发现了但是确实想不到三指针的解法\n\n```java\npublic int nthUglyNumber4(int n) {\n    int[] dp=new int[n];\n    dp[0]=1;\n    int index1=0,index2=0,index3=0;\n    for (int i=1;i<n;i++) {\n        dp[i]=Math.min(dp[index1]*2,Math.min(dp[index2]*3,dp[index3]*5));\n        index1+=(dp[index1]*2==dp[i]?1:0);\n        index2+=(dp[index2]*3==dp[i]?1:0);\n        index3+=(dp[index3]*5==dp[i]?1:0);\n    }\n    return dp[n-1];\n}\n```\n## [面试题 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) \n\n0,1,,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。\n\n**示例 1：**\n\n```java\n输入：n = 5, m = 3\n输出：3\n```\n\n**示例 2：**\n\n```java\n输入：n = 10, m = 17\n输出：2\n```\n\n**限制：**\n\n- 1 <= n <= 10^5\n- 1 <= m <= 10^6\n\n**解法一**\n\n用链表模拟的解法，在数据太大的时候会 TLE\n\n```java\n/*\n链表模拟解法\n0 1 2 3 4 5 m=3\n3 4 5 0 1\n*/\npublic int lastRemaining(int n, int m) {\n    Deque<Integer> queue=new LinkedList<>();\n    for(int i=0;i<n;i++)\n        queue.addLast(i);\n    while(queue.size()>1){\n        for(int i=0;i<m;i++){\n            int temp=queue.removeFirst();\n            if(i!=m-1){\n                queue.addLast(temp);\n            }\n        }\n    }\n    return queue.getFirst();\n}\n```\n**解法二**\n\n数学归纳法，加上一点递推 dp\n\n```java\n/*\n    0 ~ n-1 每次 kill 第 k 个人\n    k=(m-1)%n\n\n    kill k 之后，在 n-1 个人中重建新索引\n    原始索引   新的 index\n    k+1         0\n    k+2         1\n    k+3         2\n    ...         ...\n    n-1         n-k-2\n    0           n-k-1\n    1           n-k\n    2           n-k+1\n    ...         ...\n    k-1         n-2\n\n    新索引 (x) ---> 原始索引 (y)\n    y=(x+k+1)%n  eg. (n-2+k+1)%n=(n+k-1)%n=k-1\n    设在 n-1 个人中最后剩下的人是 f(n-1,m) 按照上面的公式转换成原始索引就是\n    f(n,m)=(f(n-1,m)+k+1)%n\n */\n//数学解法\npublic int lastRemaining(int n, int m) {\n    int last=0;//一个人的时候存活者 index f(1,m)=0\n    for(int i=2;i<=n;i++){ //枚举人数\n        last=(last+m)%i;\n    }\n    return last;\n}\n```\n参考了 LeetCode 的 [大佬题解](https://leetcode-cn.com/u/yuanninesuns/)，讲的挺好的\n\n**递归解法**\n\n```java\n//递归的挺好理解\npublic int lastRemaining(int n, int m) {\n    if(n==0) return 0;\n    return (lastRemaining(n-1,m)+m)%n;\n}\n```\n## [1014. 最佳观光组合](https://leetcode-cn.com/problems/best-sightseeing-pair/)\n\n给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。\n\n一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。\n\n返回一对观光景点能取得的最高分。\n\n**示例：**\n\n```java\n输入：[8,1,5,2,6]\n输出：11\n解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n```\n\n**提示：**\n\n- `2 <= A.length <= 50000`\n- `1 <= A[i] <= 1000`\n\n**解法一**\n\n暴力解法，`O(N^2)`，这题数据 5w，肯定会 T\n\n```java\n//A[i] + A[j] + i - j (i<j)\npublic int maxScoreSightseeingPair(int[] A) {\n    int res=-1;\n    for (int i=0;i<A.length;i++) {\n        for (int j=i+1;j<A.length;j++) {\n            res=Math.max(A[i]+A[j]+i-j,res);\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\n```java\n// A[i]+A[j] - (j-i) i<j\n// A[i]+i + (A[j]-j)\npublic int maxScoreSightseeingPair(int[] A) {\n    int res=-1;\n    int maxPre=A[0]+0;\n    for (int j=1;j<A.length;j++) {           \n        res=Math.max(maxPre+A[j]-j,res);\n        maxPre=Math.max(maxPre,A[j]+j);\n    }\n    return res;\n}\n```\n我们把式子合并一下 `(A[i]+i)+(A[j]-j)` ，然后发现其实上面的暴力解法中，我们想要结果最大实际上就是要两部分都最大，然后内层循环里面，`A[j]-j` 是个变量，而`A[i]+i`不变的，代表`j`位置之前，所有的`A[i]+i` 但是我们只需要最大的，所以我们完全可以用一个变量来保存这个最大值，然后遍历的过程中不断的更新它就 ok 了\n\n## [983. 最低票价](https://leetcode-cn.com/problems/minimum-cost-for-tickets/)\n\n在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 `days` 的数组给出。每一项是一个从 `1` 到 `365` 的整数。\n\n火车票有三种不同的销售方式：\n\n- 一张为期一天的通行证售价为 `costs[0]` 美元；\n- 一张为期七天的通行证售价为 `costs[1]` 美元；\n- 一张为期三十天的通行证售价为 `costs[2]` 美元。\n\n通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。\n\n返回你想要完成在给定的列表 `days` 中列出的每一天的旅行所需要的最低消费。\n\n**示例 1：**\n\n```java\n输入：days = [1,4,6,7,8,20], costs = [2,7,15]\n输出：11\n解释： \n例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：\n在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。\n在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。\n在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。\n你总共花了 $11，并完成了你计划的每一天旅行。\n```\n\n**示例 2：**\n\n```java\n输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\n输出：17\n解释：\n例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： \n在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。\n在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 \n你总共花了 $17，并完成了你计划的每一天旅行。\n```\n\n**提示：**\n\n1. `1 <= days.length <= 365`\n2. `1 <= days[i] <= 365`\n3. `days` 按顺序严格递增\n4. `costs.length == 3`\n5. `1 <= costs[i] <= 1000`\n\n**解法一**\n\n这题的递推关系其实很容易就想到：`dp[i]=Min(dp[i-dt[k]]+costs[k],dp[i])`，可是菜鸡的我还是搞了半天才 AC\n\n```java\npublic int mincostTickets(int[] days, int[] costs) {\n    int n=days.length;\n    int[] dp=new int[days[n-1]+1];\n    boolean[] visit=new boolean[days[n-1]+1];\n    for (int i:days) {\n        visit[i]=true;\n    }\n    Arrays.fill(dp,0x3f3f3f3f);\n    int [] dt = {1,7,30};\n    dp[days[0]-1]=0;//初始状态\n    //枚举所有的 day\n    for (int d=days[0];d<=days[n-1];d++) {\n        //一开始没想到这里，dubug 的时候才看出来，不在旅游计划中的应该直接延续前面的\n        if (!visit[d]) { \n            dp[d]=dp[d-1];\n            continue;\n        }\n        //三种票\n        for (int k=0;k<3;k++) {\n            dp[d]=Math.min((d-dt[k]>=days[0]-1?dp[d-dt[k]]:0)+costs[k],dp[d]);\n        }\n    }\n    return dp[days[n-1]];\n}\n```\n一开始写了二维的，然后发现一维的状态并没有用，改成一维之后又 dubug 了半天，主要就在那个非旅行计划中的`d`没处理好，这题的状态定义不是特别清晰，然后搞混了，把非旅行计划内的也算进去了\n\n## [837. 新 21 点](https://leetcode-cn.com/problems/new-21-game/)\n\n爱丽丝参与一个大致基于纸牌游戏 “21 点” 规则的游戏，描述如下：\n\n爱丽丝以 `0` 分开始，并在她的得分少于 `K` 分时抽取数字。 抽取时，她从 `[1, W]` 的范围中随机获得一个整数作为分数进行累计，其中 `W` 是整数。 每次抽取都是独立的，其结果具有相同的概率。\n\n当爱丽丝获得不少于 `K` 分时，她就停止抽取数字。 爱丽丝的分数不超过 `N` 的概率是多少？\n\n**示例 1**\n\n```java\n输入：N = 10, K = 1, W = 10\n输出：1.00000\n说明：爱丽丝得到一张卡，然后停止。\n```\n\n**示例** **2**\n\n```java\n输入：N = 6, K = 1, W = 10\n输出：0.60000\n说明：爱丽丝得到一张卡，然后停止。\n在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。\n```\n\n**示例** 3\n\n```java\n输入：N = 21, K = 17, W = 10\n输出：0.73278\n```\n\n**提示：**\n\n1. `0 <= K <= N <= 10000`\n2. `1 <= W <= 10000`\n3. 如果答案与正确答案的误差不超过 `10^-5`，则该答案将被视为正确答案通过。\n4. 此问题的判断限制时间已经减少。\n\n**解法一**\n\n题目意思都得理解好久，面试应该不会考，参考评论区大佬题解写的一个类似背包的做法\n\n```java\npublic double new21Game(int N, int K, int W) {\n    if(K==0) return 1;\n    //随机抽牌和为 i 的概率，背包问题\n    double[] dp=new double[N+1];\n    dp[0]=1;\n    dp[1]=1.0/W;\n    // i<=K\n    //dp[i] = 1/W(dp[i-1]+dp[i-2]+...+dp[i-W]);\n    //dp[i-1] = 1/W(dp[i-2]+dp[i-3]+...+dp[i-W-1])\n    //==> dp[i]=(1 + 1/W)*dp[i-1]-(1/W)*dp[i-W-1]\n    for(int i=2;i<=K;i++){\n        if(i-W-1>=0){\n            dp[i]=(1+1.0/W)*dp[i-1]-1.0/W*dp[i-W-1];\n        }else{\n            dp[i]=(1+1.0/W)*dp[i-1];\n        }\n    }\n    // i>K 从 i-W ~ i 区间选小于 K 的部分\n    //和剑指 offer 的骰子哪一题有点像\n    //dp[i] = 1/W(dp[K-1]+dp[K-2]+...+dp[i-W]) or dp[i]=1/W(dp[i-W]+dp[i-W+1]+..+dp[K-1])\n    //dp[i-1] = 1/W(dp[k-1]+dp[K-2]+...+dp[i-W-1]) or dp[i+1] = 1/W(dp[i-W+1]+dp[i-W+2]...+dp[K-1])\n    //==> dp[i] = dp[i-1]-1/W*dp[i-W-1] or dp[i]=1/W*dp[i-W]+dp[i+1] 两个是等价的\n    for (int i=K+1;i<=N;i++) {\n        if(i-W-1>=0){\n            dp[i]=dp[i-1]-1.0/W*dp[i-W-1];  \n        }else{\n            dp[i]=dp[i-1]; //1/W\n        }\n    }\n    double res=0;\n    for (int i=K;i<=N;i++) {\n        res+=dp[i];\n    }\n    return res;\n}\n```\n\n下一次碰到就不一定会做了，理解的不是很透彻，不过对背包公式的推导倒是理解多了一点\n\n## [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)\n\nDifficulty: **困难**\n\n给定一个整数矩阵，找出最长递增路径的长度。\n\n对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。\n\n**示例 1:**\n\n```go\n输入：nums = \n[\n  [9,9,4],\n  [6,6,8],\n  [2,1,1]\n] \n输出：4 \n解释：最长递增路径为 [1, 2, 6, 9]。\n```\n\n**示例 2:**\n\n```go\n输入：nums = \n[\n  [3,4,5],\n  [3,2,6],\n  [2,2,1]\n] \n输出：4 \n解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。\n```\n**解法一**\n\n记忆化递归，这题如果递推的话需要保证子问题都已经被计算过，所以需要进行排序预处理，确保大的先求出来，然后再进行转移，参考上面 [5331-跳跃游戏-V](#5331-跳跃游戏-V)\n```java\nint [][] dir ={{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nInteger [][] cache = null;\n\n//记忆化递归，数组递推的方式状态转移方向不明确，需要排序\npublic int longestIncreasingPath(int[][] matrix) {\n    if (matrix == null || matrix.length <=0){\n        return 0;\n    }\n    int m = matrix.length;\n    int n = matrix[0].length;\n    cache = new Integer[m][n];\n    int res = 0;\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n            res = Math.max(res, dfs(matrix, i, j));\n        }\n    }\n    return res;\n}\n\npublic int dfs(int[][] matrix, int x, int y){\n    if (cache[x][y] != null){\n        return cache[x][y];\n    }\n    int res = 1;\n    for (int i = 0; i < dir.length; i++){\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (valid(matrix, nx, ny) && matrix[nx][ny] > matrix[x][y]){\n            res = Math.max(res, dfs(matrix, nx, ny)+1);\n        }\n    }\n    return cache[x][y] = res;\n}\n\npublic boolean valid(int[][] matrix, int x, int y){\n    return x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length; \n}\n```\n\n##  _字符串类型的动态规划_\n\n## [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)\n\n给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。\n\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0 \n\n> 最长公共子序列问题是在一组序列（通常 2 个）中找到最长公共子序列（注意：不同于子串，LCS 不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用\n\n**示例 1:**\n\n```java\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\"，它的长度为 3。\n```\n\n**示例 2:**\n\n```java\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\"，它的长度为 3。\n```\n\n**示例 3:**\n\n```java\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0。\n```\n\n**解法一**\n\n2019.10.19 力扣终于有这题了，重新来做一遍，这题也就是经常说的 LCS，dp 的经典问题\n\n```java\npublic int longestCommonSubsequence(String A, String B) {\n    int[][] dp=new int[A.length()+1][B.length()+1];\n    for (int i=1;i<=A.length();i++) {\n        for (int j=1;j<=B.length();j++) {\n            if (A.charAt(i-1)==B.charAt(j-1)) {\n                dp[i][j]=dp[i-1][j-1]+1;\n            }else{\n                dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[A.length()][B.length()];\n}\n```\n其实看见这种什么最长的多半和 dp 有关系，这题只要明白几个要点就可以推出 dp 方程\n\n- `dp[i][j]` 代表 A 序列前`i`个字符（记为`Ai`）， 和 B 序列前`j`个字符（记为`Bj`） 的 LCS\n\n- 两层 for 循环遍历两个序列，当`A[i]==B[j]`的时候，LCS 长度就会增加 1，进而得到 dp 方程\n\n  `dp[i][j]=dp[i-1][j-1]+1`   dp[i-1] [j-1] 代表的就是不包含`Ai/Bj`的`Ai-1`和`Bj-1` 的 LCS\n\n- `A[i]!=B[j]`的时候就有两种情况了，首先`A[i]`和`B[j]`已经**不可能同时出现在最终的 LCS 里面**了，所以我们考虑另外的两种情况`dp[i][j-1]`和`dp[i-1][j]`取个最大值\n\n除此之外，还有一个值得注意的小细节，这里循环都是从 1 开始的，这样就不用处理初始值，如果从 0 开始的话，处理初始情况（i，j=0 的情况）会麻烦一点\n\n**解法二**\n\n2019.10.19 重写了一种记忆化递归的方法，没有 dp 快，但是思路其实是类似的\n\n```java\nInteger[][] cache=null;\n\npublic int longestCommonSubsequence(String text1, String text2) {\n    if(text2==null || text1==null || text1.length()<=0 ||text2.length()<=0){\n        return 0;\n    }\n    int len1=text1.length();\n    int len2=text2.length();\n    cache=new Integer[len1][len2];\n    return lcs(text1,len1-1,text2,len2-1);\n}\n\n//lcs 定义：求 text1[0,a] 和 text2[0,b] 的最长公共子序列\npublic int lcs(String text1, int a,String text2,int b) {\n    if(a==-1 || b==-1){\n        return 0;\n    }\n    if (cache[a][b]!=null) {\n        return cache[a][b];\n    }\n    if (text1.charAt(a)==text2.charAt(b)) {\n        cache[a][b]=lcs(text1,a-1,text2,b-1)+1;\n        return cache[a][b];\n    }else{\n        cache[a][b]=Math.max(lcs(text1,a-1,text2,b),lcs(text1,a,text2,b-1));\n        return cache[a][b];\n    }\n}\n```\n## [AtCoder-LCS](https://atcoder.jp/contests/dp/tasks/dp_f)\n\n题目就不 copy 了，这里就是求出 lcs 具体的字符串，而不是求长度\n\n我这里是参考了 leetcode 上一个大佬的 [文章](https://leetcode-cn.com/circle/article/CwZVuV/) 利用 back 数组，从后向前递推，但是实际上有点多余，直接根据 dp 数组也可以推回去，但是这样写比较通用，逻辑比较清楚。\n\n```java\npublic static void main(String[] args) {\n    Scanner sc=new Scanner(System.in);\n    while(sc.hasNext()){\n        String A=sc.next();\n        String B=sc.next();\n        System.out.println(longestCommonSubsequence(A,B));\n    }\n}\n\npublic static String longestCommonSubsequence(String A, String B) {\n    int lenA=A.length();\n    int lenB=B.length();\n    int[][] dp=new int[lenA+1][lenB+1];\n    int[][] back=new int[lenA+1][lenB+1];\n    for (int i=1;i<=lenA;i++) {\n        for (int j=1;j<=lenB;j++) {\n            if (A.charAt(i-1)==B.charAt(j-1)) {\n                dp[i][j]=dp[i-1][j-1]+1;\n                back[i][j]=1; //左上\n            }else if(dp[i-1][j]>dp[i][j-1]){\n                dp[i][j]=dp[i-1][j];\n                back[i][j]=2; //上\n            }else{\n                dp[i][j]=dp[i][j-1];\n                back[i][j]=0; //左\n            }\n        }\n    }\n    int i=lenA,j=lenB;\n    StringBuilder res=new StringBuilder();\n    while(i>0 && j>0){\n        if (back[i][j]==1) {\n            i--;j--;\n            res.append(A.charAt(i));\n        }else if(back[i][j]==2){\n            i--;\n        }else{\n            j--;\n        }\n    }\n    return res.reverse().toString();\n}\n```\n\n了解即可。\n\n## [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n**示例 1:**\n\n```java\n输入：\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n输出：3\n解释：\n长度最长的公共子数组是 [3, 2, 1]。\n```\n\n**说明：**\n\n1. 1 <= len(A), len(B) <= 1000\n2. 0 <= A[i], B[i] < 100\n\n**解法一**\n\n简单的递推，注意别写成上面的 lcs 了，这里的`dp[i][j]` 代表的其实是**公共子串**以`A[i]`和`B[i]` 结尾的最长重复子数组长度，如果`A[i]`和`B[i]`不相等那就是 0\n\n```java\npublic int findLength(int[] A, int[] B) {\n    int lenA=A.length;\n    int lenB=B.length;\n    int[][] dp=new int[lenA+1][lenB+1];\n    int res=0;\n    for(int i=1;i<=lenA;i++){\n        for(int j=1;j<=lenB;j++){\n            if(A[i-1]==B[j-1]){\n                dp[i][j]=dp[i-1][j-1]+1;\n                res=Math.max(dp[i][j],res);\n            }\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\n> 本来是想练练二分，在二分的 tag 里面看见的这题，结果发现这题 dp 似乎更容易，看了官方的二分的解法，其实就是二分公共子串的长度，然后检查，检查这一步有一些操作，不是很理解，以后有机会再来补充。\n> _已补充_，见 [Rabin-Karp 专题](http://imlgw.top/2020/07/01/rabinkarp-suan-fa/#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84)\n\n## [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)\n\n给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n**示例 1:**\n\n```java\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse （将 'h' 替换为 'r')\nrorse -> rose （删除 'r')\nrose -> ros （删除 'e')\n```\n\n**示例 2:**\n\n```java\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention （删除 't')\ninention -> enention （将 'i' 替换为 'e')\nenention -> exention （将 'n' 替换为 'x')\nexention -> exection （将 'n' 替换为 'c')\nexection -> execution （插入 'u')\n```\n\n**解法一**\n\n很经典的动态规划的问题，做之前看了动态规划的思路，然后很快写出了递归的解法。\n\n```java\nInteger[][] cache=null;\n\npublic int minDistance(String word1, String word2) {\n    cache=new Integer[word1.length()][word2.length()];\n    return minDistance(word1,word1.length()-1,word2,word2.length()-1);\n}\n\n//递归的定义：word1[0,idx1] 和 word2[0,idx2] 的最短编辑距离\npublic int minDistance(String word1,int idx1,String word2,int idx2) {\n    if (idx1<0) {\n        return idx2+1;\n    }\n    if (idx2<0) {\n        return idx1+1;\n    }\n    if (cache[idx1][idx2]!=null) {\n        return cache[idx1][idx2];\n    }\n    if (word1.charAt(idx1) == word2.charAt(idx2)) {\n        return cache[idx1][idx2]=minDistance(word1,idx1-1,word2,idx2-1);\n    }else{\n        return cache[idx1][idx2]=1+Math.min(minDistance(word1,idx1-1,word2,idx2),Math.min(minDistance(word1,idx1,word2,idx2-1),minDistance(word1,idx1-1,word2,idx2-1)));\n    }\n}\n```\n核心的递推公式就是 \n\n`minDis(i,j)=minDis(i-1,j-1)  word1[i]==word2[j]`\n\n`minDis(i,j)=min(minDis(i-1,j),minDis(i,j-1),minDis(i-1,j-1))+1  word1[i]!=word2[j]`\n\n第一个公式好说，相等时候就别动，延续之前的状态，关键是第二个，不相等的时候，简单来说就是求对应的三种操作增，删，改的最小值，但是这里，第二种删的操作，这里要想清楚，其实 word1 删除一个其实就等价于 word2 增加一个，所以是`minDis(i,j-1)`，虽然题目说的是从 word1 转换为 word2，但是其实结果都是一样的，这个转换的过程其实是可逆的\n\n**解法二**\n\n标准的动态规划写法，感觉还是上面的记忆化递归好写，动态规划要考虑的边界比递归要多\n\n```java\npublic int minDistance2(String word1, String word2) {\n    if (word1.length()<=0 || word2.length()<=0) {\n        return word2.length()==0?word1.length():word2.length();\n    }\n    //dp[i][j]: word1 前 i 个和 word2 前 j 个的最短编辑距离\n    int[][] dp=new int[word1.length()+1][word2.length()+1];\n    for (int i=1;i<=word2.length();i++) {\n        dp[0][i]=i;\n    }\n    for (int i=1;i<=word1.length();i++) {\n        dp[i][0]=i;\n    }\n    for (int i=1; i<=word1.length();i++) {\n        for (int j=1;j<=word2.length();j++) {\n            if (word1.charAt(i-1)==word2.charAt(j-1)) {\n                dp[i][j]=dp[i-1][j-1];\n            }else{\n                dp[i][j]=1+Math.min(dp[i-1][j],Math.min(dp[i][j-1],dp[i-1][j-1]));\n            }\n        }\n    }\n    return dp[word1.length()][word2.length()];\n}\n```\n\n## [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)\n\n给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。\n\n**示例 1:**\n\n```java\n输入：\"abc\"\n输出：3\n解释：三个回文子串：\"a\", \"b\", \"c\".\n```\n\n**示例 2:**\n\n```java\n输入：\"aaa\"\n输出：6\n说明：6 个回文子串：\"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n```\n\n**注意：**\n\n1. 输入的字符串长度不会超过 1000。\n\n**解法一**\n\n动态规划的解法，其实我是没想到的，`dp[i][j]`代表的是`s[i,j]` 是不是回文子串\n\n```java\npublic int countSubstrings(String s) { \n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    //aaaba\n    //dp[i][j] i~j 是不是回文\n    boolean [][] dp=new boolean[n][n];\n    int res=n; //下面的循环没有统计单个字符的情况\n    for (int i=n-1;i>=0;i--) {\n        for (int j=i+1;j<n;j++) { //统一写法，这里改成 j=i 就可以统计到单个字符的情况\n            if (s.charAt(i) == s.charAt(j) && (j-i<=2 || dp[i+1][j-1])) {\n                dp[i][j]=true;\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\n**解法二**\n\n很熟悉的解法，没错就是我们之前 [最长回文子串中](https://leetcode-cn.com/problems/longest-palindromic-substring/) 的解法，比上面的动态规划会快很多，也比较自然\n\n```java\n//中心扩展法\npublic int countSubstrings(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int count=0;\n    for (int i=0;i<n;i++) {\n        count+=spread(s,i,i+1)+spread(s,i,i);\n    }\n    return count;\n}\n\npublic int spread(String s,int i,int j){\n    int res=0;\n    while(i>=0 && j<s.length()){\n        if (s.charAt(i)==s.charAt(j)) {\n            i--;j++;\n            res++;\n        }else{\n            return res;\n        }\n    }\n    return res;\n}\n```\n\n## [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n\n给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n**示例 1:**\n\n```java\n输入：\"(()\"\n输出：2\n解释：最长有效括号子串为 \"()\"\n```\n\n**示例 2:**\n\n```java\n输入：\")()())\"\n输出：4\n解释：最长有效括号子串为 \"()()\"\n```\n\n**解法一**\n\n栈+dp 的思路\n\n```java\npublic int longestValidParentheses(String s) {\n    if (s==null || s.length()<=0) {\n        return  0;\n    }\n    Stack<Integer> stack=new Stack<>();\n    int[] dp=new int[s.length()]; //以 i 位置括号结尾的最长有效括号\n    dp[0]=0;\n    int res=0;\n    for (int i=0;i<s.length();i++) {\n        if (s.charAt(i)=='(') {\n            stack.push(i); //dp[i]=0\n        }else{\n            if(!stack.isEmpty()){\n                int left=stack.pop();\n                dp[i]= left==0?i-left+1:dp[left-1]+i-left+1;\n                res=Math.max(res,dp[i]);\n            }//else dp[i]=0  \n        }\n    }\n    return res;\n}\n```\n\n首先想到的就是这种解法，感觉还是很好理解的，栈中存索引，`dp[i]` 代表以`i`位置括号结尾的最长有效括号，当遇到右括号的时候将栈顶的左括号的索引`left`弹出来，两者形成的括号长度再加上左括号索引前一个元素`dp[left-1]`就是当前位置的`dp[i]`\n\n**Update**\n\n回头做第二遍地时候竟然写了个不一样的 dp 思路 hahaha~，还是挺有意思的，遇到右括号不是直接用`i-left+1` 算长度，而是直接根据前一个字符`dp[i-1]` 进行转化，其实是一样的，只不过是累加的，前面的是一次就全算出来了\n\n```java\n//update: 2020.4.13\npublic int longestValidParentheses(String s) {\n    if(s==null || s.length()<=0) return 0;\n    Deque<Integer> stack=new ArrayDeque<>();\n    int[] dp=new int[s.length()];\n    int res=0;\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)=='('){\n            stack.push(i);\n        }else{\n            if(!stack.isEmpty()){\n                int left=stack.pop();\n                //dp[i]=(left>1?dp[left-1]+dp[i-1]:dp[i-1])+2;\n                dp[i]=dp[i-1]+(left>1?dp[left-1]:0)+2;\n            }\n            res=Math.max(res,dp[i]);\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\n纯 dp 解法，上面的解法虽然也用到了一点动态规划，但是还不够纯粹\n\n```java\npublic int longestValidParentheses(String s) {\n    if (s==null || s.length()<=0) {\n        return  0;\n    }\n    int[] dp=new int[s.length()];\n    dp[0]=0;\n    int res=0;\n    for (int i=1;i<s.length();i++) {\n        if (s.charAt(i)==')') {\n            if (s.charAt(i-1)=='(') { //前一个是左括号\n                dp[i]=i-2>=0?dp[i-2]+2:2;\n            }else{ //前一个是右括号 ()(())\n                if (i-dp[i-1]-1>=0 && s.charAt(i-dp[i-1]-1)=='(') {//前一个右括号的合法序列的前一个是'('\n                    //前一个的前一个的 dp[i-dp[i-1]-2]+dp[i-1]+2\n                    dp[i]=(i-dp[i-1]-2>=0?dp[i-dp[i-1]-2]:0)+dp[i-1]+2; \n                }\n                //前一个右括号的合法序列的前一个是')', 没救了\n            }\n        }\n        res=Math.max(res,dp[i]);\n    }\n    return res;\n}\n```\n\n解释都在代码注释中，~~感觉没那么容易直接想到，毕竟 hard 题~~\n\n**Update: 2020.7.4**\n\n今天的打卡题，之前的做法只记得栈+dp 的做法，dp 的方法忘了，现场写了下纯 dp 的方法，发现其实纯 dp 的好像更简单啊，状态定义出来后，转移方程就呼之欲出了（是我变强了么🤣）\n\n```golang\n//和前面的写法不一样，感觉我的更好理解\nfunc longestValidParentheses(s string) int {\n    var dp = make([]int, len(s)) //以 s[i] 结尾的最长有效括号\n    //dp[0] = 0\n    var res = 0\n    for i := 1; i < len(s); i++{\n        if s[i] == ')' {\n            if i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '('{\n                dp[i] = dp[i - 1] + 2\n                if(i - dp[i-1] - 2 >= 0){\n                    dp[i] += dp[i - dp[i-1] - 2]\n                }\n            }\n        }\n        res = Max(res, dp[i])\n    }\n    return res\n}\n\nfunc Max(a, b int) int{\n    if a > b{\n        return a\n    }\n    return b\n}\n```\n\n> 其实还有两种方法，一种利用纯利用栈的，还有一种很神奇的方法，没什么通用性，很难直接想出来，就不做记录了，纯栈的解法后面再来补充\n\n**解法三**\n\n~~纯利用栈的解法以后再来补充~~ 算了，直接写了吧\n\n```java\npublic int longestValidParentheses(String s) {\n    if (s==null || s.length()<=0) {\n        return  0;\n    }\n    Deque<Integer> stack=new ArrayDeque<>();\n    stack.push(-1); //临界点\n    int res=0;\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)=='('){\n            stack.push(i);\n        }else{\n            stack.pop();\n            if(stack.isEmpty()){ \n                //栈为空，说明当前的')'肯定是不合法的\n                //其实相当于一个分界点，这个位置之前的字符不可能再构成合法的序列了\n                //后面的栈空的时候就不能再根据-1 来算长度了，需要一个新的临界点\n                stack.push(i);\n            }else{\n                res=Math.max(res,i-stack.peek());\n            }\n        }\n    }\n    return res;\n}\n```\n关键的地方就在于将**非法的右括号**入栈，作为一个分界点便于后面计算，初始的-1 也很关键\n\n**解法四**\n\nUPDATE: 2020.7.4，把之前所谓的“神奇”的方法也记录下，其实也没啥神奇的，看一下就懂了，这种方法还是很优秀的，空间复杂度为`O(1)`\n```golang\n//实时统计左右括号的个数，当匹配的时候统计长度，记得左右都要扫一遍\nfunc longestValidParentheses(s string) int {\n    var left, right = 0, 0\n    var res = 0\n    for i := 0; i < len(s); i++ {\n        if s[i] == '(' {\n            left++\n        } else {\n            right++\n        }\n        if right > left {\n            right, left = 0, 0\n        }else if right == left {\n            res = Max(res, left*2)\n        }\n    }\n    right, left = 0, 0\n    for i := len(s) - 1; i >= 0; i-- {\n        if s[i] == '(' {\n            left++\n        } else {\n            right++\n        }\n        if right < left {\n            right, left = 0, 0\n        } else if right == left {\n            res = Max(res, left*2)\n        }\n    }\n    return res\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n## [面试题 17.13. 恢复空格](https://leetcode-cn.com/problems/re-space-lcci/)\n\nDifficulty: **中等**\n\n哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子`\"I reset the computer. It still didn’t boot!\"`已经变成了`\"iresetthecomputeritstilldidntboot\"`。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典`dictionary`，不过，有些词没在词典里。假设文章用`sentence`表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\n\n**注意：** 本题相对原题稍作改动，只需返回未识别的字符数\n\n**示例：**\n\n```go\n输入：\ndictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]\nsentence = \"jesslookedjustliketimherbrother\"\n输出： 7\n解释： 断句后为\"jess looked just like tim her brother\"，共 7 个未识别字符。\n```\n\n**提示：**\n\n*   `0 <= len(sentence) <= 1000`\n*   `dictionary`中总字符数不超过 150000。\n*   你可以认为`dictionary`和`sentence`中只包含小写字母。\n\n**解法一**\n\n同样的解法，用 Java 写就是 922ms，我觉得主要就是 substring 拖慢了速度，Java 里面 substring 是 O(N) 的操作，而 golang 中取切片值仅仅只是修改几个切片的熟悉罢了，时间复杂度是 O(1) 的，所以会很快，时间复杂度可以近似的看作 O(N^2)\n```golang\n//正向 dp，60ms\nfunc respace(dictionary []string, sentence string) int {\n    var dict = make(map[string]bool)\n    for i := 0; i < len(dictionary); i++ {\n        dict[dictionary[i]] = true\n    }\n    var n = len(sentence)\n    //前 i 个字符的最少未识别字符\n    var dp = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        dp[i] = dp[i-1] + 1 //初始值\n        for j := 0; j < i; j++ {\n            if dict[sentence[j:i]] {\n                dp[i] = Min(dp[j], dp[i])\n            }\n        }\n    }\n    return dp[n]\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n> 查询了网上的一些资料，发现 Java 的 substring 其实在 1.7 之前时间复杂度是 O(1) 的，后面为了避免内存泄漏就改成 O(N) 了 [参考](https://www.iteye.com/blog/lvdccyb-1947937)\n\n**解法二**\n\n记忆化递归，其实一开始就被题目的 tag 给迷惑了，我一看记忆化，就直接往记忆化的方向去写了，加上前天刚写了 单词拆分 2 的记忆化，唉，看来以后不能直接看 tag 了，一开始写了个贼垃圾的 dfs，就是下面注释的部分，时间复杂度爆炸，两层 for 循环\n```golang\n//记忆化 dfs tle 了 可能思路有点问题\n//确实是思路出了问题，下面补充了正确的记忆化写法 248ms\nfunc respace(dictionary []string, sentence string) int {\n    var dict = make(map[string]bool)\n    for i := 0; i < len(dictionary); i++ {\n        dict[dictionary[i]] = true\n    }\n    var cache = make(map[string]int)\n    return dfs(sentence, dict, cache)\n}\n\n// func dfs(s string, dict map[string]bool, cache map[string]int) int {\n//     if _, ok := cache[s]; ok {\n//         return cache[s]\n//     }\n//     var res = len(s)\n//     for i := 0; i <= len(s); i++ {\n//         temp := len(s)\n//         for j := i + 1; j <= len(s); j++ {\n//             if dict[s[i:j]] {\n//                 temp = Min(temp, dfs(s[j:], dict, cache))\n//             }\n//         }\n//         res = Min(res, temp+i)\n//     }\n//     cache[s] = res\n//     return res\n// }\n\nfunc dfs(s string, dict map[string]bool, cache map[string]int) int {\n    if _, ok := cache[s]; ok {\n        return cache[s]\n    }\n    var res = len(s)\n    for i := 1; i <= len(s); i++ {\n        if dict[s[:i]] {\n            res = Min(res, dfs(s[i:], dict, cache))\n        }else{\n            res = Min(res, dfs(s[i:], dict, cache) + i)\n        }\n    }\n    cache[s] = res\n    return res\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n**解法三**\n\n上面的解法从某种角度上来说都还是是属于暴力解法，即使是 golang 的 O(N^2) 的方法，哈希表的常数也是很大的，而且因为是存的字符串，所以字符串本身 Hash 的时间也是不能忽略的，因此我们可以引入**前缀树**，不了解相关知识的可以看我 [之前的文章](http://imlgw.top/2019/12/17/zi-dian-shu/)\n\n这里我用 golang 也写了一版，但是提升不明显，所以用 Java 重写了一版，时间复杂度有了质的飞跃\n```java\n//Trie+dp 14ms, 很强\npublic int respace(String[] dictionary, String s) {\n    Node root = new Node();\n    for (String word : dictionary ) {\n        root.insert(word);\n    }\n    int n = s.length();\n    int[] dp = new int[n+1];\n    for (int i = 1; i <=n ; i++) {\n        dp[i] = dp[i-1] + 1;\n        Node cur = root;\n        for (int j = i-1; j >=0 ; j--) {\n            int c = s.charAt(j)-'a';\n            //很大的优化点，c 不存在，那么以 c 为后缀的其他字符肯定也不会存在，直接 break\n            if(cur.next[c] == null){\n                break;\n            }\n            if(cur.next[c].isWord){\n                dp[i] = Math.min(dp[i], dp[j]);\n            }\n            if(dp[i] == 0){\n                break;\n            }\n            cur = cur.next[c];\n        }\n    }\n    return dp[n];\n}\n\n//这里 Trie 不用写搜索，直接手动的搜索，这样可以做一些剪枝\nclass Node{\n    Node[] next = new Node[26];\n    \n    boolean isWord;\n\n    //反向插入\n    public void insert(String s){\n        Node cur = this;\n        for (int i = s.length()-1; i >= 0; i--) {\n            int c = s.charAt(i)-'a';\n            if(cur.next[c] == null){\n                cur.next[c] = new Node();\n            }\n            cur = cur.next[c];\n        }\n        cur.isWord = true;\n    }\n}\n```\n**解法四**\n\n没错，这题解法很多，也都很值得学习，解法四其实就是之前学过的字符串哈希的方法，所以这个解法右转--->[Rabin-Karp 算法](http://imlgw.top/2020/07/01/rabinkarp-suan-fa/#%E9%9D%A2%E8%AF%95%E9%A2%98-17-13-%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC)\n\n## [174. 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)\n\nDifficulty: **困难**\n\n一些恶魔抓住了公主（**P**）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（**K**）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。\n\n**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**\n\n例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。\n\n<table class=\"dungeon\" style=\"display: table;\">\n\n<tbody style=\"display: table-row-group;\">\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">-2 (K)</td>\n\n<td style=\"display: table-cell;\">-3</td>\n\n<td style=\"display: table-cell;\">3</td>\n\n</tr>\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">-5</td>\n\n<td style=\"display: table-cell;\">-10</td>\n\n<td style=\"display: table-cell;\">1</td>\n\n</tr>\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">10</td>\n\n<td style=\"display: table-cell;\">30</td>\n\n<td style=\"display: table-cell;\">-5 (P)</td>\n\n</tr>\n\n</tbody>\n\n</table>\n\n**说明：**\n\n*   骑士的健康点数没有上限。\n\n*   任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。\n\n**解法一**\n\n以后每日一题没写出来之前绝壁不看群了，看了一眼群，看见群友讨论了这题，说了二分和 dp，然后我就直接向二分的方向去想了，如果独立的想的话，应该也是可以得出二分的解法的，毕竟题目的描述很明显就是二分答案，**最低的健康血量**，大于这个血量的肯定可以救出来，小于这个血量的肯定救不出来，所以 check 就是判断在某个血量下，能否拯救到公主（DP）\n\n时间复杂度 O(N^2logN)（其实我认为也可以当作 N^2 毕竟上下界都确定了，logN 也就 30 左右），这种解法也挺不错的，融合了二分和 dp\n\n```java\npublic int calculateMinimumHP(int[][] dungeon) {\n    int left = 0;\n    int right = Integer.MAX_VALUE;\n    int res = 0;\n    while(left <= right){\n        int mid = left + (right-left)/2;\n        if(check(dungeon, mid)){\n            res = mid;\n            right = mid - 1;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[][] dungeon, int live){\n    int m = dungeon.length;\n    int n = dungeon[0].length;\n    int INF = Integer.MIN_VALUE;\n    //live 的血量从左上到 dungeon[i][j] 的剩余最多血量\n    int[][] dp = new int[m+1][n+1];\n    //地牢外围加上 INF 的围墙，简化逻辑\n    Arrays.fill(dp[0], INF);\n    dp[0][1] = live;\n    for(int i = 1; i <= m; i++){\n        dp[i][0] = INF;\n        for(int j = 1; j <= n; j++){\n            if(dp[i-1][j] <= 0 && dp[i][j-1] <=0 ){\n                dp[i][j] = INF; //无法到达这里\n            }else{\n                dp[i][j] = dungeon[i-1][j-1] + Math.max(dp[i][j-1], dp[i-1][j]);\n            }\n        }\n    }\n    return dp[m][n] > 0;\n}\n```\n当然这题也有纯 dp 的做法，很可惜，我压根没往上面想，我只想着二分 dp，写完了 AC 之后就去看评论区了，结果发现大家都是直接 dp 的。然后还看到了一个关键词：逆向 dp，然后赶紧关了评论区回来写了下面的 dp 解法\n\n**解法二**\n```java\n/*\n    -2  -3  3\n    -5 -10  1\n    10  30 -5 1\n            \n    7   5   2\n    6  11   5\n    1   1   6\n*/\npublic int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length;\n    int n = dungeon[0].length;\n    int INF = Integer.MAX_VALUE;\n    //从 dungeon[i-1][j-1] 到右下角至少要多少血量\n    int[][] dp = new int[m+1][n+1];\n    Arrays.fill(dp[m], INF);//末行\n    dp[m][n-1] = 1; //初始血量\n    for (int i = m-1; i >= 0; i--) {\n        dp[i][n] = INF; //首列和尾列\n        for (int j = n-1; j >= 0; j--) {\n            dp[i][j] = Math.max(Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1);\n        }\n    }\n    return dp[0][0];\n}\n```\n这题为啥不能正向 dp 呢，设`dp[i][j]`为从左上角到 i,j 所需要的最低血量？其实这个很明显就是有问题的，没办法转移，`dp[i][j]`和`dp[i-1][j]`没有任何关系，都不一定是同一条路径\n\n## [97. 交错字符串](https://leetcode-cn.com/problems/interleaving-string/)\n\nDifficulty: **困难**\n\n给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。\n\n**示例 1:**\n\n```go\n输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n输出：true\n```\n\n**示例 2:**\n\n```go\n输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n输出：false\n```\n\n**解法一**\n![Ugzon0.png](https://s1.ax1x.com/2020/07/18/Ugzon0.png)\n```java\npublic boolean isInterleave(String s1, String s2, String s3) {\n    int ns1 = s1.length(), ns2 = s2.length(), ns3 = s3.length();\n    if(ns1+ns2!=ns3) return false;\n    boolean[][] dp = new boolean[ns1+1][ns2+1];\n    for(int i = 1; i <= ns1 && s1.charAt(i-1)==s3.charAt(i-1); i++){\n        dp[i][0] = true;\n    }\n    for(int i = 1; i <= ns2 && s2.charAt(i-1)==s3.charAt(i-1); i++){\n        dp[0][i] = true;\n    }\n    dp[0][0] = true;\n    for(int i = 1; i <= ns1; i++){\n        for(int j = 1; j <= ns2; j++){\n            char sc = s3.charAt(i+j-1);\n            dp[i][j] = (sc == s1.charAt(i-1) && dp[i-1][j]) \n                || sc == s2.charAt(j-1) && dp[i][j-1];\n        }\n    }\n    return dp[ns1][ns2];\n}\n```\n\n## [857. 最小的窗口子序列（LintCode）](https://www.lintcode.com/problem/minimum-window-subsequence/description)\n\n给定字符串 S 和 T，在字符串 S 中找到最小（连续的）子字符串 W（窗口），使得 T 是 W 的子序列。\n如果 S 中没有包含 T 中的所有字符的窗口，则返回空字符串\"\"。如果有多个这样的最小长度窗口，则返回一个起点编号最小的。\n1. 输入中的所有字符串只包含小写字母。\n2. S 的长度范围在 [1, 20000]。\n3. T 的长度范围在 [1, 100]。\n\n**样例 1:**\n```go\n输入：S=\"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\"，T=\"u\"\n输出：\"\"\n解释： 无法匹配\n```\n**样例 2:**\n```go\n输入：S = \"abcdebdde\"， T = \"bde\"\n输出：\"bcde\"\n解释：\"bcde\"是答案，\"deb\"不是一个较小的窗口，因为窗口中的 T 元素必须按顺序发生。\n```\n**解法一**\n\nLeetCode 上是会员题，所以在 LintCode 上写的，一开始以为是滑窗，想了半天，也只有暴力的思路，看了下讨论区，发现大家都是 dp 做的。\n\n```java\npublic String minWindow(String S, String T) {\n    int m = S.length(), n = T.length();\n    //S 前 i 个字符包含 T 前 j 个字符的最小窗口子序列起始位置\n    int[][] dp = new int[m+1][n+1];\n    for (int i = 0; i <= m; i++){\n        //虽然 T 串为空，但是注意这里不是 0，因为需要最短，所以起点越靠后越短\n        //最后的长度就是通过 i-dp[i][j] 来计算的\n        Arrays.fill(dp[i], -1);\n        dp[i][0] = i;\n    }\n    int start = -1, end = m;\n    for (int i = 1; i <= m; i++) {\n        //注意 T 的长度小于 S 的长度（不考虑也可以，只是会多遍历很多次）\n        for (int j = 1; j <= Math.min(n, i); j++){\n            if (S.charAt(i-1) == T.charAt(j-1)) {\n                dp[i][j] = dp[i-1][j-1];\n            }else{\n                //dbd\n                //  b   dbd 和 db 包含 b 的最小窗口起始位置一样\n                dp[i][j] = dp[i-1][j];\n            }\n            \n        }\n        if (dp[i][n]!=-1 && i-dp[i][n] < end-start+1) {\n            start = dp[i][n];\n            end = i-1;\n        }\n    }\n    return start==-1 ? \"\" : S.substring(start,end+1);\n}\n```\n这题和滑动窗口专题中的 [最小覆盖子串](http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)\n算是一道姊妹题，但是解法确完全不一样，当然这题也可以滑窗但是并不是很通用（主要是我没看懂）貌似会比 dp 要好\n>双序列型 DP，后面有时间会把类似的题单独抽取出来\n\n## [1553. 吃掉 N 个橘子的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges/)\n\nDifficulty: **困难**\n\n厨房里总共有 `n` 个橘子，你决定每一天选择如下方式之一吃这些橘子：\n\n*   吃掉一个橘子。\n*   如果剩余橘子数 `n` 能被 2 整除，那么你可以吃掉 `n/2` 个橘子。\n*   如果剩余橘子数 `n` 能被 3 整除，那么你可以吃掉 `2*(n/3)` 个橘子。\n\n每天你只能从以上 3 种方案中选择一种方案。\n\n请你返回吃掉所有 `n` 个橘子的最少天数。\n\n**示例 1：**\n\n```golang\n输入：n = 10\n输出：4\n解释：你总共有 10 个橘子。\n第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。\n第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）\n第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。\n第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。\n你需要至少 4 天吃掉 10 个橘子。\n```\n\n**示例 2：**\n\n```golang\n输入：n = 6\n输出：3\n解释：你总共有 6 个橘子。\n第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）\n第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）\n第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。\n你至少需要 3 天吃掉 6 个橘子。\n```\n\n**示例 3：**\n\n```golang\n输入：n = 1\n输出：1\n```\n\n**示例 4：**\n\n```golang\n输入：n = 56\n输出：6\n```\n\n**提示：**\n\n*   `1 <= n <= 2*10^9`\n\n**解法一**\n\n题目很简单，暴力的方法非常容易想到，但是问题是这题的数据范围比较大`2*1e9`，直接暴搜肯定会 T，所以需要优化下，这里我们可以直接将`minDays(n-1)`优化掉，将这种只吃一个的情况和其他情况和并，比如我现在 n=5，那么我们就可以直接求`Min(minDays(2)+1, minDays(1)+2)`，5 没法被 2 或者 3 整除，所以我们将 5 吃掉几个，变成可以被 2 和 3 整除的，吃掉的个数就是 n%2 和 n%3，也就是在这之前额外需要的天数\n```golang\nvar dp = make(map[int]int)\n​\nfunc minDays(n int) int {\n    if n == 1 || n == 0 {\n        return n\n    }\n    if v, ok := dp[n]; ok {\n        return v\n    }\n    res := 1+Min(minDays(n/2)+n%2, minDays(n/3)+n%3)\n    dp[n] = res\n    return res\n}\n​\nfunc Min (a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n---\n\n## [NC549. 变向](https://www.nowcoder.com/practice/85efab854e60499daa524ca943b72d35)\n\n牛牛准备在一个 3 行 n 列的跑道上跑步。一开始牛牛可以自己选择位于 (1,1) 还是 (2,1) 还是 (3,1)。\n\n跑道的每一格都有一些金币，当牛牛跑到一个格子，他会获得这个格子的所有金币。\n\n当牛牛位于第 i 行第 j 列时，他可以的下一步最多可能有三种选择：\n\n1. 不花费金币跑到第 i 行第 j+1 列\n2. 花费`m[j]`的金币跑到第 i-1 行第 j+1 列（如果 i=1 则不可以这么跑）。\n3. 花费`m[j]`的金币跑到第 i+1 行第 j+1 列（如果 i=3 则不可以这么跑）。\n（牛牛是一个富豪，本身带了很多的金币，所以你不用担心他钱不够用）\n现在告诉你所有格子的金币数量和每一列的金币花费，牛牛想知道他跑到第 n 列最多可以赚得多少金币（赚得金币=获得金币-消耗金币）\n\n**示例 1**\n```go\n输入：3,[1,9,3],[6,4,6],[1,1,5],[3,2,1]\n输出：16\n说明：一开始牛牛选择位于第 2 行第 1 列，拿到 6 个金币。然后牛牛花 3 金币到第 1 行的 2 列拿到 9 个金币，最后牛牛花费 2 金币到第 2 行第 3 列。总共获得 21 金币，消耗 5 金币。赚得 16 金币。\n```\n**备注：**\n\n- 2 <= n <= 1e5\n\n- 第 1 个参数 n 代表跑道的列数\n第 2，3，4 个参数 vector<int> a1,a2,a3 各有 n 个元素，代表第 1，2，3 行每一列的金币个数\n第 5 个参数 vector<int> m 有 n 个元素代表每一列进行换行的时候需要的金币花费\n\n**解法一**\n\n题目意思搞清楚就行了\n```java\n//很直白的 dp\npublic int solve (int n, int[] a1, int[] a2, int[] a3, int[] m) {\n    // write code here\n    int[][] dp = new int[3][n];\n    dp[0][0] = a1[0];\n    dp[1][0] = a2[0];\n    dp[2][0] = a3[0];\n    for (int j = 1; j < n; j++) {\n        dp[0][j] = a1[j] + Math.max(dp[0][j-1], dp[1][j-1]-m[j-1]);\n        dp[1][j] = a2[j] + Math.max(dp[1][j-1], Math.max(dp[0][j-1]-m[j-1], dp[2][j-1]-m[j-1]));\n        dp[2][j] = a3[j] + Math.max(dp[2][j-1], dp[1][j-1]-m[j-1]);\n    }\n    return Math.max(dp[0][n-1],Math.max(dp[1][n-1], dp[2][n-1]));\n}\n```\n## [NC554 简单变向](https://www.nowcoder.com/practice/11f7c6cb54524c3693119e4088533305)\n牛牛准备在一个 3 行 n 列的跑道上跑步。一开始牛牛位于 (1,1)。\n\n当牛牛位于第 i 行第 j 列时，他可以的下一步最多可能有三种选择：\n\n1. 跑到第 i 行第 j+1 列\n2. 跑到第 i-1 行第 j+1 列（如果 i=1 则不可以这么跑）。\n3. 跑到第 i+1 行第 j+1 列（如果 i=3 则不可以这么跑）。\n\n跑道上有一些格子设置了路障（一个格子可能有多个路障），牛牛不能跑到路障上。现在牛牛想知道，从 (1,1) 到 (3,n) 有多少条不同的路径？\n\n为了防止答案过大，答案对 1e9+7 取模。\n\n比较简单就不贴 case 了\n\n**解法一**\n\n注意溢出就行了\n```java\npublic int solve (int n, int m, int[] x, int[] y) {\n    long[][] dp = new long[3][n+1];\n    int MOD = (int)1e9+7;\n    boolean[][] v = new boolean[3][n];\n    for(int i = 0; i < m; i++){\n        v[x[i]-1][y[i]-1] = true;\n    }\n    dp[0][0] = 1;\n    for (int j = 1; j < n; j++) {\n        dp[0][j] = v[0][j] ? 0 : (dp[0][j-1] + dp[1][j-1])%MOD;\n        dp[1][j] = v[1][j] ? 0 : (dp[1][j-1] + dp[0][j-1]+dp[2][j-1])%MOD;\n        dp[2][j] = v[2][j] ? 0 : (dp[2][j-1] + dp[1][j-1])%MOD;\n    }\n    return  (int)(dp[2][n-1]%MOD);\n}\n```\n## [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)\n\nDifficulty: **中等**\n\n有 `n` 个城市通过 `m` 个航班连接。每个航班都从城市 `u` 开始，以价格 `w` 抵达 `v`。\n\n现在给定所有的城市和航班，以及出发城市 `src` 和目的地 `dst`，你的任务是找到从 `src` 到 `dst` 最多经过 `k` 站中转的最便宜的价格。 如果没有这样的路线，则输出 `-1`。\n\n**示例 1：**\n\n```go\n输入：\nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 1\n输出：200\n解释：\n城市航班图如下\n\n从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。\n```\n\n**示例 2：**\n\n```go\n输入：\nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 0\n输出：500\n解释：\n城市航班图如下\n\n从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。\n```\n\n**提示：**\n\n*   `n` 范围是 `[1, 100]`，城市标签从 `0` 到 `n` `- 1`.\n*   航班数量范围是 `[0, n * (n - 1) / 2]`.\n*   每个航班的格式 `(src,` `dst``, price)`.\n*   每个航班的价格范围是 `[1, 10000]`.\n*   `k` 范围是 `[0, n - 1]`.\n*   航班没有重复，且不存在环路\n\n**解法一**\n\n范围很小只有 100，一开始以为是 Floyd，但是有 K 的限制不好处理\n```golang\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\n    //dp[i][k]：从 src 到 i 节点中转 k 次最短距离\n    var Min = func(a, b int) int {if a<b {return a};return b}\n    var INF = 0x3f3f3f3f\n    var dp = make([][]int, n)\n    for i := 0; i < n; i++ {\n        //K+2 是为了方便初始化，不用单独处理 K==0 的情况\n        dp[i] = make([]int, K+2)\n        for j := 0; j <= K+1; j++ {\n            dp[i][j] = INF   \n        }\n    }\n    for k := 0; k <= K+1; k++ {\n        dp[src][k] = 0\n    }\n    for k := 1; k <= K+1; k++ {\n        for _,flt := range flights {\n            //src 到 flt[1] 通过 flt[0] 中转\n            dp[flt[1]][k] = Min(dp[flt[1]][k], dp[flt[0]][k-1]+flt[2])\n        }\n    }\n    if dp[dst][K+1] == INF {\n        return -1\n    }\n    return dp[dst][K+1]\n}\n```\n> 这题也可以`Dijkstra`但是我不会\n\n## [NC557. 好多牛牛](https://www.nowcoder.com/practice/edced5e80f3e46efa9c965e7f634c58c)\n\n给出一个字符串 S，牛牛想知道这个字符串有多少个子序列等于\"niuniu\"子序列可以通过在原串上删除任意个字符（包括 0 个字符和全部字符）得到。为了防止答案过大，答案对 1e9+7 取模\n\n**示例 1**\n```go\n输入：\"niuniniu\"\n输出：3\n说明：\n删除第 4，5 个字符可以得到\"niuniu\"\n删除第 5，6 个字符可以得到\"niuniu\"\n删除第 6，7 个字符可以得到\"niuniu\"\n```\n**备注：**\n10 <= len(s) <= 1e5\n\n**解法一**\n\n菜啊，没想出来，真的菜\n```java\n//UPDATE: 2020.9.27，之前的解法过了 OJ，但是其实是有问题的\n//二维 DP（不方便优化成一维的）\npublic int solve1 (String s) {\n    // write code here \n    String p = \"niuniu\";\n    int m = p.length();\n    int n = s.length();\n    int MOD = (int)1e9+7;\n    //dp[i][j] 代表 s[0,j] 中有多少个 p[0,j]\n    long[][] dp = new long[7][n+1];\n    Arrays.fill(dp[0], 1);\n    for (int i = 1; i <= m; i++){\n        for (int j = 1; j <= n; j++){\n            if (s.charAt(j-1) == p.charAt(i-1)) {\n                //dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\n                //上面的是错的，之所以正确是因为题目的 niuniu 没有连续的相同字符\n                //考虑如下 case:  p = \"aa\" , s = \"abaa\" wa = 6, ac = 3\n                dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % MOD;\n            } else {\n                dp[i][j] = dp[i][j-1];\n            }\n        }\n    }\n    return (int)dp[m][n];\n}\n```\n实际上这个解法最好把内外循环交换下，这样更好降维\n```java\n//二维 DP，交换内外循环\npublic int solve2 (String s) {\n    // write code here \n    String p = \"niuniu\";\n    int n = s.length();\n    int m = p.length();\n    int MOD = (int)1e9+7;\n    //dp[i][j] 代表 s[0,i] 中有多少个 p[0,j]\n    long[][] dp = new long[n+1][m+1];\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        dp[i][0] = 1;\n        for (int j = 1; j <= m; j++){\n            if (s.charAt(i-1) == p.charAt(j-1)) {\n                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD;\n            } else {\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return (int)dp[n][m];\n}\n```\n**解法二**\n\n按照上面交换内外循环后的解法再降维\n```java\n//UPDATE: 2020.9.27，之前的解法过了 OJ，但是其实是有问题的\n//按上面的来降维舒服多了\npublic int solve3 (String s) {\n    String p = \"niuniu\";\n    int n = s.length();\n    int m = p.length();\n    int MOD = (int)1e9+7;\n    //dp[j] 代表 s[0,i] 中有多少个 p[0,i]\n    long[] dp = new long[m+1];\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++){\n        //for (int j = 1; j <= m; j++){\n        //内层应该反过来递推，保证 dp[j] 和 dp[j-1] 是上一次的\n        for (int j = m; j >= 1; j--){\n            if (s.charAt(i-1) == p.charAt(j-1)) {\n                dp[j] = (dp[j] + dp[j-1]) % MOD;\n            }\n        }\n    }\n    return (int)dp[m];\n}\n```\n\n## [926. 将字符串翻转到单调递增](https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/)\n\nDifficulty: **中等**\n\n如果一个由 `'0'` 和 `'1'` 组成的字符串，是以一些 `'0'`（可能没有 `'0'`）后面跟着一些 `'1'`（也可能没有 `'1'`）的形式组成的，那么该字符串是_单调递增_的。\n\n我们给出一个由字符 `'0'` 和 `'1'` 组成的字符串 `S`，我们可以将任何 `'0'` 翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'`。\n\n返回使 `S` 单调递增的最小翻转次数。\n\n**示例 1：**\n\n```go\n输入：\"00110\"\n输出：1\n解释：我们翻转最后一位得到 00111.\n```\n\n**示例 2：**\n\n```go\n输入：\"010110\"\n输出：2\n解释：我们翻转得到 011111，或者是 000111。\n```\n\n**示例 3：**\n\n```go\n输入：\"00011000\"\n输出：2\n解释：我们翻转得到 00000000。\n```\n\n**提示：**\n\n1.  `1 <= S.length <= 20000`\n2.  `S` 中只包含字符 `'0'` 和 `'1'`\n\n**解法一**\n\n动态规划的解法\n\n```golang\nfunc minFlipsMonoIncr(S string) int {\n    var n = len(S)\n    //dp[i][0]: [0~i] s[i]==0 需要最小额翻转次数\n    //dp[i][1]: [0~i] s[i]==1 需要最小额翻转次数\n    var dp = make([][2]int, n)\n    var Min = func(a, b int) int {if a < b {return a}; return b}\n    var preSum = make([]int, n+1)\n    for i := 1; i <= n; i++ { \n        preSum[i] = preSum[i-1] + int(S[i-1]-48)\n    }\n    if S[0] == '1' {\n        dp[0][0] = 1\n    }else {\n        dp[0][1] = 1\n    }\n    for i := 1; i < n; i++ {\n        if S[i] == '1' {\n            dp[i][1] = Min(dp[i-1][1], dp[i-1][0])\n            dp[i][0] = preSum[i+1] //包含 i\n        } else {\n            dp[i][0] = preSum[i] //不包含 i\n            dp[i][1] = Min(dp[i-1][0], dp[i-1][1]) + 1\n        }\n    }\n    return Min(dp[n-1][1], dp[n-1][0])\n}\n```\n\n**解法二**\n\n寻找分割点，使得分割点左边的 1 和右边的 0 相加的和最少\n\n```golang\n//Trick，寻找分割点，使得分割点左边的 1 和右边的 0 相加的和最少\nfunc minFlipsMonoIncr(S string) int {\n    var count0 = 0 //分割点右边的 0\n    var count1 = 0 //分割点左边的 1\n    var Min = func(a, b int) int {if a < b {return a}; return b}\n    for i := 0; i < len(S); i++ {\n        if S[i] == '0' {\n            count0++\n        }\n    }\n    var res = count0\n    for i := 0; i < len(S); i++ {\n        if S[i] == '1' {\n            count1++\n        } else {\n            count0--\n        }\n        res = Min(res, count1+count0)\n    }\n    return res\n}\n```\n\n## [LCP 19. 秋叶收藏集](https://leetcode-cn.com/problems/UlBDOe/)\n\n小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。\n出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。\n\n**示例 1：**\n```go\n输入：leaves = \"rrryyyrryyyrr\"\n输出：2\n解释：调整两次，将中间的两片红叶替换成黄叶，得到 \"rrryyyyyyyyrr\"\n```\n**示例 2：**\n```go\n输入：leaves = \"ryr\"\n输出：0\n解释：已符合要求，不需要额外操作\n提示：\n3 <= leaves.length <= 10^5\nleaves 中只包含字符 'r' 和字符 'y'\n```\n\n**解法一**\n\n和上一题 [926. 将字符串翻转到单调递增](#926-将字符串翻转到单调递增)一样，不过很明显这里有三个状态，一个是前面的 r 结尾，一个是中间的 y 结尾，一个是末尾的 r 结尾，最后求出以最后的 r 结尾的最短次数就 ok 了\n```java\npublic int minimumOperations(String s) {\n    int n = s.length();\n    int[][] dp = new int[n+1][3];\n    //0，1，2 分别代表 前面的 r 中间的 y 结尾的 r\n    dp[0][0] = s.charAt(0) == 'r' ? 0 : 1;\n    dp[0][1] = dp[0][2] = dp[1][2] = 0x3f3f3f3f;\n    //简单的递推\n    for (int i = 1; i < n; i++) {\n        if (s.charAt(i) == 'r') {\n            dp[i][0] = dp[i-1][0];\n            dp[i][1] = Math.min(dp[i-1][1]+1, dp[i-1][0]+1);\n            dp[i][2] = Math.min(dp[i-1][2], dp[i-1][1]);\n        } else {\n            dp[i][0] = dp[i-1][0]+1;\n            dp[i][1] = Math.min(dp[i-1][0], dp[i-1][1]);\n            dp[i][2] = Math.min(dp[i-1][2]+1, dp[i-1][1]+1);\n        }\n    }\n    return dp[n-1][2];\n}\n```\n> 空间还可以优化，代码也还可以更简洁，不过我懒得改了\n\n## [845. 数组中的最长山脉](https://leetcode-cn.com/problems/longest-mountain-in-array/)\n\nDifficulty: **中等**\n\n我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “_山脉”_：\n\n*   `B.length >= 3`\n*   存在 `0 < i < B.length - 1` 使得 `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`\n\n（注意：B 可以是 A 的任意子数组，包括整个数组 A。）\n\n给出一个整数数组 `A`，返回最长 _“山脉”_ 的长度。\n\n如果不含有 “_山脉” _则返回 `0`。\n\n**示例 1：**\n\n```go\n输入：[2,1,4,7,3,2,5]\n输出：5\n解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。\n```\n\n**示例 2：**\n\n```go\n输入：[2,2,2]\n输出：0\n解释：不含 “山脉”。\n```\n\n**提示：**\n\n1.  `0 <= A.length <= 10000`\n2.  `0 <= A[i] <= 10000`\n\n示例 1：\n\n```go\n输入：[2,1,4,7,3,2,5]\n输出：5\n解释：最长的山脉是 [1,4,7,3,2]，长度为 5。\n```\n\n**示例 2：**\n\n```go\n输入：[2,2,2]\n输出：0\n解释：不含山脉\n```\n\n**解法一**\n\n遍历的过程中记录上升和下降的长度，然后注意重置的时机，当且仅当 up 和 down 都大于 0 的时候为合法，统计一个最大值就可以了\n```java\npublic int longestMountain(int[] A) {\n    int res = 0;\n    int up = 0, down = 0;\n    //[2,1,4,7,3,2,5]\n    for (int i = 1; i < A.length; i++) {\n        //前面是下降，这里开始增加或者和前一个元素相同，需要重置\n        if ((down > 0 && A[i] > A[i-1]) || A[i] == A[i-1]) {\n            up = down = 0;\n        }\n        up += A[i] > A[i-1] ? 1 : 0;\n        down += A[i] < A[i-1] ? 1 : 0;\n        if (up > 0 && down > 0) {\n            res = Math.max(res, up+down+1);   \n        }\n    }\n    return res;\n}\n```\n## _区间 DP_\n\n后面有时间会单独将这些题目分类整理成文章，目前暂时先这样\n\n## [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)\n\n有 n 个气球，编号为 0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。\n\n现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。\n\n求所能获得硬币的最大数量。\n\n**说明：**\n\n- 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。\n- 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100\n\n**示例：**\n\n```java\n输入：[3,1,5,8]\n输出：167 \n解释：nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\n     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n```\n\n**解法一**\n\n暴力回溯，其实就是尝试所有的组合，这样时间复杂度`O(N!)` ，数据超过十几就不行了\n\n```java\npublic int maxCoinsTLE(int[] nums) {\n    LinkedList<Integer> list=new LinkedList<>();\n    for (int n:nums) list.add(n);\n    dfs(list,0);\n    return max;\n}\n\nprivate int max=0;\n\npublic void dfs(LinkedList<Integer> list,int sum) {\n    if (list.size()==0) {\n        max=Math.max(sum,max);\n        return;\n    }\n    for (int i=0;i<list.size();i++) {\n        int temp=list.get(i);\n        //这个值要先算\n        int cur=(i-1<0?1:list.get(i-1))*(i+1>=list.size()?1:list.get(i+1))*temp;\n        list.remove(i);\n        dfs(list,sum+cur);\n        list.add(i,temp);\n    }\n}\n```\n\n**解法二**\n\n区间型动态规划，也是我第一次听说这个名词，但是之前其实已经做了不少的区间型的 dp 了\n\n```java\npublic int maxCoins(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int[] A=new int[nums.length+2];\n    A[0]=1;A[A.length-1]=1;\n    for (int i=0;i<nums.length;i++) {\n        A[i+1]=nums[i]; //copy 一个新数组\n    }\n    //区间 DP\n    int n=A.length;\n    int[][] dp=new int[n][n]; //dp[i][j] 代表的是不包含边界 i,j 的最大得分\n    for (int len=2;len<=n;len++) { //枚举区间长度\n        for (int i=0;i<=n-len;i++) { //枚举起点\n            int j=i+len-1; //区间终点\n            for (int k=i+1;k<j;k++) { //枚举分割点\n                dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+A[k]*A[i]*A[j]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n\n这里为了处理边界将数组头尾插入了 1，copy 了一个新的数组，下面的区间型 dp 也是在看了题解，然后对着板子写的，当然这题的关键不是这里，关键是如何规划，这里搬运 [题解区大佬](https://leetcode-cn.com/problems/burst-balloons/solution/dong-tai-gui-hua-qiu-jie-by-feng-ji-wei-wang/) 的解释\n\n我们来分析一下按照上面的那个递归的思路状态转移方程能写吗？如果按照上面的递归的思路，我们定义 dp[i][j] 表示对于 i-j 的气球的最大的收益，那状态转移方程就是\n\n`dp[i][j]=max(coins[k]* coins[k-1] * coins[k+1]+dp[i][k-1]+dp[k+1][j]) k∈[i,j]`,\n\n就按上面的那个例子，[3,1,5,8], 来写一下过程\n\n```java\n扎爆 3 剩下 [] 和 [1,5,8]\n扎爆 1 剩下 [3] 和 [5,8]\n扎爆 5 剩下 [3,1] 和 [8]\n扎爆 8 剩下 [3,1,5] 和 []\n```\n\n然后在这些里面找到一个最大值返回，这其中对于扎爆 1 和 8 的最大的收益这样定义是没有问题的，因为两者都在边界，但是对于扎爆 1 和 5 就有问题了，就拿先扎爆 1 来说，扎爆 1，剩下的最大的收益变为了 [3] 和 [5,8] 这两个区间的最大的收益的和，这个肯定不对，因为剩下的 [3,5,8] 区间的最大的收益的和不会是 [3] 的最大收益和与 [5,8] 的最大收益和的总和构成的，所以这个状态转移方程是不对的\n\n那应该怎么定义状态转移方程呢，这也就是这道题巧妙的地方，它使用逆向思维，也就是上面的状态转移方程是由某个气球先爆得出来的，那么这里我们让指定的气球最后爆，这样的话状态转移方程为\n\n`dp[i][j]=max(coins[k]*coins[i-1]*coins[j+1]+dp[i][k-1]+dp[k+1][j]) k∈[i,j]` \n\n再来看上面的例子，就对了，也就是对于 [i,j] 的气球，我们让某个位置的气球最后再爆，求出它左区间的最大的收益和右区间的最大的收益，加上这个气球最后爆掉所获得的收益，一 一比较，返回一个最大值就好了，这里要注意的是，要按区间的长度来进行状态的转移，也就是先求长度为 1 的，然后 2 的依次类推，因为这里状态转移方程涉及到了当前位置的后面的区间的最大的收益，但是后面的区间的长度是小于当前区间的长度的，故应该按长度来进行状态的转移，这也是典型的区间型动态规划的套路\n\n**解法三**\n\n在解法二的基础上简化了代码，`dp[i][j]`代表`i`和`j`之间，包含`i`和`j`位置，戳爆所有气球的最大得分\n\n```java\npublic int maxCoins(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int n=nums.length;\n    //dp[i][j] 代表的是包含边界 i,j 的最大得分\n    int[][] dp=new int[n][n]; \n    for (int len=1;len<=n;len++) { //枚举区间长度\n        for (int i=0;i<=n-len;i++) { //枚举起点\n            int j=i+len-1; //区间终点\n            for (int k=i;k<=j;k++) { //枚举分割点\n                dp[i][j]=Math.max(dp[i][j],(k-1>=0?dp[i][k-1]:0)+(k+1<n?dp[k+1][j]:0)+nums[k]*(i-1>=0?nums[i-1]:1)*(j+1<n?nums[j+1]:1));\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n\n**UPDATE:2020.7.19**\n打卡题，重新写一遍，稍微好一点的写法，上面一堆三目不太好\n\n```golang\nfunc maxCoins(nums []int) int {\n    if len(nums) <= 0{\n        return 0\n    }\n    nums = append(nums, 1)\n    nums = append([]int{1}, nums...)\n    var n = len(nums)\n    var dp = make([][]int, n)\n    for i := 0; i < n; i++{\n        dp[i] = make([]int, n)\n    }\n    for tlen := 1; tlen <= n-2; tlen++{ //枚举区间长度\n        for left := 1; left+tlen-1 < n-1; left++{ //枚举左端点\n            right := left+tlen-1 //右端点\n            for k := left; k <= right; k++{ //枚举分割点\n                dp[left][right] = Max(dp[left][right], dp[left][k-1]+dp[k+1][right]+nums[k]*nums[left-1]*nums[right+1])\n            }\n        }\n    }\n    return dp[1][n-2]\n}\n\nfunc Max(a, b int)int{\n    if a > b{\n        return a\n    }\n    return b\n}\n```\n\n## [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子**排成一行**，每堆都有正整数颗石子 `piles[i]` 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 `true` ，当李赢得比赛时返回 `false` 。\n\n**示例：**\n\n```java\n输入：[5,3,4,5]\n输出：true\n解释：\n亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。\n如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。\n```\n\n**提示：**\n\n1. `2 <= piles.length <= 500`\n2. `piles.length` 是偶数。\n3. `1 <= piles[i] <= 500`\n4. `sum(piles)` 是奇数。\n\n**解法一**\n\n博弈型 dp，先采用区间 dp 的解法试试（区间 dp 是真的妙啊！！！)\n\n```java\n//通用的区间 DP\npublic boolean stoneGame(int[] piles) {\n    //[5,3,4,5]\n    int N=piles.length;\n    //(i~j) 先手 (0), 后手 (1) 的最大收益\n    int[][][] dp=new int[N][N][2];\n    //base init len=1 的情况\n    for(int i=0;i<N;i++){\n        dp[i][i][0]=piles[i];\n        dp[i][i][1]=0;\n    }\n    for (int len=2;len<=N;len++) { //枚举区间长度\n        for (int left=0;left<=N-len;left++) { //枚举所有区间\n            //left+len-1<N\n            int right=left+len-1;\n            //先手拿 left 或者 right 的最大收益\n            //我先手拿了 left 或者 right 之后，剩下 [left+1,right] 或 [left,right-1] 区间\n            //我在剩下的区间中继续选其实就成为了后手，所以我们加上剩下区间的后手最大值\n            int firLeft=piles[left]+dp[left+1][right][1];\n            int firRight=piles[right]+dp[left][right-1][1];\n            if(firLeft>firRight){\n                dp[left][right][0]=firLeft;\n                //先手选 left 那么就相当于让另一个人（后手）从 [left+1,right] 中先手取最大值\n                dp[left][right][1]=dp[left+1][right][0];\n            }else{\n                dp[left][right][0]=firRight;\n                //同上\n                dp[left][right][1]=dp[left][right-1][0];\n            }\n        }\n    }\n    return dp[0][N-1][0]-dp[0][N-1][1]>0;\n}\n```\n**解法二**\n\n数学推理的方法，具体的证明给不出来，但是很容易理解它的正确性\n\n```java\n//数学\npublic boolean stoneGame(int[] piles) {\n    return true;\n}\n```\n首先题目有两个特殊的条件（这两个条件我解法一没用到）`piles.length` 是偶数，`sum(piles)` 是奇数，这其实说明了不会有平局，因为是偶数，我们把所有的柱子用奇偶来划分，那么奇数柱子和偶数**石头堆的数量**一定是相同的，而且**两者总的石头数一定有一个数量的差异**，不可能相等，我先手拿的话我就可以只考虑拿较大的那一类石头堆，那我能保证我拿到的一定是奇数或偶数的堆吗？其实随便举一个例子就知道了，比如 4 堆石头，先手的人总是能控制自己一定拿到 1，3 或者 2，4 所以先手的一定是可以赢得，推广到 N 堆石头也同样适用\n\n## [1039. 多边形三角剖分的最低得分](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/)\n\n给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 `A[0], A[i], ..., A[N-1]`。\n\n假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。\n\n返回多边形进行三角剖分后可以得到的最低分。\n\n**示例 1：**\n\n```java\n输入：[1,2,3]\n输出：6\n解释：多边形已经三角化，唯一三角形的分数为 6。\n```\n\n**实例 2：**\n\n![J8IK8U.png](https://s1.ax1x.com/2020/04/21/J8IK8U.png)\n\n```java\n输入：[3,7,4,5]\n输出：144\n解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。\n```\n\n**解法一**\n\n区间 DP 套路，枚举所有的区间和区间内的点，`区间内的点`和`区间左右端点`将整个区间又划分为两个`已知的子区间`，典型的区间 dp\n\n```java\n//环形的结构\npublic int minScoreTriangulation(int[] A) {\n    if(A==null || A.length<=0) return 0;\n    int N=A.length;\n    //从 0 ~ N-1 形成一个环\n    //    1-3 \n    //   /    \\\n    //  5      1\n    //   \\    /\n    //    1—4\n    // dp[left][right] 代表 left~right 区间形成的环的最小得分值\n    int[][] dp=new int[N][N];\n    for (int len=3;len<=N;len++) { //枚举长度，从 3 开始\n        for (int left=0;left<=N-len;left++) { //枚举左端点\n            //left+len-1<N\n            int right=left+len-1;\n            //init 初始化区间值\n            dp[left][right]=Integer.MAX_VALUE;\n            for (int i=left+1;i<right;i++) { //枚举区间内的所有的点（不包括端点）), 将环分割成左右两部分\n                dp[left][right]=Math.min(dp[left][right],dp[left][i]+dp[i][right]+A[i]*A[left]*A[right]);\n            }\n        }\n    }\n    return dp[0][N-1];\n}\n```\n\n## [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)\n\n给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为 1000。\n\n**示例 1:**\n\n```java\n输入：\n\n\"bbbab\"\n输出：\n\n4\n一个可能的最长回文子序列为 \"bbbb\"。\n```\n\n**示例 2:**\n\n```java\n输入：\n\n\"cbbd\"\n输出：\n\n2\n一个可能的最长回文子序列为 \"bb\"。\n```\n\n**解法一**\n\n动态规划，`dp[i][j]` 代表 i~j 的最长回文串\n\n```java\npublic int longestPalindromeSubseq(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int[][] dp=new int[n][n]; //dp[i][j] 代表 i~j 的最长回文子串\n    for (int i=0;i<n;i++) {\n        dp[i][i]=1;\n    }\n    //bbbab\n    for (int i=n-1;i>=0;i--) {\n        for (int j=i+1;j<n;j++) { \n            if (s.charAt(i)==s.charAt(j)) {\n                dp[i][j]=dp[i+1][j-1]+2;\n            }else{\n                dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n\n核心的 dp 公式：\n\n1. `s[i]==p[j]`，`dp[i][j]=dp[i+1][j-1]+2` \n2. `s[i]!=p[j]` ，`dp[i][j]=max(dp[i+1][j],dp[i][j-1])`\n\n是不是有的眼熟？没错，和 LCS 的 dp 思路很相似\n\n这里其实还有个需要注意的地方，就是两次循环的方向，我们要保证每次计算 dp 值的时候右值都是已经计算过的，所以需要调整循环的执行方向让 `i`从右往左，让`j`从`i`向右，这样 i+1 和 j-1 的 dp 就都是计算过的了\n\n**UPDATE**\n\n```java\n//update: 2020.4.19\n//区间 dp 写法，更加套路化，其实思路是一样的\npublic int longestPalindromeSubseq(String s) {\n    if(s==null || s.length()<=0) return 0;\n    int N=s.length();\n    int[][] dp=new int[N][N];\n    //base len=1\n    for(int i=0;i<N;i++){\n        dp[i][i]=1;\n    }\n    for(int len=2;len<=N;len++){\n        for(int i=0;i<=N-len;i++){\n            //j=i+len-1<N\n            int j=i+len-1;\n            if(s.charAt(i)==s.charAt(j)){\n                dp[i][j]=dp[i+1][j-1]+2;\n            }else{\n                dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][N-1];\n}\n```\n\n**解法二**\n\n对比一下递归解法是真的简洁，没有那么多边界考虑\n\n```java\n//递归解法，自底向上\nprivate Integer[][] cache=null;\n\npublic int longestPalindromeSubseq(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    cache=new Integer[n][n];\n    return helper(s,0,n-1);\n}\n\npublic int helper(String s,int left,int right){\n    if (left>right) {\n        return 0;\n    }\n    if (left==right) {\n        return 1;\n    }\n    if (cache[left][right]!=null) {\n        return cache[left][right];\n    }\n    if (s.charAt(left) == s.charAt(right)) {\n        return cache[left][right]=helper(s,left+1,right-1)+2; //由外向内缩进\n    }\n    return cache[left][right]=Math.max(helper(s,left+1,right),helper(s,left,right-1));\n}\n```\n**解法三**\n\n将问题转换为 LCS 的问题\n\n```java\n//LCS 的解法\npublic int longestPalindromeSubseq(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int[][] dp=new int[n+1][n+1]; //dp[i][j] 代表 s[0,i]~rs[0,j] 的最长子序列\n    String rs=new StringBuilder(s).reverse().toString();\n    for (int i=1;i<=s.length();i++) {\n        for (int j=1;j<=rs.length();j++) {\n            if (s.charAt(i-1)==rs.charAt(j-1)) {\n                dp[i][j]=dp[i-1][j-1]+1;\n            }else{\n                dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[n][n];\n}\n```\n最长的回文序列其实就是求这个字符串和它翻转后的字符串的最长公共子序列！很妙的解法\n\n## [1312. 让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)\n\n给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。\n\n请你返回让 s 成为回文串的 **最少操作次数** 。\n\n「回文串」是正读和反读都相同的字符串。\n\n**示例 1：**\n\n```java\n输入：s = \"zzazz\"\n输出：0\n解释：字符串 \"zzazz\" 已经是回文串了，所以不需要做任何插入操作。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"mbadm\"\n输出：2\n解释：字符串可变为 \"mbdadbm\" 或者 \"mdbabdm\" 。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"leetcode\"\n输出：5\n解释：插入 5 个字符后字符串变为 \"leetcodocteel\" 。\n```\n\n**示例 4：**\n\n```java\n输入：s = \"g\"\n输出：0\n```\n\n**示例 5：**\n\n```java\n输入：s = \"no\"\n输出：1\n```\n\n**提示：**\n\n- 1 <= s.length <= 500\n- s 中所有字符都是小写字母。 \n\n**解法一**\n\n170 周赛的压轴题，其实和前面的 [516. 最长回文子序列](#516-最长回文子序列)是一样的。没啥好说的\n\n```java\npublic int minInsertions(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int[][] dp=new int[n][n];\n    for (int i=n-1;i>=0;i--) {\n        for (int j=i+1;j<n;j++) {\n            if (s.charAt(i) == s.charAt(j)) {\n                dp[i][j]=dp[i+1][j-1];   \n            }else{\n                //不相等就可以在头部插入 s[j] 或者尾部插入 s[i]\n                //头部插入 s[j] 则子区间就是 dp[i][j-1]\n                //尾部插入 s[i] 则子区间就是 dp[i+1][j]\n                dp[i][j]=1+Math.min(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n**解法二**\n\nUPDATE：2020.5.18，区间 dp 的写法\n\n```java\npublic int minInsertions(String s) {\n    int[][] dp=new int[s.length()][s.length()];\n    for(int len=2;len<=s.length();len++){\n        for(int left=0;left+len-1<s.length();left++){\n            int right=left+len-1;\n            if(s.charAt(left)==s.charAt(right)){\n                dp[left][right]=dp[left+1][right-1];\n            }else{\n                dp[left][right]=Math.min(dp[left][right-1],dp[left+1][right])+1;\n            }\n        }\n    }\n    return dp[0][s.length()-1];\n}\n```\n\n这题也可以用 LCS 的解法解，`n-lcs[n][n]`就是最少的插入次数 \n\n## [664. 奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/)\n\n有台奇怪的打印机有以下两个特殊要求：\n\n打印机每次只能打印同一个字符序列。\n每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。\n给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。\n\n**示例 1:**\n\n```java\n输入：\"aaabbb\"\n输出：2\n解释：首先打印 \"aaa\" 然后打印 \"bbb\"。\n```\n\n**示例 2:**\n\n```java\n输入：\"aba\"\n输出：2\n解释：首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 'a'。\n```\n\n**提示：** 输入字符串的长度不会超过 100。\n\n**解法一**\n\n前一天看了大致的思路，隔了一天独立的写了一下，将前天思路的很多细节都想明白了\n\n```java\npublic int strangePrinter(String s) {\n    if(s==null || s.length()<=0) return 0;\n    int N=s.length();\n    int[][] dp=new int[N][N];\n    for (int i=0;i<N;i++) {\n        dp[i][i]=1;\n    }\n    //aa        1\n    //aab       2\n    //aaba      2\n    //aabab     3\n    //aababa    4\n    for (int len=2;len<=N;len++) {\n        for (int left=0;left+len-1<N;left++) { //左端点\n            int right=left+len-1; //右端点\n            //和前一个区间 [left,right-1] 的第一个字符相等，可以直接顺带打印出来\n            if(s.charAt(right)==s.charAt(left)){ \n                //至少是 dp[left][right-1]\n                dp[left][right]=dp[left][right-1];\n                continue;\n            }\n            //最多是前一个区间+1（直接打印 right 位置的字符）\n            dp[left][right]=dp[left][right-1]+1; \n            //枚举 [left,right) 中的所有字符，如果有和 right 相等的就考虑从这个位置分割整个字符\n            //比如 abc b 这个最后的 b 就可以连同前面的 bc 一起顺带打印出来\n            //所以当前区间的值就是可以是 dp[a][a]+dp[b][c], 我们从所有的这种情况中取最小值就 ok 了\n            for (int i=left;i<right;i++) { \n                if(s.charAt(right)==s.charAt(i)){\n                    dp[left][right]=Math.min(dp[left][i-1]+dp[i][right-1],dp[left][right]);\n                }\n            }\n        }\n    }\n    return dp[0][N-1];\n}\n```\n`dp[left][right]`代表 left 到 right 的最少打印次数，然后我们要理解一点：`dp[left][right]` 其实只可能有两个取值，`dp[left][right-1]`或者`dp[left][right-1]+1`，我们求最小打印次数其实就是希望增加一个字符后打印次数不变\n\n> **eg:**  abc b 这个最后的 b 就可以连同前面的 bc 一起顺带打印出来，打印次数不变\n\n枚举所有的区间`[left,right]`，然后枚举区间`[left,right-1]`内的字符，如果区间`[left,right-1]`内的某个字符`i`和`right`相等，那么`right`就可以跟随`[i,right-1]`一起顺带打印出来，这样该区间的 dp 值为\n\n`dp[left][right]=dp[left][i-1]+dp[i][right-1]`\n这样就有可能让打印次数不变，我们求一下所有情况的最小值就可以了\n\n> 这题的代码还可以更简洁，不过我懒得改了，感觉上面的代码已经很清晰了\n>\n> ps:  这几天做了不少有点难度的 DP 题，发现确实自己对边界的处理，递推公式的理解有了一点提升，加油💪\n\n## [1547. 切棍子的最小成本](https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/)\n\nDifficulty: **困难**\n\n有一根长度为 `n` 个单位的木棍，棍上从 `0` 到 `n` 标记了若干位置。例如，长度为 **6** 的棍子可以标记如下：\n\n![UTOOLS1597929649437.png](https://upload.cc/i1/2020/08/20/5m7x61.png)\n\n给你一个整数数组 `cuts` ，其中 `cuts[i]` 表示你需要将棍子切开的位置。\n\n你可以按顺序完成切割，也可以根据需要更改切割的顺序。\n\n每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。\n\n返回切棍子的 **最小总成本** 。\n\n**示例 1：**\n\n![UTOOLS1597929677739.png](https://upload.cc/i1/2020/08/20/QGugd1.png)\n\n```go\n输入：n = 7, cuts = [1,3,4,5]\n输出：16\n解释：按 [1, 3, 4, 5] 的顺序切割的情况如下所示：\n\n第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。\n而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。\n```\n\n**示例 2：**\n\n```go\n输入：n = 9, cuts = [5,6,1,4,2]\n输出：22\n解释：如果按给定的顺序切割，则总成本为 25 。总成本 <= 25 的切割顺序很多，例如，[4，6，5，2，1] 的总成本 = 22，是所有可能方案中成本最小的。\n```\n\n**提示：**\n\n*   `2 <= n <= 10^6`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   `cuts` 数组中的所有整数都 **互不相同**\n\n**解法一**\n\n201th 周赛的 t4，感觉还是挺简单的，今天补的时候花了 10 分钟搞清楚思路，一遍看视频一边写，最后不出意外的的 T 了~😂一开始没想清楚细节，想到了以区间开始和结尾做 dp，然后就直接开了个 n*n 的数组，虽然是对的，但是在初始化的时候就 t 了，这里实际上只需要开一个 len(cuts)^2 的空间就行了\n```golang\nfunc minCost(n int, cut []int) int {\n    sort.Ints(cut)\n    //在前后加上 0 和 n\n    cut = append(cut, n)\n    cut = append([]int{0}, cut...)\n    var Min = func(a,b int) int {if a<b {return a};return b}\n    var m = len(cut)\n    //dp[i][j] 切割 i,j 的成本\n    var dp = make([][]int, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]int, m)\n        if i < m-1 {\n            dp[i][i+1] = 0   \n        }\n    }\n    for tlen := 2; tlen <= m; tlen++ {\n        for left := 0; left+tlen < m; left++ {\n            right := left+tlen //注意这里不加 1\n            dp[left][right] = math.MaxInt32\n            for k := left+1; k < right; k++ {\n                dp[left][right] = Min(dp[left][right], dp[left][k]+dp[k][right]+cut[right]-cut[left])\n            }\n        }\n    }\n    return dp[0][m-1]\n}\n```\n一开始 tle 的**错误**代码\n```golang\nfunc minCost(n int, cut []int) int {\n    sort.Ints(cut)\n    //0,1,3,4,5,6\n    cut = append(cut, n)\n    cut = append([]int{0}, cut...)\n    var Min = func(a,b int) int {if a<b {return a};return b}\n    var m = len(cut)\n    var dp = make([][]int, n+1)\n    for i := 0; i <= n; i++ {\n        dp[i] = make([]int, n+1) //这里就 t 了\n        // for j := 0; j <= n; j++ {\n        //     dp[i][j] = math.MaxInt32\n        // }\n    }\n    for i := 0; i < m-1; i++ {\n        for j := i+1; j < m; j++ {\n            dp[cut[i]][cut[j]] = 0x3f3f3f3f\n        }\n        dp[cut[i]][cut[i+1]] = 0\n    }\n    for tlen := 2; tlen <= m; tlen++ {\n        for left := 0; left+tlen-1 < m; left++ {\n            right := left+tlen-1\n            for k := left+1; k < right; k++ {\n                dp[cut[left]][cut[right]] = Min(dp[cut[left]][cut[right]], dp[cut[left]][cut[k]] + dp[cut[k]][cut[right]] + cut[right]-cut[left])\n            }\n        }\n    }\n    return dp[0][n]\n}\n```\n\n## _数位 DP_\n\n## [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)\n\n给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。\n\n**示例：**\n\n```java\n输入：13\n输出：6 \n解释：数字 1 出现在以下数字中：1, 10, 11, 12, 13 。\n```\n\n**解法一**\n\n这个题其实困扰了我很长时间，之前看了好几次都放弃了，感觉有些找规律的数学解法太难想到了，所以这里直接采用**数位 DP**，相对于其他的解法，这种解法会更加套路模板化\n```java\n//dp[pos][sumOne] 代表枚举到 pos 位置，前面 1 出现的个数为 sumOne 的时候，pos 到最低位出现的数字 1 的个数\nint [][] dp=null;\n\npublic int countDigitOne(int n) {\n    int len=0;\n    int[] num=new int[64]; //64 位肯定够了\n    while(n!=0){\n        num[len++]=n%10;\n        n/=10;\n    }\n    dp=new int[len+1][len+1];\n    //从高位向低位枚举\n    return dfs(num,len-1,0,true,true);\n}\n\npublic int dfs(int[] num,int pos,int sumOne,boolean leadZero,boolean limit){\n    //枚举完所有的数位，直接返回 sumOne（这个数有多少个 1)\n    if(pos==-1) return sumOne;\n    //状态重叠，状态要完全一致\n    if(!leadZero && !limit && dp[pos][sumOne]!=0) return dp[pos][sumOne];\n    int res=0;\n    int up=limit?num[pos]:9;\n    for (int i=0;i<=up;i++) {\n        res+=dfs(num,pos-1,sumOne+(i==1?1:0),leadZero&&i==0,i==up&&limit);\n    }\n    if(!leadZero && !limit) dp[pos][sumOne]=res;\n    return res;\n}\n```\n\n优化下代码，前导 0 对状态存取没有影响，这里考虑的是数字的组成\n\n```java\n//简化下代码，前导 0 其实没有影响\n//dp[pos][sumOne] 代表从高位枚举到 pos 位置，前面 1 的个数 sumOne 时\nint [][] dp=null;\n\npublic int countDigitOne(int n) {\n    int len=0;\n    int[] num=new int[64]; //64 位肯定够了\n    while(n!=0){\n        num[len++]=n%10;\n        n/=10;\n    }\n    dp=new int[len+1][len+1];\n    //从高位向低位枚举\n    return dfs(num,len-1,0,true);\n}\n\npublic int dfs(int[] num,int pos,int sumOne,boolean limit){\n    //枚举完所有的数位，直接返回 sumOne\n    if(pos==-1) return sumOne;\n    //状态重叠，状态要完全一致\n    if(!limit && dp[pos][sumOne]!=0) return dp[pos][sumOne];\n    int res=0;\n    int up=limit?num[pos]:9;\n    for (int i=0;i<=up;i++) {\n        res+=dfs(num,pos-1,sumOne+(i==1?1:0),i==up&&limit);\n    }\n    if(!limit) dp[pos][sumOne]=res;\n    return res;\n}\n```\n**Update: 2020.6.24**\n\n用 go 重写了下，同时发现之前对这个状态的理解是错的。\n\n```golang\nfunc countDigitOne(n int) int {\n    var nums []int\n    for n > 0 {\n        nums = append(nums, n%10)\n        n /= 10\n    }\n    dp := make([][]int, len(nums))\n    for i := 0; i < len(dp); i++ {\n        dp[i] = make([]int, len(nums))\n    }\n    return dfs(len(nums)-1, 0, true, nums, dp)\n}\n\nfunc dfs(pos int, cnt int, limit bool, nums []int, dp [][]int) int {\n    if pos == -1 {\n        return cnt\n    }\n    if !limit && dp[pos][cnt] != 0 {\n        return dp[pos][cnt]\n    }\n    var up = 9\n    if limit {\n        up = nums[pos]\n    }\n    var res = 0\n    for i := 0; i <= up; i++ {\n        if i == 1 {\n            res += dfs(pos-1, cnt+1, i == up && limit, nums, dp)\n        } else {\n            res += dfs(pos-1, cnt, i == up && limit, nums, dp)\n        }\n    }\n    if !limit {\n        dp[pos][cnt] = res\n    }\n    return res\n}\n```\n这里`cnt`指的其实是`[最高位 ~ pos 位]`的 1 出现的个数，当 pos 为-1 的时候其实就是到达了某一个具体的数字，比如`1231`这个时候就会返回`cnt=2`，与此同时，cnt 也是状态的一部分，比如`n=1200 , pos=1 , cnt=1`表示枚举到了第 1 位出现了 1 个 1，就说明高两位`1`出现了 1 次，也就是`10`或者`01`，这个时候当我们先求出了`01xx(0100 ~ 0199)`中的 1 的个数的时候，我们保存这个状态，当前我们下次再遇到这个状态的时候，也就是`10xx`的时候，我们就可以直接将前面`01xx`的 dp 值返回，因为`01xx`和`10xx`包含的 1 的数量肯定是一样的，无需重复计算\n\n> **数位 DP **的概念和模板其实我也是下午在网上查的，然后找到了两个写的比较好的文章 [数位 dp 总结 之 从入门到模板](https://blog.csdn.net/wust_zzwh/article/details/52100392)，[数字组成的奥妙——数位 dp](https://www.luogu.com.cn/blog/virus2017/shuweidp) 以后遇到类似的题又多了一种解法（数学的解法至今仍没学会🤣）只有这一题想搞懂**数位 DP **还是不太够，这题还是比较简单的，还是要多做题，多总结才能慢慢体会，lc 上好像数位 dp 好像并不多，过两天都做一下试试\n\n## [1420. 生成数组](https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/) \n\n给你三个整数 `n`、`m` 和 `k` 。下图描述的算法用于找出正整数数组中最大的元素。\n\n![JdU4w8.png](https://s1.ax1x.com/2020/04/23/JdU4w8.png)\n\n请你生成一个具有下述属性的数组 arr ：\n\n- arr 中有 n 个整数。\n- 1 <= arr[i] <= m 其中 (0 <= i < n) 。\n- 将上面提到的算法应用于 arr ，search_cost 的值等于 k 。\n\n返回上述条件下生成数组 arr 的 方法数 ，由于答案可能会很大，所以 必须 对 10^9 + 7 取余。\n\n**示例 1：**\n\n```java\n输入：n = 2, m = 3, k = 1\n输出：6\n解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n```\n\n**示例 2：**\n\n```java\n输入：n = 5, m = 2, k = 3\n输出：0\n解释：没有数组可以满足上述条件\n```\n\n**示例 3：**\n\n```java\n输入：n = 9, m = 1, k = 1\n输出：1\n解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]\n```\n\n**示例 4：**\n\n```java\n输入：n = 50, m = 100, k = 25\n输出：34549172\n解释：不要忘了对 1000000007 取余\n```\n\n**示例 5：**\n\n```java\n输入：n = 37, m = 17, k = 7\n输出：418930126\n```\n\n**提示：**\n\n- 1 <= n <= 50\n- 1 <= m <= 100\n- 0 <= k <= n \n\n**解法一**\n\n185 周赛 T4，类似于数位 DP，记忆化递归的方式很好理解\n\n```java\nint mod=(int)1e9+7;\n\nInteger [][][] dp=null;\n\npublic int numOfArrays(int n, int m, int k) {\n    dp=new Integer[n+1][m+1][k+1];\n    return dfs(n,0,m,k);\n}\n\npublic int dfs(int pos,int preMax,int m,int k){\n    if(k==0 && pos==0) return dp[pos][preMax][k]=1;\n    //k=0 但是 pos 不为 0 并没有结束，还可以继续找比 preMax 小的元素\n    //if(pos==0 || k==0) return 0; \n    if(pos==0 || k<0) return 0;\n    if(dp[pos][preMax][k]!=null){\n        return dp[pos][preMax][k];\n    }\n    long res=0;\n    for (int i=1;i<=m;i++) {\n        if(i>preMax){ //大于 preMax, 代价-1, 更新最大值\n            res=(res+dfs(pos-1,i,m,k-1))%mod;\n        }else{ //小于 preMax, 代价不变，最大值不变\n            res=(res+dfs(pos-1,preMax,m,k))%mod;\n        }\n    }\n    return dp[pos][preMax][k]=(int)(res%mod);\n}\n```\n一开始没注意给 dp 数组赋初始值，直接按照 0 判断的，结果 T 了半天，我都懵了了，后来才意识到，很多状态的结果就是 0，你直接按照 0 判断，很多相同的 dp 值为 0 的状态都没有被取出来用\n\n**优化**\n\n```java\nint mod=(int)1e9+7;\n\nLong [][][] dp=null;\n\npublic int numOfArrays(int n, int m, int k) {\n    dp=new Long[n+1][m+1][k+1];\n    return (int)dfs(n,0,m,k);\n}\n\npublic long dfs(int pos,int preMax,int m,int k){\n    if(k==0 && pos==0) return dp[pos][preMax][k]=1L;\n    //k=0 但是 pos 不为 0 并没有结束，还可以继续找比 preMax 小的元素\n    //if(pos==0 || k==0) return 0; \n    if(pos==0 || k<0) return 0L;\n    if(dp[pos][preMax][k]!=null){\n        return dp[pos][preMax][k];\n    }\n    long res=0;\n    //小于等于 preMax 的部分可以通过 dfs(pos-1,preMax,m,k) 算出来，减少递归次数\n    res=(res+(preMax*dfs(pos-1,preMax,m,k))%mod)%mod;\n    for (int i=preMax+1;i<=m;i++) {\n        res=(res+dfs(pos-1,i,m,k-1))%mod;\n    }\n    return dp[pos][preMax][k]=res%mod;\n}\n```\n**解法二**\n\n递推的方式，其实思想是一样的，但是个人感觉并不是特别容易直接想出来\n\n```java\npublic int numOfArrays(int n, int m, int k) {\n    int mod=1000_000_007;\n\n    long[][][] dp=new long[n+1][m+1][k+1];\n    for(int i=1;i<=m;i++){\n        dp[1][i][1]=1;\n    }\n    for(int i=2;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            for(int cost=1;cost<=k;cost++){\n                //新增加的元素小于等于 j 也就是原数组的最大值，对应上面递归的 i<=preMax\n                //所以新增加的元素在新数组的末尾有 1~j 种选择\n                dp[i][j][cost]=(j*dp[i-1][j][cost])%mod;\n                for(int nm=1;nm<j;nm++){\n                    //新增加的元素大于原数组的最大值 j, 对应上面递归的 i>preMax\n                    dp[i][j][cost]=(dp[i][j][cost]+dp[i-1][nm][cost-1])%mod;\n                }\n            }\n        }\n    }\n    long res=0;\n    for(int i=1;i<=m;i++){\n        res+=dp[n][i][k];\n        res%=mod;\n    }\n    return (int)(res%mod);\n}\n```\n\n## [902. 最大为 N 的数字组合](https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/)\n\nDifficulty: **困难**\n\n我们有一组**排序的**数字 `D`，它是  `{'1','2','3','4','5','6','7','8','9'}` 的非空子集。（请注意，`'0'` 不包括在内。）\n\n现在，我们用这些数字进行组合写数字，想用多少次就用多少次。例如 `D = {'1','3','5'}`，我们可以写出像 `'13', '551', '1351315'` 这样的数字。\n\n返回可以用 `D` 中的数字写出的小于或等于 `N` 的正整数的数目。\n\n**示例 1：**\n\n```\n输入：D = [\"1\",\"3\",\"5\",\"7\"], N = 100\n输出：20\n解释：\n可写出的 20 个数字是：\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n```\n\n**示例 2：**\n\n```\n输入：D = [\"1\",\"4\",\"9\"], N = 1000000000\n输出：29523\n解释：\n我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，\n81 个四位数字，243 个五位数字，729 个六位数字，\n2187 个七位数字，6561 个八位数字和 19683 个九位数字。\n总共，可以使用 D 中的数字写出 29523 个整数。\n```\n\n**提示：**\n\n1.  `D` 是按排序顺序的数字 `'1'-'9'` 的子集。\n2.  `1 <= N <= 10^9`\n\n**解法一**\n\nlc 上写的第 3 道数位 DP，套模板，理解的还不够深刻，等以后做多了再单独开专题讲解\n```java\nboolean[] dict;\n\nint[] nums;\n\nInteger[] dp;\n\npublic int atMostNGivenDigitSet(String[] D, int N) {\n    int pos = -1;\n    nums = new int[64];\n    while (N > 0) {\n        nums[++pos] = N % 10;\n        N /= 10;\n    }\n    dict = new boolean[10];\n    dp = new Integer[pos + 1];\n    for (int i = 0; i < D.length; i++) {\n        dict[Integer.valueOf(D[i])] = true;\n    }\n    return dfs(pos, true, true);\n}\n\n//从 pos~0 有多少个合法的数\npublic int dfs(int pos, boolean leadZero, boolean limit) {\n    if (pos == -1) {\n        //枚举完所有的数位，没有前导 0 说明找到了一个合法的数\n        return leadZero ? 0 : 1;\n    }\n    if (!leadZero && !limit && (dp[pos] != null)) {\n        return dp[pos];\n    }\n    int res = 0;\n    int up = limit ? nums[pos] : 9;\n    for (int i = 0; i <= up; i++) {\n        //前面全是 0 || 当前位在 dict 中\n        if ((leadZero && (i == 0)) || dict[i]) {\n            res += dfs(pos - 1, leadZero && (i == 0), limit && (i == up));\n        }\n    }\n    if (!leadZero && !limit) {\n        dp[pos] = res;\n    }\n    return res;\n}\n```\n\n## _状压 DP_\n\n## [464. 我能赢吗](https://leetcode-cn.com/problems/can-i-win/)\n\n在 \"100 game\" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。\n\n如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？\n\n例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。\n\n给定一个整数 `maxChoosableInteger` （整数池中可选择的最大数）和另一个整数 `desiredTotal`（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？\n\n你可以假设 `maxChoosableInteger` 不会大于 20， `desiredTotal` 不会大于 300。\n\n**示例：**\n\n```java\n输入：\nmaxChoosableInteger = 10\ndesiredTotal = 11\n\n输出：\nfalse\n\n解释：\n无论第一个玩家选择哪个整数，他都会失败。\n第一个玩家可以选择从 1 到 10 的整数。\n如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。\n第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利。\n同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。\n```\n\n**解法一**\n\n从 [力扣上的 DP 问题分类汇总](https://leetcode-cn.com/circle/article/NfHhXD/) 过来的，所以首先知道这个是状压 DP，但是菜鸡的我并不知道状压 DP 是啥🤣，所以先写了个暴力的搜索，然后不出意料的 t 了\n\n```java\n//TLE case 20 210 41/45\npublic boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n    if(desiredTotal<=maxChoosableInteger) return true;\n    if((1+maxChoosableInteger)*(maxChoosableInteger)/2<desiredTotal) return false;\n    boolean[] visit=new boolean[maxChoosableInteger+1];\n    return dfs(maxChoosableInteger,desiredTotal,visit);\n}\n\npublic boolean dfs(int max,int total,boolean[] visit){\n    if(total<=0) return false; //前人已经拿完了\n    for (int i=1;i<=max;i++) {\n        if(!visit[i]){\n            visit[i]=true;\n            boolean temp=dfs(max,total-i,visit);\n            visit[i]=false;\n            if(!temp){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n注意这个写法的返回时机，有些语句是不能合并的，比如下面这样就是错的（别问我为啥知道的🤣）\n\n```java\npublic boolean dfs(int max,int total,boolean[] visit){\n    if(total<=0) return false;\n    for (int i=1;i<=max;i++) {\n        if(!visit[i]){\n            visit[i]=true;\n            if(!dfs(max,total-i,visit)){\n                return true;\n            }\n            visit[i]=false;\n        }\n    }\n    return false;\n}\n```\n\n像上面这样写乍一看好像没问题，对比一下两种写法，其实就是回溯`visit`的时机不同，第一个是另一个人`dfs` 不管成功与否都会回溯状态，而第二种是另一个人`dfs` 成功后才会回溯状态，失败后就不会回溯状态了，但是在这题中不管另一个人失败与否都需要回溯状态，首先另一个人成功后我肯定是要回溯，另一个人成功意味着我失败了，我还要继续尝试找必胜的选取方法，但是另一个人失败后还是需要回溯状态，仔细想想，下一层 dfs（另一个人）失败是因为下下一层 dfs（我）成功了，我在那一次成功后并没有回溯`visit`，这样下一层（另一个人）就用不了被下下层占用的数字，就无法枚举所有情况，自然就错了\n\n> 各位大佬见谅，表达能力有限，上面的都是我胡言乱语，大佬们跳过就行了\n\n**解法二**\n\n根据昨天写的一个数位 DP，加上自己的 yy，写了个状压 DP 出来了🤣，上面的解法明显会有很多的重复解，而确定是否重复的关键其实就是数字的选取情况，上面我们是用的一个`visit`数组来记录这选取的情况，要直接通过这个`visit`来判断状态是否相同是很耗时耗力的，所以就引入了状态压缩，我们可以用二进制的第`i`位的 0 或者 1 来表示`i`这个数字的选取与否，这样所有数字的选取状态就可以用一个数来很方便的表示，题目说了不超过 20 位，所以这里就可以用一个`int`来表示状态`state`，通过`state`来判断状态是否一致，进而进行记忆化的存取\n\n```java\nBoolean[] dp=null; //用 Boolean 比较方便判断是否记忆化\n\npublic boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n    //小于最大值先手可以直接拿\n    if(desiredTotal<=maxChoosableInteger) return true;\n    //前 N 项和还不够 desiredTotal\n    if((1+maxChoosableInteger)*(maxChoosableInteger)/2<desiredTotal) return false;\n    //20 位二进制 1<<21\n    dp=new Boolean[1<<21];\n    return dfs(maxChoosableInteger,desiredTotal,0);\n}\n\npublic boolean dfs(int max,int total,int state){\n    if(total<=0) return false; //前人已经拿完了\n    if(dp[state]!=null){\n        return dp[state];\n    }\n    for (int i=max;i>=1;i--) {\n        //参数传递的，就不用回溯了，代码变的简洁多了\n        if((state>>i&1)==0 && !dfs(max,total-i,state|(1<<i))){\n            return dp[state]=true;\n        }\n    }\n    return dp[state]=false;\n}\n```\n其实一开始开了个二维的 `new Boolean[desiredTotal] [1<<21]`，然后就直接 MLE 了😅 太菜了 hahaha，然后看了下，发现`state`一样的话，`total`肯定是一样的（反过来就不一定了），所以只需要一维的就可以了\n\n其实也可以用`int[]`做状压\n\n```java\n//int 做状压，似乎性能没有提升\nint[] dp=null; //0: 未初始化 1:true 2:false\n\npublic boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n    //小于最大值先手可以直接拿\n    if(desiredTotal<=maxChoosableInteger) return true;\n    //前 N 项和还不够 desiredTotal\n    if((1+maxChoosableInteger)*(maxChoosableInteger)/2<desiredTotal) return false;\n    //20 位二进制 1<<21\n    dp=new int[1<<21];\n    return dfs(maxChoosableInteger,desiredTotal,0);\n}\n\npublic boolean dfs(int max,int total,int state){\n    if(dp[state]!=0){\n        return dp[state]==1;\n    }\n    for (int i=max;i>=1;i--) {\n        //参数传递的，就不用回溯了，代码变的简洁多了\n        if((state>>i&1)==0 && (i>=total || !dfs(max,total-i,state|(1<<i)))){\n            dp[state]=1;\n            return true;\n        }\n    }\n    dp[state]=2;\n    return false;\n}\n```\n\n## _博弈 DP_\n\n## [292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/)\n\n你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。\n\n你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。\n\n**示例：**\n\n```java\n输入：4\n输出：false \n解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；\n     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。\n```\n\n**解法一**\n\n博弈型动态规划入门题\n\n```java\npublic boolean canWinNim(int n) {\n    boolean[] dp=new boolean[n];\n    dp[0]=true;\n    dp[1]=true;\n    dp[2]=true;\n    //t t t f t t t f .....\n    //每个状态取决于前 3 个状态\n    for (int i=3;i<n;i++) {\n        //分别拿 1,2,3 个看对面能不能赢\n        dp[i]=!dp[i-1] || !dp[i-2] || !dp[i-3];\n    }\n    return dp[n-1];\n}\n```\n这个解法在数据过大的时候还是会 TLE\n\n**解法二**\n\n规律\n\n```java\npublic boolean canWinNim(int n) {\n    return n%4!=0;\n}\n```\n\n## [1025. 除数博弈](https://leetcode-cn.com/problems/divisor-game/)\n\nDifficulty: **简单**\n\n爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。\n\n最初，黑板上有一个数字 `N` 。在每个玩家的回合，玩家需要执行以下操作：\n\n*   选出任一 `x`，满足 `0 < x < N` 且 `N % x == 0` 。\n*   用 `N - x` 替换黑板上的数字 `N` 。\n\n如果玩家无法执行这些操作，就会输掉游戏。\n\n只有在爱丽丝在游戏中取得胜利时才返回 `True`，否则返回 `false`。假设两个玩家都以最佳状态参与游戏。\n\n**示例 1：**\n\n```go\n输入：2\n输出：true\n解释：爱丽丝选择 1，鲍勃无法进行操作。\n```\n\n**示例 2：**\n\n```go\n输入：3\n输出：false\n解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。\n```\n\n**提示：**\n\n1.  `1 <= N <= 1000`\n\n**解法一**\n\n博弈 DP，和上面的类似，尝试所有情况\n```golang\nfunc divisorGame(N int) bool {\n    //N=i 时，先手的人能否赢\n    var dp = make([]bool, N+1)\n    dp[1] = false\n    for i := 2; i <= N; i++ {\n        //尝试所有可行的选择\n        //从 i 中先手拿 j，看对方在 i-j 中先手能不能赢\n        for j := 1; j < i; j++ {\n            if i%j == 0 && !dp[i-j] {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    return dp[N]\n}\n```\n\n**解法二**\n\n很明显，这题也有一个数学的解法😂，利用奇数和偶数的性质，N 为偶数的时候，先手的人是必赢的\n```golang\n//规律，偶数必赢，奇数必输\n//最后在 N=2 的时候结束比赛，所以谁先到 2 谁就赢\n//奇数的因子只有奇数，奇数-奇数 = 偶数，当我拿到偶数时候可以直接拿走 1，变为奇数，如此往来\n//最终我必定能先到 2\nfunc divisorGame(N int) bool {\n    return N%2 == 0\n}\n```\n\n## [1140. 石子游戏 II](https://leetcode-cn.com/problems/stone-game-ii/)\n\nDifficulty: **中等**\n\n亚历克斯和李继续他们的石子游戏。许多堆石子 **排成一行**，每堆都有正整数颗石子 `piles[i]`。游戏以谁手中的石子最多来决出胜负。\n\n亚历克斯和李轮流进行，亚历克斯先开始。最初，`M = 1`。\n\n在每个玩家的回合中，该玩家可以拿走剩下的 **前** `X` 堆的所有石子，其中 `1 <= X <= 2M`。然后，令 `M = max(M, X)`。\n\n游戏一直持续到所有石子都被拿走。\n\n假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。\n\n**示例：**\n\n```\n输入：piles = [2,7,9,4,4]\n输出：10\n解释：\n如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 \n如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。\n所以我们返回更大的 10。 \n```\n\n**提示：**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 10 ^ 4`\n\n**解法一**\n\n瞎写的记忆化，懒得改 dp 了\n```java\nint n = 0;\n\nInteger[][] cache;\n\npublic int stoneGameII(int[] piles) {\n    n = piles.length;\n    //这里用后缀和会简单一点，懒得改了\n    int[] preSum = new int[n+1];\n    cache = new Integer[n+1][n+1];\n    preSum[0] = 0;\n    for(int i = 1; i <=n; i++){\n        preSum[i] = preSum[i-1] + piles[i-1];\n    }\n    return dfs(preSum, 0, 1);\n}\n\npublic int dfs(int[] preSum, int start, int M){\n    if(cache[start][M]!=null){\n        return cache[start][M];\n    }\n    int res = 0;\n    for(int len = 1; start + len - 1 < n && len <= 2*M; len++){\n        //start=0 len=2 (0,1)\n        int temp = preSum[n] - preSum[start] - dfs(preSum, start + len, Math.max(M, len));\n        res = Math.max(res, temp);\n    }\n    return cache[start][M] = res;\n}\n```\n## [1406. 石子游戏 III](https://leetcode-cn.com/problems/stone-game-iii/)\n\nDifficulty: **困难**\n\nAlice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 `stoneValue` 给出。\n\nAlice 和 Bob 轮流取石子，**Alice** 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 **1、2 或 3 堆石子** 。比赛一直持续到所有石头都被拿走。\n\n每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 **0** 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。\n\n假设 Alice 和 Bob 都采取 **最优策略** 。如果 Alice 赢了就返回 _\"Alice\"_ _，_Bob 赢了就返回 _\"Bob\"，_平局（分数相同）返回 _\"Tie\"_ 。\n\n**示例 1：**\n\n```go\n输入：values = [1,2,3,7]\n输出：\"Bob\"\n解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。\n```\n\n**示例 2：**\n\n```go\n输入：values = [1,2,3,-9]\n输出：\"Alice\"\n解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。\n如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。\n如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。\n注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。\n```\n\n**示例 3：**\n\n```go\n输入：values = [1,2,3,6]\n输出：\"Tie\"\n解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。\n```\n\n**示例 4：**\n\n```go\n输入：values = [1,2,3,-1,-2,-3,7]\n输出：\"Alice\"\n```\n\n**示例 5：**\n\n```go\n输入：values = [-1,-2,-3]\n输出：\"Tie\"\n```\n\n**提示：**\n\n*   `1 <= values.length <= 50000`\n*   `-1000 <= values[i] <= 1000`\n\n**解法一**\n\n某次双周赛的 T4，没参加，感觉这题还是挺简单的，比 2 还要简单，下面的做法直接套用 2 的做法，改成了后缀和数组\n```java\n//后缀数组\nint[] sufSum = null;\n\nInteger[] dp = null;\n\npublic String stoneGameIII(int[] stoneValue) {\n    int n = stoneValue.length;\n    sufSum = new int[n+1];\n    dp = new Integer[n+1];\n    for (int i = n-1; i >= 0; i--){\n        sufSum[i] = sufSum[i+1] + stoneValue[i];\n    }\n    int alice = dfs(stoneValue, 0);\n    int bob = sufSum[0]-alice;\n    if (alice == bob) {\n        return \"Tie\";\n    }\n    return alice > bob ? \"Alice\" : \"Bob\";\n}\n\npublic int dfs(int[] sv, int start){\n    if (start > sv.length) {\n        return 0;\n    }\n    if (dp[start]!=null) {\n        return dp[start];\n    }\n    int sum = sufSum[start];\n    return dp[start] = Math.max(sum-dfs(sv, start+1), Math.max(sum-dfs(sv, start+2), sum-dfs(sv, start+3)));\n}\n```\n这题还有更好的做法，先挖个坑，后面有时间再写\n\n## [1510. 石子游戏 IV](https://leetcode-cn.com/problems/stone-game-iv/)\n\nDifficulty: **困难**\n\nAlice 和 Bob 两个人轮流玩一个游戏，Alice 先手。\n\n一开始，有 `n` 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 **任意** 非零 **平方数** 个石子。\n\n如果石子堆里没有石子了，则无法操作的玩家输掉游戏。\n\n给你正整数 `n` ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 `True` ，否则返回 `False` 。\n\n**示例 1：**\n\n```go\n输入：n = 1\n输出：true\n解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。\n```\n\n**示例 2：**\n\n```go\n输入：n = 2\n输出：false\n解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。\n```\n\n**示例 3：**\n\n```go\n输入：n = 4\n输出：true\n解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -> 0）。\n```\n\n**示例 4：**\n\n```go\n输入：n = 7\n输出：false\n解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。\n如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 3 -> 2 -> 1 -> 0）。\n如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 6 -> 2 -> 1 -> 0）。\n```\n\n**示例 5：**\n\n```go\n输入：n = 17\n输出：false\n解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。\n```\n\n**提示：**\n\n*   `1 <= n <= 10^5`\n\n**解法一**\n\n前几次双周赛的 T4，太水了，大水题，顶多算 mid\n```golang\nfunc winnerSquareGame(n int) bool {\n    var dp = make([]bool, 100001)\n    dp[0] = false\n    for i := 1; i <= n; i++ {\n        for j := 1; j*j <= i; j++ {\n            if !dp[i-j*j] {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    return dp[n]\n}\n```\n**解法二**\n\n玩了一手花哨的记忆化手法😂\n```golang\n//记忆化\nfunc winnerSquareGame(n int) bool {\n    var T, F = true, false\n    var dfs func(int) bool\n    var dp = make([]*bool, 100001)\n    //先手拿 x^2 个石头\n    dfs = func (n int) bool {\n        if dp[n] != nil {\n            return *dp[n]\n        }\n        if n == 0 {\n            return F\n        }\n        for i := 1; i*i <= n; i++{\n            if !dfs(n-i*i) {\n                dp[n] = &T\n                return T\n            }\n        }\n        dp[n] = &F\n        return F\n    }\n    return dfs(n)\n}\n```\n\n## [486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)\n\nDifficulty: **中等**\n\n给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。\n\n给定一个表示分数的数组，预测玩家 1 是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。\n\n**示例 1：**\n\n```go\n输入：[1, 5, 2]\n输出：False\n解释：一开始，玩家 1 可以从 1 和 2 中进行选择。\n如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。\n所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。\n因此，玩家 1 永远不会成为赢家，返回 False 。\n```\n\n**示例 2：**\n\n```go\n输入：[1, 5, 233, 7]\n输出：True\n解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。\n     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。\n```\n\n**提示：**\n\n*   1 <= 给定的数组长度 <= 20.\n*   数组里所有分数都为非负数且不会大于 10000000 。\n*   如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。\n\n**解法一**\n\n记忆化，这种博弈的题目记忆化写起来会比较自然\n```golang\nfunc PredictTheWinner(nums []int) bool {\n    var Max = func(a, b int) int {if a > b {return a};return b}\n    var n = len(nums)\n    var preSum = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        preSum[i] = preSum[i-1] + nums[i-1]\n    }\n    //记忆化\n    var dp = make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        for j := 0; j < n; j++ {\n            dp[i][j] = -1\n        }\n    }\n    var dfs func(i int, j int) int\n    dfs = func(i int, j int) int {\n        if dp[i][j] != -1 {\n            return dp[i][j]\n        }\n        if i == j {\n            return nums[i]\n        }\n        //区间和\n        sum := preSum[j+1] - preSum[i]\n        dp[i][j] = Max(sum-dfs(i+1, j), sum-dfs(i, j-1))\n        return dp[i][j]\n    }\n    A := dfs(0, n-1)\n    return A >= preSum[n]-A\n}\n```\n**解法二**\n\n区间 DP 的写法当然也可以，思路一样\n```golang\nfunc PredictTheWinner(nums []int) bool {\n    var n = len(nums)\n    var dp = make([][]int, n)\n    var Max = func(a,b int) int {if a>b {return a};return b}\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = nums[i]\n    }\n    var preSum = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        preSum[i] = preSum[i-1] + nums[i-1]\n    }\n    for tlen := 2; tlen <= n; tlen++ {\n        for left := 0; left+tlen-1 < n; left++ {\n            right := left+tlen-1\n            sum := preSum[right+1]-preSum[left]\n            dp[left][right] = Max(sum-dp[left][right-1], sum-dp[left+1][right])\n        }\n    }\n    return dp[0][n-1] >= preSum[n]-dp[0][n-1]\n}\n```\n\n## _图论_\n\n暂时先放在这里，等后面学了 dij，spfa 那些后一起单独总结一下\n\n## [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)\n\n有 `N` 个网络节点，标记为 `1` 到 `N`。\n\n给定一个列表 `times`，表示信号经过**有向**边的传递时间。 `times[i] = (u, v, w)`，其中 `u` 是源节点，`v` 是目标节点， `w` 是一个信号从源节点传递到目标节点的时间。\n\n现在，我们从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1`。\n\n**示例：**\n\n![tfoiPf.png](https://s1.ax1x.com/2020/06/08/tfoiPf.png)\n\n```java\n输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2\n输出：2\n```\n\n**注意：**\n\n1. `N` 的范围在 `[1, 100]` 之间。\n2. `K` 的范围在 `[1, N]` 之间。\n3. `times` 的长度在 `[1, 6000]` 之间。\n4. 所有的边 `times[i] = (u, v, w)` 都有 `1 <= u, v <= N` 且 `0 <= w <= 100`。\n\n**解法一**\n\n临时起意学了下 Floyd，然后在 lc 上搜了一下找到了这一题，思路也很直接\n\n```java\n//Floyd\npublic int networkDelayTime(int[][] times, int N, int K) {\n    int[][] dis=new int[N][N];\n    int INF = 0x3f3f3f3f;\n    for(int i=0;i<N;i++) Arrays.fill(dis[i],INF);\n    for(int i=0;i<N;i++) dis[i][i]=0;\n    for(int[] t:times) dis[t[0]-1][t[1]-1]=t[2];\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                dis[i][j]=Math.min(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n    int res=0;\n    K-=1; //从 0 开始！从 1 开始的都是邪教\n    for(int i=0;i<N;i++){\n        if(dis[K][i]==INF) return -1;\n        res=Math.max(dis[K][i],res);\n    }\n    return res;\n}\n```\n\n大概说一下，其实 Floyd 就是动态规划的思想，`dp[k][i][j]`代表从`i~j`允许经过前`k`个节点中转时的最短路径，那么其实很容易推导出，`dp[k][i][j]=min(dp[k-1][i][k]+dp[k-1][k][j],dp[k][i][j])`其实也就是尝试以每个点为中转点，看能否缩短两点之间的距离，和区间 DP 有点像，关于`k`为什么要放外面其实仔细想一下就知道了，我们需要保证在求`dp[k][i][j]`的时候需要保证`dp[k-1][i][j]`以及`dp[k-1][i][k]` 和`dp[k-1][k][j]`都是已经计算完毕的，想一想，如果 k 放在里面能保证么？很明显不行，可以类比上面的 [576. 出界的路径数](#576-出界的路径数)，一样的道理。然后我们再观察整个递推方程，发现`dp[k]`只依赖于`dp[k-1]`所以就可以直接滚动数组优化掉 k 维度的空间，也就是上面的解法\n\n## [1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)\n\nDifficulty: **中等**\n\n给你一个`points` 数组，表示 2D 平面上的一些点，其中 points[i] = [x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>] 。\n\n连接点 [x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>] 和点 [x<sub style=\"display: inline;\">j</sub>, y<sub style=\"display: inline;\">j</sub>]` 的费用为它们之间的 **曼哈顿距离** ：x<sub style=\"display: inline;\">i</sub> - x<sub style=\"display: inline;\">j</sub>| + |y<sub style=\"display: inline;\">i</sub> - y<sub style=\"display: inline;\">j</sub>| ，其中 |val| 表示 val 的绝对值。\n\n请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。\n\n**示例 1：**\n![wDmhAf.png](https://s1.ax1x.com/2020/09/14/wDmhAf.png)\n\n```\n输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n输出：20\n解释：\n\n我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。\n注意到任意两个点之间只有唯一一条路径互相到达。\n```\n\n**示例 2：**\n\n```\n输入：points = [[3,12],[-2,5],[-4,1]]\n输出：18\n```\n\n**示例 3：**\n\n```\n输入：points = [[0,0],[1,1],[1,0],[-1,1]]\n输出：4\n```\n\n**示例 4：**\n\n```\n输入：points = [[-1000000,-1000000],[1000000,1000000]]\n输出：4000000\n```\n\n**示例 5：**\n\n```\n输入：points = [[0,0]]\n输出：0\n```\n\n**提示：**\n\n*   1 <= points.length <= 1000\n*   -10<sup>6</sup> <= x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub> <= 10<sup>6</sup>\n*   所有点 (x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>) 两两不同。\n\n**解法一**\n\nPrim O(V^2) 最小生成树，206th 周赛 t3，裸的 mst，但是彩笔的我并不会，事后补了一波 [OI Wiki](https://oi-wiki.org/graph/mst/#prim)，（这个是原始的暴力 Prim，应对这个题够了）  \n```java\n//Prim O(V^2) 任取一个节作为起点，dis[i] 记录 mst 点集到点 i 的最短距离\n//每次取出 mst 点集外 dis[i] 最小的点，也就是离 mst 点集最近的点，并标记为 mst 节点\n//然后利用该点更新其他的 mst 点集外的点的 dis 距离，直到将所有的点都加进去，适合稠密图（边数远大于点数）\n//可以使用一些数据结构来优化时间复杂度，暂时不深究\npublic int minCostConnectPoints(int[][] points) {\n    int INF = 0x3f3f3f3f;\n    int n = points.length;\n    //dis 表示 mst 点集到该点的最小距离\n    int[] dis = new int[n];\n    Arrays.fill(dis, INF);\n    dis[0] = 0;\n    boolean[] vis = new boolean[n];\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        int minCost = INF;\n        int k = -1; //最小的新节点\n        for (int j = 0; j < n; j++) {\n            if (!vis[j] && dis[j] < minCost) {\n                minCost = dis[j];\n                k = j;\n            }\n        }\n        vis[k] = true;\n        res += minCost;\n        for (int j = 0; j < n; j++) {\n            //更新所有 mst 点集外的点的 dis\n            if (vis[j]) continue;\n            int mhd = Math.abs(points[k][0]-points[j][0])+Math.abs(points[k][1]-points[j][1]);\n            dis[j] = Math.min(dis[j], mhd);\n        }\n    }\n    return res;\n}\n```\n这个题明显是稠密图，用邻接矩阵表示的，Prim 用邻接矩阵时机复杂度就是 O(V^2)，V 为点数\n> 数据结构中对于稀疏图的定义为：有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图（sparse graph），反之边的条数|E|接近|V|²，称为稠密图（dense graph）。\n\n**解法二**\n\nKruskal + 并查集，比较适合稀疏图，这里时机复杂度是 O(ElogE)，E 为边数\n```java\n//Kruskal+UnionFind\n//以边为中心，首先构造出所有的边，然后排序，从最短的边开始，合并该边的两个端点，这里需要用到并查集\n//合并 n-1 次后就得到 mst（n 为节点数），适合稀疏图\nint[] parent;\nint[] rank;\n//路径压缩\npublic int find(int a){\n    if (parent[a] == a) {\n        return a;\n    }\n    return parent[a] = find(parent[a]);\n}\n\npublic boolean union(int a, int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) {\n        return false;\n    }\n    //随便合并 553ms\n    //parent[pa] = pb;\n    //按秩合并 564ms 似乎没有什么变化。\n    if (rank[pa] > rank[pb]) {\n        parent[pb] = pa;\n    }else if (rank[pb] > rank[pa]) {\n        parent[pa] = pb;\n    }else{\n        parent[pa] = pb;\n        rank[pb]++;\n    }\n    return true;\n}\n\npublic int minCostConnectPoints(int[][] points) {\n    int n = points.length;\n    parent = new int[n];\n    rank = new int[n];\n    //n-1 + n-2 + n-3 +...+ 1 = (n-1) + (n-1)*(n-2)/2 = n(n-1)/2\n    //5 : 4+3+2+1 = 4*\n    //0,1: 端点，2: 边权值\n    int[][] edge = new int[n*(n-1)/2][3];\n    int idx = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            int dis = Math.abs(points[i][0]-points[j][0])+Math.abs(points[i][1]-points[j][1]);\n            edge[idx++] = new int[]{i, j, dis};\n        }\n        parent[i] = i;\n        rank[i] = 1;\n    }\n    //按照边的权值排序\n    Arrays.sort(edge, (e1, e2)->e1[2]-e2[2]);\n    int res = 0;\n    int count = 0;\n    for (int i = 0; i < edge.length; i++) {\n        if (union(edge[i][0], edge[i][1])) {\n            res += edge[i][2];\n            count++;\n        }\n        if (count == n-1) {\n            break;\n        }\n    }\n    return res;\n}\n```","tags":["动态规划","LeetCode"],"categories":["算法"]},{"title":"深入理解 Java 虚拟机（二）","url":"/2019/08/17/2c0986bb/","content":"\n> 这一篇主要讲 JVM 的类加载机制，本来很久之前就写了，但是这几天又重新学习了一遍，纠正了之前很多错误的观点，然后又补充了很多东西\n\n## 类加载的过程\n\n**前言：**\n\n在 Java 语言中，类型的加载，连接和初始化过程都是在**运行期间**完成的，这与那些在**编译期间**需要进行链接工作的语言（C/C++）不同，这样毫无疑问会增加类加载的性能开销，但是会为 Java 提供高度的灵活性，Java 天生可以动态扩展的就是依赖于运行时期**动态加载和动态链接**这个特点实现的，比如一个接口，完全可以在运行时期动态的指定其具体的实现类。又或者用户可以通过类加载器让一个本地的引用运行时从其他地方（网络等）加载一个二进制的流作为程序代码的一部分。\n\n![mark](http://static.imlgw.top///20190418/em4YNNmXXmho.png?imageslim)\n\n### ①加载\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流。\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n- 在内存中生成一个代表这个类的 `java.lang.Class` 对象\n\n#### 类加载的最终产物\n\n> 类加载的最终产物是位于堆中的`Class`对象\n\n《深入理解 Java 虚拟机》里面介绍的 JVM 内存结构 (p39)\n\n![JVM 内存结构](http://static.imlgw.top///20190417/yk2bzxILsCpL.png?imageslim)\n\n**堆（Heap）**：最大的一块区域，线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。\n\n> The Java Virtual Machine has a *heap* that is `shared` among `all` Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.\n>\n> The heap is created on virtual machine `start-up`. Heap storage for objects is reclaimed by an automatic storage management system (known as a *garbage collector(GC)*); \n>\n> 摘自  [官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3)\n\n**方法区（Method Area）**：又称为`非堆`，线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。\n\n> The Java Virtual Machine has a *method area* that is `shared` among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the \"text\" segment in an operating system process. It stores per-class structures such as the **run-time constant pool**, **field** and **method data**, and the code for methods and constructors, including the special methods ([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)) used in class and instance initialization and interface initialization.\n\n**运行时常量池 (run-time constant pool)**：\n\n是方法区的一部分，用于存放编译期生成的各种字面量\"123\"，\"LGW\" 等字符串常量池，和符号引用。运行时常量池具有动态性，并非只有 Class 文件中的内容才能进入运行时常量池，运行期间也能将新的常量放入池中。如 String.intern() 方法。\n\n**方法栈（JVM Stack）**：\n\n线程私有。存储局部变量表、操作栈、动态链接、方法出口，`对象指针`。\n\n**本地方法栈（Native Method Stack）**：\n\n线程私有。为虚拟机使用到的 Native 方法服务。如 Java 使用 c 或者 c++编写的接口服务时，代码在此区运行。\n\n**程序计数器（Program Counter Register）**：\n\n线程私有，它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。\n\n#### 加载类的方式\n\n- 本地磁盘 classpath\n- 内存中加载 ，动态代理？RPC?\n- 通过网络加载。class\n- 从 zip，jar 中加载\n- 数据库中提取。class\n- 动态编译\n\n### ②连接：\n\n#### 验证 \n\n**文件格式验证**\n\n- 是否以魔数`0xCAFEBABE`（咖啡宝贝）开头\n\n- 主、次版本号是否在当前虚拟机处理范围之内\n\n- 常量池中的常量中是否有不被支持的常量类型（检查常量 tag 标志）\n\n- .....\n\n**元数据验证**\n\n第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求\n\n**字节码验证**\n\n主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的\n\n由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在 JDK 1.6 之后的 Javac 编译器和 Java 虚拟机中进行了一项优化，给方法体的 Code 属性的属性表中增加了一项名为\" StackMapTable\" 的属性，只需要检查 StackMapTable 属性中的记录是否合法皆可以了\n\n**符号引用验证**\n\n符号引用的校验发生在虚拟机将`符号引用`转化为`直接引用`的时候，这个转化动作将在连接的第三阶段—-**解析**阶段中发生，通常需要校验以下内容：\n\n- 符号引用中通过字符串描述的全限定名是否能找到对应的类\n- 在指定类中是否存在符合方法的字段描述以及简单名称说描述的方法和字段。\n- 符号引用中的类，字段，方法的访问性是否可以被当前类访问\n- .......\n\n如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间\n\n#### 准备\n\n为类的**静态变量**分配内存，并初始化为默认值\n\n| 数据类型  | 默认值   |\n| --------- | -------- |\n| boolean   | false    |\n| char      | '/u0000' |\n| byte      | (byte)0  |\n| short     | (short)0 |\n| int       | 0        |\n| long      | 0L       |\n| double    | 0.0d     |\n| float     | 0.0f     |\n| reference | null     |\n\n🎯 当然并不是所有情况下都会初始化为零值，如果字段表的属性中有`ConstantValue` ，准备阶段就会直接初始化为这个这个`ConstantValue`属性的值\n\n#### 解析\n\n解析阶段是虚拟机将**常量池**内的**符号引用**替换为**直接引用**的过程。\n\n- **符号引用：** 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候能无歧义的定位到目标中就行。\n- **直接引用：** 直接引用可以是直接指向目标的指针，相对偏移量或者一个能间接定位到目标的句柄。\n\n除 `invokedynamic`（动态语言支持） 指令以外，虚拟机实现可以对第一次解析的结果进行缓存。\n\n解析动作主要针对类或接口、字段解析、类方法解析、接口方法解析、方法类型解析、方法句柄解析和调用点限定符 7 类符号引用进行。\n\n关于这个也可以看看 R 大的回答 [JVM 符号引用转换直接引用的过程 ](https://www.zhihu.com/question/30300585/answer/51335493)( 吹爆我 R 大 😁\n\n### ③初始化：\n\n初始化阶段就是执行`类构造器<clinit>`方法的过程\n\n#### 类构造器&lt;client&gt;\n\n💡`<clinit>`方法是由编译器自动收集类中的所有**类变量的赋值**动作和**静态语句块**（static 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中**出现的顺序决定的**，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块**可以赋值**，但是**不能访问**（比如 print）\n\n💡 和**实例构造器**`<init>` 不同，不需要显式的去调用父类的构造器，虚拟机会保证子类的`<clinit>`方法执行之前，父类的`<clinit>`方法已经执行完毕，因此虚拟机中第一个被执行的`<clinit>` 一定是 Object 类\n\n💡` <clinit>` 方法对于类或者接口来说并不是必须的，如果类中没有静态语句块也没有静态变量的**赋值**操作，那么编译器可以不为这个类生成`<clinit>` 方法\n\n💡 对于接口，不能使用 static 块，但是可以有静态变量的赋值操作。子类接口的`<clinit>`方法调用并不保证父接口的`<clinit>`方法被先调用，只有用到父接口的静态变量的时候，父接口`<clinit>`方法才会被调用。接口的实现类在初始化时也一样不会执行接口的`<clinit>`方法。\n\n💡 虚拟机会保证一个类的`<clinit>`方法在多线程环境中被正确地加锁、同步。如果一个线程的`<clinit>`方法调用时间过长，就可能造成多个线程阻塞。Demo 如下\n\n```java\npublic class ClinitThreadTest {\n    public static void main(String[] args) {\n        new Thread(()->new SimpleObj()).start();\n    }\n\n    static class SimpleObj{\n        private static AtomicBoolean init=new AtomicBoolean(true);\n\n        static {\n            System.out.println(Thread.currentThread().getName()+\" i will be init\");\n            while (init.get()){\n\n            }\n            System.out.println(\"i am finished\");\n       }\n    }\n}\n```\n\n#### 为类的静态变量赋予正确的初始值\n\n下面这个 Demo 很经典，可以帮助我们理解类加载的过程\n\n```java\npublic class SingleTon {\n    private static SingleTon ins=new SingleTon();\n\n    public static  int x=0;\n\n    public static int y;\n\n    private SingleTon(){\n        x++;y++;\n    }\n\n    public static SingleTon getIns(){\n        return ins;\n    }\n\n    public static void main(String[] args) {\n        SingleTon singleTon=getIns();\n        System.out.println(singleTon.x);\n        System.out.println(singleTon.y);\n    }\n}\n```\n\n如果不熟悉类加载的过程可能一眼就觉得应该是（1，1），其实不然，结合上面的加载过程分析\n\n🔺 首先加载连接，然后执行准备工作，在执行完**准备阶段**工作后三个静态变量都有了**默认的初始值**，然后进入初始化阶段\n\n🔺 `<clinit>`初始化阶段会按顺序**从上往下**依次赋予正确的初始值，所以**先执行**了`new Singleton()`给`ins`赋初始值，会调用它的构造器，然后 x，y 都++变为 1，**再然后**就会给 x，y 赋予正确的初始值，x 初始值为 0，而 y 没有初始值所以就是（0，1）\n\n### Class 对象在哪里？\n\n先说结论，Class 对象和其他普通的 Java 对象一样都是存放在堆中的。\n\n存放在方法区的是类的元数据 (InstanceKlass，包括类的常量池 ( constant pool)  ，域 (Field) 信息  ，方法 (Method) 信息 ，除了常量外的所有静态 (static) 变量 等），`java.lang.Class 实例`并不负责记录真正的类元数据，而只是对 VM 内部的`InstanceKlass`对象的一个包装供 Java 的反射访问用，在《深入理解 Java 虚拟机》一书里面说的存放在方法区中应该是有问题的。\n\n**类（静态）变量存放在哪里**\n\n从 JDK 1.3 到 JDK 6 的 HotSpot VM，静态变量保存在类的元数据（InstanceKlass）的末尾（永久代）。而从 JDK 7 开始的 HotSpot VM，静态变量则是保存在类的 Java 镜像（java.lang.Class 实例）的末尾，也就是堆中\n\n参考 R 大 [知乎回答](https://www.zhihu.com/question/50258991) \n\n## Java 程序对类的使用方式\n\n所有的 java 虚拟机实现必须在每个类或接口被 java 程序**首次主动使用**时才**初始化**它们\n\n### 主动使用\n\n- 创建类的实例（new）\n- 对某个类或接口的静态变量进行读写（getstatic，putstatic）\n- 调用类的静态方法（invokestatic）\n- 反射某个类 （Class.forName() 也可以设置不初始化类）\n- 初始化子类时会先初始化父类\n- 启动类 java HelloWorld  包含 main 函数的类\n- Jdk1.7 的动态语言支持\n\n### 被动使用\n\n除了上面 7 个之外，其它的都是被动使用，**不会初始化类**，下面的 Demo 有几个很容易出错的的例子\n\n```java\npackage classloader_study.misc;\npublic class ClassActiveUse {\n    static {\n        System.out.println(\"main is init\");\n    }\n    public static void main(String[] args) throws ClassNotFoundException {\n        //System.out.println(Obj.t);\n        //Obj.getObj();\n        //Class.forName(\"classloader_study.Obj\");\n        //System.out.println(ObjChild.age);\n        \n        //父类会被初始化 通过子类调用父类的静态变量，子类不会初始化但是会被加载 \n        //1. System.out.println(ObjChild.n);\n        //不会初始化 定义应用数组也不会初始化类，但是会加载类\n        //2. Obj [] arrays=new Obj[10]; \n        //不会初始化 常量会在编译期间放到常量池中不会初始化类也不会加载，子类加载也一样\n        //3. System.out.println(Obj.t); \n        //Obj 会被初始化   final 修饰的复杂化类型再编译期间无法计算得到，会初始化类\n        //4. System.out.println(Obj.x); \n        // 类加载器去加载\n        //5. ClassLoader.loadClass();\n    }\n}\n\nclass Obj{\n\n    public static  final int t=10;  //编译期间就已经确定了就是 10\n\t\n    public static int n=111;\n    \n    public static final int x=new Random().nextInt(100); //值不是常量，运行期间才会确定\n    static { \n        System.out.println(\"Obj is init\");\n    }\n\n    public static void getObj(){\n        System.out.println(\"NULL\");\n    }\n}\n\nclass ObjChild extends Obj{\n    public static int age=12;\n\n    static {\n        System.out.println(\"Child is init\");\n    }\n}\ninterface I{\n    final static int a=0;\n}\n```\n\n⚡new 一个 Obj 数组的时候，**会加载** Obj 类，**不会初始化** Obj 对象，但是会导致另一个类的初始化：`Lclassloader_study.misc.Obj`  这个类就代表了一个元素类型为 Obj 的一维数组，数组中应有的属性 length 和方法 clone() 都是在这个类实现的，这个类是由 JVM 在运行期间动态的为我们生成的，这个动作由`anewarray` 指令触发，而基本类型的数组由 `newarray` 指令触发。\n\n⚡ final 修饰的常量会在**编译期间**就放到调用这个变量的方法的类的常量池中，既不会加载也不会初始化，这一点可以通过反编译`ClassActiveUse` 看的到，两个类不存在任何关系了，甚至可以在编译完成后`将 Obj 的 class 文件删掉`仍然可以执行，但是后面的另一个 final 常量很明显在**编译期间无法确定值**，只有在运行期间才能回去到值，所以会加载并初始化类\n\n⚡ 对接口的初始化和对类的初始化有一点不同，接口也有初始化过程，接口和类真正有区别是在上面主动使用的第 5 点，在**子接口被加载的时候并不要求其父接口全部完成了初始化**，只有在真正使用到父接口的时候才会初始化，这一点可以参考前文的 [类构造器部分](#③初始化：)\n\n> `-XX:+TraceClassLoading` 可以用来追踪类的加载信息并且打印出来\n\n###  对象的访问定位\n\n**如果直接使用句柄访问**，java 堆中将会划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址，而句柄中包含了对象数据与类型数据各自的具体地址信息，如下图所示。\n\n![mark](http://static.imlgw.top///20190418/FRA9GB31iiXH.png?imageslim)\n\n**如果使用直接指针访问**，那么 java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示，每个对象都有一个自己 Class 对象的引用 (`getClass`)\n\n![mark](http://static.imlgw.top///20190418/1OtoI6wkivdz.png?imageslim)\n\n这两种对象访问方式各有优势，使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。\n\n使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。HotSpot 虚拟机使用的是直接指针访问的方式。句柄来访问的情况也十分常见。\n\n## JVM 类加载器\n\n### 概述\n\n> 虚拟机设计团队把加载阶段中的 `“通过一个类的全限定名来获取描述此类的二进制字节流”` 这个动作被放到 Java 虚拟机外部去实现，以便于让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为 `“类加载器”`\n\n 类加载器并不需要等到某个类被 \"首次使用\" 时才加载它，这一点从前面讲解的 [被动使用的例子](#被动使用) 哪里就看得出来\n\nJVM 规范允许类加载器在预料某个类将要被使用的时候就预先加载它，如果在预先加载的过程中遇到了 class 文件缺失或者存在错误，类加载器必须在程序**首次主动使用**该类时才报告错误（LinkageError 错误）\n\n 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误\n\n![JVM 类加载器](http://static.imlgw.top///20190419/pKeI6Bx6lbcX.png?imageslim)\n\n**根（Bootstrap）类加载器**\n\n该加载器没有父加载器。它负责加载虚拟机的核心类库，如 java.lang. *等。根类加载器从系统属性 sun.boot.class.path 所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承 java.lang.ClassLoader 类 (c/c++实现的）。\n\n```java\nSystem.out.println(System.getProperty(\"sun.boot.class.path\"));\nD:\\java\\jre\\lib\\resources.jar;D:\\java\\jre\\lib\\rt.jar;D:\\java\\jre\\lib\\sunrsasign.jar;D:\\java\\jre\\lib\\jsse.jar;D:\\java\\jre\\lib\\jce.jar;D:\\java\\jre\\lib\\charsets.jar;D:\\java\\jre\\lib\\jfr.jar;D:\\java\\jre\\classes\n```\n\n**扩展（Extension）类加载器**\n\n它的父加载器为根类加载器。它从 java.ext.dirs 系统属性所指定的目录中加载类库，或者从 JDK 的安装目录的 jre.lib.ext 子目录（扩展目录）下加载类库，如果把用户创建的** JAR **文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯 Java 类，是 java.lang.ClassLoader 类的子类。\n\n```java\nSystem.out.println(System.getProperty(\"java.ext.dirs\")); //java.ext.dirs 属性\nD:\\java\\jre\\lib\\ext;C:\\WINDOWS\\Sun\\Java\\lib\\ext\n```\n\n**系统（System）类加载器**\n\n也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中加载类，它是用户自定义的类加载器的`默认父加载器`。系统类加载器是纯 Java 类，是 java.lang.ClassLoader 类的子类。\n\n```java\nSystem.out.println(System.getProperty(\"java.class.path\"));\nD:\\java\\jre\\lib\\charsets.jar;D:\\java\\jre\\lib\\deploy.jar;\nD:\\java\\jre\\lib\\ext\\access-bridge-64.jar;\nD:\\java\\jre\\lib\\ext\\cldrdata.jar;\nD:\\java\\jre\\lib\\ext\\dnsns.jar;\nD:\\java\\jre\\lib\\ext\\jaccess.jar;\nD:\\java\\jre\\lib\\ext\\jfxrt.jar;\nD:\\java\\jre\\lib\\ext\\localedata.jar;\nD:\\java\\jre\\lib\\ext\\nashorn.jar;\nD:\\java\\jre\\lib\\ext\\sunec.jar;\nD:\\java\\jre\\lib\\ext\\sunjce_provider.jar;\nD:\\java\\jre\\lib\\ext\\sunmscapi.jar;\nD:\\java\\jre\\lib\\ext\\sunpkcs11.jar;\nD:\\java\\jre\\lib\\ext\\zipfs.jar;\nD:\\java\\jre\\lib\\javaws.jar;\nD:\\java\\jre\\lib\\jce.jar;\nD:\\java\\jre\\lib\\jfr.jar;\nD:\\java\\jre\\lib\\jfxswt.jar;\nD:\\java\\jre\\lib\\jsse.jar;\nD:\\java\\jre\\lib\\management-agent.jar;\nD:\\java\\jre\\lib\\plugin.jar;\nD:\\java\\jre\\lib\\resources.jar;\nD:\\java\\jre\\lib\\rt.jar;\nC:\\WorkSpace\\concurrent_package\\out\\production\\concurrent_package;\nC:\\JetBrains\\IntelliJ IDEA 2018.1.4\\lib\\idea_rt.jar\n```\n\n> 其实所谓的父子加载器并不是继承的父子关系，而是包含的关系，子加载器中包含一个父加载器的引用\n\n### 自定义类加载器\n\n**先看下 JDK 的 ClassLoader(1.8) 源码**\n\n```java\n protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        //没有父加载器就交给根加载器\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    //需要子类去实现\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n\n这是 ClassLoader 类加载类的方法，可以看到中间有一段 \n\n```java\nif(parent!=null){  c = parent.loadClass(name, false);}\n```\n\n这就是**双亲委派机制**的实现，委托父类，让父类去加载，父类（根加载器）没有就会再层层下降如果有一个加载成功就会成功返回，除此之外还调用了一个没有实现的`findClass`\n\n```java\nprotected Class<?> findClass(String name) throws ClassNotFoundException {\n    throw new ClassNotFoundException(name);\n}\n```\n\n也就是说想自定义类加载器的话就得重写`findClass`方法，实际上这个`findClass`才是类加载的核心，真正加载 Class 文件转换为 CLass 实例的就是`findClass`方法， `loadClass()`只是实现加载的逻辑，比如**双亲委派机制**\n\n**实现一个简易的 ClassLoader**\n\n```java\npublic class MyClassLoader extends ClassLoader {\n    //将字节码放到这个路径下\n    private static final String DEFAULT_DIR = \"D:\\\\ClassLoaderTest\";\n\n    private String dir = DEFAULT_DIR;\n\n    private String classLoaderName;\n\n    public MyClassLoader() {\n        \n    }\n\n    public MyClassLoader(String classLoaderName) {\n        this.classLoaderName = classLoaderName;\n    }\n\n    public MyClassLoader(ClassLoader parent, String classLoaderName) {\n        super(parent);\n        this.classLoaderName = classLoaderName;\n    }\n\n    public String getDir() {\n        return dir;\n    }\n\n    public void setDir(String dir) {\n        this.dir = dir;\n    }\n\n    public String getClassLoaderName() {\n        return classLoaderName;\n    }\n\n    /**\n     * xx.xx.xx.xx.xx.AAA\n     * xx/xx/xx/xx/xx/.AAA.class\n     *\n     * @param name\n     * @return\n     * @throws ClassNotFoundException\n     */\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        String classPath = name.replace(\".\", \"/\");\n        File classFile = new File(dir, classPath + \".class\");\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(\"The class \" + name + \" not found under \" + dir);\n        }\n\t\t//字节码文件的字节流\n        byte[] classBytes = loadClassBytes(classFile);\n        if (null == classBytes || classBytes.length == 0)\n            throw new ClassNotFoundException(\"load the class \" + name + \" failed\");\n\t\t//defineClass 方法可以把二进制流字节组成的文件转换为一个 java.lang.Class\n        return this.defineClass(name, classBytes, 0, classBytes.length);\n    }\n\t\n    //将文件流转换为字节流\n    private byte[] loadClassBytes(File classFile) {\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n             FileInputStream fis = new FileInputStream(classFile)) {\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = fis.read(buffer)) != -1) {\n                baos.write(buffer, 0, len);\n            }\n            baos.flush();\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n```\n\n> defineClass 方法可以把二进制流字节组成的文件转换为一个 java.lang.Class，前提是 Class 文件是合法的。\n\n```java\n//自定义的需要加载的类\npublic class MyObject {\n    static {\n        System.out.println(\"MyObject static is init\");\n    }\n\n    public void Hello(){\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n**测试自定义的 ClassLoader**\n\n```java\npublic class ClassLoaderTest {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n        MyClassLoader loader=new MyClassLoader(\"Resolmi\");\n        //Class<?> aClass = loader.loadClass(\"classloader_study.myClassLoader.MyObject\");\n        Class<?> aClass = Class.forName(\"classloader_study.myClassLoader.MyObject\", true, loader);\n        System.out.println(aClass);\n        System.out.println(aClass.getClassLoader());\n\n        Object obj=aClass.newInstance();\n        Method hello = aClass.getMethod(\"Hello\", null);\n        hello.invoke(obj, new Object[]{});\n    }\n}\n```\n\n这里直接`loadClass`或者`Class.forName()`都可以，通常我们的 forName() 都是默认用的** AppClassLoader **也就是系统加载器，但是我们也可以把我们的自定义加载器传递进去。\n\n> tip: loadClass 不会初始化类，不属于上面提到的 6 种主动使用的方式，属于被动使用，Class.forName 第二个参数就是控制是否初始化\n\n```java\nMyObject static is init\nclass classloader_study.myClassLoader.MyObject\nclassloader_study.myClassLoader.MyClassLoader@74a14482\nHello World\n```\n\n如果使用了`ide`的话，这里很有可能编译器帮你自动编译了，也就是在你的 classpath 里面已经有字节码文件了，所以就直交给 AppClassLoader 加载了，所以需要将 classpath 里面的删掉，将字节码拷贝到你自定义的 classLoader 指定的目录里面。\n\n### 双亲委派模式\n\n即在类加载的时候，系统会判断当前类是否已经被加载，如果被加载，就会直接返回可用的类，否则就会尝试加载，在尝试加载时，会先请求双亲处理，如果双亲请求失败，则会自己加载\n\n这里光看几个内置的 ClassLoader 可能还不太清晰这里用我们自定义的 Loader 来试试\n\n```java\npublic class MyClassLoaderTest2 {\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n        //loader1 的加载目录是 D:\\\\ClassLoaderTest（默认的）\n        MyClassLoader loader1=new MyClassLoader(\"Resolmi-father\");\n        //设置 loader1 为 loader2 的父加载器\n        MyClassLoader loader2=new MyClassLoader(loader1,\"Resolmi2-son\");\n        //这个类存放在 D:\\\\ClassLoaderTest\\\\classloader_study\\\\myClassLoader 下面\n        Class<?> aClass = loader2.loadClass(\"classloader_study.myClassLoader.MyObject\");\n        //设置 Loader2 的加载目录，这是个空目录，下面什么都没有\n        loader2.setDir(\"D:\\\\ClassLoaderTest2\");\n        System.out.println(aClass);\n        System.out.println(aClass.getClassLoader());\n        System.out.println(((MyClassLoader)aClass.getClassLoader()).getClassLoaderName());\n     }\n}\n```\n\n控制台打印如下\n\n```java\nclass classloader_study.myClassLoader.MyObject\nclassloader_study.myClassLoader.MyClassLoader@74a14482\nResolmi-father\n```\n\n我们用`Loader2`去加载类，但是这个类的加载目录是空的，然后我们指定`Loader2` 的父加载器为`Loader1`而`loader1` 得加载路径就是要加载得类的路径，可以看到这个这个类最终还是被加载出来了，而且是被 `loader1`加载出来的，也就是`loader2`把加载任务委托给了父加载器`loader1`, 然后层层委托再回到`loader1`，由它加载。\n\n到这里可能会有疑问，为什么要用双亲委派模式？这样走一圈多慢啊，其实这样做主要有两个方面的原因\n\n💡 提高系统安全性，使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。对于一些系统核心类，用户自定义的不起作用了，因为都会交给`BootStrapLoader`去加载，比如自定义了一个 java.lang.String 的类，然后在加载的时候经过层层委派最后会交给 `BootStrapLoader`去加载然后返回，所以你自定义的 String 根本没有加载的机会，这样就避免了用户篡改 Java 核心的类\n\n💡 避免重复加载，父 Loader 已经加载过的类，子 Loader 就不用再加载了，比如`Object 类`这个类在`rt.jar`下，所以无论是在哪种环境下，最终都会交给`BootStrapClassLoader`去加载这个类，加载得到的都是同一个`Object 类`，如果不采用双亲委派机制，让各个 Loader 自己加载那么可能加载出来的就会有很多个 Object 类（不是同一个 Object 类，下面会说到）\n\n```java\nException in thread \"main\" java.lang.SecurityException: Prohibited package name: java.lang\n```\n\n### 加密解密类加载器\n\n本质上和上面的没什么区别，就是多了解密的功能，这里首先用加密工具类加密 class\n\n```java\npublic final class EncryptUtil {\n\t//相当于密钥\n    public static final byte ENCRYPT_FACTOR = (byte) 0xff;\n\n    private EncryptUtil() {\n\n    }\n\n    public static void encrypt(String source, String target) throws FileNotFoundException {\n        try (FileInputStream in= new FileInputStream(source); FileOutputStream out = new FileOutputStream(target)) {\n            int data;\n            while ((data=in.read())!=-1){\n                out.write(data^ENCRYPT_FACTOR);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n        encrypt(\"D:\\\\ClassLoaderTest\\\\classloader_study\\\\myClassLoader\\\\MyObject.class\",\"D:\\\\ClassLoaderTest\\\\classloader_study\\\\myClassLoader\\\\MyObject2.class\");\n    }\n}\n```\n\n然后用加密解密类加载器加载这个类\n\n```java\npublic class DecryptClassLoader extends ClassLoader {\n\n    private final String DEFAULT_DIR = \"D:\\\\ClassLoaderTest\";\n\n    private String dir = DEFAULT_DIR;\n\n    public DecryptClassLoader() {\n        super();\n    }\n\n    public DecryptClassLoader(ClassLoader parent) {\n        super(parent);\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        String classPath = name.replace(\".\", \"/\");\n        File classFile = new File(dir, classPath + \".class\");\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(\"没找到对应的类文件 ：\" + dir);\n        }\n        byte[] classBytes = loadClassByte(classFile);\n        if (null == classBytes || classBytes.length == 0) {\n            throw new ClassNotFoundException(\"加载失败\");\n        }\n        return this.defineClass(name, classBytes, 0, classBytes.length);\n    }\n\n    private byte[] loadClassByte(File classFile) {\n        try (FileInputStream in = new FileInputStream(classFile); ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n            int data;\n            while ((data=in.read())!=-1){\n                //主要就是这里发生了变化，异或了 0xff\n                baos.write(data^0xff);\n            }\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void setDir(String dir) {\n        this.dir = dir;\n    }\n}\n```\n\n当然结果是加载成功啦😋，这里如果用其他的类加载器加载，或者把 0xff 那里去掉，就会报如下错误\n\n```java\nException in thread \"main\" java.lang.ClassFormatError: Incompatible magic value 889275713 in class file classloader_study/myClassLoader/MyObject\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:642)\n\tat classloader_study.myClassLoader.MyClassLoader.findClass(MyClassLoader.java:64)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat classloader_study.encryption_study.ClassLoaderTest.main(ClassLoaderTest.java:15)\n```\n\n这个异常是链接阶段验证的错误，是上面提到的`defineClass()`抛出来的，因为你加了密，JVM 在加载这个二进制流的时候就无法识别了自然就无法加载。\n\n### 打破双亲委派机制\n\n**覆盖 loadClass()**\n\n要打破双亲委派机制主要就是要覆盖`loadClass()`方法，自己定义加载类的方式。\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException {\n    Class<?> clazz = null;\n\n    //让父加载器加载 java 核心的包，因为有些类是继承的 Java 内部的核心类比如 Object 类\n    if (name.startsWith(\"java.\")) {\n        try {\n            ClassLoader system = ClassLoader.getSystemClassLoader();\n            //这里仍然是委托上级\n            clazz = system.loadClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return clazz;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    try {\n        //自己先找\n        clazz = findClass(name);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\t//找不到就交给父加载器\n    if (clazz == null && getParent() != null) {\n        getParent().loadClass(name);\n    }\n\n    return clazz;\n}\n```\n\n其实就是自己先找，找不到才会交给父加载器，然后一个需要注意的就是你想加载的这个类可能继承了 Java 内部核心的类像`Object`类，然后要加载子类就要先加载它的父类，而你的这个包里面肯定是加载不到这些 Java 内部的核心类的，所以这些还是得交给上层的加载器去加载。\n\n**测试效果**\n\n```java\npublic class SimpleClassLoaderTest {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        SimpleClassLoader simpleClassLoader = new SimpleClassLoader();\n        Class<?> aClass = simpleClassLoader.loadClass(\"classloader_study.break_parent.SimpleObject\");\n        System.out.println(aClass.getClassLoader());\n    }\n}\n```\n\n注意这里在`classpath`里面是有这个类的字节码文件的，按照双亲委托机制应该由 AppClassLoader 去加载\n\n![mark](http://static.imlgw.top///20190420/5Nc0S6OoIa2D.png?imageslim)\n\n但是仍然是由我们的 SimpleClassLoader 加载的，说明我们成功了打破了双亲委派机制（貌似 Tomcat 也是这种加载机制，有时间看看 Tomcat 的类加载器）\n\n**面试题**\n\n❓ **能不能自己写个类比如`java.lang.String`去覆盖 Java 的`String`？如果不覆盖`loadClass()`方法使用双亲委托肯定是不行，但是既然上面已经打破了双亲委托那是不是就可以了呢？**\n\n`Talk is cheap，show me the code` 试试就知道了\n\n先准备一个 String 类\n\n```java\npackage java.lang;\n/**\n * @author imlgw.top\n * @date 2019/4/18 12:01\n */\npublic class String {\n    static {\n        System.out.println(\"i am init\");\n    }\n    public int getVal(){\n        return  250;\n    }\n}\n```\n\n编译好之后放到我们自定义的`ClassLoader`的目录下，然后将我们`loadClass()`方法加载核心包的地方注释掉（不然还是会交给父加载器去加载）然后为了表示是我们自定义的`ClassLoader`加载的我们把 classpath 里面的字节码文件也删掉。\n\n```java\n public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        SimpleClassLoader simpleClassLoader = new SimpleClassLoader();\n        Class<?> aClass = simpleClassLoader.loadClass(\"java.lang.String\");\n        System.out.println(aClass.getClassLoader());\n    }\n```\n\n然后就会看到如下的`SecurityException`\n\n```java\njava.lang.SecurityException: Prohibited package name: java.lang\n\tat java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:761)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:642)\n\tat classloader_study.break_parent.SimpleClassLoader.findClass(SimpleClassLoader.java:52)\n\tat classloader_study.break_parent.SimpleClassLoader.loadClass(SimpleClassLoader.java:77)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:7)\n```\n\n其实 Java 为了安全，自定义类取名不能取`java.*`等核心包名开头，在`preDefineClass`里面做了检查，所以即使你打破了双亲委托机制你依然不能去覆盖 Java 的核心类（肯定不行啊😄）。\n\n其实这里后来了解了`Unsafe`后也尝试用`Unsafe` 去加载这个类\n\n```java\nprotected Class<?> findClass(String name) throws ClassNotFoundException {\n        Unsafe unsafe=UnsafeTest.getUnsafe();\n        String classPath = name.replace(\".\", \"/\");\n        File classFile = new File(dir, classPath + \".class\");\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(\"The class \" + name + \" found under \" + dir);\n        }\n\n        byte[] classBytes = loadClassBytes(classFile);\n        if (null == classBytes || classBytes.length == 0)\n            throw new ClassNotFoundException(\"load the class \" + name + \" failed\");\n\n        return unsafe.defineClass(null,classBytes,0,classBytes.length,SimpleClassLoader.this,null);\n}\n```\n\n`loadClass` 同上，尝试加载你会发现 会提示找不到`Object` 类，嗯？已经在加载父类了，难不成还真可以？这里其实已经和上面的方法不同了，上面的方法是不会进入到加载父类的环节的，直接在加载前就被检测了包名然后 GG 了，随后我在`loadClass` 中让系统加载器去加载 Object 类，再次尝试加载\n\n```java\njava.lang.SecurityException: Prohibited package name: java.lang\n\tat sun.misc.Unsafe.defineClass(Native Method)\n\tat classloader_study.break_parent.SimpleClassLoader.findClass(SimpleClassLoader.java:57)\n\tat classloader_study.break_parent.SimpleClassLoader.loadClass(SimpleClassLoader.java:83)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:7)\nException in thread \"main\" java.lang.NullPointerException\n\tat classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:8)\n```\n\n还是熟悉的味道😂 `defineClass`虚拟机本地方法抛了异常\n\n### 类加载器细节深入\n\n**定义加载器&初始加载器**\n\n⚡真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正`完成类的加载`工作是通过调用 `defineClass(findClass)`来实现的；而`启动`类的加载过程是通过调用 `loadClass`来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：**一个类的定义加载器是它引用的其它类的初始加载器**。如类 `com.example.Outer`引用了类 `com.example.Inner`，则由类 `com.example.Outer`的**定义加载器**负责启动类 `com.example.Inner`的加载过程。\n\n**命名空间&运行时包**\n\n> 每个类都有自己的命名空间，命名空间由`该加载器及所有父加载器所加载的类`组成，`子加载器的命名空间包含所有父加载器的命名空间`，因此子加载器可以加载的类可以看就按父加载器加载的类，例如系统类加载器可以看见根加载器加载的类。由父加载器加载的类看不见子加载器加载的类，如果两个类之间没有直接或者间接的父子关系，那么他们各自加载的类相互不可见\n\n⚡数组类的 Class 不是由类加载器加载的，是由 JVM 在运行期间动态生成的，但是通过`getClassLoader`返回的类加载器和数组的元素的类加载器是一样的，原生的类型比如`int` 之类的没有类加载器返回的是 null\n\n⚡每个类加载器都有其自己的命名空间，命名空间由该加载器和其所有父类加载器所加载的类组成，同一份字节码两个不同的类加载器加载出来的不是同一个类。\n\n```java\npublic class MyClassLoaderTest2 {\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n        //注意这里的 ClassLoader 要么利用前面的打破了双亲委托机制的，要么把 classpath 里面字节码的删掉。\n        MyClassLoader loader1=new MyClassLoader(\"Resolmi1\");\n        MyClassLoader loader2=new MyClassLoader(\"Resolmi2\");\n        Class<?> aClass2 = loader2.loadClass(\"classloader_study.myClassLoader.MyObject\");\n        Class<?> aClass1 = loader1.loadClass(\"classloader_study.myClassLoader.MyObject\");\n        //两个不同的加载器（没有父子关系）加载同一个类加载出来的不是同一个\n        System.out.println(aClass1.hashCode()); //2133927002\n        System.out.println(aClass2.hashCode()); //1836019240\n     }\n}\n```\n\n⚡**父类加载器**无法访问**子类加载器**加载的类，而**子加载器**可以访问到**父加载器**所加载的类\n\n```java\npublic class ClassLoaderTest {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n        //使用上面自定义的 ClassLoader\n        MyClassLoader loader=new MyClassLoader(\"Resolmi\");\n        Class<?> aClass = loader.loadClass(\"classloader_study.myClassLoader.Parent\");\n        //创建实例\n        aClass.newInstance();\n    }\n}\n```\n\n**Parent 类**\n\n```java\npublic class Parent {\n    public Parent() {\n        System.out.println(\"Parent is load by\" + this.getClass().getClassLoader());\n        Hello();\n    }\n\n    public void Hello() {\n        //父加载器访问子加载器加载的类\n        System.out.println(\"Parent can see the \" + Sub.class);\n    }\n}\n```\n\n**Sub 类**\n\n```java\npublic class Sub {\n    public Sub(){\n        System.out.println(\"Sub is load by\"+this.getClass().getClassLoader());\n        new Parent(); //构造 Parent 类\n    }\n}\n```\n\n做完了这些工作之后，编译代码，然后将 classpath 中的`Parent.class`拷贝到自定义的 ClassLoader 路径下面，然后删掉 classpath 中的`Parent.class` ，然后运行\n\n```java\nSub is load byclassloader_study.myClassLoader.MyClassLoader@74a14482\nParent is load bysun.misc.Launcher$AppClassLoader@18b4aac2\nException in thread \"main\" java.lang.NoClassDefFoundError: classloader_study/myClassLoader/Sub\n\tat classloader_study.myClassLoader.Parent.Hello(Parent.java:15)\n\tat classloader_study.myClassLoader.Parent.<init>(Parent.java:10)\n\tat classloader_study.myClassLoader.Sub.<init>(Sub.java:10)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat classloader_study.myClassLoader.ClassLoaderTest.main(ClassLoaderTest.java:14)\nCaused by: java.lang.ClassNotFoundException: classloader_study.myClassLoader.Sub\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 9 more\n```\n\n可以看到，我们的`Sub` 是由我们自定义的`MyClassLoader` 加载的，因为我们删掉了 Classpath 中的字节码，而在自定义的路径中有所以最后还是由我们的 `MyClassLoader` 加载了，所以我们的`Parent`类首先也会由我们的`自定义类加载器 MyClassLoader`去作为**初始加载器**加载，由于我们的 Classpath 中还有字节码文件，所以在双亲委派机制下`Sub 类` 最终由`AppClassLoader`加载 ，两个类由不同的类加载器加载，然后我们在`Parent` 类中试图访问`Sub` 类，结果抛出了`ClassNotFoundException`  和`NoClassDefFoundError` 异常\n\n❓ **那我们反过来在`Sub`类中访问 `Parent` 类会发生什么，改造一下 Parent 和 Sub**\n\n**Parent 类**\n\n```java\npublic class Parent {\n    public Parent() {\n        System.out.println(\"Parent is load by\" + this.getClass().getClassLoader());\n        //Hello();\n    }\n\n    public void Hello() {\n        //父加载器访问子加载器加载的类\n        System.out.println(\"Parent can see the \" + Sub.class);\n    }\n}\n```\n\n**Sub 类**\n\n```java\npublic class Sub {\n    public Sub(){\n        System.out.println(\"Sub is load by\"+this.getClass().getClassLoader());\n        new Parent(); //构造 Sub 类\n        //访问父加载器加载的类\n        System.out.println(\"Sub can see \"+Parent.class);\n    }\n}\n```\n\n和上面一样删掉 Classpath 中 Sub 类的 class 文件没然后运行\n\n```java\nfindclass is invoke MyClassLoader is loadclassloader_study.myClassLoader.Sub\nSub is load byclassloader_study.myClassLoader.MyClassLoader@74a14482\nParent is load bysun.misc.Launcher$AppClassLoader@18b4aac2\nSub can see class classloader_study.myClassLoader.Parent\n\nProcess finished with exit code 0\n```\n\n没有任何问题，由此就可以证明我们上面的结论是正确的。\n\n❓ **面试题：如何让一个类的 static 代码块执行两次**\n\n用不同的类加载器去加载这个类，至于为什么应该不用我多说了吧。\n\n**类的卸载和 ClassLoader 的卸载**\n\n>  由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中**始终不会被卸载**，Java 虚拟机本身会引用这些类加载器，而这些类加载器则会始终引用他们所加载的类的 Class 对象，因此这些 Class 对象始终是可达的。\n\n⚡JVM 中的 Class 只有满足以下三个条件，才能被 GC 回收，也就是该 Class 被卸载（unload）\n\n- 该类所有的实例都已经被 GC。\n- 加载该类的 ClassLoader 实例已经被 GC。(Class 对象里面有对 ClassLoader 的引用）\n- 该类的 java.lang.Class 对象没有在任何地方被引用。\n\nGC 的时机我们是不可控的，那么同样的我们对于 Class 的卸载也是不可控的，使用`-XX:+TraceClassUnloading` 或者 jvisualvm 可以看到类的卸载\n\n## 线程上下文加载器 (**TCCL**)\n\n​\t在说 TCCL 之前不得不说一下另一个话题，SPI（Service Provider Interface，SPI）服务提供接口，由第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 **Java 核心库**来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进**类路径**（classpath）里。SPI 接口中的代码经常需要加载具体的实现类。\n\n> 为什么要使用 SPI?  SPI 是 JDK 内置的一种**服务提供发现机制**。这样做的好处主要是为了解耦，实现动态替换，减少硬编码（比如 jdk1.6 之前的 Class.forName(\"XXXX\") ）面向接口编程，在很多开源框架中都有体现，比如 Dubbo，Spring 等\n\n那么问题来了，`SPI 的接口`是 Java 核心库的一部分位于`rt.jar`中，是由**根加载器** (Bootstrap Classloader) 来加载的，而`SPI 的实现类`是一般是第三方的提供的，位于`classpath`目录中，而**根加载器**很明显是无法直接加载到这个目录下的 SPI 的实现类的 （双亲委派），那`SPI`是如何自动加载到实现类的呢？\n\n为了解决这个问题，虚拟机提供了**线程上下文加载器（TCCL）**配合`ServiceLoader`来帮助上层加载器加载类，`TCCL`破坏了“双亲委派模型”，可以在执行过程中切换为`TCCL` 来加载第三方的 SPI 实现类，抛弃双亲委派机制，使程序可以逆向使用类加载器。**TCCL **默认是系统类加载器，也可以通过`setContextClassLoader`去设置\n\n### JDBC 源码案例分析\n\n翻到了最开始学 JDBC 的时候写的代码😄\n\n![JDBC](http://static.imlgw.top///20190420/K4uQf6h5czDb.png?imageslim)\n\n**贾琏欲执事**，可以看到第一步还是加载并且初始化驱动，前面已经提到这一步其实没有必要了，jdk1.6 之后因为 ServiceLoader，SPI 机制的出现，就不用再显示的加载驱动，但是正如上面所说`Driver`只是个接口存放于`rt.jar` 中，由根加载器所加载，那 SPI 是怎么自动的加载到`mysql`的`Driver`实例的呢？😕\n\n我们一步步的来看，首先`DriverManager.getConnection()`这里，`getConnection`是个静态方法，调用它就会先执行`DriverManager`类的静态代码块，而静态代码块里面主要执行的就是`loadInitialDrivers()`\n\n### loadInitialDrivers() 源码\n\n```java\nprivate static void loadInitialDrivers() {\n    String drivers;\n    try {\n        drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            public String run() {\n                return System.getProperty(\"jdbc.drivers\");\n            }\n        });\n    } catch (Exception ex) {\n        drivers = null;\n    }\n    // If the driver is packaged as a Service Provider, load it.\n    // Get all the drivers through the classloader\n    // exposed as a java.sql.Driver.class service.\n    // ServiceLoader.load() replaces the sun.misc.Providers()\n\t// 如果驱动正确打包为 jar 就会用 ServiceLoader 去加载它\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n            /****************************************************/\n\t\t\t/*ServiceLoad 工具类，注意这个 ServiceLoad 的加载器，默认就是 TCCL*/\n            ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n            /****************************************************/\n            /*在这里会获取到一个 Drivers 的迭代器，但是其实还没有开始加载类*/\n            Iterator<Driver> driversIterator = loadedDrivers.iterator();\n\n            /* Load these drivers, so that they can be instantiated.\n             * It may be the case that the driver class may not be there\n             * i.e. there may be a packaged driver with the service class\n             * as implementation of java.sql.Driver but the actual class\n             * may be missing. In that case a java.util.ServiceConfigurationError\n             * will be thrown at runtime by the VM trying to locate\n             * and load the service.\n             *\n             * Adding a try catch block to catch those runtime errors\n             * if driver not available in classpath but it's\n             * packaged as service and that service is there in classpath.\n             */\n            try{\n                while(driversIterator.hasNext()) {\n                    //迭代的过程中通过 next 反射加载并初始化这个驱动字节码\n                    //没有接收返回的数据库驱动实例\n                    driversIterator.next();\n                }\n            } catch(Throwable t) {\n            // Do nothing\n            }\n            return null;\n        }\n    });\n\n    println(\"DriverManager.initialize: jdbc.drivers = \" + drivers);\n\t//加载 Jdk 中的驱动实例（虽然我并不知道是什么）总之我们第三方的驱动已经加载好了\n    if (drivers == null || drivers.equals(\"\")) {\n        return;\n    }\n    String[] driversList = drivers.split(\":\");\n    println(\"number of Drivers:\" + driversList.length);\n    for (String aDriver : driversList) {\n        try {\n            println(\"DriverManager.Initialize: loading \" + aDriver);\n            Class.forName(aDriver, true,\n                    ClassLoader.getSystemClassLoader());\n        } catch (Exception ex) {\n            println(\"DriverManager.Initialize: load failed: \" + ex);\n        }\n    }\n}\n```\n\n可以看到中间有一行很关键的代码\n\n `ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);`\n\n这就是我上面所提到的 `ServiceLoader` \n\n> 对于 SPI 机制，JDK 提供了`java.util.ServiceLoader`工具类，在使用某个服务接口时，它可以帮助我们查找该服务接口的实现类，加载和初始化，前提条件是基于它的约定：当服务的提供者提供了服务接口的一种实现之后，在`jar`包的`META-INF/services/`目录里同时创建一个以`服务接口命名的文件`。该文件里就是实现该服务接口的具体实现类（去解压看看那些 jar 包就可以看见这些信息 o(*￣▽￣*) ブ）\n\n### ServiceLoader 类源码\n\n为了节约篇幅删掉了一些注释，发现其实整个类也没多少行大概 2，3 百行的样子，需要注意这个类并不是线程安全的，所以使用的时候需要注意\n\n```java\npublic final class ServiceLoader<S> implements Iterable<S> {\n\t//目录前缀就是从这里来的\n    private static final String PREFIX = \"META-INF/services/\";\n\n    //实现类 Service\n    private final Class<S> service;\n\n    // The class loader used to locate, load, and instantiate providers\n    private final ClassLoader loader;\n\n    // The access control context taken when the ServiceLoader is created\n    private final AccessControlContext acc;\n\n    // Cached providers, in instantiation order\n    // 按照实例的顺序，来缓存服务提供者避免重复的加载，具体可以看下面的 iterator 方法\n    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();\n\n    // The current lazy-lookup iterator\n    private LazyIterator lookupIterator;\n\n    public void reload() {\n        providers.clear();\n        //初始化懒加载迭代器\n        lookupIterator = new LazyIterator(service, loader);\n    }\n\t\n    //构造器\n    private ServiceLoader(Class<S> svc, ClassLoader cl) {\n        service = Objects.requireNonNull(svc, \"Service interface cannot be null\");\n        loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;\n        acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;\n        reload();\n    }\n\n    private static void fail(Class<?> service, String msg, Throwable cause)\n        throws ServiceConfigurationError\n    {\n        throw new ServiceConfigurationError(service.getName() + \": \" + msg,\n                                            cause);\n    }\n\n    private static void fail(Class<?> service, String msg)\n        throws ServiceConfigurationError\n    {\n        throw new ServiceConfigurationError(service.getName() + \": \" + msg);\n    }\n\n    private static void fail(Class<?> service, URL u, int line, String msg)\n        throws ServiceConfigurationError\n    {\n        fail(service, u + \":\" + line + \": \" + msg);\n    }\n\n    // Parse a single line from the given configuration file, adding the name\n    // on the line to the names list.\n    //\n    private int parseLine(Class<?> service, URL u, BufferedReader r, int lc,\n                          List<String> names)\n        throws IOException, ServiceConfigurationError\n    {\n        String ln = r.readLine();\n        if (ln == null) {\n            return -1;\n        }\n        int ci = ln.indexOf('#');\n        if (ci >= 0) ln = ln.substring(0, ci);\n        ln = ln.trim();\n        int n = ln.length();\n        if (n != 0) {\n            if ((ln.indexOf(' ') >= 0) || (ln.indexOf('\\t') >= 0))\n                fail(service, u, lc, \"Illegal configuration-file syntax\");\n            int cp = ln.codePointAt(0);\n            if (!Character.isJavaIdentifierStart(cp))\n                fail(service, u, lc, \"Illegal provider-class name: \" + ln);\n            for (int i = Character.charCount(cp); i < n; i += Character.charCount(cp)) {\n                cp = ln.codePointAt(i);\n                if (!Character.isJavaIdentifierPart(cp) && (cp != '.'))\n                    fail(service, u, lc, \"Illegal provider-class name: \" + ln);\n            }\n            if (!providers.containsKey(ln) && !names.contains(ln))\n                names.add(ln);\n        }\n        return lc + 1;\n    }\n\n    private Iterator<String> parse(Class<?> service, URL u)\n        throws ServiceConfigurationError\n    {\n        InputStream in = null;\n        BufferedReader r = null;\n        ArrayList<String> names = new ArrayList<>();\n        try {\n            in = u.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n            int lc = 1;\n            while ((lc = parseLine(service, u, r, lc, names)) >= 0);\n        } catch (IOException x) {\n            fail(service, \"Error reading configuration file\", x);\n        } finally {\n            try {\n                if (r != null) r.close();\n                if (in != null) in.close();\n            } catch (IOException y) {\n                fail(service, \"Error closing configuration file\", y);\n            }\n        }\n        return names.iterator();\n    }\n\n    // Private inner class implementing fully-lazy provider lookup\n    // 看名字就知道了，懒迭代器，在迭代的时候才真正的加载\n    private class LazyIterator\n        implements Iterator<S>\n    {\n\n        Class<S> service;\n        ClassLoader loader;\n        Enumeration<URL> configs = null;\n        Iterator<String> pending = null;\n        String nextName = null;\n\n        private LazyIterator(Class<S> service, ClassLoader loader) {\n            this.service = service;\n            this.loader = loader;\n        }\n\n        private boolean hasNextService() {\n            if (nextName != null) {\n                return true;\n            }\n            if (configs == null) {\n                try {\n                    String fullName = PREFIX + service.getName();\n                    if (loader == null)\n                        configs = ClassLoader.getSystemResources(fullName);\n                    else\n                        configs = loader.getResources(fullName);\n                } catch (IOException x) {\n                    fail(service, \"Error locating configuration files\", x);\n                }\n            }\n            while ((pending == null) || !pending.hasNext()) {\n                if (!configs.hasMoreElements()) {\n                    return false;\n                }\n                pending = parse(service, configs.nextElement());\n            }\n            nextName = pending.next();\n            return true;\n        }\n        \n\t\t//迭代器的 next\n        private S nextService() {\n            if (!hasNextService())\n                throw new NoSuchElementException();\n            String cn = nextName;\n            nextName = null;\n            Class<?> c = null;\n            try {\n                //利用 TCCL 加载实现类，但是不初始化\n                c = Class.forName(cn, false, loader);\n            } catch (ClassNotFoundException x) {\n                fail(service,\n                     \"Provider \" + cn + \" not found\");\n            }\n            if (!service.isAssignableFrom(c)) {\n                fail(service,\n                     \"Provider \" + cn  + \" not a subtype\");\n            }\n            try {\n                //newInstance() 初始化了对应的实现类\n                S p = service.cast(c.newInstance());\n                //放到 providers 中\n                providers.put(cn, p);\n                return p;\n            } catch (Throwable x) {\n                fail(service,\n                     \"Provider \" + cn + \" could not be instantiated\",\n                     x);\n            }\n            throw new Error();          // This cannot happen\n        }\n\n        public boolean hasNext() {\n            if (acc == null) {\n                return hasNextService();\n            } else {\n                PrivilegedAction<Boolean> action = new PrivilegedAction<Boolean>() {\n                    public Boolean run() { return hasNextService(); }\n                };\n                return AccessController.doPrivileged(action, acc);\n            }\n        }\n\n        public S next() {\n            if (acc == null) {\n                return nextService();\n            } else {\n                PrivilegedAction<S> action = new PrivilegedAction<S>() {\n                    public S run() { return nextService(); }\n                };\n                return AccessController.doPrivileged(action, acc);\n            }\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    /**\n     * Lazily loads the available providers of this loader's service.\n     * @return  An iterator that lazily loads providers for this loader's\n     *          service\n     */\n    public Iterator<S> iterator() {\n        return new Iterator<S>() {\n\n            Iterator<Map.Entry<String,S>> knownProviders\n                = providers.entrySet().iterator();\n\n            public boolean hasNext() {\n                if (knownProviders.hasNext())\n                    return true;\n                return lookupIterator.hasNext();\n            }\n\n            public S next() {\n                if (knownProviders.hasNext())\n                    return knownProviders.next().getValue();\n                return lookupIterator.next();\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n\n        };\n    }\n\n    /* 重载的 ServiceLoad */\n    public static <S> ServiceLoader<S> load(Class<S> service,\n                                            ClassLoader loader)\n    {\n        return new ServiceLoader<>(service, loader);\n    }\n\n\t//DriverManage 里面就是调用的这个方法\n    public static <S> ServiceLoader<S> load(Class<S> service) {\n        //拿到了 TCCL\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        //调用上面重载的 ServiceLoad 方法\n        return ServiceLoader.load(service, cl);\n    }\n\n    public static <S> ServiceLoader<S> loadInstalled(Class<S> service) {\n        ClassLoader cl = ClassLoader.getSystemClassLoader();\n        ClassLoader prev = null;\n        while (cl != null) {\n            prev = cl;\n            cl = cl.getParent();\n        }\n        return ServiceLoader.load(service, prev);\n    }\n\n    public String toString() {\n        return \"java.util.ServiceLoader[\" + service.getName() + \"]\";\n    }\n\n}\n```\n\n> 首先我们要明白一点，`Driver 接口`，`DriverManage 类`，以及`ServiceLoader`都是由**根加载器**去加载的（如果不相信的话可以用 TraceClassLoading 去查看），所以在`ServiceLoader`中也是无法直接加载具体得实现类的\n\n前面`loadInitialDriver()`调用的就是这里的`ServiceLoader.load(Class< S> service)` 方法，这个方法中悄悄的拿到了`TCCL` ，而 TCCL 在`Launcher` 类（系统加载器和扩展加载器都是在 Launcher 中实现的）中默认设置成了系统加载器，具体可以去看一下源码这里我就不展开了，然后调用另一个重载的构造方法将`TCCL` 传递进去，最终调用了 `reload()`方法\n\n```java\npublic void reload() {\n    providers.clear();\n    //初始化懒加载迭代器\n    lookupIterator = new LazyIterator(service, loader);\n}\n```\n\n 在这个方法中首先清空服务提供者 (providers) 缓存，然后初始化了一个`LazyIterator` 看名字就知道是啥意思了，其实到这里仍然没有任何具体的加载动作，因为这里采用的是按需加载，也就是懒加载，在迭代的时候才会去加载类\n\n```java\nprivate class LazyIterator implements Iterator<S>{\n\tClass<S> service;\n    ClassLoader loader;\n    Enumeration<URL> configs = null;\n    Iterator<String> pending = null;\n    String nextName = null;\n\n    private LazyIterator(Class<S> service, ClassLoader loader) {\n        this.service = service;\n        this.loader = loader;\n    }\n\n    private boolean hasNextService() {\n        if (nextName != null) {\n            return true;\n        }\n        if (configs == null) {\n            try {\n                //拿到接口全名\n                String fullName = PREFIX + service.getName();\n                if (loader == null)\n                    configs = ClassLoader.getSystemResources(fullName);\n                else\n                    configs = loader.getResources(fullName);\n            } catch (IOException x) {\n                fail(service, \"Error locating configuration files\", x);\n            }\n        }\n        while ((pending == null) || !pending.hasNext()) {\n            if (!configs.hasMoreElements()) {\n                return false;\n            }\n            //解析\n            pending = parse(service, configs.nextElement());\n        }\n        nextName = pending.next();\n        return true;\n    }\n    \n\t//迭代器的 next\n    private S nextService() {\n        if (!hasNextService())\n            throw new NoSuchElementException();\n        String cn = nextName;\n        nextName = null;\n        Class<?> c = null;\n        try {\n            //具体加载类的地方就是在这里\n            //利用前面传进来的 TCCL 加载实现类，但是不初始化类\n            c = Class.forName(cn, false, loader);\n        } catch (ClassNotFoundException x) {\n            fail(service,\n                 \"Provider \" + cn + \" not found\");\n        }\n        if (!service.isAssignableFrom(c)) {\n            fail(service,\n                 \"Provider \" + cn  + \" not a subtype\");\n        }\n        try {\n            //newInstance() 实例化对应的实现类\n            S p = service.cast(c.newInstance());\n            //put 到 providers 中\n            providers.put(cn, p);\n            return p;\n        } catch (Throwable x) {\n            fail(service,\n                 \"Provider \" + cn + \" could not be instantiated\",\n                 x);\n        }\n        throw new Error();          // This cannot happen\n    }\n\n    public boolean hasNext() {\n        if (acc == null) {\n            return hasNextService();\n        } else {\n            PrivilegedAction<Boolean> action = new PrivilegedAction<Boolean>() {\n                public Boolean run() { return hasNextService(); }\n            };\n            return AccessController.doPrivileged(action, acc);\n        }\n    }\n\n    public S next() {\n        if (acc == null) {\n            return nextService();\n        } else {\n            PrivilegedAction<S> action = new PrivilegedAction<S>() {\n                public S run() { return nextService(); }\n            };\n            return AccessController.doPrivileged(action, acc);\n        }\n    }\n\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n}\n```\n🔸 可以看到在迭代器的`nextService()` 中才开始利用的`Class.forName()` 加载的具体实现类，而这个加载器正器正是前面`reload`传递过来的 `TCCL` 也就是默认的系统类加载器\n\n🔸 随后在紧跟的 try 语句中通过 `newInstance()` 实例化了具体的实现类 (MySql 的驱动） ，然后 put 进 providers 队列并且返回实例化的实现类，但是在`loadInitialDrivers`中并没有接收这个返回，那他这里实例化是什么用意呢？\n\n我们回到`getConnection()` 方法\n\n### getConnection() 源码\n\n前面的静态方法调用完毕驱动已经加载，下面就是获取数据库连接了。\n\n```java\npublic static Connection getConnection(String url,\n    String user, String password) throws SQLException {\n    java.util.Properties info = new java.util.Properties();\n\n    if (user != null) {\n        info.put(\"user\", user);\n    }\n    if (password != null) {\n        info.put(\"password\", password);\n    }\n\t// Reflection.getCallerClass() 调用者的 Class 对象\n    return (getConnection(url, info, Reflection.getCallerClass()));\n}\n```\n\n一般获取连接都是调用的上面这个方法，这个方法最终会调用另一个重载的方法，同时传入一个调用者的 Class 对象\n\n```java\nprivate static Connection getConnection(\n    String url, java.util.Properties info, Class<?> caller) throws SQLException {\n    /*\n     * When callerCl is null, we should check the application's\n     * (which is invoking this class indirectly)\n     * classloader, so that the JDBC driver class outside rt.jar\n     * can be loaded from here.\n     */\n    //Caller 就是调用者的 CLass 也就是我们的应用代码类\n    //获取到我们应用类的类加载器\n    ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;\n    synchronized(DriverManager.class) {\n        // synchronize loading of the correct classloader.\n        if (callerCL == null) {\n            //如果为空就，获取线程线下文加载器\n            callerCL = Thread.currentThread().getContextClassLoader();\n        }\n    }\n\n    if(url == null) {\n        throw new SQLException(\"The url cannot be null\", \"08001\");\n    }\n\n    println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\");\n\n    // Walk through the loaded registeredDrivers attempting to make a connection.\n    // Remember the first exception that gets raised so we can reraise it.\n    SQLException reason = null;\n\t\n    //遍历这个 registeredDrivers 里面都是 DriverInfo\n    for(DriverInfo aDriver : registeredDrivers) {\n        // If the caller does not have permission to load the driver then\n        // skip it.\n        //检查加载驱动的加载器是不是调用者的类加载器\n        if(isDriverAllowed(aDriver.driver, callerCL)) {\n            try {\n                println(\"    trying \" + aDriver.driver.getClass().getName());\n                //获取连接\n                Connection con = aDriver.driver.connect(url, info);\n                if (con != null) {\n                    // Success!\n                    println(\"getConnection returning \" + aDriver.driver.getClass().getName());\n                    return (con);\n                }\n            } catch (SQLException ex) {\n                if (reason == null) {\n                    reason = ex;\n                }\n            }\n\n        } else {\n            println(\"    skipping: \" + aDriver.getClass().getName());\n        }\n\n    }\n\n    // if we got here nobody could connect.\n    if (reason != null)    {\n        println(\"getConnection failed: \" + reason);\n        throw reason;\n    }\n\n    println(\"getConnection: no suitable driver found for \"+ url);\n    throw new SQLException(\"No suitable driver found for \"+ url, \"08001\");\n}\n```\n\n🔸 可以看到中间有一个 foreach 循环，遍历`registeredDrivers`，这是个`CopyOnWriteArrayList` 这个类看名字就知道存放的是已经注册的`Drivers` 实现类，那这些实现类是什么时候注册进来的呢？回到我们之前抛出的一个问题，在`ServiceLoader`的迭代器中加载了具体的类之后进行了实例化，但是`DriverManager` 中并没有接收这个实例，我们来看一下具体的驱动实现类\n\n```java\npackage com.mysql.cj.jdbc;\n\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n    public Driver() throws SQLException {\n    }\n\n    static {\n        try {\n            //注册到 DriverManager 中去\n            DriverManager.registerDriver(new Driver());\n        } catch (SQLException var1) {\n            throw new RuntimeException(\"Can't register driver!\");\n        }\n    }\n}\n```\n\n🔸 相信看到这里大家就明白了，前面初始化这个类的作用就是为了能触发这个**静态代码块**，进而执行 registerDriver() 方法进行注册，真是妙啊👏一环套一环\n\n🔸 还有一个需要注意的地方就是这里注册的虽然是个空的 Driver 类，但是别忘了它还有个父类 NonRegisteringDriver\n\n这个类才是真正的实现类具体的`connect()` 等方法都是在这个里面实现的，而 Driver 继承了它的方法\n\n🔸 在遍历`registeredDrivers` 的时候还调用了一个`isDriverAllowed(aDriver.driver, callerCL)` 方法这个方法第一个参数就是驱动的实现类，第二个参数就是前面获取到的**调用者的类加载器** ，作用就是通过利用传进来的加载器尝试加载这个类，然后判断是不是同一个类，（众所周知不同的加载器因为命名空间的存在，即使加载同一份字节码文件得到的也不是一个类） 如果是就允许加载，否则不允许，为啥要这样做呢？其实还是因为命名空间的问题，因为有了 SPI 的机制，你**加载初始化这个实现类的加载器** (TCCL) 和最终去**调用实现类的方法的类的加载器**有可能不是同一个，因为程序员可以很容易的将 TCCL 修改成其他的类加载器，如果不保证一致的话后面就会出现`ClassCastException`等异常 \n\n```java\nprivate static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) {\n    boolean result = false;\n    if(driver != null) {\n        Class<?> aClass = null;\n        try {\n            aClass =  Class.forName(driver.getClass().getName(), true, classLoader);\n        } catch (Exception ex) {\n            result = false;\n        }\n\n         result = ( aClass == driver.getClass() ) ? true : false;\n    }\n\n    return result;\n}\n```\n\n### **总结**\n\n当高层提供了统一接口让低层去实现（面向接口编程，解耦），同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的 ClassLoader 找到并加载该类。\n\n## Jar Hell\n\nJar 包地狱，[参考](https://www.hidennis.tech/2016/05/30/what-is-jar-hell/)\n\n这个问题其实可以通过`OSGI`等组件化框架来解决，使用 OSGI 可以完美解决这个问题，OSGI 是基于模块（Bundle）驱动的，每个模块都有属于自己的 classpath 和类加载器，模块之间通过包暴露和引入进行关联，每个模块有着自己独立的生命周期，我们可以动态地对模块进行加载、卸载、更新。如此看来，OSGI 可以用一句话描述，就是一个为 Java 提供的动态模块化的系统。但是 OSGI 太过复杂，实用性并不强\n\n[阿里架构师对 OSGI 的评价](http://hellojava.info/?p=152)\n\n这里我主要想说的是怎么在代码中利用类加载器来检测 Jar Hell\n\n```java\npublic class JarHell {  \n    public static void main(String[] args) {  \n        try {  \n            Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(\"org/apache/log4j/Logger.class\");  \n            while(urls.hasMoreElements()) {  \n                URL url = urls.nextElement();  \n                System.out.println(url);  \n            }  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n       \n    }  \n}  \n```\n\n这样就可以找到 classpath 中冲突的 jar 包，当然通过 idea 的工具会更方便 😂\n\n## 参考\n\n《深入理解 Java 虚拟机》\n\n[深入探讨 Java 类加载器](https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code4)\n","tags":["JVM","ClassLoader"],"categories":["JVM"]},{"title":"深入理解 Java 虚拟机（一）","url":"/2019/08/11/1c1f6a63/","content":"\n本文在 [CyC 大佬](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=minor-gc-%e5%92%8c-full-gc) 的博客基础之上做了一些扩充改编（ 改编不是乱编，戏说不是胡说，今年下半年。......🐵\n\n## Java 内存区域\n\n![mark](http://static.imlgw.top/blog/20190817/rTyjnrafmg3Q.png?imageslim)\n\n### 程序计数器\n\n- 程序计数器是一块较小的内存空间，它可以看成当前线程执行的字节码的行号指示器\n\n- 程序计数器位于线程独占去\n- 如果线程执行的是 Java 方法，这个计数齐记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是 native 方法，这个计数器的值为 undefined\n- 此区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域 \n\n### Java 虚拟机栈\n\n每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n\n![CyC](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png)\n\n可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：\n\n```java\njava -Xss2M HackTheJavaCopy to clipboardErrorCopied\n```\n\n该区域可能抛出以下异常：\n\n- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；\n- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。\n\n### 堆\n\n所有对象实例以及数组都在这里分配内存，是垃圾收集的主要区域（\"GC 堆\"）。\n\n现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆大致分成两块：\n\n- 新生代（Young Generation）\n- 老年代（Old Generation）\n\n堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。\n\n可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。\n\n### 方法区\n\nJava 虚拟机规范中将其描述为堆的一个逻辑部分，但是它还有一个别名就叫做`非堆`，而在 HotSpot 中则称之为`永久代（Permanent Generation）`。\n\n这一块主要用于存放**已被加载的类信息（类的版本，字段，方法，接口）**、**运行时常量池**、**静态变量**、即时编译器 (JIT) 编译后的代码等数据。\n\n和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。\n\n对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。\n\n`HotSpot` 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。\n\n方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，**静态变量和字符串常量池等被放入堆中**。\n\n### 运行时常量池\n\n运行时常量池是方法区的一部分，**Class 文件中的常量池**（编译器生成的**字面量**和**符号引用**）会在**类加载后**被放入这个区域\n\n除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()\n\n> When the intern method is invoked, if the pool already contains a string equal to this {@code String} object as determined by the {@link #equals(Object)} method, then the string from the pool is returned. Otherwise, this {@code String} object is added to the pool and a reference to this {@code String} object is returned.\n\n```java\npublic class StringIntern {\n    public static void main(String[] args) {\n        //s1 s2 存放在局部变量表中\n        // abc 存放在常量池中（字节码常量）\n        String s1=\"abc\";\n        String s2=\"abc\";\n\n        System.out.println(s1==s2); //true\n        //new 出来的一定是在堆内存中\n        String s3=new String(\"abc\");\n        System.out.println(s1==s3); //false\n        //运行时常量，intern 将字符串添加到常量池中并且返回一个引用\n        System.out.println(s1==s3.intern()); //true\n        //颠覆认知的\n        //实际上这里创建了两个字符串对象，一个在堆中，一个在常量池中\n        System.out.println(s3==s3.intern()); //false\n    }\n}\n```\n\n关于 String 常量池 参考可以这篇 [文章](https://blog.csdn.net/qq_34115899/article/details/86583262)\n\n或这一篇 [美团技术团队](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)\n\n### 直接内存\n\n在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。\n\n## 对象创建\n\n![mark](http://static.imlgw.top/blog/20190811/JcRnzxY4HN5q.png?imageslim)\n\n假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为`“指针碰撞”`（Bump the Pointer）。如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为`“空闲列表”`（Free List）。选择哪种分配方式由`Java 堆是否规整`决定，而 Java 堆是否规整又由所采用的`垃圾收集器是否带有压缩整理功能决定`。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。\n\n### 线程安全问题\n\n创建对象的时候需要修指针指向的位置，在并发情况下这并不是线程安全的，虚拟机可以采用 CAS 加上失败重试（自旋）的方式保证更新操作的原子性，但是这样会影响性能，另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为`本地线程分配缓冲`（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 FLAB 时，才需要同步锁定。虚拟机是否使用 TLAB，可以通过-XX：+/-UseTLAB 参数来设定。\n\n### 对象结构\n\n#### Object Header\n\n对象头包括两部分\n\n**自身运行时数据（Mark Word）**比如 对象哈希值，对象分带年龄，锁状态标志，线程持有的锁，偏向线程 ID，偏向时间戳等，另一部分就是**类型指针**\n\n#### InstanceData\n\n实例数据，是对象真正存储的有效信息，也是在程序中定义的各个类型字段的内容，无论是从父类继承下来的还是在之类种定义的，都需要记录下来。\n\n#### **Padding**\n\n这一部分并不是必须的，其实就是用于内存对齐的，HotSpot 自动内存管理系统要求对象起始地址必须是 8 个字节的整数倍，也就是对象大小必须是 8 的整数倍，如果不够则需要填充这部分就是 Padding\n\n### HotSpot 源码\n\n找到了 openJdk 的 Java8 对应的创建对象的 [源码](http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/6a0ead6dc6db/src/share/vm/interpreter/bytecodeInterpreter.cpp)，大概 1966 行左右\n\n## 堆的划分\n\n### 堆结构分代\n\nJava 虚拟机将堆内存划分为新生代、老年代和永久代，永久代是 HotSpot 虚拟机特有的概念（JDK1.8 之后为 metaspace 替代永久代），它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，而且 HotSpot 也有取消永久代的趋势，在 JDK 1.7 中 HotSpot 已经开始了“去永久化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。\n\n**新生代（Young Generation）**\n\n新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收 70% ~ 95% 的空间，回收效率很高。\n\n**老年代（Old Generationn）**\n\n在新生代中经历了多次（具体看虚拟机配置的阀值）GC 后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行 GC 的频率相对而言较低，而且回收的速度也比较慢。\n\n**永久代（Permanent Generationn）**\n\n永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java 虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。\n\n### 堆结构分代的意义\n\n　　Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（`对 HotSpot 虚拟机而言`），这就是 JVM 的内存分代策略。\n　　堆内存是虚拟机管理的内存中最大的一块，也是`垃圾回收最频繁`的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的 GC 效率。\n　　有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在`老年代`中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。\n\n## 垃圾收集\n\n垃圾收集主要是针对`堆和方法区`进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。\n\n### 判断一个对象是否可以被回收\n\n在堆中存放着 Java 世界中几乎所有的对象实例，垃圾收集器在对堆进行回收的时候，第一件事情就是要确定这些对象之中那些还“活着”，那些已经“死去”（不会再被使用）\n\n#### 引用计数法\n\n给对象加上一个引用计数器，每当有一个地方引用它的时候，计数器值就加 1，引用失效的时候就减一，计数器为 0 的对象就是不可能再被使用的。\n\n但是在主流的 Java 虚拟机中都没有使用引用计数器来进行内存管理，主要的原因就是它很难解决循环引用的问题。\n\n```java\npublic class Test {\n    public Object instance = null;\n    public static void main(String[] args) {\n        Test a = new Test();\n        Test b = new Test();\n        a.instance = b;\n        b.instance = a;\n        a = null;\n        b = null;\n        doSomething();\n    }\n}\n```\n\n上面的代码中 `Test a`  和`Test b` 互相引用，在后续将两个对象引用赋为 null 后两个对象的引用计数器仍然不为 0，导致无法回收这两个对象。\n\n#### 可达性分析法\n\n以 `GC Roots` 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收，Java 虚拟机使用该算法来判断对象是否可被回收。\n\nJava 语言中可以作为 GC Root 的对象包括下面几种\n\n- 虚拟机栈中局部变量表中引用的对象\n- 本地方法栈中 JNI 中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中的常量引用的对象\n\n#### OopMap，安全点，安全区\n\n采用可达性分析法首先就找找到那些是`GC Root`，目前主要有两种查找 GC Roots 的方法：\n\n💡**保守式 GC**：遍历方法区和栈区查找，无法使用复制算法，除非采用`句柄访问对象的方式`但效率不高，无法准确区分是不是引用（指针）类型的变量\n\n💡**准确式 GC**：与保守式 GC 相对的就是准确式 GC，就是我们准确的知道，某个位置上面是否是指针，对于 java 来说，就是知道对于某个位置上的数据是什么类型的，这样就可以判断出所有的位置上的数据是不是指向 GC 堆的引用，包括栈和寄存器里的数据。HotSpot 则是通过 `OopMap` 数据结构来记录在对象内的什么偏移量上是什么类型的数据\n\n很明显，保守式 GC 的成本太高。准确式 GC 的优点就是能够让虚拟机快速定位到 GC Roots。\n\n对应 `OopMap` 的位置即可作为一个`Safe Point`（安全点）。\n\n**什么是安全点？**\n\nOopMap 的作用是为了在 GC 的时候，快速进行可达性分析，所以 OopMap 并不需要一发生改变就去更新这个映射表。只要这个`更新在 GC 发生之前`就可以了。所以 OopMap 只需要在预先选定的一些位置上记录变化的 OopMap 就行了。这些特定的点就是`SafePoint`（安全点）。由此也可以知道，程序并不是在所有的位置上都可以进行 GC 的，只有在达到这样的安全点才能暂停下来进行 GC。\n\n**安全点的选取**\n\n在执行 GC 操作时，所有的工作线程必须停顿，这就是所谓的`\"Stop-The-World\"`，因为可达性分析算法必须是在一个确保一致性的内存快照中进行。如果在分析的过程中对象引用关系还在不断变化，分析结果的准确性就不能保证。\n\n安全点意味着在这个点时，所有`工作线程的状态是确定`的，JVM 就可以安全地执行 GC 。\n\n安全点的选取一般在以下几个位置，避免程序过长时间执行。\n\n- 循环的末尾\n\n- 方法临返回前\n\n- 调用方法之后\n\n- 抛异常的位置\n\n**安全区**\n\n​\t安全点的使用似乎解决了 OopMap 计算的效率的问题，但是这里还有一个问题。安全点需要程序自己跑过去，那么对于那些已经停在路边休息或者看风景的程序（比如那些处在 Sleep 或者 Blocked 状态的线程），他们可能并不会在很短的时间内跑到安全点去。所以这里为了解决这个问题，又引入了安全区域的概念。\n\n​\t安全区域很好理解，就是在程序的一段代码片段中并`不会导致引用关系发生变化`，也就不用去更新 OopMap 表了，那么在这段代码区域内任何地方进行 GC 都是没有问题的。这段区域就称之为安全区域。线程执行的过程中，如果进入到安全区域内，就会标志自己已经进行到安全区域了。那么虚拟机要进行 GC 的时候，发现该线程已经运行到安全区域，就不会管该线程的死活了。所以，该线程在脱离安全区域的时候，要`自己检查`系统是否已经完成了 GC 或者根节点枚举（这个跟 GC 的算法有关系），如果完成了就继续执行，如果未完成，它就必须等待收到可以安全离开安全区域的 Safe Region 的信号为止。\n\n**中断方式**\n\n在程序需要 GC 的时候怎么让所有线程到达安全点中断然后进行 GC ?\n\n- 抢断式中断：抢断式中断就是在 GC 的时候，让所有的线程都中断，如果这些线程中发现中断地方不在安全点上的，就恢复线程，让他们重新跑起来，直到跑到安全点上。（现在几乎没有虚拟机采用这种方式）\n\n- 主动式中断：主动式中断在 GC 的时候，不会主动去中断线程，仅仅是设置一个标志，当程序运行到安全点时就去轮训该位置，发现该位置被设置为真时就自己中断挂起。所以轮训标志的地方是和安全点重合的，另外创建对象需要分配内存的地方也需要轮询该位置。\n\n#### 方法区的回收\n\n方法区（HotSpot 中的永久代），在 Java 规范中并没有要求虚拟机对该区域进行垃圾回收，这个区域的垃圾回收效率要远低于在`堆中` \n\n回收的主要对象：\n\n- 废弃常量\n- 无用的类 (Class 对象）\n\n判断一个常量是否是废弃常量，只要没有任何对象引用常量池中的常量，该常量就可以回收。\n\n判断一个类是不是无用的类条件则比较苛刻。\n\n- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。\n- 加载该类的 ClassLoader 已经被回收。\n- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。\n\n满足了上述条件虚拟机才**可以** 对其进行回收，但是这也并不是必然的。\n\n#### Finalize()\n\n这个方法忘了就好😁\n\n当一个对象可被回收时，如果重写该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。\n\n### 引用类型\n\n无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。\n\nJava 提供了四种强度不同的引用类型。\n\n#### 强引用\n\n被强引用关联的对象不会被回收。\n\n使用 new 一个新对象的方式来创建强引用。\n\n```java\nObject obj = new Object();Copy to clipboardErrorCopied\n```\n\n#### 软引用\n\n被软引用关联的对象只有在内存不够的情况下才会被回收。\n\n使用 SoftReference 类来创建软引用。\n\n```java\nObject obj = new Object();\nSoftReference<Object> sf = new SoftReference<Object>(obj);\nobj = null;  // 使对象只被软引用关联 Copy to clipboardErrorCopied\n```\n\n#### 弱引用\n\n被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。\n\n使用 WeakReference 类来创建弱引用。\n\n```java\nObject obj = new Object();\nWeakReference<Object> wf = new WeakReference<Object>(obj);\nobj = null;Copy to clipboardErrorCopied\n```\n\n####  虚引用\n\n又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。\n\n为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。\n\n使用 PhantomReference 来创建虚引用。\n\n```java\nObject obj = new Object();\nPhantomReference<Object> pf = new PhantomReference<Object>(obj, null);\nobj = null;\n```\n\n### 垃圾收集算法\n\n#### 标记 - 清除算法\n\n![CyC](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png)\n\n在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。\n\n在清除阶段，会遍历整个堆进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 `“空闲链表”` 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。\n\n在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。\n\n详细可以参考 [垃圾回收的算法与实现](http://www.ituring.com.cn/book/tupubarticle/10955)\n\n#### 复制算法\n\n![CyC](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png)\n\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n\n主要不足是`只使用了内存的一半`。\n\n现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块`较大的 Eden` 空间和`两块较小的 Survivor 空间`，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，`最后清理 Eden 和使用过的那一块 Survivor。`\n\nHotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要`依赖于老年代进行空间分配担保`，也就是借用老年代的空间存储放不下的对象。\n\n#### 标记 - 整理\n\n复制算法在对象存活率较高的时候就要进行很多的复制操作，效率将会变低，老年代也没有额外的空间做担保，所以老年代一般不能直接使用这种算法。\n\n![CyC](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png)\n\n让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n- 不会产生内存碎片\n\n- 需要移动大量对象，处理效率比较低。\n\n#### 分代收集\n\n分代收集顾名思义就是分代来收集，针对不同的代执行不同的收集算法。\n\n一般将堆分为新生代和老年代。\n\n- 新生代使用：少量存活对象，采用复制算法只需要付出少量的复制成本就可以完成收集。\n- 老年代使用：存活率高没有担保，采用标记 - 清除 或者 标记 - 整理 算法，\n\n### 垃圾收集器\n\n![mark](http://static.imlgw.top/blog/20190813/3f2uQGV4SjI4.png?imageslim)\n\n以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。\n\n#### Serial 收集器\n\n**Serial（串行）**收集器是最基本、发展历史最悠久的收集器，它是采用`复制算法`的`新生代收集器`，曾经（JDK 1.3.1 之前）是虚拟机`新生代`收集的唯一选择。它是一个单线程收集器，只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是**它在进行垃圾收集时，必须暂停其他所有的工作线程，直至 Serial 收集器收集结束为止（“Stop The World”）**。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。\n\n下图展示了 Serial 收集器（老年代采用 Serial Old 收集器）的运行过程：\n\n![mark](http://static.imlgw.top/blog/20190813/03PTqvGk6jdy.png?imageslim)\n\n为了消除或减少工作线程因内存回收而导致的停顿，HotSpot 虚拟机开发团队在 JDK 1.3 之后的 Java 发展历程中研发出了各种其他的优秀收集器，这些将在稍后介绍。但是这些收集器的诞生并不意味着 Serial 收集器已经“老而无用”，实际上到现在为止，它依然是** HotSpot 虚拟机运行在 Client 模式下的默认的新生代收集器**。它也有着优于其他收集器的地方：**简单而高效（与其他收集器的单线程相比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。**\n\n在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接收。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。\n\n#### ParNew 收集器\n\n`ParNew`收集器就是 Serial 收集器的多线程版本，它也是一个`新生代收集器`。除了使用多线程进行垃圾收集外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与 Serial 收集器完全相同，两者共用了相当多的代码。\n\nParNew 收集器的工作过程如下图（老年代采用 Serial Old 收集器）：\n\n![mark](http://static.imlgw.top/blog/20190813/NDuVa0QjwwYM.png?imageslim)\n\nParNew 收集器除了使用多线程收集外，其他与 Serial 收集器相比并无太多创新之处，但它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，`除了 Serial 收集器外，目前只有它能和 CMS 收集器（Concurrent Mark Sweep）配合工作`，CMS 收集器是 JDK 1.5 推出的一个具有划时代意义的收集器，具体内容将在稍后进行介绍。\n\nParNew 收集器在`单 CPU 的环境`中绝对不会有比 Serial 收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越。在多 CPU 环境下，随着 CPU 的数量增加，它对于 GC 时系统资源的有效利用是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多的情况下可使用`-XX:ParallerGCThreads`参数设置。\n\n#### Parallel Scavenge 收集器\n\n`Parallel Scavenge`收集器也是一个并行的多线程`新生代收集器`，它也使用`复制算法`。Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量（Throughput）。\n\n> **吞吐量**：CPU 用于运行用户代码的时间和 CPU 消耗的总时间（CPU 执行时间+垃圾收集时间）的比值\n>\n> **单线程与多线程**：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；\n>\n> **并行（Parallel）**：指多条垃圾收集线程同时执行，但是此时用户线程仍然处于等待状态，也就是说和用户线程是串行的。\n>\n> **并发（Concurrent）**：并发指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以并行的方式执行。\n\n`停顿时间越短就越适合需要与用户交互的程序`，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在`后台运算而不需要太多交互的任务`。\n\n`Parallel Scavenge`  提供了两个参数用于较精确控制吞吐量\n\n- `-XX:MaxGCPauseMills` 控制最大垃圾收集停顿时间\n\n- `-XX:GCTimeRatio` 直接设置吞吐量大小\n\n缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。\n\nParallel Scavenge 收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数`-XX:+UseAdaptiveSizePolicy`，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为`GC 自适应的调节策略（GC Ergonomics）`。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别\n\n另外值得注意的一点是，Parallel Scavenge 收集器`无法与 CMS 收集器配合使用`，所以在 JDK 1.6 推出 Parallel Old 之前，如果新生代选择 Parallel Scavenge 收集器，老年代只有 Serial Old 收集器能与之配合使用。\n\n#### Serial Old 收集器\n\nSerial 收集器的老年代版本，同样是单线程，使用标记整理算法\n\n![mark](http://static.imlgw.top/blog/20190813/y1H9NyikWogV.png?imageslim)\n\n这个收集器的主要意义是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：\n\n- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。\n- 作为 CMS 收集器的后备预案，在并发收集发生 `Concurrent Mode Failure` 时使用（下面会介绍）。\n\n#### Parallel Old 收集器\n\n是 Parallel Scavenge 收集器的老年代版本。\n\n![mark](http://static.imlgw.top/blog/20190813/itz21ThRoKAD.png?imageslim)\n\n在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器\n\n#### CMS 收集器（Concurrent Mark Sweep）\n\n并发的老年代收集器，Mark Sweep 指的是标记 - 清除算法，它的运作相对前面几种来说要更加复杂一些，整体分为 4 哥步骤\n\n- **初始标记**：仅仅是标记一下 GC Root 能直接关联到的对象，速度很快，需要停顿\n- **并发标记**：进行 GC Root Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿，\n- **重新标记**：为了`修正`并发标记阶段程序继续运行导致标记变化的那一部分对象的标记记录，需要停顿\n- **并发清除**：不需要停顿\n\n在整个过程中耗时最长的`并发标记`和`并发清除`过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。\n\n![mark](http://static.imlgw.top/blog/20190813/zJiEhyXRjfTO.png?imageslim)\n\n**缺点**\n\n- 对 CPU 资源非常敏感 其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU 数量+3）/4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25%的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个时（比如 2 个），CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受，后面出现了`i-CMS`让 GC 线程和用户线程交替运行，但是表现很一般已被弃用。\n\n- 无法处理`浮动垃圾`，可能出现 `Concurrent Mode Failure`。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存给用户线程使用，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够用户线程运行，就会出现 `Concurrent Mode Failure`，jdk1.6 之后虚拟机会临时启用 Serial Old 来替代 CMS。\n\n- 标记-清除算法导致的空间碎片 CMS 是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发`Full GC`\n\n#### G1 收集器\n\nG1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n\n堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。\n\n![mark](http://static.imlgw.top/blog/20190814/o8sxTPY30GnJ.png?imageslim)\n\nG1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。\n\n![mark](http://static.imlgw.top/blog/20190814/3olH4WWVEysA.png?imageslim)\n\n通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个`优先列表`，每次根据允许的收集时间，优先回收价值最大的 Region。\n\n但是即使是这样分了 Region 垃圾回收器就一定会以 Region 为单位分配么？显然是不可能的，Region 不可能完全独立，一个对象分配在 Region 中并不是只能被当前 Region 部分引用，而是可以与整个 Java 堆的任意对象发生引用关系，这样在做可达性分析的时候岂不是仍然需要遍历整个堆？这个问题并不是只在 G1 中存在，其他收集器也会存在，只是 G1 这样划分之后问题更加突出了，在`G1 收集器`中每个 Region 都有一个 Remembered Set，用来记录该 Region 对象`的引用对象`所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。\n\n如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：\n\n- **初始标记（Initial Marking）** 仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的 Region 中创建对象，此阶段需要停顿线程，但耗时很短。\n- **并发标记（Concurrent Marking）** 从 GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。\n- **最终标记（Final Marking）** 为了修正在`并发标记期间`因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要`停顿线程`，但是可并行执行。\n- **筛选回收（Live Data Counting and Evacuation）** 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，`但是因为只回收一部分 Region，时间是用户可控制的`，而且停顿用户线程将大幅度提高收集效率。\n\n**特点**\n\n- **并行与并发** G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。\n- **分代收集** 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次 GC 的旧对象来获取更好的收集效果。\n- **空间整合** G1 从整体来看是基于`“标记-整理”`算法实现的收集器，从局部（两个 Region 之间）上来看是基于**“复制”**算法实现的。这意味着 G1 运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。\n- **可预测的停顿** 这是 G1 相对 CMS 的一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。\n\n#### 理解 GC 日志\n\nGC(Garbage Collection) 是 Java 虚拟机中一个很重要的组成部分，在很多情况下我们都需要查看它的日志，下面内容就是介绍如何查看 GC 日志。\n\n可选参数\n\n```java\n-XX:+PrintGC 输出 GC 日志\n-XX:+PrintGCDetails 输出 GC 的详细日志\n-XX:+PrintGCTimeStamps 输出 GC 的时间戳（以基准时间的形式）\n-XX:+PrintGCDateStamps 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）\n-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息\n-Xloggc:../logs/gc.log 日志文件的输出路径\n```\n\n**测试类**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/8/15 17:16\n */\npublic class GCTest {\n    \n    /**\n     * vm 参数 ：-XX:+PrintGCDetails 输出 GC 的详细日志\n     */\n    private byte[] data =new byte[1024*1024*10]; //10M\n\n    public static void main(String[] args) {\n        GCTest gcTest = new GCTest();\n        gcTest=null; //for gc\n        System.gc();\n        System.out.println(\"GC Test\");\n    }\n}\n```\n\n**控制台打印结果**\n\n```java\n[GC (System.gc()) [PSYoungGen: 12902K->712K(38400K)] 12902K->720K(125952K), 0.3622244 secs] [Times: user=0.00 sys=0.00, real=0.36 secs] \n[Full GC (System.gc()) [PSYoungGen: 712K->0K(38400K)] [ParOldGen: 8K->638K(87552K)] 720K->638K(125952K), [Metaspace: 3438K->3438K(1056768K)], 0.0103044 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] \nGC Test\nHeap\n PSYoungGen      total 38400K, used 998K [0x00000000d5e00000, 0x00000000d8880000, 0x0000000100000000)\n  eden space 33280K, 3% used [0x00000000d5e00000,0x00000000d5ef9b20,0x00000000d7e80000)\n  from space 5120K, 0% used [0x00000000d7e80000,0x00000000d7e80000,0x00000000d8380000)\n  to   space 5120K, 0% used [0x00000000d8380000,0x00000000d8380000,0x00000000d8880000)\n ParOldGen       total 87552K, used 638K [0x0000000081a00000, 0x0000000086f80000, 0x00000000d5e00000)\n  object space 87552K, 0% used [0x0000000081a00000,0x0000000081a9fb68,0x0000000086f80000)\n Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n  \nProcess finished with exit code 0\n```\n\n`PSYoungGen` 看见这个其实就猜的到了，Parallel Scavenge 收集器收集的新生代，代表 GC 的区域和收集器。下面的`ParOldGen`对应的就是 Parallel Old 的老年代 ，PSYoungGen 后面紧跟的 `12902K->712K(38400K)` 则代表 `GC 前该区域已经使用的容量 -> GC 后该区域已使用的容量（该区域总容量）`  ，而方括号外面的部分则代表 `GC 前 Java 堆已使用量 -> GC 后 Java 堆已使用量（Java 堆中容量）` 。\n\n### 内存分配与回收策略\n\n- **Minor GC**：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。\n- **Full GC**：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多，出现 Full GC 通常会伴随着 Minor GC，但是并不一定有时候也会直接进行 Full GC。\n\n对象的内存分配，往大的方向讲就是在堆上分配内存（也有可能被 JIT 拆散并间接的在栈上分配），对象主要分配在新生代的`Eden` 区上，如果启动了`本地线程分配缓冲`（TLAB） 会优先在 TLAB 上分配，少数情况也会直接分配在老年代中，分配的规则不是确定的，取决于垃圾收集器的组合以及虚拟机相关的参数的设置。\n\n> -Xms  初始 Heap 大小\n>\n> -Xmx  java heap 最大值 \n>\n> -Xmn  Young generation 的 heap 大小\n>\n> 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。\n\n#### 对象优先分配在 Eden 上\n\n大多数情况，对象会直接在新生代 Eden 上分配。当 Eden 区没有足够的区域进行分配的时候，虚拟机将会发起一次`Minor GC` 。\n\n下面我们通过代码来感受一下这个过程\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/8/15 17:16\n */\npublic class GCTest {\n    private static int _1M= 1024*1024; //1m\n\n    /*\n        -XX:+PrintGCDetails\n        -verbose:gc\n        -Xms20M 限制 Java 堆大小 20M 不可扩展\n        -Xmx20M\n        -Xmn10M 10M 分配给新生代\n        -XX:SurvivorRatio=8\n    */\n    public static void main(String[] args) throws InterruptedException {\n        byte[] alloc1,alloc2,alloc3,alloc4;\n        alloc1=new byte[2*_1M];\n        alloc2=new byte[2*_1M];\n        alloc3=new byte[2*_1M];\n        System.out.println(\"GC Test\"); //发生 GC\n        alloc4=new byte[3*_1M];\n    }\n}\n\n```\n\n**控制台打印**\n\n```java\nGC Test\n[GC (Allocation Failure) [PSYoungGen: 8002K->696K(9216K)] 8002K->6840K(19456K), 0.0028974 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Ergonomics) [PSYoungGen: 696K->0K(9216K)] [ParOldGen: 6144K->6783K(10240K)] 6840K->6783K(19456K), [Metaspace: 3439K->3439K(1056768K)], 0.0042088 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] \nHeap\n PSYoungGen      total 9216K, used 3154K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n  eden space 8192K, 38% used [0x00000000ff600000,0x00000000ff914930,0x00000000ffe00000)\n  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)\n  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)\n ParOldGen       total 10240K, used 6783K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  object space 10240K, 66% used [0x00000000fec00000,0x00000000ff29fc88,0x00000000ff600000)\n Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n\nProcess finished with exit code 0\n\n```\n\n在`alloc4`的时候 发现空间已经不足以装下了，所以进行了一次 Minor GC，随后 GC 掉了 YoungGen 大概 6M 的空间，但是这些对象大于`from` 和`to` 两块`Survivor` 区域无法直接存入所以通过分配担保进入老年代中，可以看到后面老年代 66%的占用存放的就是这几个对象。GC 结束后，`alloc4` 也顺利的进入的`Eden` \n\n#### 大对象直接进入老年代\n\n所谓的大对象其实就是需要大量连续内存空间的 Java 对象，最典型的就是那种很长的字符串以及数组，比如我上面代码中的 byte 数组，经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来“安置”这些大对象，所以应该避免产生“朝生夕死”的短命大对象。\n\n虚拟机提供了一个  `-XX: PretenureSizeThreshold`参数，令大于这个设置值的对象直接在老年代分配（只对 Serial 和 ParNew 两款收集器有效，Parallel 一般不用设置）。\n\n```java\npublic class GCTest {\n    private static int _1M= 1024*1024; //1m\n\n    /*\n        -XX:+PrintGCDetails\n        -verbose:gc\n        -Xms20M 限制 Java 堆大小 20M 不可扩展\n        -Xmx20M\n        -Xmn10M 10M 分配给新生代\n        -XX:SurvivorRatio=8\n    */\n    public static void main(String[] args) throws InterruptedException {\n        byte[] alloc1,alloc2,alloc3,alloc4;\n        alloc1=new byte[9*_1M];\n        System.out.println(\"GC Test\");\n    }\n}\n```\n\n**控制台打印**\n\n```java\nGC Test\nHeap\n PSYoungGen      total 9216K, used 2022K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n  eden space 8192K, 24% used [0x00000000ff600000,0x00000000ff7f9990,0x00000000ffe00000)\n  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)\n  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)\n ParOldGen       total 10240K, used 9216K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  object space 10240K, 90% used [0x00000000fec00000,0x00000000ff500010,0x00000000ff600000)\n Metaspace       used 3447K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n\nProcess finished with exit code 0\n\n```\n\n可以看到这个对象几乎全部被放到了老年代里面，老年代占用率 90%\n\n#### 长期存活的对象将进入老年代\n\n虚拟机为对象定义年龄计数器 Age，对象在 Eden 出生并经过 Minor GC 依然存活并且能被 Survivor 容纳的话，将移动到 Survivor 中，年龄就增加 1 岁，对象在 Survivor 区域每熬过一次 Minor GC 年龄就增加一岁，当他的年龄增加到一定程度（默认为 15 岁），就会将它移动到老年代中（很形象有没有 😁）\n`-XX:MaxTenuringThreshold` 用来定义年龄的阈值。\n\n#### 动态年龄判定\n\n虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 `Survivor` 中`相同年龄`所有对象大小的总和大于 `Survivor 空间的一半`，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄\n\n#### 空间分配担保\n\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的`连续空间`是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\n如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代\n最大可用的连续空间是否`大于`历次晋升到老年代对象的`平均大小`，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC，如果出现了担保失败，那就只好发起一次`Full GC`  ，绕的圈子是最大的，但是一般情况下这个开关还是默认打开的，避免产生太多的 Full GC，JDK1.6 之后这个参数就被废掉了，`只要老年代的连续空间大于新生代总空间或者每次晋升的平均大小就进行 Minor GC 否则进行 Full GC`\n\n#### Full GC 触发条件\n\n对于 Minor GC，其触发条件非常简单，当 Eden 空间快满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下情况：\n\n**_调用 System.gc()_**\n只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。\n\n**_老年代空间不足_**\n老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。\n为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数\n调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对\n象进入老年代的年龄，让对象在新生代多存活一段时间。\n\n**_空间分配担保失败_**\n使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。\n\n**_JDK 1.7 及以前的永久代空间不足_**\n在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据\n当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也\n会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。\n为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。\n\n**_Concurrent Mode Failure_**\n执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n\n## 参考\n\n**周志明《深入理解 Java 虚拟机》**\n\n[CYC 大佬的博客🙏](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=minor-gc-%e5%92%8c-full-gc)","tags":["JVM"],"categories":["JVM"]},{"title":"自旋锁，CLH 锁，MCS 锁","url":"/2019/08/10/418ce30a/","content":"\n- [自旋锁](#自旋锁)\n  - [简单自旋锁](#简单自旋锁)\n  - [Ticket Lock](#ticket-lock)\n- [CLH 锁](#clh-锁)\n- [MCS 锁](#mcs-锁)\n- [总结](#总结)\n- [参考](#参考)\n\n## 自旋锁\n\n自旋锁 (spin lock) 是一个典型的对临界资源的互斥手段，自旋锁是基于 CAS 原语的，所以它是轻量级的同步操作，它的名称来源于它的特性。自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。由于自旋锁只不进行线程状态的改变（挂起线程），所以当线程竞争不激烈时，它的响应速度极快（因为`避免了线程调度的上下文切换`）。自旋锁适用于锁保护的临界区很小的情况，线程竞争不激烈的场景下。如果线程之间竞争激烈或者临界区的操作特别耗时，那么线程的自旋操作就会耗费大量的 cpu 资源，所以这种情况下性能就会下降明显。\n\n###  简单自旋锁\n\n```java\npublic class SimpleSpinLock {\n    private AtomicReference<Thread> owner = new AtomicReference<Thread>();\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        // 后面解锁的就只能是当前线程\n        while (!owner.compareAndSet(null, currentThread)) {\n        }\n    }\n\n    public void unlock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁\n        owner.compareAndSet(currentThread, null);\n    }\n}\n```\n\n**缺点**\n\n- CAS 操作需要硬件的配合（现代处理器大多都支持）\n\n- 保证各个 CPU 的缓存（L1、L2、L3、跨 CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重（这是由于 Atomic 的 volatile 变量导致的，同时这也是必须的）\n\n- 没法保证公平性，不保证等待进程/线程按照 FIFO 顺序获得锁。\n\n### Ticket Lock\n\n```java\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); // 服务号\n    private AtomicInteger ticketNum = new AtomicInteger(); // 排队号\n\n    public int lock() {\n        // 首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        // 只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n        }\n        return myTicketNum;\n    }\n\n    public void unlock(int myTicket) {\n        // 解锁后只有拥有该线程的下一个排队号线程才能加锁，保证了公平性，不会有插队的情况\n        int next = myTicket + 1;\n        // 只有当前线程拥有者才能释放锁\n        serviceNum.compareAndSet(myTicket, next);\n    }\n}\n```\n\n**缺点**\n\nTicket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量 serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。\n\n## CLH 锁\n\nCLH 的发明人是：Craig，Landin and Hagersten，三个人的名字合称\n\nCLH 锁是一种基于隐式链表（节点里面没有 next 指针）的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。\n\n```java\npublic class CLHLock {\n    public static class CLHNode {\n        private volatile boolean isLocked = true; // 默认是在等待锁\n    }\n\n    private volatile CLHNode tail ;\n\n    private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER = AtomicReferenceFieldUpdater\n            . newUpdater(CLHLock.class, CLHNode .class , \"tail\" );\n\n    public void lock(CLHNode currentThreadNode) {\n        //获取之前的尾结点，然后将自己设置为尾节点\n        CLHNode preNode = UPDATER.getAndSet( this, currentThreadNode);\n        if(preNode != null) {//已有线程占用了锁，进入自旋\n            while(preNode.isLocked ) {\n            }\n        }\n    }\n\n    public void unlock(CLHNode currentThreadNode) {\n        // 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。\n        // 尝试设置尾节点为自己，传入的期望值是自己，成功就代表队列中只有它一个\n        if (!UPDATER.compareAndSet(this, currentThreadNode, null)) {\n            // 还有后续线程\n            currentThreadNode.isLocked = false ;// 改变状态，让后续线程结束自旋\n        }\n    }\n}\n```\n\n这里用到了`原子字段更新器`，让 tail 变量可以具有 CAS 的功能，具体可以参考之前的文章 [CAS 与原子变量](http://imlgw.top/2019/04/22/cas-yu-yuan-zi-bian-liang/#%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8)\n\n**缺点**\n\n先说一下`NUMA`和`SMP`两种处理器结构\nSMP(Symmetric Multi-Processor)，即对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 的优点是`能够保证内存一致性`，缺点是这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。\n\nNUMA(Non-Uniform Memory Access) 非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，`访问本地内存的速度将远远高于访问远地内存（系统内其它节点的内存）的速度`，这也是非一致存储访问 NUMA 的由来。NUMA 优点是可以较好地解决原来 SMP 系统的扩展问题，缺点是由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。\n\n**CLH 锁的缺点是在 NUMA 系统结构下性能很差，在这种系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，在 SMP 架构下能够保证内存一致性所以自旋判断较快**\n\n## MCS 锁\n\nMCS Spinlock 是一种基于显式链表（节点里面拥有 next 指针）的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，由直接前驱负责通知其结束自旋（与 CLH 自旋锁不同的地方，不在轮询前驱的状态，而是由前驱主动通知），从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/8/10 21:49\n */\npublic class MCSLock {\n    public static class MCSNode {\n        //持有后继者的引用\n        volatile MCSNode next;\n        // 默认是在等待锁\n        volatile boolean block = true;\n    }\n\n    volatile MCSNode tail;// 指向最后一个申请锁的 MCSNode\n\n    private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER = AtomicReferenceFieldUpdater\n            .newUpdater(MCSLock.class, MCSNode.class, \"tail\");\n\n    public void lock(MCSNode currentThreadMcsNode) {\n        //更新 tail 为最新加入的线程节点，并取出之前的节点（也就是当前节点的前驱）\n        MCSNode predecessor = UPDATER.getAndSet(this, currentThreadMcsNode);\n        if (predecessor != null) {\n            //连接在 tail 的尾部\n            predecessor.next = currentThreadMcsNode;\n            //轮询自己的 isLocked 属性\n            while (currentThreadMcsNode.block) {\n\n            }\n        } else {\n            //前驱节点为空直接获取锁，自己是第一个\n            currentThreadMcsNode.block = false;\n        }\n    }\n\n    public void unlock(MCSNode currentThreadMcsNode) {\n        if (currentThreadMcsNode.block) {\n            return;\n        }\n        //判断是不是只有一个线程\n        if (currentThreadMcsNode.next == null) {\n            //CAS 将 tail 设置为空\n            if (UPDATER.compareAndSet(this, currentThreadMcsNode, null)) {\n                // 设置成功返回，没有其他线程等待锁\n                return;\n            } else {\n                //CAS 更新 tail 失败，有线程抢先一步执行 lock 更新了 tail\n                //但是可能还没有连接在 之前的 tail（当前节点）后\n                while (currentThreadMcsNode.next == null) {\n                    //等待 predecessor.next = currentThreadMcsNode 执行\n                    //否则后面会报 NPE\n                }\n            }\n        }\n        //修改后继者的 isLocked, 通知后继者结束自旋\n        currentThreadMcsNode.next.block = false;\n        currentThreadMcsNode.next = null;// for GC\n    }\n}\n```\n\n## 总结\n\n传统的`Spin lock` 和 `Ticket Lock`都在同一个共享变量上竞争（例如 SimpleSpinLock 中的 owner、Ticket Lock 中的 serviceNum），这样对给 CPU 保证缓存一致性带来的压力比较大，每次读写都需要同步到所有的线程，而 MCS 和 CLH 最大的优化点在于把上述同一个点上的竞争分散到队列的每个节点中去了。\n\n## 参考\n\n[自旋锁、排队自旋锁、MCS 锁、CLH 锁](https://coderbee.net/index.php/concurrent/20131115/577)","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"阻塞队列","url":"/2019/08/07/159c6098/","content":"\n## 阻塞队列\n\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\n**非阻塞队列中的几个主要方法：**\n\n- `add(E e)`: 将元素 e 插入到队列末尾，如果插入成功，则返回 true；如果插入失败（即队列已满），则会抛出异常\n\n-  `remove()`: 移除队首元素，若移除成功，则返回 true；如果移除失败（队列为空），则会抛出异常\n\n- `offer(E e)`：将元素 e 插入到队列末尾，如果插入成功，则返回 true；如果插入失败（即队列已满），则返回 false\n\n- `poll()`：移除并获取队首元素，若成功，则返回队首元素；否则返回 null\n\n- `peek()`：获取队首元素，若成功，则返回队首元素；否则返回 null\n\n对于非阻塞队列，一般情况下建议使用 offer、poll 和 peek 三个方法，不建议使用 add 和 remove 方法。因为使用 offer、poll 和 peek 三个方法可以通过返回值判断操作成功与否，而使用 add 和 remove 方法却不能达到这样的效果。注意，非阻塞队列中的方法都没有进行同步措施。\n\n**阻塞队列中的几个主要方法：**\n\n阻塞队列包括了非阻塞队列中的大部分方法，上面列举的 5 个方法在阻塞队列中都存在，但是要注意这 5 个方法在阻塞队列中都进行了**同步措施**。除此之外，阻塞队列提供了另外 4 个非常有用的方法：\n\n- `put(E e)`方法用来向队尾存入元素，如果队列满，则等待\n\n- `take()`方法用来从队首取元素，如果队列为空，则等待\n\n- `offer(E e,long timeout, TimeUnit unit)`方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回 false；否则返回 true\n\n- `poll(long timeout, TimeUnit unit)`方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果没取到，则返回 null；否则返回取得的元素\n\n###  Java 里的阻塞队列\n\n- **ArrayBlockingQueue** ：一个由数组结构组成的有界阻塞队列。\n- **LinkedBlockingQueue** ：一个由链表结构组成的有界阻塞队列。\n- **PriorityBlockingQueue** ：一个支持优先级排序的无界阻塞队列。\n- **DelayQueue**：一个使用优先级队列实现的无界阻塞队列。\n- **SynchronousQueue**：一个不存储元素的阻塞队列。\n- **LinkedTransferQueue**：一个由链表结构组成的无界阻塞队列。\n- **LinkedBlockingDeque**：一个由链表结构组成的双向阻塞队列。\n\n> 除了这几个外还有一个 `ScheduledThreadPoolExecutor.DelayedWorkQueue`这个其实是 DelayQueue 的优化\n\n### ArrayBlockingQueue\n\nArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：\n\n`ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);`\n\n访问者的公平性是使用可重入锁实现的\n\n### LinkedBlockingQueue\n\nLinkedBlockingQueue 是一个用链表实现的**有界**阻塞队列。此队列按照先进先出的原则对元素进行排序。\n\n容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被\n设置为 Integer.MAX_VALUE ，成为了无界队列。\n\n### PriorityBlockingQueue\n\nPriorityBlockingQueue 是一个支持优先级的无界队列。底层采用数组实现了二叉堆，相比 PriorityQueue 其实就是将默认情况下元素采取自然顺序排列，也可以通过比较器 comparator 来指定元素的排序规则。\n\n### DelayQueue\n\n这个队列还是挺有意思的，DelayQueue 是一个支持延时获取元素的无界阻塞队列。内部使用 PriorityQueue 来存储元素。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中**取出**元素。我们可以将 DelayQueue 运用在以下应用场景：\n\n- 缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取（删除）元素时，表示缓存有效期到了。\n- 定时任务调度。使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。\n\n队列中的 Delayed 必须实现 compareTo 来指定元素的顺序。比如让延时时间最长的放在队列的末尾。实现代码如下：\n\n**如何实现 Delayed 接口**\n\n我们可以参考 ScheduledThreadPoolExecutor 里 ScheduledFutureTask 类。这个类实现了 Delayed 接口。\n\n然后使用 getDelay 可以查询当前元素还需要延时多久，代码如下：\n\n```java\npublic long getDelay(TimeUnit unit) {\n    return unit.convert(time - now(), TimeUnit.NANOSECONDS);\n}\n```\n\n通过构造函数可以看出延迟时间参数 ns 的单位是纳秒，自己设计的时候最好使用纳秒，因为 getDelay 时可以指定任意单位，一旦以纳秒作为单位，而延时的时间又精确不到纳秒就麻烦了。使用时请注意当 time 小于当前时间时，getDelay 会返回负数。\n\n**如何实现延时队列**\n\n延时队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。\n\n```java\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.TimeUnit;\n\npublic class DelayedEle implements Delayed {\n\n    private final long delayTime; //延迟时间\n    private final long expire;  //到期时间\n    private String data;   //数据\n\n    public DelayedEle(long delay, String data) {\n        delayTime = delay;\n        this.data = data;\n        expire = System.currentTimeMillis() + delay;\n    }\n\n    /**\n     * 剩余时间=到期时间-当前时间\n     */\n    @Override\n    public long getDelay(TimeUnit unit) {\n        return unit.convert(this.expire - System.currentTimeMillis() , TimeUnit.MILLISECONDS);\n    }\n\n    /**\n     * 优先队列里面优先级规则\n     */\n    @Override\n    public int compareTo(Delayed o) {\n        //根据 delay 时间\n        return (int) (this.getDelay(TimeUnit.MILLISECONDS) -o.getDelay(TimeUnit.MILLISECONDS));\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"DelayedElement{\");\n        sb.append(\"delay=\").append(delayTime);\n        sb.append(\", expire=\").append(expire);\n        sb.append(\", data='\").append(data).append('\\'');\n        sb.append('}');\n        return sb.toString();\n    }\n}\n```\n\n**测试**\n\n```java\nimport java.util.concurrent.DelayQueue;\n\n/**\n * @author imlgw.top\n * @date 2019/8/7 17:55\n */\npublic class DelayedQueueTest {\n    public static void main(String[] args) throws InterruptedException {\n        DelayQueue<DelayedEle> delayQueue = new DelayQueue<DelayedEle>();\n\n        DelayedEle element1 = new DelayedEle(3000,\"lgw\");\n        DelayedEle element2 = new DelayedEle(3000,\"top\");\n\n        delayQueue.offer(element1);\n        delayQueue.offer(element2);\n        long l = System.currentTimeMillis();\n\n        System.out.println(l);\n        element1 =  delayQueue.take();\n        System.out.println(System.currentTimeMillis()-l);\n\n        System.out.println(element1);\n    }\n}\n\n/** 测试结果\n *  1565176036796\n *  3016\n *  DelayedElement{delay=3000, expire=1565176039796, data='lgw'}\n */\n \n```\n\n### SynchronousQueue\n\nSynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景，比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。\n\n> 线程池工厂方法 **newCachedThreadPool** 底层就是用的 Synchronized\n\n### LinkedTransferQueue\n\nTransferQueue 相比 SynchronousQueue 用处更广、更好用，因为你可以决定是使用 BlockingQueue 的方法（译者注：例如 put 方法）还是确保一次传递完成（译者注：即 transfer 方法）。在队列中已有元素的情况下，调用 transfer 方法，可以确保队列中被传递元素之前的所有元素都能被处理。[Doug Lea 说](http://cs.oswego.edu/pipermail/concurrency-interest/2009-February/005888.html) 从功能角度来讲，LinkedTransferQueue 实际上是 ConcurrentLinkedQueue、SynchronousQueue（公平模式）和 LinkedBlockingQueue 的超集。而且 LinkedTransferQueue 更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。\n\nLinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列 LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。\n\nLinkedTransferQueue 与 SynchronousQueue 中公平模式的实现 TransferQueue 是一样的，队列中存放的不是数据，而是操作（取出数据的操作 take 和放入数据的操作 put）队列中既可以存放 take 操作也可以存放 put 操作，但是队列中不能同时存在两种不同的操作，因为不同的操作会触发队列进行配对（操作出队）。\n\n**transfer 方法**。如果当前有消费者正在等待接收元素（消费者使用 take() 方法或带时间限制的 poll() 方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。transfer 方法的关键代码如下：\n\n```java\nprivate E xfer(E e, boolean haveData, int how, long nanos) {\n    if (haveData && (e == null))\n        throw new NullPointerException();\n    Node s = null;                        // the node to append, if needed\n\n    retry:\n    for (;;) {                            // restart on append race\n\n        for (Node h = head, p = h; p != null;) { // find & match first node\n            boolean isData = p.isData;\n            Object item = p.item;\n            if (item != p && (item != null) == isData) { // unmatched\n                if (isData == haveData)   // can't match\n                    break;\n                if (p.casItem(item, e)) { // match\n                    for (Node q = p; q != h;) {\n                        Node n = q.next;  // update by 2 unless singleton\n                        if (head == h && casHead(h, n == null ? q : n)) {\n                            h.forgetNext();\n                            break;\n                        }                 // advance and retry\n                        if ((h = head)   == null ||\n                            (q = h.next) == null || !q.isMatched())\n                            break;        // unless slack < 2\n                    }\n                    LockSupport.unpark(p.waiter);\n                    return LinkedTransferQueue.<E>cast(item);\n                }\n            }\n            Node n = p.next;\n            p = (p != n) ? n : (h = head); // Use head if p offlist\n        }\n\n        if (how != NOW) {                 // No matches available\n            if (s == null)\n                s = new Node(e, haveData);\n            //（1）尝试添加到链表尾部\n            Node pred = tryAppend(s, haveData);\n            if (pred == null)\n                continue retry;           // lost race vs opposite mode\n            if (how != ASYNC)\n            //（2）等待消费者消费\n                return awaitMatch(s, pred, e, (how == TIMED), nanos);\n        }\n        return e; // not waiting\n    }\n}\n```\n\n（1）代码是试图把存放当前元素的 s 节点作为 tail 节点。（2）代码是让 CPU 自旋等待消费者消费元素。因为自旋会消耗 CPU，所以自旋一定的次数后使用 Thread.yield() 方法来暂停当前正在执行的线程，并执行其他线程。\n\n**tryTransfer 方法**。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。\n\n对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit) 方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。\n\n**实例**\n\n```java\npackage juc_study.collection.blocking;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedTransferQueue;\n\npublic class LinkedTransferQueueDemo {\n    static LinkedTransferQueue<String> lnkTransQueue = new LinkedTransferQueue<String>();\n    public static void main(String[] args) {\n        ExecutorService exService = Executors.newFixedThreadPool(2);\n        Producer producer = new LinkedTransferQueueDemo().new Producer();\n        Consumer consumer = new LinkedTransferQueueDemo().new Consumer();\n        exService.execute(producer);\n        exService.execute(consumer);\n        exService.shutdown();\n    }\n    class Producer implements Runnable{\n        @Override\n        public void run() {\n            for(int i=0;i<3;i++){\n                try {\n                    System.out.println(\"Producer is waiting to transfer...\");\n                    lnkTransQueue.transfer(\"A\"+i);\n                    System.out.println(\"producer transfered element: A\"+i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable{\n        @Override\n        public void run() {\n            for(int i=0;i<3;i++){\n                try {\n                    System.out.println(\"Consumer is waiting to take element...\");\n                    String s= lnkTransQueue.take();\n                    System.out.println(\"Consumer received Element: \"+s);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n### LinkedBlockingDeque\n\nLinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。在初始化 LinkedBlockingDeque 时可以初始化队列的容量，用来防止其再扩容时过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。\n\n## 参考\n\n[并发容器学习—LinkedTransferQueue](https://my.oschina.net/bzhangpoorman/blog/3044802)\n\n[阻塞队列之 LinkedTransferQueue](https://blog.csdn.net/YJian2008/article/details/16951811)\n\n[并发队列-无界阻塞延迟队列 DelayQueue 原理探究](https://www.jianshu.com/p/2659eb72134b)\n\n[并发编程网](http://ifeve.com/blocking-queues/)\n\n[Java 7 中的 TransferQueue](http://ifeve.com/java-transfer-queue/)","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"ThreadPoolExecutor 源码解析","url":"/2019/07/30/ca94e89b/","content":"\n## 深入 ThreadPoolExecutor 源码\n\n### 类结构\n\n![mark](http://static.imlgw.top/blog/20190802/wTkHh1NbyM8K.png?imageslim)\n\n这里主要要说的是 `ThreadPoolExecutor`类\n\n### 线程池状态\n\n打开源码映入眼帘的就是这几个字段和方法，对应的就是线程池的一些运行状态和相关方法\n\n```java\n//控制线程池中数量和状态的字段，用 AtomicInteger 保存\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n//count bit 顾名思义就是 workerCount 的位数，这里是 29\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n//1<<29 -1 == 1111....1111(29 个 1) 线程数 (workerCount) 上限 大约 5 亿\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\n//高三位存放状态，相应的低 29 位就是 workerCount\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\n// 拆解 ctl 获取状态和数量\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\n// 拼接状态和数量得到 ctl\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n#### 状态转换过程\n\n![mark](http://static.imlgw.top/blog/20190802/EWlphYbCMVjv.png?imageslim)\n\n💡 **RUNNING** ：能接受新提交的任务，并且也能处理阻塞队列中的任务；\n\n💡 **SHUTDOWN**：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 `RUNNING` 状态时，调用 `shutdown()`方法会使线程池进入到该状态。（`finalize()` 方法在执行过程中也会调用 shutdown() 方法进入该状态）\n\n💡 **STOP**：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 `RUNNING` 或 `SHUTDOWN` 状态时，调用 `shutdownNow()` 方法会使线程池进入到该状态\n\n💡 **TIDYING**：如果所有的任务都已终止了，workerCount （有效线程数） 为 0，线程池进入该状态后会调用 terminated() 方法进入 TERMINATED 状态\n\n💡 **TERMINATED**：在 terminated() 方法执行完后进入该状态，默认 terminated() 方法中什么也没有做。\n\n进入`TERMINATED`的条件如下：\n\n- 线程池不是 RUNNING 状态；\n- 线程池状态不是 TIDYING 状态或 TERMINATED 状态；\n- 如果线程池状态是 SHUTDOWN 并且 workerQueue 为空；\n- workerCount 为 0；\n- 设置 TIDYING 状态成功。\n\n### 成员变量\n\n再往下，就会看见一些很重要的成员变量\n\n```java\n//任务缓存队列，存放待执行的任务\nprivate final BlockingQueue<Runnable> workQueue; \n//可重入锁，线程池主要的锁\nprivate final ReentrantLock mainLock = new ReentrantLock();\n//线程集合（线程池的 workers 集合）\nprivate final HashSet<Worker> workers = new HashSet<Worker>();\n//对应的条件变量\nprivate final Condition termination = mainLock.newCondition(); \n//用来记录线程池中曾经出现过的最大线程数，和线程池容量没有关系\nprivate int largestPoolSize;\n//用来记录已经执行完毕的任务个数\nprivate long completedTaskCount; \n//工厂方法，用来创建线程\nprivate volatile ThreadFactory threadFactory; \n//拒绝策略\nprivate volatile RejectedExecutionHandler handler; \n//线程闲置时候的最大存活时间\nprivate volatile long keepAliveTime; \n//是否允许核心线程闲置的时候超时\nprivate volatile boolean allowCoreThreadTimeOut; \n//核心线程数\nprivate volatile int corePoolSize; \n//最大线程数\nprivate volatile int maximumPoolSize; \n//默认的拒绝策略：AbortPolicy 直接拒绝并抛异常\nprivate static final RejectedExecutionHandler defaultHandler = new AbortPolicy();\n```\n\n### execute()\n\n **源码分析**\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n\n    //获取线程池的状态和线程数量\n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) { //workerCount 小于核心线程数量\n        //将任务添加到 workers 中，第二个参数代表是否根据 corePoolSize 来添加线程，false 则根据 maxPoolSize\n        if (addWorker(command, true))\n            return;\n        //添加失败，重新获取 ctl\n        c = ctl.get();\n    }\n    \n    //上面添加到 workers 中失败，有可能是核心线程不够用了或者线程池不是运行状态\n    //如果线程池是 Running 状态 尝试添加任务到阻塞队列中\n    if (isRunning(c) && workQueue.offer(command)) {\n        //添加到等待队列成功，重新获取 ctl\n        int recheck = ctl.get();\n        //如果线程池不是 Running 状态就从等待队列中 remove 这个任务\n        if (! isRunning(recheck) && remove(command))\n            reject(command); //采用拒绝策略拒绝该任务\n        else if (workerCountOf(recheck) == 0)\n            //线程池 Running 但是没有线程\n            //创建一个线程但是不传入 Runnable（已经在阻塞队列中了）\n            addWorker(null, false);\n    }\n    //两种情况\n    //1. 线程池不是 Running 状态并且 command 不为 null，addWorker 会直接 false 然后拒绝这个任务\n    //2. 添加到 workQueue（阻塞队列）失败，也就是 queue 满了，可能是需要扩容了\n    //   所以后面的参数是 false，添加失败也会直接拒绝\n    else if (!addWorker(command, false))\n        reject(command);\n}\n```\n\n这里要理解 addWorker 的第二个参数，true 则代表当前线程池的**上界**仍然是 corePoolSize，后面的 addWorker 会根据上界来判断是否增加线程，false 则代表**上界**是 maximumPoolSize，这一点在后面的分析中会看到。\n\n**Executor 大致执行流程**\n\n![mark](http://static.imlgw.top/blog/20190803/j3xQrmOkc3Kl.png?imageslim)\n\n### addWorker()\n\n`addWorker()` 的作用就是创建线程 (Worker) 并且添加到 Workers 集合中，然后启动线程\n\n**源码分析**\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // rs>=SHUTDOWN 说明不是 RUNNING 状态\n        if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null &&!workQueue.isEmpty()))\n            return false;\n        \n        for (;;) {\n            int wc = workerCountOf(c);\n            //如果大于可允许的最大线程数，或者大于当前的线程池的上界，直接 false\n            //上面传入的第二个参数的作用体现出来了，为 true 上界则是 corePoolSize\n            if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            //利用 CAS 自增 增大 workCount 线程数，成功后就跳出循环\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            //CAS 失败，重新获取 ctl\n            c = ctl.get();  // Re-read ctl\n            //判断还是不是 Running 状态（能到这里说明 rs==Running 状态），不是的话就跳出去重新来过\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n            // CAS 失败并且还是 Running 状态，继续自旋尝试自增\n        }\n    }\n    //线程是否启动，以及线程是否添加\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        //创建一个 Worker（对线程的封装）\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\t\t\t\t//是 RUNNING 状态 或者 是 SHUTDOWN 状态且没有提交任务 (SHUTDOWN 状态还可以执行阻塞队列的任务）\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    //添加到工作集中\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s; //记录最大值\n                    workerAdded = true; //添加成功\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                //启动线程，执行 Worker 的 run 方法\n                t.start(); \n                workerStarted = true; //启动成功\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            //启动失败，回滚 workers 并尝试关闭线程池\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n🔸 首先判断当前线程池的状态是否适合继续 addWorker，分析这里的 if 条件，RUNNING 不会 false ，STOP，TIDYING，TERMINATED 直接 false，SHUTDOWN 状态如果 firstTask 为空 阻塞队列中还有任务的时候不会 false，其他情况都 false。\n\n🔸 获取当前的 workerCount 判断是否超过了当前的上界，这里就用到了第二个参数\n\n🔸 然后利用 CAS 自旋增加 workerCount\n\n🔸 创建 Worker 对象，获取 mainLock 并加锁，因为 workers 是 HashSet 并不是线程安全的\n\n🔸 再次获取线程池转台并判断是否合法，合法就添加到 workers 中，然后在 finally 块中释放锁\n\n🔸 根据前面的 workerAdded 判断是否启动线程\n\n🔸 在最终的 finally 块中根据是否启动成功来决定是否回滚\n\n### addWorkerFailed()\n\n启动失败，回滚之前的添加操作\n\n```java\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    //获取锁\n    mainLock.lock();\n    try {\n        if (w != null)\n            //从 workers 中移除\n            workers.remove(w);\n        //减少 workerCount\n        decrementWorkerCount();\n        //尝试关闭线程池\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n### Worker 类\n\n封装了线程对象，线程池维护的就是这些 worker\n\n```java\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable\n{\n    /**\n     * This class will never be serialized, but we provide a\n     * serialVersionUID to suppress a javac warning.\n     */\n    private static final long serialVersionUID = 6138294804551838833L;\n\n    /** Thread this worker is running in.  Null if factory fails. */\n    final Thread thread;\n    /** Initial task to run.  Possibly null. */\n    Runnable firstTask; //传入的任务\n    /** Per-thread task counter */\n    volatile long completedTasks;\n\n    /**\n     * Creates with given first task and thread from ThreadFactory.\n     * @param firstTask the first task (null if none)\n     */\n    Worker(Runnable firstTask) {\n        setState(-1); // 设置状态为 -1\n        this.firstTask = firstTask;\n        //根据工厂方法创建线程\n        //将 Worker 传递进去，作为 Thread 的参数\n        //new Thread(Worker worker);\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    /** Delegates main run loop to outer runWorker  */\n    public void run() {\n        runWorker(this);\n    }\n\n    // Lock methods\n    //\n    // The value 0 represents the unlocked state.\n    // The value 1 represents the locked state.\n    // 是否获取到了锁\n    protected boolean isHeldExclusively() {\n        return getState() != 0; \n    }\n\n    protected boolean tryAcquire(int unused) {\n        //利用 CAS 设置 state\n        //很明显这里是个不可重入的独占锁，具体可以对比 ReentrantLock 的实现方法\n        if (compareAndSetState(0, 1)) {\n            //继承自 AbstractOwnableSynchronizer\n            //保存当前的持有锁的线程\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n    \n    //释放锁设置 state=0\n    protected boolean tryRelease(int unused) {\n        //设置独占锁线程为空\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); } //最终会调用 tryAcquire(1);\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); } //最终会调用 tryRelease(1);\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    //打断已经启动的线程\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n```\n\n这里可以看到 Worker 继承了 AQS 并且实现了 Runnable 接口，然后借助 AQS 实现了一个`独占的不可重入的锁`，其实这也是很巧妙的一点（这里我和博客上的理解有点出入）。\n\n到这里大家肯定会有疑问，为什么这里要实现 AQS 然后实现一个锁？既然要又为什么要实现一个不可重入的，而不直接使用`ReentrantLock` 那不是更加方便么？？除此之外还有一个小细节就是构造器里面为什么`setState(-1)`  这样不就获取不到锁了么？？\n\n其实这是为了后面`shutdown`的时候`interruptIdleWorkers`能判断出线程是否在工作，从而打断那些空闲的线程。如果使用可重入锁的话就无法通过`tryLock()` 来判断线程是否在工作。而`setState(-1)` 则是为了防止在任务没有开始前被打断\n\n### runWorker()\n\n在上面`AddWorker()`最后添加成功后会启动 Worker 线程，而在 worker 线程中 run 方法又会调用一个`runWorker()`方法，这里就是具体执行任务的地方\n\n```java\nfinal void runWorker(Worker w) {\n    //当前执行线程\n    Thread wt = Thread.currentThread();\n    //拿到任务\n    Runnable task = w.firstTask; \n    w.firstTask = null;\n    //前面构造 worker 的时候设置了 state=-1\n    //设置 state 为 0，tryRelease(1)\n    //其实这样是为了在这之前不会被打断（还没有开始执行任务）\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true; //是否因为异常而退出？\n    try {\n        //task 为空就从阻塞队列中拿任务\n        while (task != null || (task = getTask()) != null) {\n            //加锁，但是这个锁不会和其他的 Worker 互斥，这个锁只是用来判断 worker 是否在工作\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                //打断当前执行线程 wt\n                wt.interrupt();\n            try {\n                //空方法交给子类去实现\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run(); //执行任务\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    //空方法交给子类去实现\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++; //完成任务数++\n                w.unlock();\n            }\n        }\n        completedAbruptly = false; //下面的收尾工作会根据这个判断是否调整线程数\n    } finally {\n        processWorkerExit(w, completedAbruptly); //收尾工作\n    }\n}\n```\n\n🔸 首先获取了参数传递进来的 worker 携带的任务\n\n🔸 然后执行了 w.unlock()，实际上这里就对应了上面 Worker 类构造器中的 setState(-1)，正因为前面设置了 state 为 -1 所以在 unlock() 之前，获得锁的 CAS 操作肯定都会失败，当然这也是为了在任务启动前不会被打断，所以在这里 unlock() 就又将 state 设置为了 0 也就表示可以通过 CAS 获得锁了，也可以被 shutdown 打断了。\n\n🔸 然后这个线程就会执行 worker 中的任务，如果 worker 中任务为空就会从阻塞队列中获取任务\n\n🔸 获取到任务后进入循环先进行 lock() 操作，这就代表已经开始执行任务了，这个时候 shutdown 就无法发送中断信号中断这个线程执行 （注意这个 lock 并不会和其他的 worker 互斥，因为每个 Worker 都是新 new 出来的，完全不相关的，他们的 state 状态都是独立的）\n\n🔸 `runStateAtLeast(ctl.get(), STOP)` 返回`ctl.get() >= STOP`  ，判断线程池是否正在关闭如果是就打断该线程，如果不是需要确保线程不是 Interrupt 状态\n\n`If pool is stopping, ensure thread is interrupted;  if not, ensure thread is not interrupted.`\n\n🔸`beforeExecute()` 和`afterExecute()` 都是空方法交给子类去实现的。\n\n🔸 到 finally 块里面就代表这个工作线程已经快要结束了，`processWorkerExit()`  就是处理一些\"后事\"的\n\n### getTask()\n\n这个方法就是用来从阻塞队列中获取任务的，如果 `getTask()` 返回 null，在`runWorker()` 里面接收到`null` 后就会**跳出循环**进而执行`finally` 块里面的`processWorkerExit()` 。而这也就意味着这个线程`执行结束`了，不会在执行任务了，剩下的就是等待 JVM 回收这个线程。\n\n```java\nprivate Runnable getTask() {\n    //是否超时？和 keepAliveTime 相关\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 如果线程池状态为 SHUTDOWN 并且任务队列没任务 或者 线程状态>=STOP\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        // 是否允许线程超时 允许核心线程超时（主动超时）？ 或者 wc 大于了核心线程数（被动超时）\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\t\t//此时需要回收多余的线程\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c)) //cas 减少线程数\n                return null; //返回 null\n            continue; //cas 失败 继续循环\n        }\n\n        try {\n            //根据 timed 判断是限时获取还是直接获取\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take(); //阻塞的获取\n            if (r != null)\n                return r;\n            //没获取到，超时了\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n🔸 获取线程池状态，如果线程池状态为 SHUTDOWN 并且任务队列没任务 或者 线程状态>=STOP 就通过 CAS 自旋减少线程数，然后返回 null\n\n🔸 判断是否允许当前线程获取任务超时，如果允许核心线程超时就代表所有线程都会超时限制，又或者是当前线程数超过了核心线程数，也就是经过了扩容，所以核心线程之外的线程都是有超时限制的。\n\n🔸 如果 ① wc 超过最大线程数  ②没超过最大线程数，但是超时了并且此时 wc>1（留一个处理任务）③没超过最大线程数，但是超时了并且阻塞队列为空，此时需要回收多余的线程\n\n🔸 根据 timed 选取从阻塞队列中获取任务的方式，要么是限时获取的 poll 或者一直阻塞的 take，获取到了之后返回\n\n### processWorkerExit()\n\n看名字就知道是一个收尾的方法，执行线程结束后的一些必要收尾工作。\n\n```java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        //如果是因为异常而退出则 getTask() 没有机会去调整线程数所以需要在这里调整\n        decrementWorkerCount();  // wc--\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        //完成任务总数+=该 worker 完成的任务数\n        completedTaskCount += w.completedTasks;\n        //移除出线程集 workers\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n    \n    //尝试结束线程池\n    tryTerminate();\n    \n    //获取 ctl\n    int c = ctl.get();\n    if (runStateLessThan(c, STOP)) {\n        //非异常结束\n        if (!completedAbruptly) {\n            //最小值根据是否允许核心线程超时来判断\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1; //如果最小为 0 并且任务队列不为空则保证线程池中至少有一个线程执行这些任务\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        //1. 异常结束，新增加一个线程到线程池，相当于替换了异常的线程\n        //2. 非异常结束，工作线程小于核心线程，增加线程，确保在不允许核心线程超时的情况下线程数不小于 corePoolSize\n        addWorker(null, false);\n    }\n}\n```\n\n`runStateLessThan`  c < STOP 返回 true 就说明是`SHUTDOWN` 或者`RUNNING` ，到这里该工作线程（Worker）的生命周期就结束了。\n\n### 工作线程的生命周期\n\n![mark](http://static.imlgw.top/blog/20190803/NbjiMxDqJlu4.png?imageslim)\n\n### tryTerminate()\n\n在上面的处理收尾工作的`processWorkerExit()` 的时候中间调用了一个 `tryTerminate()` 方法\n\n```java\nfinal void tryTerminate() {\n    for (;;) {\n        int c = ctl.get();\n        //如果是在 RUNNING 状态 直接 return\n        //如果已经是 TIDYING 或者 TERMINATED 状态 直接 return\n        //如果是 SHUTDOWN 状态并且阻塞队列中还有任务 直接 return\n        //return 就说明线程池还不到关闭的时候\n        if (isRunning(c) ||\n            runStateAtLeast(c, TIDYING) ||\n            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))\n            return;\n        //到这里就说明要么是 STOP 状态，要么是 SHUTDOWN 状态阻塞队列也没任务了\n        if (workerCountOf(c) != 0) { // Eligible to terminate\n            //中断一个空闲的 worker 线程\n            interruptIdleWorkers(ONLY_ONE);\n            return;\n        }\n\t\t\n        //wc==0 没有线程存活了\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            //CAS 自旋 修改线程池状态为 TIDYING\n            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {\n                try {\n                    terminated(); //空方法，交给子类去实现的\n                } finally {\n                    //设置状态为 TERMINATED\n                    ctl.set(ctlOf(TERMINATED, 0));\n                    //唤醒 termination 上 awiat 的线程\n                    termination.signalAll();\n                }\n                return;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n        // else retry on failed CAS\n    }\n}\n```\n\n这里最后的`termination.signalAll()` 实际上是唤醒的`awaitTermination()` 方法阻塞的线程\n\n```java\npublic boolean awaitTermination(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (;;) {\n            if (runStateAtLeast(ctl.get(), TERMINATED))\n                return true;\n            if (nanos <= 0)\n                return false;\n            //限时等待\n            nanos = termination.awaitNanos(nanos);\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n### shutdown()\n\n```java\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        //CAS 自旋设置线程池状态为 SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        //打断 idle（空闲）的 worker\n        interruptIdleWorkers(); \n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n```\n\n这里关键的就是这个打断空闲线程的操作。\n\n### interruptIdleWorkers()\n\n打断空闲的 worker，这里的空闲线程其实指的就是在阻塞队列上获取不到任务而阻塞的线程\n\n经过上面的分析我们知道 Worker 会不断的从阻塞队列中去拿任务也就是 `getTask()` 方法，如果阻塞队列为空就会阻塞住 直到有任务提交到阻塞队列中，或者执行线程被中断。\n\n这里我们是要 SHUTDOWN 那阻塞队列中肯定是不会再有任务提交，所以`take()` 会阻塞住，所以我们就只能通过打断执行线程的方式来打断`take()` 操作，否则会一直阻塞，线程池无法关闭。\n\n```java\nprivate void interruptIdleWorkers(boolean onlyOne) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock(); //加锁，因为 Wokers 是 HashSet 是线程不安全的\n    try {\n        for (Worker w : workers) {\n            Thread t = w.thread;\n            //没有被打断并且没有在工作（空闲）\n            if (!t.isInterrupted() && w.tryLock()) {\n                try {\n                    //打断 Worker 里面的线程\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            //只打断一个就直接 break\n            if (onlyOne)\n                break;\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n🔸首先获取了 mainLock 保证了 workers 的线程安全避免产生并发修改异常。\n\n🔸然后遍历 workers，打断那些没有被打断并且没有工作的线程，那这里怎么知道线程是不是在工作呢？\n\n别忘了前面提到的 Worker 类借助 AQS 实现了一个`不可重入`的`lock` 方法，而在 worker 执行任务的时候会执行 `lock` 加锁，所以在这里`tryLock()` 如果返回`true`则说明 并没有在工作可以打断，反之如果正在工作`tryLock()` 不可重入，无法获取到自己持有的锁返回 false，所以线程肯定是在工作状态所以不应该打断，这些线程会在执行完任务后自行了断，因为线程池状态已经设置为`SHUTDOWN` 当然前提是这些任务是**可终止的**\n\n🔸打断后释放`tryLock()`获取到的锁\n\n🔸如果只打断一个就直接 break，否则就继续下一轮循环\n\n🔸释放 mianLock\n\n> 瞎猜：这里可以通过 getState 判断线程状态但是有可能在执行任务的过中阻塞\n\n### shutdownNow()\n\n和上面的 shutdown() 一样都是用来关闭线程池的但是看方法名就知道这个比较粗暴，shutdownNow 立刻马上关闭，一点情面都不给😂，虽然说是打断所有的线程但是毕竟使用的是`Interrupt` ，也许别人正在执行的线程根本就不会理你😂，所以在提交任务的时候要对任务进行正确的 interrupt 响应，或者确保线程不会一直阻塞否则线程池就无法正常关闭\n\n```java\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        //CAS 自旋设置状态为 STOP\n        advanceRunState(STOP);\n        //打断所有的线程包括正在工作的线程\n        interruptWorkers();\n        //排干阻塞队列，因为已经 STOP 了不会再执行队列里面的任务了\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    //尝试关闭线程池\n    tryTerminate();\n    return tasks;\n}\n```\n\n### interruptWorkers()\n\n```java\nprivate void interruptWorkers() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers)\n            //打断所有启动的线程\n            w.interruptIfStarted();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n打断了所有的启动的线程，即使他们可能不会响应这个 Interrupted 信号，但是由于线程池状态已经变为了 STOP，所以他们也活不长了（当然前提是执行的任务是可以结束的），在下一次获取任务的时候就会直接 return 。\n\n## 细节是魔鬼\n\n在群里面看见的问题，为什么线程池要用 线程不安全的 `HashSet` 然后设置了一个 `mainLock` 控制并发，而不是直接使用线程安全的并发集合？\n\n这一点其实在源码的注释中已经说的很清楚了，之前一直没有注意到\n\n```java\n    /**\n     * Lock held on access to workers set and related bookkeeping.\n     * While we could use a concurrent set of some sort, it turns out\n     * to be generally preferable to use a lock. Among the reasons is\n     * that this serializes interruptIdleWorkers, which avoids\n     * unnecessary interrupt storms, especially during shutdown.\n     * Otherwise exiting threads would concurrently interrupt those\n     * that have not yet interrupted. It also simplifies some of the\n     * associated statistics bookkeeping of largestPoolSize etc. We\n     * also hold mainLock on shutdown and shutdownNow, for the sake of\n     * ensuring workers set is stable while separately checking\n     * permission to interrupt and actually interrupting.\n     */\n    private final ReentrantLock mainLock = new ReentrantLock();\n\n```\n\n一开始还挺抗拒的，感觉有的地方有的看不懂（英语渣渣留下眼泪）然后去 stackoverflower 上看了一下找到了一个答案  [Using ReentrantLock in ThreadPoolExecutor to ensure thread-safe workers](https://stackoverflow.com/questions/31942117/using-reentrantlock-in-threadpoolexecutor-to-ensure-thread-safe-workers) \n\n大概总结一下就是两点\n\n1. 避免 “中断风暴” ，如果是用的显式锁那么如果有 10 个线程同时去执行 shutdown 方法，那么 10 个线程会排队去执行`interruptIdleWorkers` ，如果使用并发安全的队列的话，在 10 个线程同时去执行 shutdown 方法，那么肯定会同时去 `interruptIdleWorkers` 也就是所谓的中断风暴\n\n   > [中断风暴（维基百科）](https://en.wikipedia.org/wiki/Interrupt_storm) 中文几乎搜不到相关资料，其实就是字面意思，而太多的中断请求会的影响系统的整体性能，不得不说大师就是大师，细节之处则更能体现水平，我等也只能膜拜了\n\n2. 另一点就是为了方便统计线程池的一些信息比如 `largestPoolSize` 等，这点也好理解，使用并发的 Set 只能保这个 set 的并发安全，而对于其他的一些线程池的相关的信息统计起来就比较麻烦，可能又需要另外的加锁，所以索性就直接搞一个全局的锁，一举两得\n\n## ThreadPoolExecutor 使用\n\n### 构造方法\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n\n其实从中也可以看出对各个参数的一些限制。\n\n**corePoolSize：**核心池的大小，这个参数与后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了`prestartAllCoreThreads()`或者`prestartCoreThread()`方法，从这 2 个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。`默认情况下`，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中\n\n**maximumPoolSize：**线程池最大线程数，它表示在线程池中最多允许创建多少个线程\n\n**keepAliveTime**：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当`线程池中的线程数大于 corePoolSize 时`，keepAliveTime 才会起作用，直到线程池中的线程数不大于 corePoolSize：即当线程池中的线程数大于`corePoolSize`时，如果一个线程空闲的时间达到 keepAliveTime，则会终止，直到线程池中的线程数不超过 corePoolSize，但是如果调用了`allowCoreThreadTimeOut(boolean)`方法，在线程池中的线程数不大于 corePoolSize 时，keepAliveTime 参数也会起作用，直到线程池中的线程数为 0，这些内容其实在上面的深入源码中都有过分析。\n\n**unit：**参数 keepAliveTime 的时间单位\n\n**workQueue**：一个阻塞队列，用来存储等待执行的任务，这个参数的选择会对线程池的运行过程产生重大影响\n\n**threadFactory**：线程工厂，主要用来创建线程（根据传进来的 Runnable/Callable)\n\n**handler**：表示当拒绝处理任务时的策略，有以下四种取值\n\n- **ThreadPoolExecutor.AbortPolicy** 丢弃任务并抛出 RejectedExecutionException 异常。 \n- **ThreadPoolExecutor.DiscardPolicy** 也是丢弃任务，但是不抛出异常。 \n- **ThreadPoolExecutor.DiscardOldestPolicy** 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n- **ThreadPoolExecutor.CallerRunsPolicy**  由调用线程处理该任务 \n\n### 线程池的关闭\n\n`shutdown()`  `shutdownNow()` ，上面已经分析过了，就不再过多介绍了。\n\n### 工厂方法\n\n上面的构造器中一共有 7 个参数，可见要构造一个线程池并非那么容易，所以 jdk 在`Executors` 类中为我们提供了一些工厂方法，可以直接构造一些特定的线程池。\n\n**newCachedThreadPool()**\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n可以看到`core`为 0，最大值为`Integer.MAX_VALUE`，任务队列使用的`SynchronousQueue` ，这个队列是一个很奇葩的阻塞队列，实际上它不是一个真正的队列，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作，只有两个都准备好的时候才不会阻塞，所以它内部不会为队列元素维护空间，也就是说并不会缓存任务，一旦提交了 (put) 任务，要么就由空闲线程去执行 (take)，要么创建一条新线程去执行 (take)。\n\n**newFixedThreadPool()**\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n可以看到，最大值和 core 都是 `nThread` ，也就是最多`nThread`个线程，阻塞队列采用 `LinkedBlockQueue` \n\n**newSingleThreadExecutor()**\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n等价于`newFixedThreadPool(1)` ，但是这里的返回值经过了一层包装 返回的不再是`ThreadPoolExecutor` 也就是不会再有那些扩展的 monitor 方法\n\n> A wrapper class that exposes only the ExecutorService methods  of an ExecutorService implementation.\n>\n\n类似的方法其实还有一些，像`newWorkStealingPool` 等，感兴趣可以自己去查一查。\n\n其实这里阿里巴巴 Java 开发规范并不建议使用工厂方法创建线程\n\n![mark](http://static.imlgw.top/blog/20190806/lMVPdlPqEPNO.png?imageslim)\n\n所以建议还是通过构造器的方式去创建线程，这样也更加灵活更加可控。","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"JUC 并发工具包","url":"/2019/07/24/7187a079/","content":"\n## CountDownLatch\n\n结合前面的知识，我们知道`Thread.join()`可以实现一个线程等待另一个线程`结束`再执行，但是有时候我们可能并不需要等到另一个线程结束，只需要等待特定的操作结束后就可以，可能有人会说可以通过`wait/notify`模型来实现，但是其实我们可以采用更加方便的工具类也就是 `java.util.concurrent.CountDownLatch`。\n\n| Constructor and Description                                  |\n| ------------------------------------------------------------ |\n| `CountDownLatch(int count)`   构造一个以给定计数 `CountDownLatch` CountDownLatch。 |\n\n**案例**\n\n```java\npublic class CountDownLatchTest {\n\n    private static Random random=new Random(System.currentTimeMillis());\n\n    private static ExecutorService executor=Executors.newFixedThreadPool(2);\n\n    private static  CountDownLatch latch;\n\n    public static void main(String[] args) throws InterruptedException {\n        int  []data=query();\n        //构造器的参数代表需要执行的先决条件的数量\n        latch=new CountDownLatch(data.length);\n        for (int i = 0; i <data.length ; i++) {\n            executor.execute(new SimpleRunnable(data,i,latch));\n        }\n        latch.await();\n        //异步关闭\n        executor.shutdown();\n        System.out.println(\"all of works done \");\n\n    }\n\n    static class SimpleRunnable implements Runnable{\n        private final int []data;\n        private final int index;\n        private final CountDownLatch latch;\n\n        public SimpleRunnable(int[] data, int index, CountDownLatch latch) {\n            this.data = data;\n            this.index = index;\n            this.latch=latch;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(random.nextInt(2000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            int value=data[index];\n            if (value%2==0) {\n                data[index]=2*value;\n            }else{\n                data[index]=10*value;\n            }\n            System.out.println(Thread.currentThread().getName()+\" finished\");\n            latch.countDown();\n        }\n    }\n    \n    private static int[] query(){\n        return new int[]{1,2,3,4,5,6,7,8,9,10};\n    }\n}\n```\n\n`CountDownLatch`内部维护了一个未执行操作的计数器 `count`这个 count 需要通过构造器传入，CountDownLatch 实例的 countdown 方法每执行一次`count` 就会减一 ，在`count` 减为 0 之前`await` 方法的执行线程会被暂停，\n\n直到`count`减为 0 的时候才会被唤醒继续执行。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/24 15:09\n */\npublic class CountDownLatchTest2 {\n    private static int data;\n\n    public static void main(String[] args) throws InterruptedException {\n        final CountDownLatch latch=new CountDownLatch(4);\n\n        new Thread(() -> {\n            for (int i = 1; i <10; i++) {\n                data=i;\n                latch.countDown();\n                try {\n                    Thread.sleep(new Random().nextInt(1000));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        latch.await();\n        System.out.println(\"data:\"+data);\n    }\n}\n```\n\nCountDownLatch 传入的 count 为 4，循环执行了 10 次，结果是多少？当然是 4 了，当减为 0 的时候 await 调用就会返回不会再等待，后面即使 count 已经减为 0 再减也没有什么意义。\n\n### API\n\n| Modifier and Type | Method and Description                                       |\n| ----------------- | ------------------------------------------------------------ |\n| `void`            | `await()`   导致当前线程等到锁存器计数到零，除非线程是 interrupted 。 |\n| `boolean`         | `await(long timeout,  TimeUnit unit)`  使当前线程等待直到锁存器计数到零为止，除非线程为 interrupted 或指定的等待时间过去。 |\n| `void`            | `countDown()`   减少锁存器的计数，如果计数达到零，释放所有等待的线程。 |\n| `long`            | `getCount()`   返回当前计数。                                |\n| `String`          | `toString()`   返回一个标识此锁存器的字符串及其状态。        |\n\n## CyclicBarrier\n\n有时候多个线程可能需要相互等待对方执行到某一步然后再执行下一步。生活中就有很多这样的情形？比如相约爬山：大家约定好集合的地点然后等所有人到达指定的集合地点后再一起去，先到达的人需要等待后到达的人，只有所有人到齐后才会出发去爬山。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/24 15:54\n */\npublic class CyclicbarrierTest1 {\n    public static void main(String[] args){\n        CyclicBarrier cyclicBarrier=new CyclicBarrier(2);\n        new Thread(()->{\n            try {\n                //do something\n                Thread.sleep(2000);\n                System.out.println(\"t1 finished\");\n                cyclicBarrier.await();\n                System.out.println(\"other thread is done too\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(()->{\n            try {\n                //do something\n                Thread.sleep(6000);\n                System.out.println(\"t2 finished\");\n                cyclicBarrier.await();\n                System.out.println(\"other thread is done too\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n上面的代码就体现了这种情况，两个线程开始先分别做各自的事情，然后到达一个点之后，需要相互等待，先到达的等待后到达的，上面的例子中很显然 `t1` 先到达它需要等待`t2` 到达后才能继续运行。\n\n同时，如果外界是想要知道这个 CyclicBarrier 的任务执行情况可以在构造函数中加入一个回调的`Runnable`\n\n```java\nCyclicBarrier cyclicBarrier=new CyclicBarrier(2,()->{\n    System.out.println(\"t1,t2 both arrived\");\n});\n```\n\n这样的方式还是很优雅的。\n\n如果细心的话其实你还会发现相比上面的 CountDown 多了一个 BrokenBarrierException，我们来看看 doc\n\n如果有线程正在 waiting 而 Barrier 已经被 reset 了\n\n> If the barrier is {@link #reset} while any thread is waiting\n>\n> or if the barrier {@linkplain #isBroken is broken} when\n>\n> {@code await} is invoked, or while any thread is waiting, then\n>\n> {@link BrokenBarrierException} is thrown.\n\n如果某一个线程在 waiting 的时候被打断了，那么其他的 waiting 线程将会抛出这个异常\n\n>If any thread is {@linkplain Thread#interrupt interrupted} while waiting\n>\n>then all other waiting threads will throw\n>\n>{@link BrokenBarrierException} and the barrier is placed in the broken\n>\n>state.\n\n**源码解析**\n\n`CyclicBarrier`并没有借助 AQS 而是利用`Condition`条件变量来实现的，关于`Condition`后面会介绍。\n\n**doAwait()**\n\n```java\nprivate int dowait(boolean timed, long nanos)\n    throws InterruptedException, BrokenBarrierException,\n           TimeoutException {\n    final ReentrantLock lock = this.lock;\n    lock.lock(); //加锁\n    try {\n        final Generation g = generation;\n\n        if (g.broken)\n            throw new BrokenBarrierException();\n\n        if (Thread.interrupted()) {\n            breakBarrier();\n            throw new InterruptedException();\n        }\n\n        int index = --count; //和 countDownLatch 类似\n        if (index == 0) {  // tripped 所有线程都抵达了\n            boolean ranAction = false;\n            try {\n                final Runnable command = barrierCommand; \n                if (command != null)\n                    command.run(); //执行构造器中传入的 CallBack\n                ranAction = true;\n                nextGeneration(); //下一个轮回\n                return 0;\n            } finally {\n                if (!ranAction)\n                    breakBarrier();\n            }\n        }\n\n        // loop until tripped, broken, interrupted, or timed out\n        for (;;) {\n            try {\n                if (!timed)\n                    trip.await();\n                else if (nanos > 0L)\n                    nanos = trip.awaitNanos(nanos);\n            } catch (InterruptedException ie) {\n                if (g == generation && ! g.broken) {\n                    breakBarrier();\n                    throw ie;\n                } else {\n                    // We're about to finish waiting even if we had not\n                    // been interrupted, so this interrupt is deemed to\n                    // \"belong\" to subsequent execution.\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            if (g != generation)\n                return index;\n\n            if (timed && nanos <= 0L) {\n                breakBarrier();\n                throw new TimeoutException();\n            }\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n **nextGeneration()** \n\n```java\nprivate void nextGeneration() {\n    // signal completion of last generation\n    trip.signalAll(); //唤醒这个 barrier 上所有的等待线程，trip 是一个 condition\n    // set up next generation\n    count = parties; //count 复位\n    generation = new Generation();\n}\n```\n\n其实也可以用 CountDownLatch 实现和 CyclicBarrier 类似的功能，这里就不再演示。\n\n### API\n\n| Modifier and Type | Method and Description                                       |\n| ----------------- | ------------------------------------------------------------ |\n| `int`             | `await()`   等待所有 parties 到达屏障，并且在这个障碍上调用`await` 。 |\n| `int`             | `await(long timeout,  TimeUnit unit)`  等待所有 parties 已经在此屏障上调用  `await` ，或指定的等待时间过去。 |\n| `int`             | `getNumberWaiting()`   返回目前正在等待的线程的数量。        |\n| `int`             | `getParties()`   返回 parties                                 |\n| `boolean`         | `isBroken()`   查询这个障碍是否处于 Broken                    |\n| `void`            | `reset()`   将屏障重置为初始状态。                           |\n\n### 区别\n\n- `CountDownLatch`不能`reset`（递减到 0 后不能复原），`CyclicBarrier`正如其名是可以循环使用的。\n\n- `CountDownLatch`工作线程之间互不关心，`CyclicBarrier`所有线程必须到达一个共同的点才会继续执行\n\n## Exchanger\n\nJDK1.5 引入的，看名字就猜得到大概是干嘛的，主要就是用于`两个线程` 之间的数据交换，其实也就相当于只有两个参与方的`CyclicBarrier` 当两个线程都达到`exchanger point` （集合点） 就会进行数据的交换，`一手交钱，一手交货` 所以在使用的时候也要注意两个线程能否正确的到达`exchanger point` 如果有一方无法到达则另一方就会陷入等待，当然你可以加上 timeout。另外这个只适用与两个线程，如果有 2 个以上的线程参与将会造成数据传输混乱，无法控制。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 13:54\n */\npublic class ExchangerTest1 {\n    public static void main(String[] args) {\n        final Exchanger<String> exchanger=new Exchanger<>();\n        new Thread(()->{\n            System.out.println(Thread.currentThread().getName()+\" start\");\n            try {\n                String res = exchanger.exchange(\"i am  A\",10,TimeUnit.SECONDS);\n                System.out.println(\"back msg=\" +res);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (TimeoutException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\"done\");\n        }).start();\n\n        new Thread(()->{\n            System.out.println(Thread.currentThread().getName()+\" start\");\n            try {\n                String res = exchanger.exchange(\"i am  B\");\n                System.out.println(\"back msg=\" +res);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\"done\");\n        });\n    }\n}\n```\n\n### 线程安全问题\n\n确实 Exchanger 如果使用不当会造成很多问题，所以在使用的时候一定要谨慎，首先它只适用与两个线程之间传输数据，其次这里传输的对象是`同一个` ，也就是说发送端和接收端的对象内存地址是一样的是一个对象。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 15:14\n */\npublic class ExchangerTest2 {\n    public static void main(String[] args) {\n        final Exchanger<Simple> exchanger=new Exchanger<>();\n        new Thread(()->{\n            Simple simple = new Simple(1);\n            System.out.println(Thread.currentThread().getName()+\" start. send to B\"+simple);\n            try {\n                Simple res = exchanger.exchange(simple);\n                //休眠 10s\n                TimeUnit.SECONDS.sleep(3);\n                System.out.println(\"A receive from B obj:\"+res +\" data:\"+res.a);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\" done\");\n        },\"A\").start();\n\n        new Thread(()->{\n            Simple simple = new Simple(2);\n            System.out.println(Thread.currentThread().getName()+\" start. send to A:\"+simple);\n            try {\n                Simple res = exchanger.exchange(simple);\n                //修改发送出去的 obj\n                simple.setA(100000);\n                System.out.println(\"B receive from A obj:\"+res +\" data:\"+res.a);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\" done\");\n        },\"B\").start();\n    }\n\n    static class Simple{\n        private int a;\n\n        public Simple(int a) {\n            this.a = a;\n        }\n\n        public int getA() {\n            return a;\n        }\n\n        public void setA(int a) {\n            this.a = a;\n        }\n    }\n}\n```\n\n**结果**\n\n```java\nA start. send to Bjuc_study.tools.Exchanger.ExchangerTest2$Simple@72d6db17\nB start. send to A:juc_study.tools.Exchanger.ExchangerTest2$Simple@4295c176\nB receive from A obj:juc_study.tools.Exchanger.ExchangerTest2$Simple@72d6db17 data:1\nB done\nA receive from B obj:juc_study.tools.Exchanger.ExchangerTest2$Simple@4295c176 data:100000\nA done\n```\n\n两个线程拿到的是同一个对象并不是拷贝，两个线程同时的去操作这个对象这其实是很危险的很有可能就会产生一些线程安全问题，使用的时候一定要注意\n\n## Semaphore\n\n信号量，相信学过操作系统的同学肯定对这个很熟悉了，熟悉 PV 操作的话这个一看就懂了。\n\n| Constructor and Description                                  |\n| ------------------------------------------------------------ |\n| `Semaphore(int permits)`   创建一个 `Semaphore`与给定数量的许可证，默认非公平锁 |\n| `Semaphore(int permits,  boolean fair)`  创建一个 `Semaphore`与给定数量的许可证和是否公平 |\n\n### Semaphore 实现一个显示锁\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 15:48\n */\npublic class SemaphoreTest1 {\n    public static void main(String[] args) {\n        final SemaphoreLock semaphoreLock=new SemaphoreLock();\n\n        new Thread(()->{\n            try {\n                semaphoreLock.lock();\n                System.out.println(Thread.currentThread().getName()+\" get the lock\");\n                TimeUnit.SECONDS.sleep(4);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }finally {\n                semaphoreLock.unlock();\n                System.out.println(Thread.currentThread().getName()+\"release the lock\");\n            }\n\n        }).start();\n\n        new Thread(()->{\n            try {\n                semaphoreLock.lock();\n                System.out.println(Thread.currentThread().getName()+\" get the lock\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }finally {\n                semaphoreLock.unlock();\n                System.out.println(Thread.currentThread().getName()+\"release the lock\");\n            }\n\n        }).start();\n    }\n\n    static class SemaphoreLock{\n        private final  Semaphore semaphore =new Semaphore(1);\n\n        private void lock() throws InterruptedException {\n            semaphore.acquire();\n        }\n\n        public void unlock(){\n            semaphore.release();\n        }\n    }\n}\n```\n\n### 实现生产者消费者模型\n\n生产者消费者模型其实也挺重要的，有时候面试会让你手写一个生产者消费者模型，在之前的文章中其实有实现过一个但是那个其实还是很简单的一个，那个是没有 Buffer 的，下面这个用信号量实现的就是有 Buffer 的，后面会单独整理出所有的生产者消费者模型的实现方法。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 16:43\n */\npublic class ProduceConsumerV4 {\n    public static void main(String[] args) {\n        ProduceConsumerV4 pc = new ProduceConsumerV4();\n        Stream.of(\"Produce1\", \"Produce2\", \"Produce3\", \"Produce4\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.produce();\n                }\n            }, n).start();\n        });\n        Stream.of(\"Consumer1\", \"Consumer2\", \"Consumer3\", \"Consumer4\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.consumer();\n                }\n            }, n).start();\n        });\n    }\n\t\n    //buffer 载体\n    private LinkedList<Object> buffer=new LinkedList<>();\n\n    private final Semaphore full = new Semaphore(0);\n\t\n    //buffer 最大值\n    private final Semaphore empty = new Semaphore(3);\n\n    //互斥锁\n    private final Semaphore mutex= new Semaphore(1);\n\n    public void produce() {\n        //已经生产了\n        try {\n            empty.acquire();\n            //不能和上面的信号量交换\n            mutex.acquire();\n            buffer.add(new Object());\n            System.out.println(Thread.currentThread().getName() + \" produce a obj , current list size:\" +buffer.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            mutex.release();\n            full.release();\n        }\n    }\n\n    public void consumer() {\n        try {\n            full.acquire();\n            mutex.acquire();\n            //移除最后一个\n            buffer.removeLast();\n            System.out.println(Thread.currentThread().getName() + \" consumer a obj, current size: \" + buffer.size());//consumer\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            mutex.release();\n            empty.release();\n        }\n    }\n}\n```\n\n### API\n\n| Modifier and Type              | Method and Description                                       |\n| ------------------------------ | ------------------------------------------------------------ |\n| `void`                         | `acquire()`   从该信号量获取许可证，阻塞直到获取到，可以被 interrupt |\n| `void`                         | `acquire(int permits)`   从该信号量获取给定数量的许可证，阻塞直到获取到可以被 interrupt |\n| `void`                         | `acquireUninterruptibly()`  从该信号量获取许可证，阻塞直到获取到，无视 interrupt，不会被 interrupt |\n| `void`                         | `acquireUninterruptibly(int permits)`   从该信号量获取给定数量的许可证，阻止直到获取到，不可被 interrupt。 |\n| `int`                          | `availablePermits()`   返回此信号量中当前可用的许可数。      |\n| `int`                          | `drainPermits()`   获取并返回所有可立即获得的许可证。        |\n| `protected Collection<Thread>` | `getQueuedThreads()`   返回一个包含`可能`正在等待获取的线程的集合。 |\n| `int`                          | `getQueueLength()`   返回等待获取的线程数的估计值。          |\n| `boolean`                      | `hasQueuedThreads()`   查询是否有线程等待获取。              |\n| `boolean`                      | `isFair()`   是不是公平锁                                    |\n| `protected void`               | `reducePermits(int reduction)`   缩小可用许可证的数量。      |\n| `void`                         | `release()`   释放许可证，将其返回到信号量。(0 的时候也可以 release) |\n| `void`                         | `release(int permits)`   释放给定数量的许可证，将其返回到信号量。 |\n| `String`                       | `toString()`   返回一个标识此信号量的字符串及其状态。        |\n| `boolean`                      | `tryAcquire()`   从这个信号量获得许可证，立即返回，不会阻塞。 |\n| `boolean`                      | `tryAcquire(int permits)`   从这个信号量获取给定数量的许可证，不会阻塞 |\n| `boolean`                      | `tryAcquire(int permits,  long timeout, TimeUnit unit)`  从该信号量获取给定数量的许可证，如果在给定的等待时间获取到，就返回 true，可以被打断 |\n| `boolean`                      | `tryAcquire(long timeout,  TimeUnit unit)`  从该信号量获取许可证，如果在给定的等待时间获取到，就返回 true，可以被打断 |\n\n## Lock\n\n通常被称为显式锁，与之对应的`synchroized` 则被称为内部锁，显式锁是 jdk1.5 引入的锁，他的作用与内部锁相同，但是它的功能比内部锁更加强大，但是并不是内部锁的替代品，其实在之前的 [Java 多线程基础](http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/#LOCK%E6%8E%A5%E5%8F%A3)  一文中就手写过一个带有`限时等待`的锁 ，那个其实就是模仿的`Lock` 接口\n\n### ReentrantLock\n\nReentrantLock 是 Lock 接口的一个实现类也是用的最多的一个实现类，`Reentrant` 本意就是 可重入的，可再入的， 表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，`synchnorized`也是可重入的。\n\n| Constructor and Description                                  |\n| ------------------------------------------------------------ |\n| `ReentrantLock()`   创建一个 `ReentrantLock`的实例。         |\n| `ReentrantLock(boolean fair)`   根据给定的公平策略创建一个 `ReentrantLock`的实例。 |\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 20:07\n */\npublic class ReentrantLockTest1 {\n\n    private static final ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread0 = new Thread(() -> needLock() );\n        Thread thread1 = new Thread(() -> needLock() );\n        thread0.start();\n        thread1.start();\n        TimeUnit.SECONDS.sleep(3);\n        thread1.interrupt();\n    }\n\n    public static void needLock() {\n        try {\n            //可打断的获取锁\n            lock.lockInterruptibly();\n            System.out.println(Thread.currentThread().getName()+\" is get the lock\");\n            while (true){\n\t\t\t\t//空转\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock(); //确保锁的释放\n        }\n    }\n}\n```\n\n**测试结果**\n\n```java\nThread-0 is get the lock\njava.lang.InterruptedException\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)\n\tat java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)\n\tat juc_study.tools.Lock.ReentrantLockTest1.needLock(ReentrantLockTest1.java:26)\n\tat juc_study.tools.Lock.ReentrantLockTest1.lambda$main$1(ReentrantLockTest1.java:16)\n\tat java.lang.Thread.run(Thread.java:748)\nException in thread \"Thread-1\" java.lang.IllegalMonitorStateException\n\tat java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)\n\tat java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)\n\tat juc_study.tools.Lock.ReentrantLockTest1.needLock(ReentrantLockTest1.java:34)\n\tat juc_study.tools.Lock.ReentrantLockTest1.lambda$main$1(ReentrantLockTest1.java:16)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n\n#### API\n\n| Modifier and Type              | Method and Description                                       |\n| ------------------------------ | ------------------------------------------------------------ |\n| `int`                          | `getHoldCount()`  当前线程调用 lock() 的次数 （重入的次数）      |\n| `protected Thread`             | `getOwner()`   返回当前拥有此锁的线程，如果没有，返回 `null` 。 |\n| `protected Collection<Thread>` | `getQueuedThreads()`   返回包含可能正在等待获取此锁的线程的集合。 |\n| `int`                          | `getQueueLength()`   返回等待获取此锁的线程数的估计值。      |\n| `protected Collection<Thread>` | `getWaitingThreads(Condition condition)`   返回包含可能在与此锁相关联的给定条件下等待的线程的集合。 |\n| `int`                          | `getWaitQueueLength(Condition condition)`   返回与此锁相关联的给定条件等待的线程数的估计。 |\n| `boolean`                      | `hasQueuedThread(Thread thread)`  查询给定线程是否等待获取此锁。 |\n| `boolean`                      | `hasQueuedThreads()`   查询是否有线程正在等待获取此锁。      |\n| `boolean`                      | `hasWaiters(Condition condition)`   查询任何线程是否等待与此锁相关联的给定条件。 |\n| `boolean`                      | `isFair()`   如果此锁的公平设置为 true，则返回 `true` 。      |\n| `boolean`                      | `isHeldByCurrentThread()`   查询此锁是否由当前线程持有。     |\n| `boolean`                      | `isLocked()`   查询此锁是否由任何线程持有。                  |\n| `void`                         | `lock()`   获得锁，不能被打断                                |\n| `void`                         | `lockInterruptibly()`   获得锁，可以被打断                   |\n| `Condition`                    | `newCondition()`   返回`Condition`用于这种用途实例`Lock`实例。 |\n| `String`                       | `toString()`   返回一个标识此锁的字符串以及其锁定状态。      |\n| `boolean`                      | `tryLock()`   尝试获取该锁，不会阻塞，直接返回，             |\n| `boolean`                      | `tryLock(long timeout,  TimeUnit unit)`  尝试在给定时间内获取锁，可以被打断 |\n| `void`                         | `unlock()`   释放锁。                                        |\n\n### ReadWriteLock\n\n看名字就知道是干啥的了，之前我们在 [多线程设计模式](http://imlgw.top/2019/04/09/java-duo-xian-cheng-li-mian-de-she-ji-mo-shi/#%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F) 中也提到了读写锁，并且实现了一个简易的读写锁。\n\n**读写锁案例**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/26 12:15\n */\npublic class ReadWriteLockTest1 {\n\n    private final static ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock(false);\n\n    private final static Lock readLock=readWriteLock.readLock();\n\n    private final static Lock writeLock=readWriteLock.writeLock();\n\n    private  static final List<Long> data=new ArrayList<>();\n\n    public static void main(String[] args) {\n        Thread thread0 = new Thread(() -> write());\n        thread0.start();\n\n        Thread thread1 = new Thread(() -> read());\n        thread1.start();\n\n        Thread thread2 = new Thread(() -> read());\n        thread2.start();\n    }\n\n    public static void write(){\n        try {\n            writeLock.lock();\n            data.add(System.currentTimeMillis());\n            TimeUnit.SECONDS.sleep(5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    public static void read(){\n        try {\n            readLock.lock();\n            data.forEach(System.out::println);\n            TimeUnit.SECONDS.sleep(5);\n            System.out.println(Thread.currentThread().getName()+\" ====\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            readLock.unlock();\n        }\n    }\n}\n```\n\n### 显式锁对比内部锁\n\n显式锁和内部锁都各有优缺点，谁也不能替代谁（这里的显式锁主要指`ReentrantLock`）。\n\n**特性上**\n\n- 显式锁支持公平锁（显式锁，内部锁默认都是非公平的）\n- 显式锁可以`tryLock()`无需等待，内部锁只能一直等待锁释放\n\n- 显式锁有带超时的`tryLock(long timeout,  TimeUnit unit)`。\n- 显式锁可以响应中断请求 `lockInterruptibly()`\n- 显式锁提供了一系列的方法对锁的相关信息监控，内部锁则没有\n- .........\n\n**性能上**\n\n其实很多人会认为`synchronized`性能很差，不如显式锁\n\n- jdk1.5 中，在高争用的情况下，确实显式锁要优于内部锁\n- jdk1.5 之后， 对内部锁进行了一些优化，包括 **锁消除**，**锁粗化**，**偏向锁**，和**适应性锁** （这些优化后面的文章会再做解释） 。这些优化使得内部锁的性能提升了很多，甚至在低争用情况下性能还要优于 显式锁。\n\n**使用上**\n\n- Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问。\n\n- Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用，而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。\n\n其实很明显内部锁相比显式锁使用起来要简单易用，所以保守一点默认优先使用内部锁，在需要显式锁的特性的时候再选用显式锁。\n\n## Condition\n\nCondition 对应的其实就是显式锁的通信方法，`Lock.newCondition()` 返回的就是一个 Condition 实例 \n\n`Condition`接口的`await()/signal()`  其实就对应了 `synchronize` 的 `wait()/notify()` ，但是相对于 `wait()/notify()`  Condition 接口解决了 **过早唤醒**  问题以及 `Object.wait(time)` 无法区分是否是由于等待超时还是被唤醒的问题。\n\n`Object.wait()/notify()`要求执行线程持有所属对象的内部锁，同样`Condition.await()/notify()`也需要线程持有**创建**该 Condition 的显式锁，`每个 Condition`实例内部都维护了一个等待队列，不同的 Condition 之间不会相互影响，这样一来就解决了过早唤醒的问题，对于生产者消费者问题我们可以分别给消费者和生产者创建一个 Condition，生产者通知消费者时候只会唤醒消费者，消费者通知生产者的时候也只会通知生产者。\n\n### 解决过早唤醒\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/26 15:09\n */\npublic class ConditionTest1 {\n\n    private static final ReentrantLock LOCK = new ReentrantLock();\n\n    private static final Condition pCondition = LOCK.newCondition();\n\n    private static final Condition cCondition = LOCK.newCondition();\n\n    private static LinkedList<Long> buffer = new LinkedList<>();\n\n    private static final Integer MAX_BUFFER = 5;\n\n    public static void main(String[] args) {\n        ConditionTest1 conditionTest1 = new ConditionTest1();\n        Stream.of(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\", \"p8\", \"p9\", \"p10\", \"p11\").forEach(name -> {\n            new Thread(() -> conditionTest1.produce(), name).start();\n        });\n\n        Stream.of(\"c1\", \"c2\", \"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\", \"c10\", \"c11\").forEach(name -> {\n            new Thread(() -> conditionTest1.consumer(), name).start();\n        });\n    }\n\n    public void produce() {\n        try {\n            LOCK.lock();\n            while (buffer.size() >= MAX_BUFFER) {\n                pCondition.await();\n            }\n            long l = System.currentTimeMillis();\n            buffer.add(l);\n            System.out.println(Thread.currentThread().getName() + \" produced \" + l + \" ,current buffer size \" + buffer.size());\n            //通知消费者\n            cCondition.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            LOCK.unlock();\n        }\n    }\n\n    public void consumer() {\n        try {\n            LOCK.lock();\n            while (buffer.size() == 0) {\n                cCondition.await();\n            }\n            Long aLong = buffer.removeLast();\n            System.out.println(Thread.currentThread().getName() + \" consumer \" + aLong + \" ,current buffer size \" + buffer.size());\n            //通知生产者\n            pCondition.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            LOCK.unlock();\n        }\n    }\n}\n```\n\n### 解决 Object.wait() 无法区分其返回原因\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/26 17:48\n */\npublic class ConditionTest2 {\n    private static final Object obj = new Object();\n\n    private static final ReentrantLock LOCK = new ReentrantLock();\n\n    private static final Condition condition = LOCK.newCondition();\n\n    private static boolean isReady = false;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        new Thread(() -> {\n            //3s+\n            Date date = new Date(System.currentTimeMillis() + 3000);\n            try {\n                LOCK.lock();\n                while (!isReady) {\n                    boolean b = condition.awaitUntil(date);\n                    if (!b) {\n                        System.out.println(\"Fucking t0!!!!!, i am timeout\");\n                        return;\n                    }\n                    System.out.println(\"oh i get the lock!!!\");\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                LOCK.unlock();\n            }\n        }, \"t1\").start();\n\n        TimeUnit.SECONDS.sleep(5);\n        \n        new Thread(() -> {\n            try {\n                LOCK.lock();\n                isReady = true;\n                condition.signal();\n            } finally {\n                LOCK.unlock();\n            }\n        }, \"t0\").start();\n    }\n}\n```\n\n可见** awaitUntil()** 是有一个返回值的，返回 true 则表示在等待时间内获取到了锁，反之则是因为超时。\n\n> 写这个 Demo 的时候是拿之前的改的，然后有一个地方的 notify 忘了改成 signal，然后一直抛异常。因为 condition 里面也有 wait/notify 方法所以使用的时候一定要注意不要调错了。\n\n### API\n\n| Modifier and Type | Method and Description                                       |\n| ----------------- | ------------------------------------------------------------ |\n| `void`            | `await()`   使当前线程等待直到发出信号或中断                 |\n| `boolean`         | `await(long time,  TimeUnit unit)`  使当前线程等待直到发出信号或中断，或指定的等待时间过去。 |\n| `long`            | `awaitNanos(long nanosTimeout)`   使当前线程等待直到发出信号或中断，或指定的等待时间过去。 |\n| `void`            | `awaitUninterruptibly()`   使当前线程等待直到发出信号。      |\n| `boolean`         | `awaitUntil(Date deadline)`  使当前线程等待直到发出信号或中断，或者指定的最后期限到达。 |\n| `void`            | `signal()`   唤醒一个等待线程。                              |\n| `void`            | `signalAll()`   唤醒所有等待线程。                           |\n\n## StampedLock\n\n`StampedLock`是`Java8`引入的一种新的锁机制，是对读写锁`ReentrantReadWriteLock`的增强，读写锁虽然分离了读和写的功能，使得读与读之间不互斥，但是读和写之间依然是互斥的，本质上仍然是悲观锁，如果有大量的读线程就会引起写线程的饥饿，而`StampedLock`则提供了一种乐观的读策略，这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会写线程\n\n### 悲观锁策略\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/28 13:47\n */\npublic class StampedLockTest1 {\n    \n    private static final StampedLock stampedLock = new StampedLock();\n\n    private final static List<Long> shareData = new ArrayList<>();\n\n    public static void main(String[] args) {\n        final ExecutorService executorService = Executors.newFixedThreadPool(10);\n        Runnable readRunnable = () -> {\n            while (true) {\n                read();\n            }\n        };\n\n        Runnable writeRunnable = () -> {\n            while (true) {\n                write();\n            }\n        };\n        executorService.submit(readRunnable);\n\n        executorService.submit(writeRunnable);\n\n    }\n\n    private static void read() {\n        long stamped = -1;\n        try {\n            stamped = stampedLock.readLock();\n            System.out.println(Thread.currentThread().getName() + \" read \" + shareData);\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            stampedLock.unlockRead(stamped);\n        }\n    }\n\n    private static void write() {\n        long stamp = -1;\n        try {\n            stamp = stampedLock.writeLock();\n            shareData.add(System.currentTimeMillis());\n            System.out.println(Thread.currentThread().getName() + \" Write \");\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            stampedLock.unlockWrite(stamp);\n        }\n    }\n}\n```\n\n其实这种方式就和`ReadWriteLock` 是等价的了。\n\n### 乐观读策略\n\n相对上面的方式，其实就是改变了读的策略\n\n```java\n    private static void read() {\n        long stamp = stampedLock.tryOptimisticRead(); //非阻塞\n        //暂存 res\n        String res=Thread.currentThread().getName() + \" read \" + shareData;\n        if (!stampedLock.validate(stamp)) {\n            try {\n                //验证失败，说明有线程进行了写操作，可能造成数据不一致\n                //进行锁升级，获取共享读锁\n                stamp = stampedLock.readLock();\n                //覆盖 res\n                res=Thread.currentThread().getName() + \" read \" + shareData;\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n        System.out.println(res);\n    }\n```\n\n先尝试获取乐观读锁（非阻塞）返回一个戳，然后进行读操作，缓存读的结果，然后根据前面返回的戳验证在此过程中是否有写线程被占用过，如果被占用过就表示数据可能不一致了，就需要转换成普通的`共享读锁` ，再次读取数据刷新结果，保证数据的一致性，最后释放锁。\n\n这里一开始被视频里面讲的搞懵了他写的是这样的\n\n```java\n    private static void read() {\n        long stamp = stampedLock.tryOptimisticRead(); //非阻塞\n        if (stampedLock.validate(stamp)) {\n            try {\n                stamp = stampedLock.readLock();\n                System.out.println(Thread.currentThread().getName() + \" read \" + shareData);\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n    }\n```\n\n然后就说这样比 ReadWriteLock 效率高很多，我越看越觉得不对劲，然后自己查了下，看了下官方的 Demo 发现他写的确实是错的。\n\nAPI 什么的就不多说了，这里如果想了解更多可以看看 [这篇文章](https://segmentfault.com/a/1190000015808032#articleHeader20)\n\n另外如果想看看性能对比的可以看看 [这篇文章](http://ifeve.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/)\n\n> 这里还要存个疑，最后的释放读锁之后到最后一步的时候不是也有可能有写线程进入么，那样不是也会造成数据不一致的情况么？ 因为源码上注释的 Demo 也是这样写的所以这里还是有点疑问的。\n\n### 需要注意的地方\n\n- 所有获取锁的方法，都返回一个邮戳（Stamp），Stamp 为 0 表示获取失败，其余都表示成功；\n- 所有释放锁的方法，都需要一个邮戳（Stamp），这个 Stamp 必须是和成功获取锁时得到的 Stamp 一致；\n\n-  StampedLock 是不可重入的 （如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁），所以这就要我们开发人员不要去修改返回的戳或者让它逃逸出去\n-  StampedLock 不支持 Condition\n\n## ForkJoin\n\nForkJoin 是 Java7 提供的原生多线程并行处理框架，其基本思想是将大任务分割成小任务，最后将小任务聚合起来得到结果。fork 是分解的意思，join 是收集的意思。它非常类似于 HADOOP 提供的 MapReduce 框架，只是 MapReduce 的任务可以针对集群内的所有计算节点，可以充分利用集群的能力完成计算任务。ForkJoin 更加类似于单机版的 MapReduce。\n\n### RecursiveTask\n\n**计算 sum 和**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/30 11:58\n */\npublic class RecursiveTest1 {\n\t\n    //这个值代表一个线程可以处理的最大数据，不能太小也不能太大\n    private final static int MAX_THRESHOLD=3;\n\n    public static void main(String[] args) {\n        final ForkJoinPool forkJoinPool=new ForkJoinPool();\n        ForkJoinTask<Integer> submit = forkJoinPool.submit(new CaculateRecursiveTask(0, 100));\n        try {\n            Integer integer = submit.get();\n            System.out.println(integer);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class CaculateRecursiveTask extends RecursiveTask<Integer>{\n\n        private final int start;\n        private final int end;\n\n        private CaculateRecursiveTask(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        @Override\n        protected Integer compute() {\n            if(end-start<=MAX_THRESHOLD){\n                return IntStream.rangeClosed(start,end).sum();\n            }else{\n                int mid=(start+end)/2;\n                CaculateRecursiveTask leftTask=new CaculateRecursiveTask(start,mid);\n                CaculateRecursiveTask rightTask=new CaculateRecursiveTask(mid+1,end);\n                //阻塞\n                leftTask.fork();\n                rightTask.fork();\n                //返回结果\n                return leftTask.join()+rightTask.join();\n            }\n        }\n    }\n}\n```\n\n### RecursiveAction\n\n**计算 sum 和**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/30 13:08\n */\npublic class RecursiveActionTest1 {\n\n    private final static int MAX_THRESHOLD=3;\n\n    private static AtomicInteger SUM=new AtomicInteger(0);\n\n    public static void main(String[] args) throws InterruptedException {\n        final ForkJoinPool forkJoinPool=new ForkJoinPool();\n        forkJoinPool.submit(new CalculateRecursiveAction(0, 100));\n        TimeUnit.SECONDS.sleep(3);\n        System.out.println(SUM.get());\n    }\n\n    private static class CalculateRecursiveAction extends RecursiveAction{\n\n        private final int start;\n        private final int end;\n\n        private CalculateRecursiveAction(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        @Override\n        protected void compute() {\n\n            if(end-start<=MAX_THRESHOLD){\n                SUM.addAndGet(IntStream.rangeClosed(start,end).sum());\n            }else{\n                int mid=(start+end)/2;\n                CalculateRecursiveAction leftTask=new CalculateRecursiveAction(start,mid);\n                CalculateRecursiveAction rightTask=new CalculateRecursiveAction(mid+1,end);\n                //阻塞\n                leftTask.fork();\n                rightTask.fork();\n            }\n        }\n    }\n}\n```\n\n## Phaser\n\nCountDownLatch 和 CyclicBarrier 都是 JDK 1.5 引入的，而 Phaser 是 JDK 1.7 引入的。Phaser 的功能与 CountDownLatch 和 CyclicBarrier 有部分重叠，同时也提供了更丰富的语义和更灵活的用法。\n\nPhaser 顾名思义，与阶段相关。Phaser 比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。这种场景可以使用多个 CyclicBarrier 来实现，每个 CyclicBarrier 负责等待一个阶段的任务全部完成。但是使用 CyclicBarrier 的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而 Phaser 可同时解决这两个问题。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/30 13:44\n */\npublic class PhaserTest1 {\n    public static void main(String[] args) {\n        final Phaser phaser = new Phaser();\n\n        Stream.of(\"t1\", \"t2\", \"t3\", \"t4\", \"t5\").forEach(name -> new Thread(new Task(phaser), name).start());\n        //注册 main 线程\n        phaser.register();\n        phaser.arriveAndAwaitAdvance();\n        System.out.println(\"all of work finished\");\n    }\n\n    static class Task implements Runnable {\n        private final Phaser phaser;\n\n        Task(Phaser phaser) {\n            this.phaser = phaser;\n            //动态增加\n            this.phaser.register();\n        }\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" is working\");\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            //\n            phaser.arriveAndAwaitAdvance();\n        }\n    }\n}\n```\n\n### API\n\n| Modifier and Type   | Method and Description                                       |\n| ------------------- | ------------------------------------------------------------ |\n| `int`               | `arrive()`   抵达这个移相器，而不用等待别人到达。            |\n| `int`               | `arriveAndAwaitAdvance()`   到达这个移相器，等待其他人。     |\n| `int`               | `arriveAndDeregister()`   到达这个移相器并从其中注销，而无需等待别人到达。 |\n| `int`               | `awaitAdvance(int phase)`   等待该相位器的相位从给定相位值前进，如果当前相位不等于给定相位值，则立即返回，或者该相位器被终止。 |\n| `int`               | `awaitAdvanceInterruptibly(int phase)`   等待该移相器的阶段从给定的相位值推进，如果在等待时 `InterruptedException`则抛出  `InterruptedException` ，或者如果当前相位不等于给定的相位值或者该相位器被终止，则立即返回。 |\n| `int`               | `awaitAdvanceInterruptibly(int phase,  long timeout, TimeUnit unit)`  等待该移相器的阶段从给定的相位值或给定的超时时间  `InterruptedException`到等待时抛出 `InterruptedException`  ，如果当前相位不等于给定的相位值，则立即返回，或者该相位器被终止。 |\n| `int`               | `bulkRegister(int parties)`   增加给定数量的新的有争议的派对到这个移相器。 |\n| `void`              | `forceTermination()`   强制此移相器进入终止状态。            |\n| `int`               | `getArrivedParties()`   返回在此移相器的当前阶段到达的已注册方的数量。 |\n| `Phaser`            | `getParent()`   返回此移相器的父级，如果没有，则返回 `null` 。 |\n| `int`               | `getPhase()`   返回当前相位数。                              |\n| `int`               | `getRegisteredParties()`   返回在此移动设备上注册的各方数量。 |\n| `Phaser`            | `getRoot()`   返回此移相器的根祖先，如果它没有父代，则与该移相器相同。 |\n| `int`               | `getUnarrivedParties()`   返回尚未到达此移相器当前阶段的已注册方的数量。 |\n| `boolean`           | `isTerminated()`   返回 `true`如果移相器已被终止。           |\n| `protected boolean` | `onAdvance(int phase,  int registeredParties)`  在即将进行的相位提前执行动作的可覆盖方法，并控制终止。 |\n| `int`               | `register()`   添加一个新的 unririved party 到这个移相器。     |\n| `String`            | `toString()`   返回一个标识此移相器的字符串及其状态。        |\n\n## 总结\n\n大致归纳了一些常见的并发工具，当然只是浅显的记录了一下怎样使用，原理部分还没有深入的了解，后续肯定会去研究底层实现源码包括`AQS`和`LockSupport`等等，其实越往后学就越想知道到底层是怎样个过程，到底是如何加锁如何解锁？CAS 又起到了什么作用？Synchnorized 底层又是如何实现？... 学无止境啊。JUC 除了这些并发工具外还有**线程池** ，**阻塞队列** 还没介绍，后面会继续介绍。","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"LeetCode 滑动窗口","url":"/2019/07/20/41e491de/","content":"\n## LeetCode 滑动窗口\n\n滑动问题包含一个滑动窗口，它是一个运行在一个大数组上的子列表，该数组是一个底层元素集合。假设有数组 [a b c d e f g h ]，一个大小为 3 的 **滑动窗口** 在其上滑动，则有：\n\n```java\n[a b c]\n  [b c d]\n    [c d e]\n      [d e f]\n        [e f g]\n          [f g h]\n```\n\n一般情况下就是使用这个窗口在数组的 **合法区间** 内进行滑动，同时 **动态地**记录一些有用的数据，很多情况下，能够极大地提高算法地效率。\n\n## [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)\n\n给定一个数组 *nums*，有一个大小为 *k* 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 *k* 内的数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口最大值。\n\n**示例：**\n\n```java\n输入：nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出：[3,3,5,5,6,7] \n解释：\n\n  滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n**注意：**\n\n你可以假设 *k* 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。\n\n**进阶：**\n\n你能在线性时间复杂度内解决此题吗？\n\n**解法一**\n\n```java\npublic static int[] maxSlidingWindow2(int[] nums, int k) {\n    //题目上说的不为空，还是给我来了个空。\n    if(nums.length==0){\n        return new int[]{};\n    }\n    if(k==1) return nums;\n    LinkedList<Integer> list=new LinkedList<Integer>();\n    int []res=new int[nums.length-k+1];\n    int index=0;\n    list.add(0);\n    for (int i=1;i<nums.length;i++) {\n        while(!list.isEmpty() && nums[list.getLast()]<nums[i]){\n            //小于 nums[i] 的元素，从右边（尾）出队列 , 控制最左边（头）最大\n            list.removeLast();\n        }\n        //然后将它加到队列中，从右边（尾）\n        list.addLast(i);\n        //如果队列溢出了就从右边移除一个（头）\n        if(i-list.getFirst()==k){\n            list.removeFirst();\n        }\n        if(i>=k-1){\n            res[index++]=nums[list.getFirst()];\n        }\n    }\n    return res;\n}\n```\n\n> 2020.2.9 回头看了下，这不是单调队列么😂（用堆也可以啦，不过既然要在头尾都操作，直接用队列会更方便）\n\n其实开始我也不会做，看了提示后搞了半天才弄出来，23ms，70%左右，思路就是利用一个双端队列（头尾都可以进出），队列中存**数组下标**，然后遍历数组，在进入队列时从右向左遍历队尾，将**小于当前元素**的队尾元素去除（因为已经没用了，后面的最大值不可能是它们），举个例子\n\n> [2，1，-1，3，......]  k=3 ，当读到** 3 **这个元素的时候，窗口再向右移动最大值肯定不会是右边的元素了，所以直接剔除他们，在纸上画一画就明白了\n\n然后很关键的一步就是什么时候移除最左边的元素，其实按照人的思路来想就是最左边的元素不在窗口内的时候，比如上面的例子，读到** 3 **的时候，**2 **其实就应该剔除了因为它已经不在窗口内了。用代码来描述就是\n\n`i-list.getFirst()==k`，i 代表**当前元素下标**，上面的例子** 3 **对应的** i **就是** 3**，**list.getFirst()=0**，刚好差为 k，就代表** 2 **已经超出窗口了应该移除了。\n\n其实这里我开始不是这样做的，我在队列里面存的不是元素索引，我存的是元素，然后在判断什么时候移除的时候发现判断不了，**index **也只是结果元素的下标，并不能代表队列最左元素的下标，对于数组存下标优先于存元素，多一个已知量有时候还是很方便的\n\n**解法二**\n\n属于对暴力法的优化吧，最坏情况下时间复杂度`O(NK)`，比如完全逆序的情况（2020.2.9 回顾 fix）\n\n```java\npublic static int[] maxSlidingWindow3(int[] nums, int k) {\n    //题目上说的不为空，还是给我来了个空。\n    int len = nums.length;\n    if (len == 0) return new int[]{};\n    if (len == 1) return new int[]{nums[0]};\n    int localMax = Integer.MIN_VALUE;\n    int[] result = new int[len - k + 1];\n    for (int i = 0; i < k; i++) {\n        //找到第一个窗口的最大值\n        localMax = max(nums[i], localMax);\n    }\n    result[0] = localMax;\n    for (int i = 1; i < len - k + 1; i++) {\n        //窗口的下一个元素 k=3 , i=1 下一个元素下标为 3\n        if (nums[i + k - 1] > localMax) {\n            //判断当前窗口最大值和下一个元素的大小\n            //如果比当前窗口的最大值还要大 就不用找了 就是它了\n            localMax = nums[i + k - 1];\n        } else if (nums[i - 1] == localMax) {\n            //下一个元素比当前窗口最大值小 而且很不巧\n            //当前最大值刚好是当前窗口的最左边的元素，也就是马上要超过窗口的元素\n            localMax = nums[i];\n            //所以就要重新找最大值\n            for (int x = i; x < i + k; x++) {\n                localMax = max(nums[x], localMax);\n            }\n        }\n        //剩下的请况就是 比当前最大值小，并且最大值不是最左边的元素（还没有出界），最大值不变\n        //copy 到结果中\n        result[i] = localMax;\n    }\n    return result;\n}\n\n//其实可以用 Math.max()\npublic static int max(int a,int b){\n    if(a>=b)return a;\n    return b;\n}\n```\n\n2ms，99%  提交记录这种做法是最快的😂，时间复杂度最坏应该是`O(NK)`\n\n## [5312. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/) \n\n给你一个整数数组 `arr` 和两个整数 `k` 和 `threshold` 。\n\n请你返回长度为 `k` 且平均值大于等于 `threshold` 的子数组数目。\n\n **示例 1：**\n\n```java\n输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n输出：3\n解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值）。\n```\n\n**示例 2：**\n\n```java\n输入：arr = [1,1,1,1,1], k = 1, threshold = 0\n输出：5\n```\n\n**示例 3：**\n\n```java\n输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n输出：6\n解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。\n```\n\n**示例 4：**\n\n```java\n输入：arr = [7,7,7,7,7,7,7], k = 7, threshold = 7\n输出：1\n```\n\n**示例 5：**\n\n```java\n输入：arr = [4,4,4,4], k = 4, threshold = 1\n输出：1\n```\n\n**提示：**\n\n- `1 <= arr.length <= 10^5`\n- `1 <= arr[i] <= 10^4`\n- `1 <= k <= arr.length`\n- `0 <= threshold <= 10^4`\n\n**解法一**\n\n19 双周赛的第 2 题，很简单的滑动窗口，枚举所有窗口计数就行了\n\n```java\npublic int numOfSubarrays(int[] arr, int k, int threshold) {\n    threshold*=k;\n    int sum=0;\n    int count=0;\n    for (int i=0;i<k;i++) {\n        sum+=arr[i];\n    }\n    for (int i=k;i<arr.length;i++) {\n        if (sum>=threshold) {\n            count++;\n        }\n        //0 1 2 3\n        sum+=arr[i];\n        sum-=arr[i-k];\n    }\n    return count;\n}\n```\n\n## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例 1:**\n\n```java\n输入：\"abcabcbb\"\n输出：3 \n解释：因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```java\n输入：\"bbbbb\"\n输出：1\n解释：因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```java\n输入：\"pwwkew\"\n输出：3\n解释：因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**解法一**\n\n这题其实很久以前（半年前）做过一次，当时用的方法很 low😂\n\n![mark](http://static.imlgw.top///20190503/zQ9MBrOhQm4S.png?imageslim)\n\n```java\npublic int lengthOfLongestSubstring(String s) {\n    char [] chars = s.toCharArray();\n    if (chars.length == 0) {\n        return 0;\n    }\n    int length = 1;\n    String temp=new String();\n    for (int i = 0; i <s.length()-1; i++) {\n        if(chars[i] != chars[i+1]) {\n            temp=s.substring(i, i+2);\n        } else continue;\n        for (int j = i+2; j < s.length(); j++) {\n            if (!temp.contains(chars[j]+\"\")) {\n                temp = s.substring(i, j+1);\n            } else break;\n        }\n        //Break 出来后判断是否是最长的 k\n        length=temp.length()>length?temp.length():length;\n    }\n    return length;\n}\n```\n\n我这种完全就是利用 api 暴力法，居然还跑过了，时间复杂度应该是 O(N3)，这题的 ac 率还是挺低的只有 29.3%\n\n**解法二**\n\n下面的是我下午重新做的\n\n```java\npublic static int lengthOfLongestSubstring4(String s) {\n    //边界问题永远不能忽略\n    //LinkedList<Integer> list=new LinkedList<>();\n    int length=s.length();\n    if(length==0) return 0;\n    int head=0,tail=0;\n    int max=1;\n    for (int i=1;i<length;i++) {\n        int index=i-1; //当前元素前一个元素下标\n        while(index>=head){\n            if(s.charAt(i)!=s.charAt(index)){\n                index--;\n            }else{\n                //按思路应该是把相等前所有元素移除，但是那样效率好低，所以这里我决定用数组模拟队列\n                head=index+1;\n                tail++;\n                break;\n            }\n            //从尾遍历到头仍然没有相等，可以添加到队列中\n            if(index==head-1){\n                tail++;\n                break;\n            }\n        }\n        //每次结束循环后 尾 index-头 index\n        max=tail-head+1 > max?tail-head+1:max;\n        //System.out.println(max);\n    }\n    return max;\n}\n```\n\n20ms 左右 80%左右，思路也比较清晰，遍历字符串，然后从后往前遍历字符串，判断当前字符串在前面有没有，有的话就将前面相等那个元素 (index) 前的元素都移除（窗口右移）\n\neg: `[head...index....tail] i`  向右移动`....index [head ... i]`\n\n把当前元素添加进来，时间复杂度是 O(N^2)，比上面单纯的暴力法要快多了，但是并不是最优解\n\n**解法三**\n\n上面的算法，其实还可以优化，每次判断前面有没有重复元素的时候可以直接用一个大小 256 的扩展 ASCII 码表数组来判断（前提是这些字符都在标准的 ASCII 字符中），`freq[s.charAt(i)]` 代表的就是 s.charAt(i) 这个字符在窗口内出现过没有，出现过就为 1，否则就是 0，这里如果 ASCII 不够其实也可以用 HashMap，查找效率也很高接近 O(1)\n\n```java\npublic int lengthOfLongestSubstring(String s) {\n    int length=s.length();\n    if(length==0) return 0;\n    int[] freq=new int[256]; //ASCII 码表\n    freq[s.charAt(0)]=1;\n    int head=0,tail=0;\n    int max=1;\n    while(head<length){\n        if(tail+1<length&&freq[s.charAt(tail+1)]==0){\n            //没有重复，右边界右移\n            tail++;\n            freq[s.charAt(tail)]++;\n        }else{\n            //逐渐缩减左边界，直到不再有重复元素\n            freq[s.charAt(head)]--;\n            head++;\n        }\n        max=max<tail-head+1?tail-head+1:max;\n    }\n    return max;\n}\n```\n这种做法最坏情况（没有重复的字符）下其实会遍历两遍数组 tail 先移动到尾部 head 随后有移动到尾部，但是比较好理解，解法四实际上就是对这里的优化，head 每次移动都是直接移动到上一个重复元素的位置，而不是一个一个的向右移\n\n**解法四**\n\n提交记录上最快的方法，理解起来有点费劲，现在回头看又看不懂了。\n\n```java\npublic int lengthOfLongestSubstring(String s) {\n    int n = s.length(), ans = 0;\n    //索引为元素值，这里因为元素都是字符转过来就是 askll 码，所以可以直接这样\n    int[] index = new int[128];\n    for (int j = 0, i = 0; j < n; j++) {\n        //如果字符 char 在没有出现过，index[char] 为 0，出现则 index[char] 是遍历出现的最后的 char 的位置\n        // index[s.charAt(j)] 是当前字符上一次出现的位置（从 1 开始）\n        i = Math.max(i,index[s.charAt(j)]);\n        //j - i + 1 就是舍弃 s.charAt(j) 重复出现之前字符的长度  如 abca, 当 s.charAt(j) == a 时，j - i + 1 就是 bca 的长度\n        //求最大值常规操作\n        ans = Math.max(ans, j - i + 1);\n        index[s.charAt(j)] = j + 1;\n        // 从 1 开始\n    }\n    return ans;\n}\n```\n\n这里最主要就是这个** i **的理解\n\n![mark](http://static.imlgw.top///20190503/Qcj2l3E0v5sN.png?imageslim)\n\n这个 i 不一定是当前元素上一次出现的位置，也有可能是离**当前**元素从右向左**最近**的**重复字符**的_位置_。而 index 中存的就是这个元素的索引位置+1，为什么要加 1？\n\n![mark](http://static.imlgw.top///20190503/N4GzYaft0suh.png?imageslim)\n\n主要是因为 i 的默认值是 0 而数组默认值也是 0，如果以 0 开始就会出现上面的情况。\n\n其实这两种算法也比较类似，只是后面判断字符是否出现过的方式不同，前者是直接遍历这个子串，后者是利用字符为索引，其值就是上一次出现的位置 (+1)，借此来计算长度。\n\n**回首掏**\n\n19/9/14，在网页上又写了一种不同的解法，属于解法 4 的变体（做的时候并没有想到解法 4），`freq[]` 数组索引是字符串，但是值是该字符在 s 中对应的索引，不会遍历两遍数组，left 可以通过索引直接跳到上一次出现的位置\n\n```java\npublic static int lengthOfLongestSubstring6(String s) {\n    if(s==null||s.length()<1) return 0;\n    if(s.length()==1) return 1;\n    int[] freq=new int[256];\n    int left=0,right=0,res=0;\n    Arrays.fill(freq,-1);\n    while(right<s.length()){\n        char sr=s.charAt(right);\n        //已经存在，并且在窗口内\n        if(freq[sr]!=-1 && freq[sr]>=left){\n            //System.out.println(left+\",\"+right+\",\"+freq[sr]);\n            res=Math.max(res,right-left);\n            left=freq[sr]+1;\n            freq[sr]=right;\n        }else{\n            res=Math.max(res,right-left+1);\n            freq[sr]=right;\n        }\n        right++;\n    }\n    return res;\n}\n```\n**回首掏 2**\n\n```java\npublic static int lengthOfLongestSubstring7(String s) {\n    if(s==null||s.length()<1) return 0;\n    if(s.length()==1) return 1;\n    int[] freq=new int[256];\n    int left=0,right=0,res=0;\n    //Arrays.fill(freq,-1);\n    while(right<s.length()){\n        char sr=s.charAt(right);\n        //已经存在（出现过）, 并且上一次出现在窗口内\n        if(freq[sr]!=0 && freq[sr]>=left){\n            //这里不包含 right, 所以不用加 1\n            res=Math.max(res,right-left);\n            //left 移动到重复位置元素的下一个\n            //因为 freq 的值是存的索引+1 所以这里不用+1\n            left=freq[sr];\n        }else{\n            //这里包含 right 所以需要加 1\n            res=Math.max(res,right-left+1);\n        }\n        //加 1 是为了区别 s 的第一个字符\n        freq[sr]=right+1;\n        right++;\n    }\n    return res;\n}\n```\n感觉对这题有很深的执念😅，对上面右优化了一下，但是其实还是上面的解法三比较简单，说到解法三，我又抽风改了一个 boolean 数组版本的\n\n```java\n//update: 2020.4.13 重写了一遍，代码更简洁了\npublic int lengthOfLongestSubstring(String s) {\n    if(s==null ||s.length()<=0) return 0;\n    boolean[] freq=new boolean[128];\n    int left=0,right=0;\n    int max=0;\n    while(left<=right && right<s.length()){\n        if(!freq[s.charAt(right)]){\n            max=Math.max(max,right-left+1);\n            freq[s.charAt(right++)]=true;\n        }else{\n            freq[s.charAt(left++)]=false;\n        }\n    }\n    return max;\n}\n```\n**_以上解法全部作废_**\n\n统一使用`for-while`结构，能用`for-if`的一定可以用`for-while`，反过来就不行\n\n```java\n//2020.5.5 根据自己总结的滑窗模板重写\npublic int lengthOfLongestSubstring(String s) {\n    if(s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int left=0;\n    int res=1;\n    boolean[] freq=new boolean[128];\n    for(int right=0;right<n;right++){\n        while(freq[s.charAt(right)]){\n            freq[s.charAt(left++)]=false; //left 不用限制\n        }\n        freq[s.charAt(right)]=true;\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n**最优解**\n\nmap 记录元素最后出现的位置，当重复的时候更新起点，只用遍历一遍\n```go\nfunc lengthOfLongestSubstring(s string) int {\n    if len(s)==0{\n        return 0\n    }\n    m:=make(map[rune]int)\n    start:=0\n    res:=0\n    for i,ch:=range s{\n        if idx,ok:=m[ch];ok && idx+1>start{\n            start=idx+1\n        }\n        m[ch]=i\n        res=Max(res,i-start+1)\n    }\n    return res\n}\n\nfunc Max(a,b int) int{\n    if a>b{\n        return a\n    }\n    return b\n}\n```\n\n## [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)\n\n给定一个整数数组和一个整数 *k*，判断数组中是否存在两个不同的索引 *i* 和 *j*，使得 **nums [i] = nums [j]**，并且 *i* 和 *j* 的差的绝对值最大（不超过）为 *k*。\n\n**示例 1:**\n\n```java\n输入：nums = [1,2,3,1], k = 3\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：nums = [1,0,1,1], k = 1\n输出：true\n```\n\n**示例 3:**\n\n```java\n输入：nums = [1,2,3,1,2,3], k = 2\n输出：false\n```\n\n**解法一**\n\n这题建议区看看原版的英文题，这里翻译过来有点误导人，应该是不超过 k，写个最大搞得我有点懵\n\n```java\npublic static Boolean containsNearbyDuplicate2(int[] nums, int k) {\n    int len=nums.length;\n    //if(k==35000) return false; 哈哈哈哈\n    if(len==0||k==0)return false;\n    for (int i=1;i<len;i++) {\n        int index=i-1;\n        while(i-index<=k){\n            //k 步之内\n            if(index<0){\n                break;\n            }\n            if(nums[i]==nums[index--]){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n暴力法，惨不忍睹，600ms，15%beats 。这题最好的做法还是借助 hash 表\n\n**解法二**\n\n```java\npublic static Boolean containsNearbyDuplicate3(int[] nums, int k) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    int len=nums.length;\n    if(len==0||k==0) return false;\n    for (int i=0;i<len;i++) {\n        if(map.containsKey(nums[i])){\n            int index=map.get(nums[i]);\n            if(i-index<=k) {\n                return true;\n            } else {\n                //大于 k 了那前面那个没用了\n                map.replace(nums[i],i);\n            }\n        } else {\n            map.put(nums[i],i);\n        }\n    }\n    return false;\n}\n```\n\n12ms，90%，其实效率的差距就在查找子串里有没有这个字符上，HashMap 的 containsKey 的效率比我们遍历的不知道高到那里去了，底层源码暂时还看不太懂，以后看的时候再专门来讲\n\n19.9.14 又做了一遍，直接在网页上写的，本来应该是 bugfree 的，结果减反了。\n\n```java\npublic static boolean containsNearbyDuplicate4(int[] nums, int k) {\n\tHashMap<Integer,Integer> hashMap=new HashMap<>();\n\tint left=0,right=0;\n\twhile(right<nums.length){\n\t\tif(hashMap.containsKey(nums[right])){\n\t\t\t//md, 重新做的时候这里减反了真是个 zz\n\t\t\tif(right-hashMap.get(nums[right])<=k){\n\t\t\t\treturn true;\n\t\t\t} else{\n\t\t\t\thashMap.put(nums[right],right);\n\t\t\t}\n\t\t}else{\n\t\t\thashMap.put(nums[right],right);\n\t\t}\n\t\tright++;\n\t}\n\treturn false;\n}\n```\n19.9.15 又做了一遍，这次代码写的很简洁，思路也不同了，直接利用 set 集合，维护一个大小为 k 的连续 set（窗口）\n\n```java\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashSet<Integer> set=new HashSet<>();\n    for (int i=0;i<nums.length;i++) {\n        if (!set.add(nums[i])) {\n            return true;\n        }\n        if (set.size()>k) {\n            set.remove(nums[i-k]);\n        }\n    }\n    return false;\n}\n```\n\n## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)\n\n给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0。\n\n**示例：** \n\n```java\n输入：s = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的连续子数组。\n```\n\n**进阶：**\n\n如果你已经完成了* O*(*n*) 时间复杂度的解法，请尝试 *O*(*n* log *n*) 时间复杂度的解法。\n\n**解法一**\n\n老规矩先上个慢的\n\n```java\npublic static int minSubArrayLen(int s, int[] nums) {\n    int len=nums.length;\n    if(len==0)return 0;\n    int minLen=Integer.MAX_VALUE;\n    for (int i=1;i<len;i++){\n        if(nums[i-1]>=s) return 1;\n        int index=i-1;\n        int sum=nums[i];\n        //累加前面的元素，直到大于 s 或者 index<0\n        while(sum<s&&index>=0){\n            sum+=nums[index--];\n        }\n        if(sum>=s){\n            minLen=minLen>i-index?i-index:minLen;\n        } else if(i==len-1){\n            return 0;\n        }\n    }\n    return minLen;\n}\n```\n\n这个是最开始想到了思路比较清晰，遍历数组然后逆序求和直到大于 S，要注意边界，比较慢，主要就是那个循环累加前面的元素会很耗费时间，111ms，14% beats🤣\n\n**解法二**\n\n```java\npublic static int minSubArrayLen2(int s, int[] nums) {\n    int len =nums.length;\n    if(len==0)return 0;\n    //窗口左右边界\n    int head=0,tail=-1;\n    int minLen=Integer.MAX_VALUE;\n    int sum=0;\n    // 2,3,1,2,4,3 | 7\n    while (tail<len) {\n        if(sum>=s){\n            minLen=minLen>tail-head+1?tail-head+1:minLen;\n            //System.out.println(minLen);\n            //删除头节点（左边界左移）\n            sum-=nums[head++];\n        } else{\n            //尾指针到达边界了\n            if(tail==len-1) break;\n            //尾节点++，（右边界右移）\n            sum+=nums[++tail];\n            //如果有元素大于 s 直接返回，节约时间\n            if(nums[tail]>=s){\n                return 1;\n            }\n        }\n    }\n    return minLen==Integer.MAX_VALUE?0:minLen;\n}\n```\n\n2ms ，99%beats，一对比差距就出来了，上面这种做法就是利用了滑动窗口的思想，很巧妙的利用了上一次计算的值，不用重复的计算累加和，上面的那种方法每次都会重新计算累加和，但是很多都是重复的计算，所以浪费了很多时间，要注意边界条件\n\n`2 3 1 2 4 3  s=7`\n\n![mark](http://static.imlgw.top///20190504/U9BTOJMRVhDO.jpg?imageslim)\n\n自己在纸上画一下就懂了\n\n**解法三**\n\n~~找到一个模板，统一一下写法~~\n\n```java\npublic static int minSubArrayLen3(int s, int[] nums) {\n    int len =nums.length-1;\n    if(len==0)return 0;\n    int head=0,tail=-1;\n    int minLen=Integer.MAX_VALUE;\n    int sum=0;\n    // 2,3,1,2,4,3 | 7\n    while (head<=len) {\n        if(tail+1<=len && sum<s){\n            sum+=nums[++tail];\n        }else{\n            sum-=nums[head++];\n        }\n        if(sum>=s){\n            minLen=minLen>tail-head+1?tail-head+1:minLen;\n        }\n    }\n    return minLen==Integer.MAX_VALUE?0:minLen;\n}\n```\n\n**Update(2020.5.4)**\n\n上面的这也配叫模板？下面的是重做的时候统一的写法\n\n```go\nvar INF = 1 << 31\n\nfunc minSubArrayLen(s int, nums []int) int {\n    left := 0\n    sum := 0\n    res := INF\n    for right := 0; right < len(nums); right++ {\n        sum += nums[right]\n        for sum >= s {\n            res = Min(res, right-left+1)\n            sum -= nums[left]\n            left++\n        }\n    }\n    if res == INF {\n        return 0\n    }\n    return res\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n## [面试题 57 - II. 和为 s 的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) \n\n输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n**示例 1：**\n\n```java\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n```\n\n**示例 2：**\n\n```java\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n```\n\n**限制：**\n\n- `1 <= target <= 10^5`\n\n**解法一**\n\n滑动窗口，根据等差数列前 n 项和求 sum，然后逐步的缩圈，右移\n\n```java\npublic int[][] findContinuousSequence(int target) {\n    List<int[]> res=new ArrayList<>();\n    int left=1,right=2;\n    int sum=0;\n    //9 right 最多到 5\n    while(left<=right && right<=(target+1)/2){\n        //等差数列前 n 项和\n        int n=right-left+1;\n        sum=left*n+n*(n-1)/2;\n        if(sum>target){\n            left++; //剔除一个小的\n        }else if(sum<target){\n            right++; //添加一个大的\n        }else{ //build 结果集\n            res.add(build(left,right));\n            left++;//窗口左移，剔除一个小的\n            right++; //回头重写发现这里还可以优化，右边界也可以扩大\n        }\n    }\n    return res.toArray(new int[0][0]);\n}\n\npublic int[] build(int left,int right){\n    int[] res=new int[right-left+1];\n    for(int i=left;i<=right;i++){\n        res[i-left]=i;\n    }\n    return res;\n}\n```\n这里其实并不是最优解，还有更好的数学解法，直接根据求和公式，枚举所有的长度，逆向求出所有的首项，这里后面有时间再来实现\n\n## [480. 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)\n\n中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。\n\n例如：\n\n```java\n[2,3,4]，中位数是 3\n[2,3]，中位数是 (2 + 3) / 2 = 2.5\n```\n\n给出一个数组 nums，有一个大小为 *k* 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。\n\n例如：\n\n给出 *nums* = `[1,3,-1,-3,5,3,6,7]`，以及 *k* = 3。\n\n```java\n窗口位置                      中位数\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n```\n\n 因此，返回该滑动窗口的中位数数组 `[1,-1,-1,3,5,6]`。\n\n**提示：**\n假设`k`是合法的，即：`k` 始终小于输入的非空数组的元素个数。\n\nhead 题，理清楚思路后也不难。\n\n```java\npublic static double[] medianSlidingWindow(int[] nums, int k) {\n    //看了一圈评论区，大概知道思路了，还是要排序\n    //List<Integer> list=new ArrayList<>(); 用链表还是不方便啊\n    int [] queue=new int[k];\n    int head=0,tail=k-1;\n    //头尾\n    double [] res=new double[nums.length-k+1];\n    for (int i=0;i<k;i++) {\n        queue[i]=nums[i];\n    }\n    Arrays.sort(queue);\n    printArray(queue);\n    if (k%2==0) {\n        res[0]=queue[(k-1)/2]/2.0+queue[(k-1)/2+1]/2.0;\n        //注意除小数 .。这里的测试用例 Integer 最大值，直接相加/2 会越界\n    } else {\n        res[0]=queue[k/2];\n    }\n    for (int i=k;i<nums.length;i++) {\n        //插入之前要移除上一次的头元素，这里用数组不好搞啊啊\n        //System.out.println(nums[i-k]);\n        deleHead(queue,nums[i-k]);\n        tail--;\n        //printArray(queue);\n        //二分找插入点\n        int index=binarySearch(queue,0,tail,nums[i]);\n        System.out.println(index);\n        tail++;\n        //插入元素，tail++;\n        for (int j=tail;j>index;j--) {\n            //后一个等于前一个，给插入的元素腾出位置\n            queue[j]=queue[j-1];\n        }\n        queue[index]=nums[i];\n        //求中点\n        if (k%2==0) {\n            res[i-k+1]=queue[head+(tail-head)/2]/2.0+queue[head+(tail-head)/2+1]/2.0;\n        } else {\n            res[i-k+1]=queue[head+(tail-head)/2];\n        }\n    }\n    return res;\n}\n\npublic static void deleHead(int []nums,int target){\n    for (int j=0,i=0;j<nums.length;j++,i++) {\n        if(nums[j]==target){\n            if (i==nums.length-1) {\n                return;\n            }\n            while(i<nums.length-1){\n                nums[i]=nums[i+1];\n                i++;\n            }\n            return;\n        }\n    }\n}\n\npublic  static int binarySearch(int []nums,int lo,int hi,int target){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]<target){\n            lo=mid+1;\n        } else if(nums[mid]>target){\n            hi=mid-1;\n        } else{\n            return mid;\n        }\n    }\n    return lo;\n}\n```\n\n根据评论区提供的思路，用数组实现了一遍，当时就感觉有问题，确实，最后 164ms ，27%，很慢了，我觉得主要问题就是那个删除头的操作，但是毕竟数组，没办法，随即改用链表\n\n```java\npublic static double[] medianSlidingWindow2(int[] nums, int k) {\n    //看了一圈评论区，大概知道思路了，还是要排序\n    List<Integer> list=new ArrayList<>();\n    int head=0,tail=k-1;\n    //头尾\n    double [] res=new double[nums.length-k+1];\n    //Arrays.sort(nums,0,k);\n    int []temp=new int[k];\n    for (int i=0;i<k;i++) {\n        temp[i]=nums[i];\n    }\n    Arrays.sort(temp);\n    for (int i=0;i<k;i++) {\n        list.add(temp[i]);\n    }\n    if (k%2==0) {\n        res[0]=list.get((k-1)/2)/2.0+list.get((k-1)/2+1)/2.0;\n    } else {\n        res[0]=list.get(k/2);\n    }\n    for (int i=k;i<nums.length;i++) {\n        //插入之前要移除上一次的头元素，这里用数组不好搞啊啊\n        //list.remove((Object)nums[i-k]); 直接删太慢了\n        int dele=binarySearch(list,0,k-1,nums[i-k]);\n        list.remove(dele);\n        //System.out.println(list);\n        //二分找插入点，找的区间为 [i-k+1, i-1]\n        //int head=i-k+1,tail=i-1;\n        int index=binarySearch(list,0,k-2,nums[i]);\n        System.out.println(index);\n        list.add(-1);\n        for (int j=k-1;j>index;j--) {\n            //后一个等于前一个，给插入的元素腾出位置\n            list.set(j,list.get(j-1));\n        }\n        list.set(index,nums[i]);\n        System.out.println(list);\n        //求中点\n        if (k%2==0) {\n            res[i-k+1]=list.get((k-1)/2) / 2.0 + list.get((k-1)/2+1)/2.0;\n        } else {\n            res[i-k+1]=list.get(k/2);\n        }\n    }\n    return res;\n}\npublic  static int binarySearch(List<Integer> list,int lo,int hi,int target){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(list.get(mid)<target){\n            lo=mid+1;\n        } else if(list.get(mid)>target){\n            hi=mid-1;\n        } else{\n            return mid;\n        }\n    }\n    return lo;\n}\n```\n\n47ms，70%左右，删除的时候利用二分删除，如果直接根据元素去删就跟数组效率差不多了。\n\n## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)\n\n给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。\n\n**示例：**\n\n```java\n输入：S = \"ADOBECODEBANC\", T = \"ABC\"\n输出：\"BANC\"\n```\n\n**说明：**\n\n- 如果 S 中不存这样的子串，则返回空字符串 \"\"。\n- 如果 S 中存在这样的子串，我们保证它是唯一的答案。\n\n**解法一**\n\n```java\npublic static String minWindow(String s, String t) {\n    int slen=s.length();\n    int tlen=t.length();\n    int l=0,r=0; //初始都为 0\n    int[] target=new int[256]; //A:1 B:1 C:1\n    int[] window=new int[256];\n    int count=0; //不同字符的数量\n    for (int i=0;i<tlen;i++) {\n        target[t.charAt(i)]++;\n    }\n    for (int a:target) {\n        if (a!=0) {\n            count++; //统计不同字符出现的次数\n        }\n    }\n    int match=0; //match 代表已经匹配的字符\n    int[] res=new int[]{0,Integer.MAX_VALUE};\n    while(r<slen){\n        char c=s.charAt(r); \n        if(target[c]!=0){ //在目标子串中存在\n            window[c]++; //window 对应的 char++\n            if(window[c]==target[c]){ //到达了目标串中该 char 所需的数量\n                match++;\n            }\n        }\n        r++;\n        while(l<r&&count==match) { //满足目标串，注意别越界\n            char d=s.charAt(l);\n            if (r-l<res[1]-res[0]) { //统计最小值\n                res[0]=l;\n                res[1]=r;\n            }\n            l++;\n            if (target[d]!=0) {\n                window[d]--;\n                if (window[d]<target[d]) {//左边界左移后不再满足目标串\n                    match--;\n                }\n            }\n        }\n    }\n    return res[1]==Integer.MAX_VALUE?\"\":s.substring(res[0],res[1]);\n}\n```\n10ms 86%，Hard 题，其实大致的思路还是有的，主要是不知道怎么去和目标串对比，没想到用一个`window`数组去对比，一致想的是在目标串的数组上做手脚，但是越想越复杂。太蠢了😅，这题其实也可以用一个 HashMap 来做，但是我看了下提交记录上的普遍都是 7,80ms，相对都比较慢，实际上题目没有明确的说明有特殊字符的话都是可以用一个** ASCII **数组来充当 HashMap 的，当然我这里用数组的时候相比 HashMap 要多了一步，需要统计不同字符出现的次数，不过这个操作也是常数级别的操作，并不耗时，整体时间复杂度 O(N+M)，NM 分别代表目标子串`t` 和源字符串 `p`的长度，首先遍历了`t` 然后滑动窗口，后面的滑动窗口左右边界最多移动 2M 次\n\n**Update**\n\n2020.4.15，在瞄了一眼之前做的之后按照之前的思路重写了一遍，感觉还行，有一个地方 WA 了一次\n\n```java\n//update: 2020.4.15\npublic String minWindow(String s, String t) {\n    if(s==null || t==null) return \"\";\n    int[] needMap=new int[128]; //需要的字符 map\n    int[] curMap=new int[128];  //已经匹配的字符 map\n    int needCount=0; //需要匹配的字符个数\n    for(int i=0;i<t.length();i++){\n        if(needMap[t.charAt(i)]==0){\n            needCount++;\n        }\n        needMap[t.charAt(i)]++;\n    }\n    int matchCount=0; //已经匹配的个数\n    int left=0,right=0;\n    int minLeft=0,maxRight=Integer.MAX_VALUE;\n    while(left<=right && right<s.length()){\n        char c=s.charAt(right);\n        if(needMap[c]!=0){\n            curMap[c]++;\n            if(curMap[c]==needMap[c]){\n                matchCount++;\n            }\n        }\n        while(left<=right && right<s.length() && matchCount==needCount){\n            if(right-left<maxRight-minLeft){\n                maxRight=right;\n                minLeft=left;\n            }\n            char cl=s.charAt(left);\n            if(curMap[cl]!=0){\n                curMap[cl]--;\n                //这里注意，WA 点，开始写的=0\n                if(curMap[cl]<needMap[cl]){\n                    matchCount--;\n                }\n            }\n            left++;\n        }\n        right++;\n    }\n    return Integer.MAX_VALUE==maxRight?\"\":s.substring(minLeft,maxRight+1);\n}\n```\n> 刷题的时候发现有一道很类似的题，[最小窗口子序列](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#857-%E6%9C%80%E5%B0%8F%E7%9A%84%E7%AA%97%E5%8F%A3%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LintCode%EF%BC%89) 唯一的区别就是这道题要求有序（子序列）\n\n## [632. 最小区间](https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/)\n\nDifficulty: **困难**\n\n你有 `k` 个升序排列的整数数组。找到一个**最小**区间，使得 `k` 个列表中的每个列表至少有一个数包含在其中。\n\n我们定义如果 `b-a < d-c` 或者在 `b-a == d-c` 时 `a < c`，则区间 [a,b] 比 [c,d] 小。\n\n**示例 1:**\n\n```java\n输入：[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n输出：[20,24]\n解释：\n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\n```\n\n**注意：**\n\n1.  给定的列表可能包含重复元素，所以在这里升序表示 >= 。\n2.  1 <= `k` <= 3500\n3.  -10<sup>5</sup> <= `元素的值` <= 10<sup>5</sup>\n\n**解法一**\n\n```golang\nfunc smallestRange(nums [][]int) []int {\n    var n = len(nums)\n    //列表中所有元素 k, 存在于那些数组中\n    var m = make(map[int][]int)\n    var Max = func (a, b int) int {if a > b {return a}; return b}\n    var Min = func (a, b int) int {if a < b {return a}; return b}\n    //记录最大最小值，然后在区间内滑窗，也可以直接将所有数组归并排一下，然后滑窗，比较麻烦，懒得写了\n    //所以下面的做法实际上是和循序无关的，没有用到有序这个条件\n    var maxV = math.MinInt32\n    var minV = math.MaxInt32\n    for i :=0; i < n; i++ {\n        for j := 0; j < len(nums[i]); j++ {\n            m[nums[i][j]] = append(m[nums[i][j]], i)\n            maxV = Max(maxV, nums[i][j])\n            minV = Min(minV, nums[i][j])\n        }\n    }\n    //同 76. 最小覆盖子串，这题可能思维的转换比较重要\n    var count = 0\n    var freq = make([]int, n+1)\n    var res =[]int{minV, maxV}\n    var left = minV\n    for right := minV; right <= maxV; right++ {\n        if lis, ok := m[right]; ok {\n            for _, numIdx := range lis {\n                freq[numIdx]++\n                if freq[numIdx] == 1{\n                    count++\n                }\n            }\n        }\n        for count == n && left <= right {\n            if right-left < res[1]-res[0] {\n                res[0] = left\n                res[1] = right\n            }\n            if lis, ok := m[left]; ok{\n                for _, numIdx := range lis {\n                    freq[numIdx]--\n                    if freq[numIdx] < 1 {\n                        count--\n                    }\n                }\n            }\n            left++\n        }\n    }\n    return res\n}\n```\n**解法二**\n\n上面的解法并不是最好的解法，没有用到有序的条件，比较好的解法应该是小根堆（本来打算用 Go 撸一个的，写一半感觉太麻烦了，不过整体小根堆的逻辑实现是对的，就是没有泛型要改很多东西，不太方便）\n![](https://i.loli.net/2020/11/30/Q5KsxNi3MquZtWE.png)\n维护两个最值，一个是找到一个能覆盖当前所有列表的最小的右端点（max），一个是当前列表最小的那个元素（最左的端点），然后不断缩减左端点求最小区间\n```java\nclass Node {\n    int i, j;\n    public Node (int i, int j) {\n        this.i = i;\n        this.j = j;\n    }\n}\n\n//k 组链表，平均 m 个元素，时间复杂度 O(kmlog(k))\npublic int[] smallestRange(List<List<Integer>> nums) {\n    PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> nums.get(a.i).get(a.j)-nums.get(b.i).get(b.j));\n    int INF = (int) 1e5+1;\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i < nums.size(); i++) {\n        pq.add(new Node(i, 0));\n        max = Math.max(max, nums.get(i).get(0));\n    }\n    int [] res = {-INF, INF};\n    while (true) {\n        Node cur = pq.poll();\n        //应该把 val 也存进去的，懒得改了\n        if (max-nums.get(cur.i).get(cur.j) < res[1]-res[0]) {\n            res[0] = nums.get(cur.i).get(cur.j);\n            res[1] = max;\n        }\n        if (cur.j+1 >= nums.get(cur.i).size()) {\n            break;\n        }\n        pq.add(new Node(cur.i, cur.j+1));\n        max = Math.max(max, nums.get(cur.i).get(cur.j+1));\n    }\n    return res;\n}\n```\n\n## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)\n\n给定一个字符串 **s** 和一个非空字符串 **p**，找到 **s** 中所有是 **p** 的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串 **s** 和 **p** 的长度都不超过 20100。\n\n**说明：**\n\n- 字母异位词指字母相同，但排列不同的字符串。\n- 不考虑答案输出的顺序。\n\n**示例 1:**\n\n```java\n输入：\ns: \"cbaebabacd\" p: \"abc\"\n输出：\n[0, 6]\n\n解释：\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。\n```\n\n **示例 2:**\n\n```java\n输入：\ns: \"abab\" p: \"ab\"\n\n输出：\n[0, 1, 2]\n\n解释：\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n```\n\n**解法一**\n\n这题和上面一题其实一样，只是这里要求是连续的，在上面一题的基础上在添加结果的时候判断下长度就 OK\n\n```java\npublic List<Integer> findAnagrams(String s, String p) {\n    int[] target=new int[256];\n    int[] window=new int[256];\n    int l=0,r=0;\n    int plen=p.length();\n    int slen=s.length();\n    int count=0,match=0;\n    List<Integer> res=new ArraysList<>();\n    for (int i=0;i<plen;i++) {\n        target[p.charAt(i)]++;\n    }\n    for (int a:target) {\n        if(a!=0){\n            count++;\n        }\n    }\n\n    while(r<slen){\n        char right=s.charAt(r);\n        if (target[right]!=0) {\n            window[right]++;\n            if (window[right]==target[right]) {\n                match++;\n            }\n        }\n        r++;\n        while(l<r && count==match){\n            char left=s.charAt(l);\n            if (r-l==res) {\n                res.add(l);\n            }\n            l++;\n            if (target[left]!=0) {\n                window[left]--;\n                //不满足了\n                if (window[left]<target[left]) {\n                    match--;\n                }\n            }\n        }\n    }\n    return res;\n}\n```\n**UPDATE:2020.7.23**\n\n用模板重写了下\n```golang\nfunc findAnagrams(s string, p string) []int {\n    var target = make([]int, 128)\n    var window = make([]int, 128)\n    var match = 0\n    for _, sp := range p {\n        if target[sp] == 0 {\n            match++\n        }\n        target[sp]++\n    }\n    var left = 0\n    var count = 0\n    var res []int\n    for right := 0; right < len(s); right++ {\n        if target[s[right]] > 0 {\n            window[s[right]]++\n            if window[s[right]] == target[s[right]] {\n                count++\n            }\n        }\n        for count == match && left <= right {\n            if right-left+1 == len(p) {\n                res = append(res, left)\n            }\n            if window[s[left]] > 0 {\n                window[s[left]]--\n                if window[s[left]] < target[s[left]] {\n                    count--\n                }\n            }\n            left++\n        }\n    }\n    return res\n}\n```\n15ms，86%时间复杂度`O(M+N)`，其实是完全套的之前最小覆盖子串的模板，不如肯定不好写这么长\n\n**解法二**\n\n正常的做法，实际上上面的解法一直在避免直接比较 target 和 window，但是实际上比较这两个数组的成本是很低的，两个数组长度固定，比较时间复杂度 O(1)，具体情况具体分析，不过套模板几乎是通用的\n```golang\nfunc findAnagrams(s string, p string) []int {\n    var left = 0\n    //-'a'看起来太丑了，直接 128\n    var target [128]int //注意用数组，可以直接比较\n    var window [128]int\n    for _, sp := range p {\n        target[sp]++\n    }\n    var res []int\n    for right := 0; right < len(s); right++ {\n        if target[s[right]] > 0 {\n            window[s[right]]++\n        }\n        for right-left+1 > len(p) {\n            if window[s[left]] > 0 {\n                window[s[left]]--\n            }\n            left++\n        }\n        if window == target {\n            res = append(res, left)\n        }\n    }\n    return res\n}\n```\n\n## [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)\n\n给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。\n\n换句话说，第一个字符串的排列之一是第二个字符串的子串。\n\n**示例 1:**\n\n```java\n输入：s1 = \"ab\" s2 = \"eidbaooo\"\n输出：True\n解释：s2 包含 s1 的排列之一 (\"ba\").\n```\n\n**示例 2:**\n\n```java\n输入：s1= \"ab\" s2 = \"eidboaoo\"\n输出：False\n```\n\n**注意：**\n\n1. 输入的字符串只包含小写字母\n2. 两个字符串的长度都在 [1, 10,000] 之间\n\n**解法一**\n\n这题其实是 [76. 最小覆盖子串](#76-最小覆盖子串) 的弱化版本，套路滑窗，但是有一些细节需要注意\n\n```java\npublic boolean checkInclusion(String s1, String s2) {\n    if(s1==null || s2==null || s1.length()>s2.length()){\n        return false;\n    }\n    int n1=s1.length();\n    int n2=s2.length();\n    int[] freq=new int[26];\n    int count=0;\n    for(int i=0;i<n1;i++){\n        int c=s1.charAt(i)-'a';\n        if(freq[c]==0){\n            count++;\n        }\n        freq[c]++;\n    }\n    int[] window=new int[26];\n    int match=0;\n    int left=0;\n    for(int right=0;right<n2;right++){\n        int cr=s2.charAt(right)-'a';\n        if(freq[cr]>0){\n            window[cr]++;\n            if(window[cr]==freq[cr]){\n                match++;\n            }\n        }\n        while(right-left+1>n1){\n            int cl=s2.charAt(left)-'a';\n            if(freq[cl]>0){\n                //WA 点，开始写错了\n                //window[cl]--;\n                if(window[cl]==freq[cl]){\n                    match--; //match--的前提是原本是匹配的\n                }\n                window[cl]--;\n            }\n            left++;\n        } \n        if(match==count){\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n一开始写完了，测试了用例发现都是对的，心里一喜，难道又 bugfree 了？提交，结果还是 WA 了🤣，debug 了半天，根据错误的哪个长 case 自己构造了一个短 case（长的不好 debug），然后发现了问题，这个问题我看见评论区也有人问到，顺手还回了一下😁，其实错误的原因就是套模板没套好，没理解模板的细节\n\n这里的核心问题就是`match--`的时候有一个大前提：`cl`字符已经匹配好了，也就是`window[cl]==freq[cl]`\n\n这个时候你`left++`将`cl`移除窗口，才能做`match--`操作，否则像之前的模板中\n\n```java\nif (target[left]!=0) {\n    window[left]--;\n    //不满足了\n    if (window[left]<target[left]) {\n        match--;\n    }\n}\n```\n\n这样写就有可能 window[left] 还没有匹配上，这个时候直接减就错了，之前的模板中缩圈都是在 match==count 的前提下缩圈的，所以没问题，都是匹配的，其实也可以像之前的模板一样写，就像下面这样\n\n```java\npublic boolean checkInclusion(String s1, String s2) {\n    if(s1==null || s2==null || s1.length()>s2.length()){\n        return false;\n    }\n    int n1=s1.length();\n    int n2=s2.length();\n    int[] freq=new int[26];\n    int count=0;\n    for(int i=0;i<n1;i++){\n        int c=s1.charAt(i)-'a';\n        if(freq[c]==0){\n            count++;\n        }\n        freq[c]++;\n    }\n    int[] window=new int[26];\n    int match=0;\n    int left=0;\n    for(int right=0;right<n2;right++){\n        int cr=s2.charAt(right)-'a';\n        if(freq[cr]>0){\n            window[cr]++;\n            if(window[cr]==freq[cr]){\n                match++;\n            }\n        }\n        //****************************\n        //主要就是这里不一样\n        while(match==count){\n            if(right-left+1==n1) return true;\n            int cl=s2.charAt(left)-'a';\n            if(freq[cl]>0){\n                window[cl]--;\n                if(window[cl]<freq[cl]){\n                    match--;\n                }\n            }\n            left++;\n        } \n        //****************************\n    }\n    return false;\n}\n```\n这样就不用考虑先减还是后减的问题了\n\n**解法二**\n\n这题其实还可以暴力做，窗口大小固定，每滑动一次就判断窗口和`freq`是不是相等，因为题目说了都是小写字母所以也是行得通的，只是常数会大一些，这里我就不写了，笔试推荐这样写，代码好写一点\n\n## [面试题 17.18. 最短超串](https://leetcode-cn.com/problems/shortest-supersequence-lcci/)\n\n假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。\n\n返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。\n\n**示例 1:**\n\n```java\n输入：\nbig = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]\nsmall = [1,5,9]\n输出：[7,10]\n```\n\n**示例 2:**\n\n```java\n输入：\nbig = [1,2,3]\nsmall = [4]\n输出：[]\n```\n\n**提示：**\n\n- `big.length <= 100000`\n- `1 <= small.length <= 100000`\n\n**解法一**\n\n也是属于 [76. 最小覆盖子串](#76-最小覆盖子串)的弱化，虽然解法都一样，没啥好说的，注意细节\n\n```java\n//没啥好说的，套模板就行了\npublic int[] shortestSeq(int[] big, int[] small) {\n    if(big==null || big.length<=0) {\n        return new int[0];\n    }\n    int slen=small.length;\n    int blen=big.length;\n    int[] res=new int[2];\n    res[0]=-1;res[1]=-1;\n    int min=Integer.MAX_VALUE;\n    HashSet<Integer> set=new HashSet<>();\n    for(int i:small) set.add(i);\n    HashMap<Integer,Integer> window=new HashMap<>();\n    int match=0;\n    int left=0;\n    for(int right=0;right<blen;right++){\n        int wr=big[right];\n        if(set.contains(wr)){\n            window.put(wr,window.getOrDefault(wr,0)+1);\n            if(window.get(wr)==1){\n                match++;\n            }\n        }\n        while(match==slen){\n            if(right-left+1<min){\n                res[0]=left;\n                res[1]=right;\n                min=right-left+1;\n            }\n            int wl=big[left];\n            if(set.contains(wl)){\n                window.put(wl,window.get(wl)-1);\n                if(window.get(wl)==0){\n                    match--;\n                }\n            }\n            left++;\n        }\n    }\n    return res[0]==-1?new int[0]:res;\n}\n```\n\n## [1004. 最大连续 1 的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)\n\n给定一个由若干 `0` 和 `1` 组成的数组 `A`，我们最多可以将 `K` 个值从 0 变成 1 。\n\n返回仅包含 1 的最长（连续）子数组的长度。\n\n**示例 1：**\n\n```java\n输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2\n输出：6\n解释： \n[1,1,1,0,0,1,1,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 6。\n```\n\n**示例 2：**\n\n```java\n输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\n输出：10\n解释：\n[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 10。\n```\n\n**提示：**\n\n1. `1 <= A.length <= 20000`\n2. `0 <= K <= A.length`\n3. `A[i]` 为 `0` 或 `1` \n\n**解法一**\n\n这题其实下面一题 [424. 替换后的最长重复字符](#424-替换后的最长重复字符)的弱化版本\n\n```java\n//简单的滑窗\npublic int longestOnes(int[] A, int K) {\n    if(A==null || A.length<=0) return 0;\n    int N=A.length;\n    int left=0,res=0,countA=0;\n    for(int right=0;right<N;right++){\n        countA+=(A[right]&1);\n        //if 也可以，个人喜欢 while 通用性更强\n        while(right-left+1-countA>K){ \n            countA-=(A[left++]&1);\n        }\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n按照模板来写简直是信手拈来（其实也没有什么模板，就是规范了写法而已）\n\n## [5434. 删掉一个元素以后全为 1 的最长子数组](https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/)\n\nDifficulty: **中等**\n\n给你一个二进制数组 `nums` ，你需要从中删掉一个元素。\n\n请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。\n\n如果不存在这样的子数组，请返回 0 。\n\n**提示 1：**\n\n```java\n输入：nums = [1,1,0,1]\n输出：3\n解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [0,1,1,1,0,1,1,0,1]\n输出：5\n解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,1,1]\n输出：2\n解释：你必须要删除一个元素。\n```\n\n**示例 4：**\n\n```java\n输入：nums = [1,1,0,0,1,1,1,0,1]\n输出：4\n```\n\n**示例 5：**\n\n```java\n输入：nums = [0,0,0]\n输出：0\n```\n\n**提示：**\n\n*   `1 <= nums.length <= 10^5`\n*   `nums[i]` 要么是 `0` 要么是 `1` 。\n\n**解法一**\n\n29th 双周赛的 t3，秒切，其实是上一题 [1004. 最大连续 1 的个数 III](#1004-最大连续 1 的个数-iii) 的弱化\n```java\n   public int longestSubarray(int[] nums) {\n       int res=0, sum=0;\n       int left=0;\n       for(int right=0;right<nums.length;right++){\n           sum+=(nums[right]&1);\n           //区间和小于 right-left-1 说明中间不止一个 0 需要缩减窗口\n           while(left<right && sum<= right-left-1){\n               if(nums[left] == 1){\n                   sum--;\n               }\n               left++;\n           }\n           //至少删除一个，所以不用+1\n           res = Math.max(res,right-left);\n       }\n       return res;\n   }\n```\n很可惜这次前 3 题 15 分钟就做完了，都是直接 web 上写的，本以为有机会 AK，最后一题搞了半天最后交了一发还是没过，貌似很多人写了假算法，贪心莽过了（lc 数据太弱了）\n![UTOOLS1593333299362.png](https://upload.cc/i1/2020/06/28/mhTiQ9.png)\n\n## [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)\n\n给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。\n\n**注意：**\n字符串长度 和 k 不会超过 104。\n\n**示例 1:**\n\n```java\n输入：\ns = \"ABAB\", k = 2\n输出：\n4\n解释：\n用两个'A'替换为两个'B', 反之亦然。\n```\n\n**示例 2:**\n\n```java\n输入：\ns = \"AABABBA\", k = 1\n输出：\n4\n解释：\n将中间的一个'A'替换为'B', 字符串变为 \"AABBBBA\"\n子串 \"BBBB\" 有最长重复字母，答案为 4\n```\n\n**解法一**\n\n上面一题的加强版\n\n```java\npublic int characterReplacement(String s, int k) {\n    int max = 0, start = 0, end = 0, cur = -1;\n    int[] count = new int[256];\n    while (end < s.length()) {\n        //当前窗口出现最多的字符\n        cur = Math.max(cur, ++count[s.charAt(end)]);\n        //不能替换了，不同字符太多了，需要缩减窗口\n        while (end - start + 1 - cur > k){\n            //缩减左边界的 count\n            count[s.charAt(start)]--;\n            start++;//不能替换了，start++\n        }\n        //统计最大值\n        max = Math.max(max, end - start + 1);\n        end++;\n    }\n    return max;\n}\n```\n\n**UPDATE: (2020.5.5)**\n\n按照模板重写，果然滑窗的题都是一样的\n\n```java\npublic int characterReplacement(String s, int k) {\n    if(s==null || s.length()<=0){\n        return 0;\n    }\n    int n=s.length();\n    int res=1;\n    int left=0;\n    int[] freq=new int[128];\n    int maxFreq=0;\n    for(int right=0;right<n;right++){\n        char c=s.charAt(right);\n        freq[c]++;\n        maxFreq=Math.max(maxFreq,freq[c]);\n        while((right-left+1-maxFreq)>k){\n            freq[s.charAt(left)]--;\n            left++; //这里实际上只会执行一次，改成 if 也是可以的，不过为了统一写法就不改了\n        }\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n\n重写这题的时候发现这题还是挺有意思的，这个里面的`maxFreq`是一个只增不减的量，是一个历史最大值，只有当出现更大的 freq 的时候才会更新`maxFreq`，当`maxFreq`保持不变的时候结果不会受到影响，只有出现了更大 freq 的时候才有可能会使结果变大\n\n> [拷贝自题解区](https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/hua-dong-chuang-kou-chang-gui-tao-lu-by-xiaoneng/) \n>\n> 因为我们只对最长有效的子字符串感兴趣，所以我们的滑动窗口不需要收缩，即使窗口可能覆盖无效的子字符串。我们可以通过在右边添加一个字符来扩展窗口，或者将整个窗口向右边移动一个字符。而且我们只在新字符的计数超过历史最大计数（来自覆盖有效子字符串的前一个窗口）时才增长窗口。也就是说，我们不需要精确的当前窗口的最大计数；我们只关心最大计数是否超过历史最大计数；这只会因为新字符而发生。\n\n**解法二**\n\n憨憨的解法，不过绝对是能 AC 的，时间复杂度并没有问题，依然是`O(N)`\n\n```java\npublic int characterReplacement(String s, int k) {\n    if(s==null || s.length()<=0){\n        return 0;\n    }\n    int n=s.length();\n    int res=1;\n    for(int c='A';c<='Z';c++){\n        int[] freq=new int[128];\n        int temp=1;\n        int left=0;\n        for(int right=0;right<n;right++){\n            if(s.charAt(right)==c){\n                freq[c]++;\n            }\n            while((right-left+1-freq[c])>k){\n                if(s.charAt(left)==c){\n                    freq[c]--;\n                }\n                left++;\n            }\n            temp=Math.max(temp,right-left+1);\n        }\n        res=Math.max(res,temp);\n    }\n    return res;\n}\n```\n既然题目说了只有大写字母，那就直接枚举所有的字符然后滑窗就行了😂，简单直白\n\n## [1234. 替换子串得到平衡字符串](https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/)\n\n有一个只含有 `'Q', 'W', 'E', 'R'` 四种字符，且长度为 n 的字符串。\n\n假如在该字符串中，这四个字符都恰好出现 `n/4` 次，那么它就是一个「平衡字符串」。\n\n给你一个这样的字符串 `s`，请通过「替换子串」的方式，使原字符串 s 变成一个「平衡字符串」。\n\n你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。\n\n请返回待替换子串的最小可能长度。\n\n如果原字符串自身就是一个平衡字符串，则返回 0 \n\n**示例 1：**\n\n```java\n输入：s = \"QWER\"\n输出：0\n解释：s 已经是平衡的了。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"QQWE\"\n输出：1\n解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 \"RQWE\" （或 \"QRWE\") 是平衡的。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"QQQW\"\n输出：2\n解释：我们可以把前面的 \"QQ\" 替换成 \"ER\"。 \n```\n\n**示例 4：**\n\n```java\n输入：s = \"QQQQ\"\n输出：3\n解释：我们可以替换后 3 个 'Q'，使 s = \"QWER\"。\n```\n\n**提示：**\n\n- 1 <= s.length <= 10^5\n- s.length 是 4 的倍数\n- s 中只含有 'Q', 'W', 'E', 'R' 四种字符\n\n**解法一**\n\n周赛题，说实话不多做做竞赛真不知道自己多菜\n\n(update: 2020.4.15)\n\n我拿到这题，首先想到的是无脑套路滑窗，既然要保证平衡，那么每个字符出现的次数都应该是`N/4`，所以我们可以统计下多出来的有几个，比如`QQQW`，那么多出来的就是 2 个**`Q`**，也就是说我们要求的窗口内**至少**有 2 个 Q，这样问题其实就转换成了 [76. 最小覆盖子串](#76-最小覆盖子串）（这明明是个 mid 题，你咋还给转换成 hard 了，你是不是傻🤣)\n\n其实最小覆盖子串看起来好像挺难，但是是有套路的，我们直接套模板就可以了\n\n```java\npublic int balancedString(String s) {\n    if(s==null || s.length()<=0) return -1;\n    int N=s.length();\n    //这里用 26 有的浪费，为了方便写代码，就这样吧\n    int[] need=new int[26];\n    //初始化为-N/4 这样最后得到的大于 0 的值就是多出来的\n    Arrays.fill(need,-N/4);\n    int[] cur=new int[26];\n    for(int i=0;i<N;i++){\n        need[s.charAt(i)-'A']++;\n    }\n    //有几个字符多出来了\n    int needCount=0; \n    for(int i=0;i<need.length;i++){\n        if(need[i]>0) needCount++;\n    } \n    if(needCount==0) return 0;\n    int res=N;\n    int left=0,right=0;\n    int matchCount=0;\n    //无脑套路滑窗\n    while(right<s.length()){\n        char c=s.charAt(right);\n        if(need[c-'A']>0){\n            cur[c-'A']++;\n            if(cur[c-'A']==need[c-'A']){\n                matchCount++;\n            }\n        }\n        while(left<=right && matchCount==needCount){\n            res=Math.min(right-left+1,res);\n            char cl=s.charAt(left);\n            if(need[cl-'A']>0){\n                cur[cl-'A']--;\n                if(cur[cl-'A']<need[cl-'A']){\n                    matchCount--;\n                }\n            }\n            left++;\n        }\n        right++;\n    }\n    return res;\n}\n```\n\n**解法二**\n\n上面的解法是考虑`窗口内`的元素组成，窗口内至少应该有哪些元素，反过来想，我们窗口内的元素是多出来的元素，我们是把多的元素放到窗口中，那么窗口外的元素就肯定都是`小于等于 N/4`的了，那么我们就可以利用这一点进行滑窗，统计符合条件的窗口的最小值，这样代码就会简洁很多\n\n```java\n//code 删掉了，之前的代码有点问题，最后的返回值有些情况过不去，lc 的 case 太弱了，让我过了\n```\n\n**UPDATE: (2020.5.4)**\n\n按照先前的模板来分析下，这里要求的是最小的修改次数，很明显不能用`for-if`，所以采用`for-while`的结构，`for-while`最基本的结构就是外层枚举所有`right`，内层根据题目要求缩减`left`，但是这题 left 也需要控制边界，我这里用的是`left<=right` 但是实际上这样会有一类 case 结果不对，比如\"QWER\"这样的，返回的结果是 1，~~我上面在最后做了特判~~（上面的特判是错的，比如“QWEE”这样的就返回 0），其实这里还可以修改下边界，改成`left<N`，这样就没问题了，这样 left 就可以超过 right 达到 right+1，这样对”QWER\"就能得到正确的结果，并且根据题目信息当`left=right+1`之后`left`就不会再增加了，while 条件就无法满足了，但是有的题目`left`是不用设置限制的，基本上都是在达到 right+1 之后就不会继续增加了\n\n```java\nclass Solution {\n    public int balancedString(String s) {\n        if(s==null || s.length()<=0){\n            return 0;\n        }\n        int N=s.length();\n        int left=0;\n        int res=N;\n        int[] freq=new int[26];\n        for(int i=0;i<N;i++) {\n            freq[s.charAt(i)-'A']++;\n        }\n        for(int right=0;right<N;right++){\n            freq[s.charAt(right)-'A']--;\n            while(left<N && freq['Q'-'A']<=N/4 && freq['W'-'A']<=N/4 && freq['E'-'A']<=N/4 && freq['R'-'A']<=N/4){\n                res=Math.min(res,right-left+1);\n                freq[s.charAt(left++)-'A']++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n## [1358. 包含所有三种字符的子字符串数目](https://leetcode-cn.com/problems/number-of-substrings-containing-all-three-characters/)  \n\n给你一个字符串 s ，它只包含三种字符 a, b 和 c 。\n\n请你返回 a，b 和 c 都 **至少** 出现过一次的子字符串数目。\n\n**示例 1：**\n\n```java\n输入：s = \"abcabc\"\n输出：10\n解释：包含 a，b 和 c 各至少一次的子字符串为 \"abc\", \"abca\", \"abcab\", \"abcabc\", \"bca\", \"bcab\", \"bcabc\", \"cab\", \"cabc\" 和 \"abc\" （相同字符串算多次）。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"aaacb\"\n输出：3\n解释：包含 a，b 和 c 各至少一次的子字符串为 \"aaacb\", \"aacb\" 和 \"acb\" 。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"abc\"\n输出：1\n```\n\n**提示：**\n\n- 3 <= s.length <= 5 x 10^4\n- s 只包含字符 a，b 和 c 。\n\n**解法一**\n\n20 双周赛 T3\n\n```java\npublic int numberOfSubstrings(String s) {\n    int[] freq=new int[3];\n    int left=0,right=-1,slen=s.length();\n    int res=0;\n    //abc\n    while(left<slen-2){\n        while(right+1<slen && !valid(freq)){\n            freq[s.charAt(++right)-'a']++;\n        }\n        res+=valid(freq)?(slen-right):0;\n        freq[s.charAt(left)-'a']--;\n        left++;\n    }\n    return res;\n}\n\npublic boolean valid(int[] freq){\n    return freq[0]!=0 && freq[1]!=0 && freq[2]!=0;\n}\n```\n枚举所有的左边界，然后找到最短的可以满足的右边界，那么包括右边界和之后的所有的都满足条件，直接计算就可以了，时间复杂度`O(N)`\n\n**解法二**\n\n2020.5.4 用自己总结的滑窗模板重写，也是`for-while`结构，right 和 left 不能同时扩展。比如`\"aaacb\"`这样的 case\n\n```java\npublic int numberOfSubstrings(String s) {\n    int left=0;\n    int res=0;\n    int n=s.length();\n    int[] freq=new int[3];\n    for(int right=0;right<n;right++){\n        freq[s.charAt(right)-'a']++;\n        while(freq[0]>0 && freq[1]>0 && freq[2]>0){\n            res+=n-right; //后面的都符合条件\n            freq[s.charAt(left)-'a']--;\n            left++;\n        }\n    }\n    return res;\n}\n```\n## [1423. 可获得的最大点数](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)\n\n几张卡牌 **排成一行**，每张卡牌都有一个对应的点数。点数由整数数组 `cardPoints` 给出。\n\n每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 `k` 张卡牌。\n\n你的点数就是你拿到手中的所有卡牌的点数之和。\n\n给你一个整数数组 `cardPoints` 和整数 `k`，请你返回可以获得的最大点数。\n\n**示例 1：**\n\n```java\n输入：cardPoints = [1,2,3,4,5,6,1], k = 3\n输出：12\n解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。\n```\n\n**示例 2：**\n\n```java\n输入：cardPoints = [2,2,2], k = 2\n输出：4\n解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。\n```\n\n**示例 3：**\n\n```java\n输入：cardPoints = [9,7,7,9,7,7,9], k = 7\n输出：55\n解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。\n```\n\n**示例 4：**\n\n```java\n输入：cardPoints = [1,1000,1], k = 1\n输出：1\n解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 \n```\n\n**示例 5：**\n\n```java\n输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3\n输出：202\n```\n\n**提示：**\n\n- `1 <= cardPoints.length <= 10^5`\n- `1 <= cardPoints[i] <= 10^4`\n- `1 <= k <= cardPoints.length`\n\n**解法一**\n\n186 周赛 T2，很明显的滑动窗口，前后拿 K 张最大，只需要求一个最小的`[n-k]`区间值就行了，也可以用前缀和，思路都一样\n\n```go\nfunc maxScore(cardPoints []int, k int) int {\n    if cardPoints == nil || len(cardPoints) == 0 {\n        return 0\n    }\n    n := len(cardPoints)\n    left := 0\n    right := n - k - 1\n    sum := 0\n    windowSum := 0\n    for i, num := range cardPoints {\n        sum += num\n        if i == right {\n            windowSum = sum\n        }\n    }\n    if k == n {\n        return sum\n    }\n    minWin := windowSum\n    for right+1 < n {\n        windowSum += (cardPoints[right+1] - cardPoints[left])\n        minWin = min(windowSum, minWin)\n        right++\n        left++\n    }\n    return sum - minWin\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\n```\n\nTag 里面有 dp，确实这题和前面的 [石子游戏](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F) 有一点像，但是还是滑窗来的比较直接。\n\n## [1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)\n\n给你两个长度相同的字符串，`s` 和 `t`。\n\n将 `s` 中的第 `i` 个字符变到 `t` 中的第 `i` 个字符需要 `|s[i] - t[i]|` 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。\n\n用于变更字符串的最大预算是 `maxCost`。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。\n\n如果你可以将 `s` 的子字符串转化为它在 `t` 中对应的子字符串，则返回可以转化的最大长度。\n\n如果 `s` 中没有子字符串可以转化成 `t` 中对应的子字符串，则返回 `0`。\n\n**示例 1：**\n\n```go\n输入：s = \"abcd\", t = \"bcdf\", cost = 3\n输出：3\n解释：s 中的 \"abc\" 可以变为 \"bcd\"。开销为 3，所以最大长度为 3。\n```\n\n**示例 2：**\n\n```go\n输入：s = \"abcd\", t = \"cdef\", cost = 3\n输出：1\n解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。\n```\n\n**示例 3：**\n\n```go\n输入：s = \"abcd\", t = \"acde\", cost = 0\n输出：1\n解释：你无法作出任何改动，所以最大长度为 1。\n```\n\n**提示：**\n\n- `1 <= s.length, t.length <= 10^5`\n- `0 <= maxCost <= 10^6`\n- `s` 和 `t` 都只含小写英文字母。\n\n**解法一**\n\n```go\nfunc equalSubstring(s string, t string, maxCost int) int {\n    left := 0\n    cost := 0\n    res := 0\n    for right := 0; right < len(s); right++ {\n        cost += getCost(s[right], t[right])\n        if cost <= maxCost {\n            res = max(res, right-left+1)\n        } else {\n            cost -= getCost(s[left], t[left])\n            left++\n        }\n    }\n    return res\n}\n\nfunc getCost(a, b byte) int {\n    if a < b { //a-b<0 byte 是 uint8 直接这样减会变成正数\n        return int(b - a)\n    }\n    return int(a - b)\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n这个题本身不难，主要是为了学习滑窗类型的题，这题我又改了好长时间，果然做滑窗的题还是有点乱，不过做了这一题之后已经有点感觉了，目前打算把所有的滑窗都重做一遍，然后总结一下套路\n\n**思考**\n\n下面`for-while`的结构似乎更加统一，上面`for-if`的结构只能用在求**最长，最大**的情况下，这种时候`left`和`right`允许同时加加，所以用`if`也是可以的，但是求最短的时候，比如上面 [209. 长度最小的子数组](#209-长度最小的子数组)就不能用`for-if` ，当 right 到达边界的时候 left 可能还需要继续移动，所以不能用`if`\n\n```go\nfunc equalSubstring(s string, t string, maxCost int) int {\n    left := 0\n    cost := 0\n    res := 0\n    for right := 0; right < len(s); right++ {\n        cost += getCost(s[right], t[right])\n        for cost > maxCost {\n            cost -= getCost(s[left], t[left])\n            left++\n        }\n        res = max(res, right-left+1)\n    }\n    return res\n}\n```\n\n## [1052. 爱生气的书店老板](https://leetcode-cn.com/problems/grumpy-bookstore-owner/)\n\n今天，书店老板有一家店打算试营业 `customers.length` 分钟。每分钟都有一些顾客（`customers[i]`）会进入书店，所有这些顾客都会在那一分钟结束后离开。\n\n在某些时候，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。\n\n书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `X` 分钟不生气，但却只能使用一次。\n\n请你返回这一天营业下来，最多有多少客户能够感到满意的数量。\n\n**示例：**\n\n```\n输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3\n输出：16\n解释：\n书店老板在最后 3 分钟保持冷静。\n感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n```\n\n**提示：**\n\n- `1 <= X <= customers.length == grumpy.length <= 20000`\n- `0 <= customers[i] <= 1000`\n- `0 <= grumpy[i] <= 1`\n\n**解法一**\n\n滑动窗口的感觉来了，越来越熟练了，这题直接 bugfree 了😁\n\n```java\npublic int maxSatisfied(int[] customers, int[] grumpy, int X) {\n    if(grumpy==null || grumpy.length<0) return 0;\n    int N=grumpy.length;\n    int left=0;\n    int window=0;//窗口内反转人数\n    int max=0; //最多反转人数\n    for(int right=0;right<N;right++){\n        if(grumpy[right]==1){\n            window+=customers[right];\n        }\n        //while 和 if 都可以，个人比较喜欢 while 通用性比较强\n        while(right-left+1>X){\n            if(grumpy[left]==1){\n                window-=customers[left];\n            }\n            left++;\n        }\n        max=Math.max(window,max);\n    }\n    int res=0;\n    for(int i=0;i<N;i++){\n        res+=(grumpy[i]==0?customers[i]:0);\n    }\n    return res+max;\n}\n```\n可以看到仍然是前面总结的`for-while`结构，等我把所有的滑窗 tag 做完了再来总结一波\n\n## [1040. 移动石子直到连续 II](https://leetcode-cn.com/problems/moving-stones-until-consecutive-ii/)\n\n在一个长度**无限**的数轴上，第 `i` 颗石子的位置为 `stones[i]`。如果一颗石子的位置最小/最大，那么该石子被称作**端点石子**。\n\n每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。\n\n值得注意的是，如果石子像 `stones = [1,2,5]` 这样，你将**无法**移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。\n\n当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。\n\n要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：`answer = [minimum_moves, maximum_moves]` 。\n\n**示例 1：**\n\n```java\n输入：[7,4,9]\n输出：[1,2]\n解释：\n我们可以移动一次，4 -> 8，游戏结束。\n或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。\n```\n\n**示例 2：**\n\n```java\n输入：[6,5,4,3,10]\n输出：[2,3]\n解释：\n我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。\n或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。\n注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。\n```\n\n**示例 3：**\n\n```java\n输入：[100,101,104,102,103]\n输出：[0,0]\n```\n\n**提示：**\n\n1. `3 <= stones.length <= 10^4`\n2. `1 <= stones[i] <= 10^9`\n3. `stones[i]` 的值各不相同。\n\n**解法一**\n\n懵逼，某次周赛的 T4，嗯抄，不会做，题目都差点没看懂\n\n```java\npublic int[] numMovesStonesII(int[] stones) {\n    if(stones==null || stones.length<=0){\n        return new int[2];\n    }\n    //0 1 2 3 4 5 6 7 8 9 10\n    //      0 1 2 3        4\n    int N=stones.length;\n    Arrays.sort(stones);\n    int left=0;\n    int[] res=new int[2];\n    res[0]=Integer.MAX_VALUE;\n    for(int right=0;right<N;right++){\n        //整个区间范围大于 N 了需要缩小区间\n        while(stones[right]-stones[left]+1>N){ \n            left++;\n        }\n        int windowStones=right-left+1;\n        if(windowStones==N-1&&stones[right]-stones[left]+1==N-1){\n            res[0]=Math.min(2,res[0]);\n        }else{\n            res[0]=Math.min(res[0],N-windowStones);\n        }\n    }\n    res[1]=Math.max(stones[N-1]-stones[1]-N+2,stones[N-2]-stones[0]-N+2);\n    return res;\n}\n```\n\n## [1456. 定长子串中元音的最大数目](https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)\n\n给你字符串 s 和整数 k 。\n\n请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。\n\n英文中的 元音字母 为（a, e, i, o, u）。\n\n**示例 1：**\n\n```java\n输入：s = \"abciiidef\", k = 3\n输出：3\n解释：子字符串 \"iii\" 包含 3 个元音字母。\n```\n**示例 2：**\n\n```java\n输入：s = \"aeiou\", k = 2\n输出：2\n解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n```\n**示例 3：**\n\n```java\n输入：s = \"leetcode\", k = 3\n输出：2\n解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。\n```\n**示例 4：**\n\n```java\n输入：s = \"rhythms\", k = 4\n输出：0\n解释：字符串 s 中不含任何元音字母。\n```\n**示例 5：**\n\n```java\n输入：s = \"tryhard\", k = 4\n输出：1\n```\n\n**提示：**\n\n- 1 <= s.length <= 10^5\n- s 由小写英文字母组成\n- 1 <= k <= s.length\n\n**解法一**\n\n好久没写滑窗的题了，回顾下之前的模板，`for-while`结构\n```java\npublic int maxVowels(String s, int k) {\n    int left=0;\n    int res=0;\n    int count=0;\n    for(int right=0;right<s.length();right++){\n        if(vowel(s.charAt(right))){\n            count++;\n        }\n        while(right-left >= k){\n            if(vowel(s.charAt(left))){\n                count--;\n            }\n            left++;\n        }\n        res=Math.max(res,count);\n    }\n    return res;\n}\n\npublic boolean vowel(char ch){\n    return ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u';\n}\n\n```\n\n## [1461. 检查一个字符串是否包含所有长度为 K 的二进制子串](https://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/)\n\nDifficulty: **中等**\n\n给你一个二进制字符串 `s` 和一个整数 `k` 。\n\n如果所有长度为 `k` 的二进制字符串都是 `s` 的子串，请返回 True ，否则请返回 False 。\n\n**示例 1：**\n\n```go\n输入：s = \"00110110\", k = 2\n输出：true\n解释：长度为 2 的二进制串包括 \"00\"，\"01\"，\"10\" 和 \"11\"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。\n```\n\n**示例 2：**\n\n```go\n输入：s = \"00110\", k = 2\n输出：true\n```\n\n**示例 3：**\n\n```go\n输入：s = \"0110\", k = 1\n输出：true\n解释：长度为 1 的二进制串包括 \"0\" 和 \"1\"，显然它们都是 s 的子串。\n```\n\n**示例 4：**\n\n```go\n输入：s = \"0110\", k = 2\n输出：false\n解释：长度为 2 的二进制串 \"00\" 没有出现在 s 中。\n```\n\n**示例 5：**\n\n```go\n输入：s = \"0000000001011100\", k = 4\n输出：false\n```\n\n**提示：**\n\n*   `1 <= s.length <= 5 * 10^5`\n*   `s` 中只含 0 和 1 。\n*   `1 <= k <= 20`\n\n**解法一**\n\n某次周赛的 T2 还是 T3，忘了，我用了最暴力的方法，直接回溯生成了所有的二进制串，然后对比的，写的很快，也 AC 了，但是但是后面一直没时间重写，今天偶然发现了这道题，重写下\n\n经典 for-while 结构\n```golang\nfunc hasAllCodes(s string, k int) bool {\n    var set = make(map[int]bool)\n    var left = 0\n    var cur = 0\n    for right := 0; right < len(s); right++{\n        cur = cur * 2 + int(s[right] & 1)\n        for right - left + 1 > k{\n            cur &= ^(1 << k) //将首位置为 0\n            left++\n        }\n        if right - left + 1 == k{\n            set[cur] = true   \n        }\n    }\n    return len(set) == 1 << k\n}\n```\n这个题也可以直接存字符串进去，但是存字符串的时间复杂度就不是 O(N) 了 (N 为字符长度），而是 O(KN)，因为字符串 Hash 的复杂度是 O(K)，但是这里 K 很小，所以其实也无所谓，但是我们还是要追求更加优秀的解法，所以最好的做法还是将其转换成数字，然后存到哈希表中，这里看了别人的解法又学到了一手位运算的小技巧，`cur & ^(1<<k)`（k 为 cur 长度-1）可以将 cur 首位置为 0，也就是消去首位，原理也很简单，就不赘述了\n\n## [1498. 满足条件的子序列数目](https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/)\n\nDifficulty: **中等**\n\n给你一个整数数组 `nums` 和一个整数 `target` 。\n\n请你统计并返回 `nums` 中能满足其最小元素与最大元素的 **和** 小于或等于 `target` 的 **非空** 子序列的数目。\n\n由于答案可能很大，请将结果对 10^9 + 7 取余后返回。\n\n**示例 1：**\n\n```go\n输入：nums = [3,5,6,7], target = 9\n输出：4\n解释：有 4 个子序列满足该条件。\n[3] -> 最小元素 + 最大元素 <= target (3 + 3 <= 9)\n[3,5] -> (3 + 5 <= 9)\n[3,5,6] -> (3 + 6 <= 9)\n[3,6] -> (3 + 6 <= 9)\n```\n\n**示例 2：**\n\n```go\n输入：nums = [3,3,6,8], target = 10\n输出：6\n解释：有 6 个子序列满足该条件。（nums 中可以有重复数字）\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]\n```\n\n**示例 3：**\n\n```go\n输入：nums = [2,3,3,4,6,7], target = 12\n输出：61\n解释：共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）\n有效序列总数为（63 - 2 = 61）\n```\n\n**示例 4：**\n\n```go\n输入：nums = [5,2,4,1,7,6,8], target = 16\n输出：127\n解释：所有非空子序列都满足条件 (2^7 - 1) = 127\n```\n\n**提示：**\n\n*   `1 <= nums.length <= 10^5`\n*   `1 <= nums[i] <= 10^6`\n*   `1 <= target <= 10^6`\n\n**解法一**\n\n双指针滑窗，很关键的一步就是排序，因为我们只关心最大最小值，而且是子序列，与顺序无关\n```java\n//双指针\npublic int numSubseq(int[] nums, int target) {\n    Arrays.sort(nums);\n    int MOD = (int)(1e9+7);\n    int n = nums.length;\n    //预处理出幂值表\n    int[] pow = new int[n];\n    pow[0] = 1;\n    for (int i = 1; i < n; i++){\n        pow[i] = (pow[i-1] << 1) % MOD;\n    }\n    int left = 0, right = n-1;\n    long count = 0;\n    while(left <= right){\n        while(left <= right && nums[left] + nums[right] > target) {\n            right--;\n        }\n        if (left <= right) {\n            //nums[left] + nums[right] <>= target \n            //包含 left 的子序列个数：left 固定，在 [left+1,right] 选若干个，就有 2^(right-left) 种选法\n            count = (count + pow[right-left]) % MOD ;\n        }\n        left++;\n    }\n    return (int)count%MOD;\n}\n```\n**解法二**\n\n二分\n```java\n//二分\npublic int numSubseq(int[] nums, int target) {\n    Arrays.sort(nums);\n    int MOD = (int)(1e9+7);\n    int n = nums.length;\n    //预处理出幂值表\n    int[] pow = new int[n];\n    pow[0] = 1;\n    for (int i = 1; i < n; i++){\n        pow[i] = (pow[i-1] << 1) % MOD;\n    }\n    long count = 0;\n    for (int i = 0; i < n; i++) {\n        if (target-nums[i] < 0){\n            break;\n        }\n        int right = search(nums, target-nums[i]);\n        if (right >= i){\n            count = (count + pow[right-i]) % MOD;\n        }\n    }\n    return (int) count % MOD;\n}\n\n//搜索最后一个小于等于 target 的值\npublic int search(int[] nums, int target){\n    int left = 0, right = nums.length-1;\n    int res = -1;\n    while (left <= right) {\n        int mid = left + (right-left)/2;\n        if (nums[mid] <= target){\n            res = mid;\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n```\n## [904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)\n\nDifficulty: **中等**\n\n在一排树中，第 `i` 棵树产生 `tree[i]` 型的水果。  \n你可以**从你选择的任何树开始**，然后重复执行以下步骤：\n\n1.  把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。\n2.  移动到当前树右侧的下一棵树。如果右边没有树，就停下来。\n\n请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。\n\n你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。  \n用这个程序你能收集的水果总量是多少？\n> 感觉这里想表达的应该是水果树的数量\n**示例 1：**\n\n```go\n输入：[1,2,1]\n输出：3\n解释：我们可以收集 [1,2,1]。\n```\n\n**示例 2：**\n\n```go\n输入：[0,1,2,2]\n输出：3\n解释：我们可以收集 [1,2,2].\n如果我们从第一棵树开始，我们将只能收集到 [0, 1]。\n```\n\n**示例 3：**\n\n```go\n输入：[1,2,3,2,2]\n输出：4\n解释：我们可以收集 [2,3,2,2].\n如果我们从第一棵树开始，我们将只能收集到 [1, 2]。\n```\n\n**示例 4：**\n\n```go\n输入：[3,3,3,1,2,1,1,2,3,3,4]\n输出：5\n解释：我们可以收集 [1,2,1,1,2].\n如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。\n```\n\n**提示：**\n\n1.  `1 <= tree.length <= 40000`\n2.  `0 <= tree[i] < tree.length`\n\n**解法一**\n\n题目意思其实就是求只包含 2 个元素的最长子串，题目表述的不太清楚，已经反馈了\n```golang\nfunc totalFruit(tree []int) int {\n    var left = 0\n    var Max = func (a, b int) int {if a>b {return a};return b}\n    var n = len(tree)\n    var freq [40001]int\n    var res, count = 0, 0\n    for right := 0; right < n; right++ {\n        if freq[tree[right]] == 0 {\n            count++\n        }\n        freq[tree[right]]++\n        for count > 2 {\n            freq[tree[left]]--\n            if freq[tree[left]] == 0 {\n                count--\n            }\n            left++\n        }\n        res = Max(res, right-left+1)\n    }\n    return res\n}\n```\n## [NC562. 牛牛的魔法卡](https://www.nowcoder.com/practice/9b6fe52a68904c77aa81502f57ceac86)\n\n牛牛从小就有收集魔法卡的习惯，他最大的愿望就是能够集齐 k 种不同种类的魔法卡，现在有 n 张魔法卡，这 n 张魔法卡存在于一维坐标点上，\n每张魔法卡可能属于某一种类。牛牛如果想收集魔法卡就需要从当前坐标点跳跃到另外一个魔法卡所在的坐标点，花费的代价是两个跳跃坐标点之间的距离差。\n牛牛可以从任意的坐标点出发，牛牛想知道他集齐 k 种魔法卡所花费的最小代价是多少，如果集不齐 k 种魔法卡，输出-1。\n第一行输入两个整数 n,k, 分别表示魔法卡的个数和种类个数。\n接下来有 n 行，每行两个数 x，y 分别表示属于哪一种魔法卡和魔法卡所在的坐标\n\n**示例 1**\n```go\n输入：7,3,[[0,1],[0,2],[1,5],[1,1],[0,7],[2,8],[1,3]]\n输出：3\n说明：\n样例一：牛牛从坐标点 5 出发，经过 7、8 两个点就收集了 3 张不同种类的魔法卡，达成成就。所需代价 （7-5）+（8-7） = 3\n```\n**备注：**\n- 1<=n<=10^6\n- 1<=k<=50 0<=x<k\n- 0 <= y <= 1e9\n\n**解法一**\n\ntag 是二分，但是想了一会儿感觉好像没啥好的二分的思路，二分答案貌似可行，不过这题滑窗的思路更简单，类似 [76-最小覆盖子串](#76-最小覆盖子串)滑就完事儿了\n```java\npublic int solve (int n, int k, int[][] card) {\n    // write code here\n    Arrays.sort(card, (c1,c2)->c1[1]-c2[1]);\n    int INF = Integer.MAX_VALUE;\n    int left = 0;\n    int count = 0;\n    int[] freq = new int[k+1];\n    int res = INF;\n    for (int right = 0; right < n; right++) {\n        if (freq[card[right][0]] == 0) {\n            count++;\n        }\n        freq[card[right][0]]++;\n        while(left<=right && count == k){\n            res = Math.min(res, card[right][1] - card[left][1]);\n            freq[card[left][0]]--;\n            if (freq[card[left][0]]==0) {\n                count--;\n            }\n            left++;\n        }\n    }\n    if (res == INF) {\n        return -1;\n    }\n    return res;\n}\n```\n## [1870. 全零子串的数量（LintCode）](https://www.lintcode.com/problem/number-of-substrings-with-all-zeroes/description)\n\n给出一个只包含 0 或 1 的字符串 str, 请返回这个字符串中全为 0 的子字符串的个数 1<=|str|<=30000\n\n**例 1:**\n```go\n输入：\"00010011\"\n输出：9\n解释：\n\"0\"子字符串有 5 个，\n\"00\"子字符串有 3 个，\n\"000\"子字符串有 1 个。\n所以返回 9\n```\n**例 2:**\n```go\n输入：\"010010\"\n输出：5\n```\n**解法一**\n\n直接滑就行了，统计所有 0 区间的长度，注意组合数的计算就行了\n```java\n// 1 1 1 1 1 (5+4+3+2+1) = n(n-1)/2 + n or n(n+1)/2\npublic int stringCount(String str) {\n    // Write your code here.\n    int left = 0, right = 0;\n    int res = 0;\n    while (right < str.length()) {\n        while(right < str.length() && str.charAt(right) == '0'){\n            right++;\n        }\n        // (0  0  0) 1 1\n        //  l  n     r\n        int n = right-left;\n        //C(n+1,2)/2\n        res += n*(n+1)/2;\n        right++;\n        left = right;\n    }\n    return res;\n}\n```\n\n## [1529. 绝对差不超过限制的三元子数组（LintCode](https://www.lintcode.com/problem/triplet-subarray-with-absolute-diff-less-than-or-equal-to-limit/description)）\n\n给定一个递增的整数数组 nums，和一个表示限制的整数 limit，请你返回满足条件的三元子数组的个数，使得该子数组中的任意两个元素之间的绝对差小于或者等于 limit。\n\n如果不存在满足条件的子数组，则返回 0 。\n\n**数据范围：** 1 ≤ len(nums) ≤ 1e4，1 ≤ limit ≤ 1e6，0 ≤ nums[i] ≤ 1e6\n由于答案可能很大，请返回它对 99997867 取余后的结果。\n\n**样例 1:**\n```go\n输入：[1, 2, 3, 4], 3\n输出：4\n解释：可选方案有 (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)。因此，满足条件的三元组有 4 个。\n```\n\n**样例 2:**\n```go\n输入：[1, 10, 20, 30, 50], 19\n输出：1\n解释：唯一可行的三元组是 (1, 10, 20)，所以答案为 1。\n```\n**挑战**\n你可以只用 O(n) 的时间复杂度解决这个问题吗？\n\n**解法一**\n\n我一开始看见是 Hard 想的挺复杂的，什么单调栈都搞出来了，但是仔细看题会发现题目给的数组是有序的，所以直接滑窗然后统计就行了，这里需要注意计算的方式，避免算重\n```java\n//LintCode 上居然是 Hard，感觉不是很难\npublic int tripletSubarray(int[] nums, int limit) {\n    // write your code here\n    int n = nums.length;\n    int left = 0, right = 0;\n    int res = 0;\n    while (left <= right) {\n        //找到最远的合法 right\n        while (right < n && nums[right]-nums[left] <= limit) {\n            right++;\n        }\n        //  1  (2 3 4)  5\n        //left   len  right\n        int len = right-left-1;\n        left++;\n        if (len < 2) continue;\n        //C(len,2) 求以 left 开头，包含 left 的所有 3 元组，这样不会重复\n        res += len*(len-1)/2;\n    }\n    return res;\n}\n```\n> 感觉自己静下心来想的话很多题目还是可以自己做出来的，但是就是想的可能有点慢，特别是竞赛中，规定了时间后一慌就更慢了。看来还是练少了\n\n## [1375. 至少 K 个不同字符的子串（LintCode）](https://www.lintcode.com/problem/substring-with-at-least-k-distinct-characters/description)\n\n给定一个仅包含小写字母的字符串 S.\n\n返回 S 中至少包含 k 个不同字符的子串的数量。\n\n- 10 ≤ length(S) ≤ 1,000,000\n- 1 ≤ k ≤ 26\n\n**样例 1:**\n```go\n输入：S = \"abcabcabca\", k = 4\n输出：0\n解释：字符串中一共就只有 3 个不同的字符。\n```\n**样例 2:**\n```go\n输入：S = \"abcabcabcabc\", k = 3\n输出：55\n解释：任意长度不小于 3 的子串都含有 a, b, c 这三个字符。\n    比如，长度为 3 的子串共有 10 个，\"abc\", \"bca\", \"cab\" ... \"abc\"\n    长度为 4 的子串共有 9 个，\"abca\", \"bcab\", \"cabc\" ... \"cabc\"\n    ...\n    长度为 12 的子串有 1 个，就是 S 本身。\n    所以答案是 1 + 2 + ... + 10 = 55.\n```\n\n**解法一**\n\n经典滑窗，非常套路，想好怎么统计就行了\n```java\npublic long kDistinctCharacters(String s, int k) {\n    int n = s.length();\n    int left = 0;\n    int[] freq = new int[128];\n    int count = 0;\n    long res = 0;\n    for (int right = 0; right < n; right++) {\n        char cr = s.charAt(right);\n        if (freq[cr] == 0) {\n            count++;\n        }\n        freq[cr]++;\n        while (count >= k && left <= right) {\n            // abc | abcabcabc\n            // l r(2)          n(12)\n            //统计以 s[left,right] 开头的所有子串\n            //10+9+8+7+...+1\n            res += n-right;\n            char cl = s.charAt(left);\n            freq[cl]--;\n            if (freq[cl] <= 0) {\n                count--;\n            }\n            left++;\n        }\n    }\n    return res;\n}\n```\n\n## [386. 最多有 k 个不同字符的最长子字符串 (LintCode)](https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/description)\n\n给定字符串 S，找到最多有 k 个不同字符的最长子串 T。\n\n**样例 1:**\n```go\n输入：S = \"eceba\" 并且 k = 3\n输出：4\n解释：T = \"eceb\"\n```\n**样例 2:**\n```go\n输入：S = \"WORLD\" 并且 k = 4\n输出：4\n解释：T = \"WORL\" 或 \"ORLD\"\n```\n**挑战**： O(n) 时间复杂度\n\n**解法一**\n\n无脑滑窗就行了，太套路了\n```java\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    // write your code here\n    int n = s.length();\n    int left = 0;\n    int res = 0;\n    int[] freq = new int[128];\n    int count = 0;\n    for (int right = 0; right < n; right++) {\n        char cr = s.charAt(right);\n        if (freq[cr] == 0) {\n            count++;\n        }\n        freq[cr]++;\n        while (left <= right && count > k) {\n            char cl = s.charAt(left);\n            freq[cl]--;\n            if (freq[cl] <= 0) {\n                count--;\n            }\n            left++;\n        }\n        res = Math.max(res, right-left+1);\n    }\n    return res;\n}\n```\n## [1675. 数组的最小偏移量](https://leetcode-cn.com/problems/minimize-deviation-in-array/)\n\nDifficulty: **困难**\n\n给你一个由 `n` 个正整数组成的数组 `nums` 。\n\n你可以对数组的任意元素执行任意次数的两类操作：\n\n*   如果元素是偶数 ，除以 `2`\n    *   例如，如果数组是 `[1,2,3,4]` ，那么你可以对最后一个元素执行此操作，使其变成 `[1,2,3,2]`\n*   如果元素是奇数 ，乘上 `2`\n    *   例如，如果数组是 `[1,2,3,4]` ，那么你可以对第一个元素执行此操作，使其变成 `[2,2,3,4]`\n\n数组的 **偏移量** 是数组中任意两个元素之间的 **最大差值** 。\n\n返回数组在执行某些操作之后可以拥有的 **最小偏移量** 。\n\n**示例 1：**\n\n```c\n输入：nums = [1,2,3,4]\n输出：1\n解释：你可以将数组转换为 [1,2,3,2]，然后转换成 [2,2,3,2]，偏移量是 3 - 2 = 1\n```\n\n**示例 2：**\n\n```c\n输入：nums = [4,1,5,20,3]\n输出：3\n解释：两次操作后，你可以将数组转换为 [4,2,5,5,3]，偏移量是 5 - 2 = 3\n```\n\n**示例 3：**\n\n```c\n输入：nums = [2,10,8]\n输出：3\n```\n\n**提示：**\n\n*   n == nums.length\n*   2 <= n <= 10<sup><span style=\"display: inline;\">5</span></sup>\n*   1 <= nums[i] <= 10<sup>9</sup>\n\n**解法一**\n\n和上面 [632-最小区间](#632-最小区间)一样，将数据变成和最小区间一样的形式，然后直接套用\n```java\npublic int minimumDeviation(int[] nums) {\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->a[2]-b[2]);\n    List<List<Integer>> lis = new ArrayList<>();\n    int max = 0;\n    for (int i = 0; i < nums.length; i++) {\n        ArrayList<Integer> tmp = new ArrayList<>();\n        if (nums[i] % 2 == 1) {\n            pq.add(new int[]{i, 0, nums[i]});\n            max = Math.max(max, nums[i]);\n            tmp.add(nums[i]);\n            tmp.add(nums[i] * 2);\n        } else {\n            tmp.add(nums[i]);\n            while (nums[i] % 2 == 0) {\n                tmp.add(nums[i]/2);\n                nums[i]/=2;\n            }\n            pq.add(new int[]{i, 0, nums[i]});\n            max = Math.max(max, nums[i]);\n            Collections.reverse(tmp);\n        }\n        lis.add(tmp);\n    }\n    int res = Integer.MAX_VALUE;\n    while (true) {\n        int[] min = pq.poll();\n        res = Math.min(res, max-min[2]);\n        if (min[1]+1 >= lis.get(min[0]).size()) {\n            break;\n        }\n        int next = lis.get(min[0]).get(min[1]+1);\n        pq.add(new int[]{min[0], min[1]+1, next});\n        max = Math.max(max, next);\n    }\n    return res;\n}\n```\n\n**解法二**\n\n```java\n    public int minimumDeviation2(int[] nums) {\n        int INF = 0x3f3f3f3f;\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b-a);\n        int min = INF;\n        for (int i = 0; i < nums.length; i++) {\n            if ((nums[i] & 1) == 1) {\n                nums[i] <<= 1;\n            }\n            min = Math.min(min, nums[i]);\n            pq.add(nums[i]);\n        }\n        int res = INF;\n        while (true) {\n            int max = pq.poll();\n            res = Math.min(res, max-min);\n            if ((max&1)==1) {\n                break;\n            }\n            pq.add(max/2);\n            min = Math.min(min, max/2);\n        }\n        return res;\n    }\n```","tags":["LeetCode","滑动窗口"],"categories":["算法"]},{"title":"Socket 网络编程","url":"/2019/07/19/df38ad26/","content":"\n### Socket 概述\n\n​\t套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I/O 插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。socket 提供的函数是**操作系统内核将“TCP/IP 协议栈 + 底层网卡”抽象出来的一个个用户友好的函数，用于操纵本地的“TCP/IP 协议栈 + 底层网卡”与远端的服务器/主机完成通信的任务。**\n\n### TCP\n\n🔸 TCP 是面向连接的通信协议\n\n🔸 通过`三次握手`建立连接，通讯完成时要拆除连接\n\n🔸 由于 TCP 是面向连接的所以只能用于端到端的通讯\n\n🔸 三次握手四次挥手\n\n🔸 具有校验机制，可靠，数据传输稳定\n\n#### 简单的 Socket 小案例\n\n**Socket 客户端**\n\n```java\npackage TcpDemo;\nimport java.io.*;\nimport java.net.*;\nimport java.util.Scanner;\n\n/**\n * @author imlgw.top\n * @date 2019/7/7 9:45\n */\npublic class Client {\n    private static final int REMOTE_PORT = 20000;\n\n    private static final int LOCAL_PORT = 30000;\n\n    public static void main(String[] args) throws IOException {\n        Socket socket = creatSocket();\n        initSocket(socket);\n        //setRecessAddress 前\n        socket.bind(new InetSocketAddress(InetAddress.getLocalHost(), LOCAL_PORT));\n        //连接远程 server\n        socket.connect(new InetSocketAddress(InetAddress.getLocalHost(), REMOTE_PORT), 3000);\n        System.out.println(\"客户端已经发起连接\");\n        System.out.println(\"客户端信息：\" + socket.getLocalAddress() + \"port:\" + socket.getLocalPort());\n        System.out.println(\"服务端信息\" + socket.getInetAddress() + \"port:\" + socket.getPort());\n        try {\n            sendMsg(socket);\n        } catch (Exception e) {\n            System.err.println(\"连接异常关闭！！！！\");\n            e.printStackTrace();\n        } finally {\n            socket.close();\n        }\n    }\n\n    private static void initSocket(Socket socket) throws SocketException {\n        socket.setSoTimeout(3000);\n        //是否复用未完全关闭后的端口 (TIME_WAIT 状态），必须在 bind 前，所以就不能通过构造器来绑定本地端口\n        socket.setReuseAddress(true);\n        //是否开启 Nagle 算法（默认开启） https://baike.baidu.com/item/Nagle%E7%AE%97%E6%B3%95\n        socket.setTcpNoDelay(false);\n        //长时间无数据相应的时候发送确认数据（心跳包）时间大约两个小时\n        socket.setKeepAlive(true);\n        \n        /*\n          close 关闭后的处理\n          这个 Socket 选项可以影响 close 方法的行为。\n          false 0 默认情况 关闭后立即返回，底层系统接管输出流，将缓冲区的数据发送完成\n          true 0 关闭后直接返回 缓冲区数据直接抛弃 直接发送 RES 结束命令到对方，无需经过 2MSL 等待\n          true 200 关闭时最长阻塞 200s 随后按第二情况处理\n          （是 s 不是 ms, 开始搞错了 设置了 20 重启就会端口占用。)\n        */\n        socket.setSoLinger(true, 0);\n       \n        /*\n        设置紧急数据是否内敛，如果这个 Socket 选项打开，\n        可以通过 Socket 类的 sendUrgentData 方法\n        向服务器发送一个单字节的数据 这个单字节数据并不经过输出缓冲区，而是立即发出。\n        虽然在客户端并不是使用 OutputStream 向服务器发送数据，\n        但在服务端程序中这个单字节的数据是和其它的普通数据混在一起的\n        因此，在服务端程序中并不知道由客户\n        端发过来的数据是由 OutputStream\n        还是由 sendUrgentData 发过来的\n        */\n        socket.setOOBInline(true);\n        //设置收发缓冲器大小，默认 32K\n        socket.setReceiveBufferSize(64*1024);\n        socket.setSendBufferSize(64*1024);\n        //设置性能参数的 优先级  短链接 延迟 带宽\n        socket.setPerformancePreferences(1,1,1);\n    }\n    @SuppressWarnings(\"all\")\n    private static Socket creatSocket() throws IOException {\n        /*\n        //无代理模式，相当于空构造函数\n        Socket socket = new Socket(Proxy.NO_PROXY);\n        //HTTP 代理模式传输的数据将通过 www.imlgw.top 转发\n        socket = new Socket(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(Inet4Address.getByName(\"www.imlgw.top\"), 80)));\n\n        //下面两种方式回在创建的时候就去链接远程的服务器（具体看源码）, 然而一般情况下其实在连接之前我们还需要设置一些参数\n        //新建一个套接字 链接到远程服务器和端口（本地端口为系统分配）\n        socket = new Socket(\"imlgw.top\", REMOTE_PORT);\n        //新建套接字直接链接到远程端口 并绑定本地端口\n        socket=new Socket(\"imlgw.top\",REMOTE_PORT,InetAddress.getLocalHost(),LOCAL_PORT);\n        */\n\n        //新建 socket 然后绑定到本地端口\n        Socket socket = new Socket();\n        return socket;\n    }\n\n    private static void sendMsg(Socket socket) throws IOException {\n        //键盘的输入流\n        Scanner scanner = new Scanner(System.in);\n        //拿到 socket 的输出流\n        OutputStream socketOutputStream = socket.getOutputStream();\n        //转换为打印流\n        PrintStream printStream = new PrintStream(socketOutputStream);\n        //socket 的输入流\n        InputStream inputStream = socket.getInputStream();\n        //转换位 buffer 流\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\n        boolean flag = true;\n        do {\n            //客户端发送消息\n            printStream.println(scanner.nextLine());\n            //服务端的响应\n            String s = bufferedReader.readLine();\n            if (\"bye\".equals(s)) {\n                flag = false;\n            } else {\n                System.out.println(\"服务端响应：\" + s);\n            }\n        } while (flag);\n        bufferedReader.close();\n        printStream.close();\n        scanner.close();\n    }\n}\n```\n\n**Socket 服务端**\n\n 这里为了同时处理多个客户端设计成了**多线程**异步的模式\n\n```java\npackage TcpDemo;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.*;\n\n/**\n * @author imlgw.top\n * @date 2019/7/7 9:46\n */\npublic class Server {\n\n    private static final int SERVER_PORT = 20000;\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket server = creatServerSocket();\n        initServerSocket(server);\n        //初始化之后再绑定，不然一些设置会失效，比如 setReuseAddress\n        server.bind(new InetSocketAddress(InetAddress.getLocalHost(), SERVER_PORT), 50);\n        System.out.println(\"服务器准备就绪\");\n        System.out.println(\"服务端信息\" + server.getInetAddress() + \" port:\" + server.getLocalPort());\n        //监听客户端的消息\n        while (true) {\n            //阻塞方法\n            Socket client = server.accept();\n            ClientHandle clientHandle = new ClientHandle(client);\n            new Thread(clientHandle).start();\n        }\n    }\n\n    private static void initServerSocket(ServerSocket server) throws SocketException {\n        //同 client\n        server.setReuseAddress(true);\n        //设置 accept 的 buffer\n        server.setReceiveBufferSize(64 * 1024);\n        //设置 timeout\n        //server.setSoTimeout(2000);\n        //设置性能参数，连接前设置\n        server.setPerformancePreferences(1, 1, 1);\n    }\n\n    private static ServerSocket creatServerSocket() throws IOException {\n        ServerSocket server = new ServerSocket();\n        //绑定端口 backlog: 新连接队列的长度限制，不是链接的数量，是允许等待的队列长度\n        //server.bind(new InetSocketAddress(InetAddress.getLocalHost(),SERVER_PORT),50);\n        //server =new ServerSocket(SERVER_PORT,50); 等效方案\n        //server =new ServerSocket(SERVER_PORT,50,InetAddress.getLocalHost());\n        return server;\n    }\n\n    private static class ClientHandle implements Runnable {\n        private Socket socket;\n\n        ClientHandle(Socket client) {\n            this.socket = client;\n        }\n\n        //接收消息\n        public void run() {\n            System.out.println(\"新客户端连接：\" + socket.getInetAddress() + \"port：\" + socket.getPort());\n            try {\n                //输入流获取信息\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                //输出流响应客户端\n                PrintStream printStream = new PrintStream(socket.getOutputStream());\n                boolean flag = true;\n                do {\n                    String s = reader.readLine();\n                    if (\"bye\".equalsIgnoreCase(s)) {\n                        flag = false;\n                        System.out.println(\"客户端关闭了连接\");\n                        printStream.println(\"bye\");\n                    } else {\n                        System.out.println(s);\n                        printStream.println(\"字符串长度#\" + s.length());\n                    }\n                } while (flag);\n                reader.close();\n                printStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n> 具体的一些常用的方法解释都在代码的注释中 [参考](https://elf8848.iteye.com/blog/1739598)\n\n![mark](http://static.imlgw.top/image/20190707/eBKfzShaiIHU.png?imageslim)\n\n#### 传输基本数据类型\n\n上面的哪个小案例传送的都是字符串类型的数据，也许有同学会说这些基本类型不都是可以通过字符串来传吗？为什么要费那个劲去传这些基本类型？其实不然，这里假设要传送的是 int 类型的 12345678 ，如果通过 `int` 来传输只要在范围内都是** 4 **个字节大小固定，然而通过`String`传送将会是\"12345678\" 也就是** 8 **个字节，消耗要比使用`int`要大，而且长度不固定，不方便后期接受的长度判断。\n\n **`int` 类型**  \n\n在网络上传输的都是以** Byte **为基本单位，如果要传送** int **我们就需要将** int **转换为** byte**，一个** int **是 4 个字节，我们可以将其转换为一个** byte[] **数组，废话不多说，上代码\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/11 13:23\n */\npublic class ByteTools {\n    public static byte[] int2byte(int a) {\n        //无符号右移\n        return new byte[]{\n                (byte) (a >>> 24),\n                (byte) (a >>> 16),\n                (byte) (a >>> 8),\n                (byte) (a)\n        };\n    }\n    public static int byte2int(byte[] a) {\n        //&0xff-->转换为 int 将高位补 0, 低 8 位不变\n        //-127 ：10000001（补） &0xff --> 00000000 00000000 00000000 10000001\n        return a[3] & 0xff | (a[2] & 0xff) << 8 | (a[1] & 0xff) << 16 | (a[0] & 0xff) << 24;\n    }\n}\n```\n\n为什么这样做的一些细节可以参考 [这篇博客](https://www.cnblogs.com/think-in-java/p/5527389.html)\n\n有了这个工具类我们就可以将** int **转换为** byte[] **后进行传输，同时接收端也可以通过这个方法将数据还原。\n\n等等🙄 ，这样一来不是所有的类型对应的都要去写个这样的转换的方法？那还是有点麻烦的，而且也没有什么技术含量，所以这样的事情** JDK **帮我们做了\n\n**`ByteBuffer`**：nio 中的一个包，这里我还不太熟悉这个具体的作用，目前只知道可以用来包装** byte[]**，然后可以实现上面的类型转换\n\n**Client 发送端**\n\n```java\nbyte[] buffer=new byte[256];\n//包装 buffer （装饰器模式？\nByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\n//byte  1\nbyteBuffer.put((byte) 126);\n//int 类型 4\nbyteBuffer.putInt(123);\n//char 2(unicode)\nbyteBuffer.putChar('A');\n//long 8\nbyteBuffer.putLong(323333231234124321L);\nboolean isOk=true;\n//byte 1\nbyteBuffer.put((byte) (isOk?1:0));\n//float 4\nbyteBuffer.putFloat(123.2132F);\n//double 8 =28\nbyteBuffer.putDouble(231.1412421321);\n//String 10\nbyteBuffer.put(\"HelloWorld\".getBytes());\n//发送 38 Byte \nsocketOutputStream.write(buffer,0,byteBuffer.position());\n```\n\n需要注意的地方就是最后** write **的时候，第二个参数** len**，直接传** position()**, 就可以了，不用+1，这个 position 是下一个字节位置\n\n> 这里其实我看的教程这里是加 1 了的，最后接收过来的数据长度死活对不上，我开始还以为是什么**内存对齐**，什么乱七八糟的然后才发现是这里有问题。\n\n**Server 接收端**\n\n基本类型的读取与上面对应的** get**，最后一个 String 需要注意，直接用原始的** buffer **就可以了，不需要借助** ByteBuffer**，这里同样后面不用-1\n\n```java\nString str = new String(buffer, byteBuffer.position(), readByteCount-byteBuffer.position());\n```\n\n**测试结果**\n\n```java\n服务器准备就绪\n服务端信息 LAPTOP-V5R5ABUJ/192.168.25.1 port:20000\n新客户端连接：/192.168.25.1port：30000\n当前下标 28\n接受到 Client 数据长度 (byte)：38\nClient 发送的数据：\n126\n123\nA\n323333231234124321\ntrue\n123.2132\n231.1412421321\nHelloWorld\n```\n\n### UDP\n\n🔸  UDP 是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。\n\n🔸  UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。\n\n🔸   UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。\n\n🔸   UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用（如 IP 电话、实时视频会议等）要去源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太多的时延。UDP 正好符合这种要求。\n\n🔸   UDP 支持一对一、一对多、多对一和多对多的交互通信。\n\n🔸   UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。\n\n#### 单播\n\n**消息接收者**\n\n```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketAddress;\n/**\n * @author imlgw.top\n * @date 2019/7/7 21:31\n */\npublic class UDPProvide {\n    public static void main(String[] args) throws IOException {\n        //监听 20000 端口\n        DatagramSocket socket=new DatagramSocket(20000);\n        System.out.println(\"UDPProvide is start....\");\n        final byte[] buf=new byte[512];\n        //构建接受的 DatagramPacket\n        DatagramPacket udp_receive=new DatagramPacket(buf,buf.length);\n        //构建接受的 DatagramPacket （阻塞）\n        socket.receive(udp_receive);\n        //获取发送人的 SocketAddress\n        SocketAddress socketAddress = udp_receive.getSocketAddress();\n        int datalen = udp_receive.getLength();\n        //获取发送的数据\n        String receive=new String(udp_receive.getData(),0,datalen);\n        System.out.println(\"receive from the: \"+socketAddress);\n        System.out.println(\"receive data: \"+ receive);\n        //构建响应的 DatagramPacket\n        byte[] bytes = (\"provider receive the data success \"+datalen).getBytes();\n        DatagramPacket udp_sendBack=new DatagramPacket(bytes,bytes.length,socketAddress);\n        socket.send(udp_sendBack);\n        //结束\n        System.out.println(\"UDPProvide Finished.\");\n        socket.close();\n    }\n}\n```\n\n**消息发送者**\n\n```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n/**\n * @author imlgw.top\n * @date 2019/7/7 21:31\n */\n\npublic class UDPSearch {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"UDPSearch is ready...\");\n        //构建 socket\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buff= \"hello world\".getBytes();\n        //构建发送段\n        DatagramPacket udp_send=new DatagramPacket(buff,buff.length);\n        //指定对方 ip\n        udp_send.setAddress(InetAddress.getLocalHost());\n        udp_send.setPort(20000);\n        socket.send(udp_send);\n        //获取响应段\n        final byte[] buf=new byte[512];\n        DatagramPacket udp_receive=new DatagramPacket(buf,buf.length);\n        socket.receive(udp_receive);\n        String s = new String(udp_receive.getData(), 0, udp_receive.getLength());\n        System.out.println(s);\n        System.out.println(\"UDPSearch is over\");\n        socket.close();\n    }\n}\n```\n\n#### 多播&广播\n\n**消息建造器**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/8 8:48\n */\npublic class MessageCreator {\n    private static final String SN_HEADER = \"收到暗号，我是 SN:\";\n    private static final String PORT_HEADER = \"这是暗号，请回送到该端口：\";\n\n    public static String buildWithPort(int port) {\n        return PORT_HEADER + port;\n    }\n\n    public static int parsePort(String sn) {\n        if (sn.startsWith(PORT_HEADER)) {\n            return Integer.parseInt(sn.substring(PORT_HEADER.length()));\n        }\n        return  -1;\n    }\n\n    public static String buildWithSn(String sn){\n        return SN_HEADER+sn;\n    }\n\n    public static String parseSn(String sn){\n        if(sn.startsWith(SN_HEADER)){\n            return sn.substring(SN_HEADER.length());\n        }\n        return null;\n    }\n}\n```\n\n**消息接受者**\n\n```java\npackage UdpDemo2;\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.UUID;\n\n/**\n * @author imlgw.top\n * @date 2019/7/7 21:31\n */\npublic class UDPProvide {\n    public static int PROVIDE_LISTEN_PORT = 20000;\n\n    public static void main(String[] args) throws IOException {\n        String sn = UUID.randomUUID().toString();\n        Provider provider = new Provider(sn);\n        new Thread(provider).start();\n        System.in.read();\n        provider.shutdown();\n    }\n\n    public static class Provider implements Runnable {\n        public volatile boolean isDone = false;\n        public DatagramSocket socket = null;\n        public final String sn;\n\n        public Provider(String sn) {\n            this.sn = sn;\n        }\n\n        public void run() {\n            System.out.println(\"UDPProvide is start....\");\n            try {\n                socket = new DatagramSocket(PROVIDE_LISTEN_PORT);\n                while (!isDone) {\n                    final byte[] buf = new byte[512];\n                    //构建接受的 DatagramPacket\n                    DatagramPacket udp_receive = new DatagramPacket(buf, buf.length);\n                    //接受 DatagramPacket （阻塞）\n                    socket.receive(udp_receive);\n                    //获取发送人的 SocketAddress\n                    InetSocketAddress socketAddress = (InetSocketAddress) udp_receive.getSocketAddress();\n                    int datalen = udp_receive.getLength();\n                    //获取发送过来的数据\n                    String receive = new String(udp_receive.getData(), 0, datalen);\n                    //打印获取到的数据\n                    System.out.println(\"receive from the: \" + socketAddress);\n                    System.out.println(\"receive data: \" + receive);\n                    //解析 sn, 获取需要回送的端口\n                    int port = MessageCreator.parsePort(receive);\n                    if (port != -1) {\n                        //构建回送的 DatagramPacket\n                        byte[] responseBody = MessageCreator.buildWithSn(sn).getBytes();\n                        DatagramPacket udp_sendBack = new DatagramPacket(responseBody, 0, responseBody.length, socketAddress.getAddress(), port);\n                        socket.send(udp_sendBack);\n                    }\n                }\n            } catch (IOException e) {\n                // e.printStackTrace();\n            } finally {\n                closeRes();\n            }\n            //结束\n            System.out.println(\"UDPProvide Finished.\");\n        }\n\n        public void shutdown() {\n            isDone = true;\n            //这里仅仅 isDone=true 远远不够，因为 socket.receive 是一个永久阻塞的方法\n            //所以下面还要 close 这个 socket 这样就会捕获到一个异常然后结束\n            closeRes();\n        }\n\n        private void closeRes() {\n            if (socket != null) {\n                socket.close();\n                socket = null;\n            }\n        }\n    }\n}\n```\n\n与上面不同的是这里为了随时可以停止将其构建成了异步线程，当接受到终止信号的时候就会改变状态量，并 close 资源，然后利用异常停止线程。\n\n**消息发送者**\n\n```java\npackage UdpDemo2;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\n/**\n * @author imlgw.top\n * @date 2019/7/7 21:31\n */\n\npublic class UDPSearch {\n    private static final int SEARCH_LISTEN_PORT = 30000;\n    private static DatagramSocket socket = null;\n    public static void main(String[] args) throws IOException, InterruptedException {\n        System.out.println(\"UDPSearch is start...\");\n        Listener listen = listen();\n        sendBoard();\n        System.in.read();\n        List<Device> devices = listen.closeAndGetDeviceList();\n        for (Device device : devices) {\n            System.out.println(device);\n        }\n    }\n\n    private static Listener listen() throws InterruptedException {\n        System.out.println(\"UDPSearch Listener is start\");\n        CountDownLatch countDownLatch=new CountDownLatch(1);\n        Listener listener=new Listener(SEARCH_LISTEN_PORT,countDownLatch);\n        new Thread(listener).start();\n        countDownLatch.await();\n        return listener;\n    }\n\n    public static void sendBoard() throws IOException {\n        //系统自动分配的端口\n        DatagramSocket socket = new DatagramSocket();\n        //构建 socket\n        byte[] buff = MessageCreator.buildWithPort(SEARCH_LISTEN_PORT).getBytes();\n        //构建发送段\n        DatagramPacket udp_send = new DatagramPacket(buff, buff.length);\n        //广播地址\n        udp_send.setAddress(InetAddress.getByName(\"255.255.255.255\"));\n        //接收方的端口\n        udp_send.setPort(UDPProvide.PROVIDE_LISTEN_PORT);\n        socket.send(udp_send);\n        socket.close();\n        System.out.println(\"UDPSearch Board is over\");\n    }\n\n    private static class Device {\n        int port;\n        String ip;\n        String sn;\n\n        public Device(int port, String ip, String sn) {\n            this.port = port;\n            this.ip = ip;\n            this.sn = sn;\n        }\n        @Override\n        public String toString() {\n            return \"Device{\" +\n                    \"port=\" + port +\n                    \", ip='\" + ip + '\\'' +\n                    \", sn='\" + sn + '\\'' +\n                    '}';\n        }\n    }\n\n    public static class Listener implements Runnable {\n        private final int listenPort;\n        private final CountDownLatch countDownLatch;\n        private final List<Device> deviceList = new ArrayList<Device>();\n        //private static DatagramSocket socket = null;\n\n        private boolean isDone = false;\n\n        public Listener(int listenPort, CountDownLatch countDownLatch) {\n            this.listenPort = listenPort;\n            this.countDownLatch = countDownLatch;\n        }\n\n        public void run() {\n            //通知已经启动\n            countDownLatch.countDown();\n            try {\n                socket = new DatagramSocket(listenPort);\n                while (!isDone) {\n                    final byte[] buf = new byte[512];\n                    //构建接受的 DatagramPacket\n                    DatagramPacket udp_receive = new DatagramPacket(buf, buf.length);\n                    //接受 DatagramPacket （阻塞）\n                    socket.receive(udp_receive);\n                    //获取发送人的 SocketAddress\n                    InetSocketAddress socketAddress = (InetSocketAddress) udp_receive.getSocketAddress();\n                    int datalen = udp_receive.getLength();\n                    //获取发送过来的数据\n                    String sn = new String(udp_receive.getData(), 0, datalen);\n                    System.out.println(\"back from the：\" + socketAddress);\n                    System.out.println(\"back data：\" + sn);\n                    sn=MessageCreator.parseSn(sn);\n                    if (sn != null) {\n                        deviceList.add(new Device(socketAddress.getPort(), socketAddress.getAddress().toString(), sn));\n                    }\n                }\n            } catch (IOException e) {\n               //e.printStackTrace();\n            } finally {\n                closeRes();\n            }\n            System.out.println(\"UDPSearch Listener is Finished...\");\n        }\n\n        public void closeRes() {\n            if (socket != null) {\n                socket.close();\n                socket = null;\n            }\n        }\n\n        List<Device> closeAndGetDeviceList() {\n            isDone = true;\n            closeRes();\n            return deviceList;\n        }\n    }\n}\n\n```\n\n这里需要注意的就是广播的地址** 255.255.255.255**\n\n> 如果是在局域网内和其他机器通信需要关闭虚拟机的网卡，不然是走的虚拟机的网卡，其他机器接收不到。（我说怎么发送的** IP **不是我的本机的** IP**)\n\n🔸UDP 是面向无连接的通讯协议，基于用户数据报的协议\n\n🔸UDP 数据包括目的端口号和源端口号信息\n\n🔸通讯不需要连接，所以可以实现广播发送，并不局限于端到端\n\n🔸结构简单，无校验，速度快，容易丢包，可广播\n\n🔸他一旦把应用程序发给网络层的数据发送出去就不保留数据备份\n\n### UDP 辅助 TCP 实现点对点传输\n\n客户端先利用`UDP`向局域网发送广播，然后对应的服务器接收到之后就会将对应的`TCP`的端口回送给客户端，然后二者进行 TCP 的双向通信，代码太多这里就只放一下`Server`端的`Handler`\n\n```java\npackage udp_tcp_concurrency.server.handle;\n\nimport udp_tcp_concurrency.utils.CloseUtils;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * 用来处理客户端的类\n * @author imlgw.top\n * @date 2019/7/17 11:48\n */\npublic  class ClientHandler {\n\n    private final Socket socket;\n    private final ServerReadHandler serverReadHandler;\n    private final ServerWriterHandler serverWriterHandle;\n\n    private final CloseNotify closeNotify;\n\n    public ClientHandler(Socket socket, CloseNotify closeNotify) throws IOException {\n        this.socket = socket;\n        this.serverReadHandler = new ServerReadHandler(socket.getInputStream());\n        this.serverWriterHandle = new ServerWriterHandler(socket.getOutputStream());\n        this.closeNotify = closeNotify;\n        System.out.println(\"新客户端连接：\" + socket.getInetAddress() + \"port：\" + socket.getPort());\n    }\n\n    public void send(String str) {\n        serverWriterHandle.send(str);\n    }\n\n    //从外界关闭\n    public void stop() {\n        serverReadHandler.stopRead();\n        serverWriterHandle.stopWriter();\n        CloseUtils.close(socket);\n        System.out.println(\"客户端已经退出\");\n        System.out.println(\"address:\" + socket.getInetAddress() + \",port:\" + socket.getPort());\n    }\n\n    //自我关闭--->自闭\n    private void stopByMyself() {\n        stop();\n        closeNotify.onSelfClosed(this);\n    }\n\n    //读取并打印到屏幕（启动 ClientReadHandle 线程）\n    public void read2Print() {\n        new Thread(serverReadHandler).start();\n    }\n\n    /**\n     *  将已经关闭的 handle 暴露给 TCPServer 然后从 list 中移除\n     */\n    public interface CloseNotify{\n        void onSelfClosed(ClientHandler clientHandler);\n    }\n\n    /**\n     * 处理服务端用于读取客户端消息的 Handle\n     */\n    class ServerReadHandler implements Runnable {\n        private boolean done = false;\n        private final InputStream inputStream;\n\n        public ServerReadHandler(InputStream inputStream) {\n            this.inputStream = inputStream;\n        }\n\n        public void run() {\n            try {\n                //输入流获取信息\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                do {\n                    String s = reader.readLine();\n                    if (s == null) {\n                        System.out.println(\"客户端已经无法发送数据\");\n                        //结束当前 Handle\n                        ClientHandler.this.stopByMyself();\n                        break;\n                    }\n                    //打印到屏幕\n                    System.out.println(s);\n                } while (!done);\n            } catch (IOException e) {\n                if (!done) {\n                    //非正常关闭\n                    System.err.println(\"连接异常断开\"+e.getMessage());\n                    ClientHandler.this.stopByMyself();\n                }\n            } finally {\n                CloseUtils.close(inputStream);\n            }\n        }\n\n        public void stopRead() {\n            done = true;\n            CloseUtils.close(inputStream);\n        }\n    }\n\n    /**\n     * 处理服务端向客户端发送消息的 Handle\n     */\n    class ServerWriterHandler  {\n        private boolean done = false;\n        private final PrintStream printStream;\n        //线程池\n        private final ExecutorService executorService;\n\n        public ServerWriterHandler(OutputStream outputStream) {\n            this.printStream = new PrintStream(outputStream);\n            //单例线程池\n            executorService = Executors.newSingleThreadExecutor();\n        }\n\n        public void send(String str) {\n            //这里如果不用线程池\n            executorService.submit(new WriteRunnable(str));\n        }\n\n        //线程池的 Runnable\n        class WriteRunnable implements Runnable {\n            private final String msg;\n\n            public WriteRunnable(String msg) {\n                this.msg = msg;\n            }\n\n            @Override\n            public void run() {\n                if(ServerWriterHandler.this.done){\n                    return;\n                }\n                try {\n                    ServerWriterHandler.this.printStream.println(msg);\n                }catch (Exception e){\n                    System.out.println(\"write 异常退出：\"+e.getMessage());\n                }\n            }\n        }\n        \n        public void stopWriter() {\n            done = true;\n            CloseUtils.close(printStream);\n            executorService.shutdownNow();\n        }\n    }\n}\n\n```\n\n完整代码放在 [github](https://github.com/imlgw/socketDemo) 有一点需要注意的是这里用了一个单线程池去处理服务端发送消息的功能，这里其实用线程通信机制`wait/notify`也可以做到但是相比使用线程池会复杂许多。\n\n### 局域网聊天室实现\n\n> 这里的聊天室，其实关键的地方就在于对客户端发送的消息交由服务端进行转发。\n\n基于上面的进行改造\n\n```java\n/**\n* 回调接口\n*/\npublic interface ClientHandleCallBack {\n    /**\n    * 将已经关闭的 handle 暴露给 TCPServer 然后从 list 中移除\n    */\n\tvoid onSelfClosed(ClientHandler clientHandler);\n\n    /**\n    * 将消息交给服务器转发\n    * @param clientHandler\n    * @param msg\n    */\n\tvoid onNewMessageArrived(ClientHandler clientHandler,String msg);\n}\n```\n\n增加一个消息抵达的接口，然后为了避免阻塞交给异步的单线程池去处理\n\n```java\n\t@Override\n    public void onNewMessageArrived(ClientHandler clientHandler, String msg) {\n        System.out.println(\"Receive from:\"+clientHandler.getClientInfo()+\" msg:\"+msg);\n        forwardThreadPool.submit(()->{\n            for (ClientHandler clientHandle : clientHandles) {\n                //跳过自己\n                if(clientHandle.equals(clientHandler)){\n                    continue;\n                }\n                //对其他客户端发送消息\n                clientHandle.send(msg);\n            }\n        });\n    }\n```\n\n详细代码 见 [Github](https://github.com/imlgw/socketDemo)\n","tags":["Socket"],"categories":["网络编程"]},{"title":"JMeter 压测","url":"/2019/06/06/f990e699/","content":"\n## JMeter 入门\n\n[官网地址](http://jmeter.apache.org/) 下载好之后直接运行 jar 包 \n\n### 简单上手\n\n**添加线程组**\n\n![mark](http://static.imlgw.top/image/20190529/wBWwVD5chqtc.png?imageslim)\n\n**设置线程个数和配置**\n\n![mark](http://static.imlgw.top/image/20190529/KonWE6pHVdMz.png?imageslim)\n\nRamp-Up 就是多长时间内启动这些线程设置位 0 就是同时启动。\n\n**设置 HTTP 请求默认值**\n\n![mark](http://static.imlgw.top/image/20190529/73A4su1jMAWM.png?imageslim)\n\n设置好后再添加具体的请求的时候就不用再写这个了\n\n![mark](http://static.imlgw.top/image/20190529/Uwy5zrWzFsji.png?imageslim)\n\n**添加 HTTP 请求**\n\n![mark](http://static.imlgw.top/image/20190529/iVbmgkdG7D88.png?imageslim)\n\n这里对我们的秒杀商品列表进行压测。\n\n**添加监听器**\n\n![mark](http://static.imlgw.top/image/20190529/yVm6imNhWYKe.png?imageslim)\n\n这里添加比较常用的聚合报告就可以了\n\n**结果**\n\n![mark](http://static.imlgw.top/image/20190531/C3pwAwyh7BhG.png?imageslim)\n\n这里我们可以需要关注的就是吞吐量这个参数，一开始可能会不太准多测几次。\n\n同时我们也可以用 Linux 的`top`命令查看当前 CPU 的利用率。\n\n### 添加自定义参数\n\n![mark](http://static.imlgw.top/image/20190601/VQ9adD8KBfvA.png?imageslim)\n\n![mark](http://static.imlgw.top/image/20190601/j1XB0mewqvJG.png?imageslim)\n\n```java\n17362363659,3d3ae96d381d4376b87cb7ebf14aadb6\n12012341234,fbb11e35f16b4a54be1315a0a1619193\n11012341234,58d63f1d9482472f907829da2ae3b4ff\n10012341234,09fe09587b924c49b6db64f763c1ad10\n```\n\n**效果**\n\n![mark](http://static.imlgw.top/image/20190601/5up85aDbSTWM.png?imageslim)\n\n### 生成 token\n\n方便后面的压测，可以直接写一个工具类生成 token 供后面的 redis 使用\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest\npublic class TokenUtils {\n\n    @Autowired\n    private SpikeUserService spikeUserService;\n\n    static String str=\"0123456789\";\n\n    static  Random random = new Random();\n\n    static HttpServletResponse resp;\n\n    @Test\n    public  void test() throws IOException {\n        FileOutputStream outputStream=new FileOutputStream(new File(\"D:\\\\AliyunKey\\\\config.txt\"));\n        for (int i=0;i<20000;i++){\n            String phone = creatPhone();\n            RegisterVo registerVo = new RegisterVo(phone,\"123456\",\"user-\"+i);\n            spikeUserService.register(registerVo);\n            //需要在 service 层 token 返回出来\n            String token= spikeUserService.login(resp, new LoginVo(registerVo.getMobile(), registerVo.getPassword()));\n            outputStream.write((phone+\",\"+token+\"\\n\").getBytes());\n        }\n    }\n\n    public  String creatPhone(){\n        String res=\"1\";\n        for (int i=0;i<10;i++){\n            res+=str.charAt(random.nextInt(10));\n        }\n        return res;\n    }\n}\n```\n\n### Redis 压测\n\n①redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000\n\n100 个并发，十万个请求，对常用的一些命令进行测试\n\n![mark](http://static.imlgw.top/image/20190601/oPkioXCFgL8R.png?imageslim)\n\n②redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100\n\n100 bytes payload \n\n-q 是 quiet 输出信息较少\n\n③ redis-benchmark -n 100000 -q script load \"redis.call('set','foo','bar')\"\n\n对特定的语句压测\n\n##  搭建压测环境\n\n### 命令行压测\n\n其实还是需要借助图形界面来录好 jmx 文件然后上传到 Linux 上，然后执行\n\nsh jmeter.sh -n -t Xxx.jmx -l result.jtl\n\n然后再用图形界面导入 result.jtl 就可以看到结果\n\n> 上面的测试都是在我的开发机 (win) 上进行的，压测和服务都在本地，结果可能并不准确，这里为了隔离环境我开了了 2 个虚拟机，一个是部署服务的机器（2G 4 核），一个是部署 mysql 和 redis 的机器（2G 4 核），这里在 Linux 上运行部署项目有两种方式，一种是打成 war 包放在 tomcat 目录下，一种是打成 jar 包直接运行。\n\n### 环境\n\n✔ 192.168.25.123   Centos6  mysql+redis  2G4 核\n\n✔ 192.168.25.4     Centos7   SpikeServer+压测  2.5G 4 核\n\n✔~~win10 开发机     Jmeter 压测 SpikeServer~~ \n\n✔~~192.168.25.129 Centos7 压测设备 2G4 核~~\n\n### SpringBoot 打 war 包\n\n**添加 tomcat 依赖（编译时依赖）**\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n\t<scope>provided</scope>\n</dependency>\n```\n\n**添加一个 maven 插件**\n\n```java\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-war-plugin</artifactId>\n\t<configuration>\n    \t<failOnMissingWebXml>false</failOnMissingWebXml>\n\t</configuration>\n</plugin>\n```\n\n**修改 pom 打包方式位 war**\n\n```java\n<packaging>war</packaging>\n```\n\n**boot 类添加一个方法**\n\n```java\n@SpringBootApplication\npublic class SpikeApplication extends SpringBootServletInitializer {\n    public static void main(String[] args) {\n        SpringApplication.run(SpikeApplication.class, args);\n    }\n    /**\n     * @param builder\n     * @return 打 war 包\n     */\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {\n        return builder.sources(SpikeApplication.class);\n    }\n}\n```\n\n然后在项目目录下执行`mvn clean package`就会在 target 目录下生成 war 包，然后将 war 包拷到 tomcat 里面就可以直接运行了。\n\n### SpringBoot 打 jar 包\n\n**pom 里的打包方式改为 jar（默认就是 jar)**\n\n```java\n<packaging>war</packaging>\n```\n\n**添加一个 maven 插件**\n\n```java\n<!--打 jar 包的插件-->\n<plugin>\n    <groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-maven-plugin</artifactId>\n</plugin>\n```\n\n**执行 mvn clean package**\n\n同上会在 target 目录下生成一个 jar 包，jar 包内容大致如下\n\n```java\nManifest-Version: 1.0\nImplementation-Title: Spike\nImplementation-Version: 1.0-SNAPSHOT\nBuilt-By: priva\nImplementation-Vendor-Id: top.imlgw\nSpring-Boot-Version: 2.1.2.RELEASE\nMain-Class: org.springframework.boot.loader.JarLauncher\nStart-Class: top.imlgw.spike.SpikeApplication\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nCreated-By: Apache Maven 3.5.3\nBuild-Jdk: 1.8.0_172\nImplementation-URL: https://projects.spring.io/spring-boot/#/spring-bo\n ot-starter-parent/Spike\n```\n\n如果确少一些信息比如 Main-Class 和 Start-Class，说明 jar 包打的有问题，运行会报`没有主清单属性`，我一开始没注意，我的`plugins`上层还有个`pluginmanagement`插件根本没加载进来，去掉就行了。\n\n## 开始压测\n\n### 压测商品列表页面\n\n```java\n@RequestMapping(\"/to_list\")\npublic String tolist(Model model,SpikeUser spikeUser) {\n    List<GoodsVo> goodsVos = goodsService.goodsVoList();\n    model.addAttribute(\"user\", spikeUser);\n    model.addAttribute(\"goodsList\",goodsVos);\n\treturn \"goods_list\";\n}\n```\n\n这个接口主要就做了一个查询的 mysql 的操作，没有 cookie 所以不会去操作 redis\n\n### 遇到的问题\n\n一开始直接设置了 5000*10 的并发，然后服务端报了   打开文件过多的错误\n\n```java\njava.io.IOException: 打开的文件过多\n        at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method) ~[na:1.8.0_171]\n        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422) ~[na:1.8.0_171]\n        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250) ~[na:1.8.0_171]\n        at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:448) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14]\n        at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:70) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14]\n        at org.apache.tomcat.util.net.Acceptor.run(Acceptor.java:95) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14]\n        at java.lang.Thread.run(Thread.java:748) [na:1.8.0_171]\n```\n\ngoogle 后发现是句柄太少的原因，Linux 默认是 1024，而我们同时起了 5000 个线程自然就出问题了。\n\n通过`ulimit -a` 可以查看到当前的最大句柄数`open files` ，这里我们可以通过 `ulimit -n 2048`临时的设置一个较大的值，但是重启后就会失效。\n\n```java\ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 14707\nmax locked memory       (kbytes, -l) 64\nmax memory size         (kbytes, -m) unlimited\nopen files                      (-n) 1024\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 14707\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n```\n\n这里最好是直接修改  /etc/security/limits.conf\n\n```java\n*  soft nofile  32768\n*  hard nofile 65536\n```\n\n就可以将文件句柄限制统一改成软 32768，硬 65536。配置文件最前面的是指 domain，设置为星号代表全局，另外你也可以针对不同的用户做出不同的限制。\n\n注意：这个当中的硬限制是实际的限制，而软限制，是 warnning 限制，只会做出 warning，其实 ulimit 命令本身就有分软硬设置，加-H 就是硬，加-S 就是软\n\n修改后记得重启才会生效 [参考资料](https://www.cnblogs.com/ibook360/archive/2012/05/11/2495405.html) \n\n一开始是打算直接用 win 开发机做压测的，但是发现在进程开大了之后老是跑不完，跑一半就停了（可能是内存给小了），而且数据出入也比较大，然后改用秒杀服务的那条机器来压测，一开始只增大了跑秒杀服务的虚拟机，发现还是会有异常，然后我把 mysql 和 redis 的虚拟机也调大了就没报异常了，但是在压测的时候秒杀服务的虚拟机 cpu 飙到了 `9.0+`，4 核的机子，cpu 飙到这么高就有点问题了一般来说应该维持在 `4*0.7` 左右。\n\n![mark](http://static.imlgw.top/image/20190604/LedMcRvfSXeb.png?imageslim)\n\n![mark](http://static.imlgw.top/image/20190604/UbcTCaTGiEJ9.png?imageslim)\n\n可以看到平均等待时间都在 2s 以上。\n\n为了更准确的模拟，我又开了一台~~1G2 核~~ 2G4 核的虚拟机专门来做压测（8G 内存吃不消了）。\n\n![mark](http://static.imlgw.top/image/20190604/pr4yMAE2Jamf.png?imageslim)\n\n这里用 top 观察了两台虚拟机的情况发现 mysql 的那台机器负载一直很低，SpikeServer 那台机器（1G 双核）负载一路飙到 6.0+。吞吐率也明显的下降了，这里我连续测试了两次都是 400 多。\n\n### 最终配置\n\n经过一上午的折腾，我决定还是值利用两台你虚拟机，一台跑 SpikeServer 和压测，另外一台跑 mysql 和 redis，再启动一台成本太大了，这里主要根据这个做一个标准量，后期优化后拿来对比\n\n#### 结果\n\n![mark](http://static.imlgw.top/image/20190604/IEGxtWU8pujI.png?imageslim)\n\n后面在调整机器或连续测试了 5，6 次 在 5000 的并发下 QPS 大概是 1000 左右的样子，小于 1000。\n\n### 压测 Redis 查询的性能\n\n上面的 goods_list 实际上只对 mysql 进行了一个查询操作，而 mysql 的并发量并不大。\n\n下面我们单独对 redis 做一下压测，看下系统的 QPS（这里）\n\n![mark](http://static.imlgw.top/image/20190604/h2NOJszwC7Lo.png?imageslim)\n\n#### 结果\n\n一开测试忘了调大 redis 链接池的大小，一直跑不出来，后来改大之后测了 4，5 次，同样的 5000 并发 10 次，QPS 大概在 3000 左右\n\n![mark](http://static.imlgw.top/image/20190606/58L5ieKaxR7a.png?imageslim)\n\n可以说是相当快了，而且`top`观察 redis 那台机器发现负载依然很低，说明这点并发确实对 redis 来说是小意思，前面其实也单独对 redis 用它自带的压测工具测试过，大概每秒 10 0000 的 GET 是没问题的\n\n### 重头戏—压测 do_spike 接口\n\n```java\n @RequestMapping(\"/do_spike\")\n public String do_spike(Model model, SpikeUser spikeUser, @RequestParam(\"goodsId\") long goodsId) {\n        if (spikeUser==null) { //没有登录\n            return \"login\";\n        }\n        //检查库存\n        GoodsVo goodsVo= goodsService.getGoodsVoByGoodsId(goodsId);\n        int stock=goodsVo.getStockCount(); //这里拿的秒杀商品里面的库存，不是商品里面的库存\n        if(stock<=0){\n            model.addAttribute(\"failMsg\",CodeMsg.STOCK_EMPTY);\n            return \"spike_fail\";\n        }\n        //看是否重复秒杀\n        SpikeOrder spikeOrder=spikeService.getGoodsVoByUserIdAndGoodsId(spikeUser.getId(), goodsId);\n        if(spikeOrder!=null){\n            model.addAttribute(\"failMsg\",CodeMsg.SKIPE_REPEAT);\n            return \"spike_fail\";\n        }\n        OrderInfo orderInfo=spikeService.doSpike(spikeUser.getId(),goodsVo);\n        model.addAttribute(\"orderInfo\",orderInfo);\n        model.addAttribute(\"goods\",goodsVo);\n        return \"order_detail\";\n }\n```\n\n步骤都跟上面一样，不过要多加一个商品 id 的参数，这里依然是 5000 的并发 10 次，其实这里测出来的结果和上面的商品列表差不太多，差不多 950 左右 QPS，毕竟这里有判断库存的操作，一旦小于 0 之后就不会对 mysql 再进行操作，进行复杂的**减库存**和**生成订单**操作\n\n#### 超卖问题\n\n本来只有 10 件商品，硬生生给减成了负数😂\n\n![mark](http://static.imlgw.top/image/20190606/m5RhIzmdXRV1.png?imageslim)\n\n可以看到有 16 个人秒杀到了这个商品这显然是不合理的\n\n![mark](http://static.imlgw.top/image/20190606/nJmnvKvVzAHt.png?imageslim)\n\n这个问题会在后面的文章中提出解决方案，这一篇主要熟悉下压测。","tags":["JMeter","秒杀"],"categories":["Web"]},{"title":"数据库大作业","url":"/2019/05/20/bc749bca/","content":"\n## 准备工作\n\n### 环境\n\n- JDK（建议 1.8 以上）\n- 开发工具，Eclipse 或者 idea ...\n- **mysql **或者** mssql**（我是用的** mysql5.7.17**，给的 demo 是 mysql 的）\n\n### 测试给的 Demo \n\n①装好 mysql 之后启动它，然后用管理工具我用的是** navicat**，打开然后将给的 demo 里面的 sql 脚本导入进去（导入不好的可以手动建立一个，用脚本文件导入后的名字是 tb_demo，我这里是手动建的）\n\n<video controls=\"controls\" src=\"http://static.imlgw.top/image/20190530/M2IOTaKdyaQO.mp4\" width=\"100%\"></video>\n\n![mark](http://static.imlgw.top/image/20190524/oNHeEFJhHEYX.png?imageslim)\n\n最后差不多是这样的结构\n\n②在** Eclipse **里面** import **项目，这里我** import **会有个感叹号，**最好重新建一个项目，不然可能会有奇怪的错误**下面是**如何新建的步骤视频**\n\n<video controls=\"controls\" src=\"http://static.imlgw.top/f0xim-iyaow.mp4\" width=\"100%\"></video>\n\n这里要改的地方就是 DbUtil 里面数据库配置\n\n```java\npublic class DbUtil {\n\t//com.microsoft.sqlserver.jdbc.SQLServerDriver\n    //数据库驱动的名字（1.6 还是 1.8 之后就不需要了，这里还是加上吧）\n\tString driverName = \"com.mysql.jdbc.Driver\";\n\t//jdbc:sqlserver://127.0.0.1:1433;DatabaseName=demo\n    //连接数据库的地址，前面的不用改，这里要改的就是后面的 demo 换成你的数据库名字（我上面的是 demo）\n\tString dbURL = \"jdbc:mysql://localhost:3306/demo\";\n    //你的数据库的帐号\n\tString userName = \"root\";\n    //装 mysql 时设置的密码\n\tString userPwd = \"admin\"; \n\n\tpublic Connection getCon() throws ClassNotFoundException, SQLException {\n\t\tClass.forName(driverName);\n\t\tConnection conn = DriverManager.getConnection(dbURL, userName, userPwd);\n\t\treturn conn;\n\t}\n\n\tpublic void closeCon(Connection conn) throws SQLException {\n\t\tif (conn != null)\n\t\t\tconn.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tDbUtil dbUtil = new DbUtil();\n\t\ttry {\n\t\t\tdbUtil.getCon();\n\t\t\tSystem.out.println(\"连接成功\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n#### 注意事项\n\n```java\n\t//com.microsoft.sqlserver.jdbc.SQLServerDriver\n    //数据库驱动的名字（1.6 还是 1.8 之后就不需要了，这里还是加上吧）\n\tString driverName = \"com.mysql.jdbc.Driver\";\n\t//jdbc:sqlserver://127.0.0.1:1433;DatabaseName=demo\n    //连接数据库的地址，这里要改的就是后面的 demo 换成你的数据库名字（我上面的是 demo）\n\tString dbURL = \"jdbc:mysql://localhost:3306/demo\";\n    //你的数据库的帐号\n\tString userName = \"root\";\n    //密码\n\tString userPwd = \"admin\"; \n```\n\n要改的差不多就是这 4 个配置\n\n①如果是** mysql **并且版本是 8 以下的，那么** driverName** 可以不用改，如果是 8 以上的（群里面那个是 8 以上的）就需要改成\n\n**com.mysql.cj.jdbc.Driver**，并且**找到适合版本的驱动拷贝到 lib 目录然后右键 bulidpath**（在这之前先将老的驱动删掉，bulidpath 的作用是将 jar 包**真正的**加到你的项目中去）\n\n- 8 以上 驱动下载地址 链接：https://pan.baidu.com/s/1WXjAAHX5gQC6v5pfiTOqmQ  提取码：5lf5 \n\n- sqlServer 需要改的地方我也注释在上面但是我电脑上没 sqlserver 我没有测试，老师给的包里面有 sqlserver 的驱动\n\n②**dbURL**，前面的不用改，这里只需要改一下后面的数据库名字，比如我上面建的数据库名字是** demo**, 后面就应该是/demo（如果用脚本直接导入生成的数据库名字是 db_demo，这里就要改成 jdbc:mysql://localhost:3306/db_demo\n\n- 对应 sqlserver 的我也放在上面但是我没装 sqlserver 所以没测试。\n\n③**userName**，数据库账号（一般默认就是 root）\n\n④**password**，数据库密码\n\n### 启动\n\n在 view 包下的** MainPage**，这是用 java 的 swing 组件开发的一个 GUI 页面，最下面有一个 main 函数直接启动它就行，（如果有乱码，需要将 eclipes 的工作空间的编码方式换为** utf-8**），到此环境就基本 ok 了，后面的就是写代码的事了。\n\n### 改用自己的数据库\n\n> 后面的部分主要是代码的问题了，每个人数据库不同也会有一些差距\n\n- 导入自己的数据\n\n  数据库名字，字段名不要用中文！\n\n  数据库名字，字段名不要用中文 ！\n\n  数据库名字，字段名不要用中文！\n\n- 实体类改成自己的\n\n```java\nimport java.util.Date;\n\npublic class StuInfo {\n\n\tprivate Long stuId;\n\tprivate String stuName;\n\tprivate String stuSex;\n\tprivate Date stuDob;\n\tprivate String stuMajor;\n\t\n\tpublic Long getStuId() {\n\t\treturn stuId;\n\t}\n\n\tpublic void setStuId(Long stuId) {\n\t\tthis.stuId = stuId;\n\t}\n\n\tpublic String getStuName() {\n\t\treturn stuName;\n\t}\n\n\tpublic void setStuName(String stuName) {\n\t\tthis.stuName = stuName;\n\t}\n\n\tpublic String getStuSex() {\n\t\treturn stuSex;\n\t}\n\n\tpublic void setStuSex(String stuSex) {\n\t\tthis.stuSex = stuSex;\n\t}\n\n\tpublic Date getStuDob() {\n\t\treturn stuDob;\n\t}\n\n\tpublic void setStuDob(Date stuDob) {\n\t\tthis.stuDob = stuDob;\n\t}\n\n\tpublic String getStuMajor() {\n\t\treturn stuMajor;\n\t}\n\n\tpublic void setStuMajor(String stuMajor) {\n\t\tthis.stuMajor = stuMajor;\n\t}\n\t\n\tpublic StuInfo() {\n\n\t}\n\n\tpublic StuInfo(String stuName, String stuSex, Date stuDob, String stuMajor) {\n\t\tthis.stuName = stuName;\n\t\tthis.stuSex = stuSex;\n\t\tthis.stuDob = stuDob;\n\t\tthis.stuMajor = stuMajor;\n\t}\n}\n```\n\n这里实体类是和数据库的表和字段对应的，一个 StuInfo 对象就对应一条数据。\n\n- 增删改查的修改\n\n```java\n\npublic class UserDao {\n\tpublic ResultSet getUsers(User user, Connection con) throws SQLException {\n\t\tStringBuffer sql = new StringBuffer(\"select * from t_user \");\n\t\tif (user.getUserName()!= null) {\n\t\t\tsql.append(\" where userName like '%\"+user.getUserName()+\"%'\");\n\t\t}\n\t\tPreparedStatement ps = con.prepareStatement(sql.toString());\n\t\treturn ps.executeQuery();\n\t}\n\t\n\tpublic int delete(User user, Connection con) throws SQLException{\n\t\tString sql=\"delete from t_user where userName='\"+user.getUserName()+\"'\";\n\t\tPreparedStatement ps = con.prepareStatement(sql);\n\t\treturn ps.executeUpdate();\n\t}\n\t\n\tpublic int add(User user, Connection con) throws SQLException{\n\t\tString sql=\"insert into t_user  values(?,?)\";\n\t\tPreparedStatement ps = con.prepareStatement(sql);\n\t\tps.setString(1, user.getUserName());\n\t\tps.setString(2, user.getTel());\n\t\treturn ps.executeUpdate();\n\t}\n\t\n\tpublic int modify(User user, Connection con) throws SQLException{\n\t\tString sql=\"update t_user  set userName=?, tel=? where userName = '\"+user.getUserName()+\"'\";\n\t\tPreparedStatement ps = con.prepareStatement(sql);\n\t\tps.setString(1, user.getUserName());\n\t\tps.setString(2, user.getTel());\n\t\tSystem.out.println(sql);\n\t\treturn ps.executeUpdate();\n\t}\n}\n\n```\n\n最终都是通过调用这个 Dao 类实现的增删改查。\n\n- 页面的修改\n\n按照老师的要求是对我们常用的数据库做增删改查，因为我们用的数据库和给的 demo 的表结构不一样，所以需要修改 MainPage，这个是用 java 的 swing 写的一个 GUI，所以需要改这些界面上的一些元素，我记的好像有个插件可以直接拖动生成 swing 这些界面的（看见刘勇用过），我对 swing 不熟悉（早就过时了，没有学的意义），我用 web 写的界面\n\n![mark](http://static.imlgw.top/image/20190530/96gB7wwVz4Xj.png?imageslim)\n\n### Mysql\n\n[Mysql5.7 解压版的安装和卸载及常见问题](https://blog.csdn.net/mr_green1024/article/details/53222526?tdsourcetag=s_pcqq_aiomsg)\n","tags":["工具"],"categories":["工具"]},{"title":"WebMvcConfigurer 小结","url":"/2019/05/20/a28427/","content":"\n## 起源\n\n利用 Redis 做分布式 session，因为没有借助 Spring-session 或者其他的 session 共享方案，手动处理 session 的存取，在控制层获取 cookie 中的数据是较为麻烦，所以希望直接将 cookie 的数据转化为需要的 bean 然后绑定到参数中，这里就可以借助** WebMvcConfigurer **来实现这个需求简化代码\n\n## WebMvcConfigurer 是干嘛的？\n\nSpring 把实现了 WebMvcConfigurer 接口的 bean 都看作为 SpringMvc 的**扩展配置**，如果既想要使用 SpringBoot 对 SpringMvc 的自动配置，又想要对自动配置进行扩展，添加一些用户自己的配置，像拦截器，消息转换器或者下文中的参数绑定，只需要写一个实现了 WebMvcConfigurer 接口的配置类，实现相关方法就能够添加自己的配置了。\n\n> SpringBoot2.0 之前也就是 Spring5 之前可以直接继承** WebMvcConfigurationAdapter**+**@EnableWebMvc **注解来实现上述需求，但是这个方法在之后的版本中弃用了（还可以用但是不太好），因为 jdk8 之后的接口中可以有**默认方法**了，所以这个抽象类就并没有存在的意义了\n\n### WebMvcConfigurationSupport\n\n其实还有一种方法就是直接继承这个 WebMvcConfigurationSupport，上面的 WebMvcConfigurer 只是扩展配置，如果直接继承 WebMvcConfigurationSupport，那么就可以重写默认的配置，如果对原理不是很清楚的开发者不小心重写错了默认的配置，springmvc 可能相关功能就无法生效。\n\n## WebMvcConfigurer 内的方法\n\n```java\npublic interface WebMvcConfigurer {\n    default void configurePathMatch(PathMatchConfigurer configurer) {\n    }\n\n    default void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n    }\n\n    default void configureAsyncSupport(AsyncSupportConfigurer configurer) {\n    }\n\n    default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n    }\n\n    default void addFormatters(FormatterRegistry registry) {\n    }\n\t\n    //添加拦截器\n    default void addInterceptors(InterceptorRegistry registry) {\n    }\n\t//添加资源处理器\n    default void addResourceHandlers(ResourceHandlerRegistry registry) {\n    }\n\n    default void addCorsMappings(CorsRegistry registry) {\n    }\n\t//视图控制器\n    default void addViewControllers(ViewControllerRegistry registry) {\n    }\n\n    default void configureViewResolvers(ViewResolverRegistry registry) {\n    }\n\t//添加参数解析器\n    default void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {\n    }\n\n    default void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> handlers) {\n    }\n\t//消息转换器\n    default void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n    }\n\n    default void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n    }\n\n    default void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n    }\n\n    default void extendHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n    }\n\n    @Nullable\n    default Validator getValidator() {\n        return null;\n    }\n\n    @Nullable\n    default MessageCodesResolver getMessageCodesResolver() {\n        return null;\n    }\n}\n```\n\n## 注意事项\n\n在** SpringBoot **下自定义的 WebMvcConfigurer 实现配置类上是不需要添加**@EnableWebMvc **的，因为** SpringBoot **已经实例化了 WebMvcConfigurationSupport，如果添加了该注解，默认的 WebMvcConfigurationSupport 配置类就会失效，mvc 默认的配置会失效，也就是以用户定义的为主，一般建议还是不覆盖默认的好。\n\n这点可以从 SpringBoot 的** WebMvcAutoConfiguration **中看到。（@EnableWebMvc 会导入一个 WebMvcConfigurationSupport 的子类，叫 DelegatingWebMvcConfiguration）。\n\n![mark](http://static.imlgw.top///20190520/p5I6RuWHJPMy.png?imageslim)\n\n当没有 WebMvcConfigurationSupport 的时候自动配置才会生效\n\n> [官方文档](https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration)\n>\n> If you want to keep Spring Boot MVC features and you want to add additional [MVC configuration](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc) (interceptors, formatters, view controllers, and other features), you can add your own `@Configuration` class of type `WebMvcConfigurer` but **without** `@EnableWebMvc`. If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter`, or `ExceptionHandlerExceptionResolver`, you can declare a `WebMvcRegistrationsAdapter` instance to provide such components.\n\n## 实例\n\n### Controller 参数绑定\n\n在 SpringMVC 里面可以轻松的把表单的数据映射到对应的 bean 中，但是有时候这并不能满足我们的需求，比如下面的例子。\n\n```java\n@RequestMapping(\"/to_list\")\npublic String tolist(HttpServletResponse response, Model model,\n                         @CookieValue(value = SpikeUserService.COOK1_NAME_TOKEN, required = false) String cookie,\n                         @RequestParam(value = SpikeUserService.COOK1_NAME_TOKEN, required = false) String param) {\n        /*手机浏览器，有可能将 cookie 放在参数中*/\n        if (param == null && cookie == null) {\n            return \"login\";\n        }\n        String cook = cookie != null ? cookie : param;\n        SpikeUser user = spikeUserService.getUserByToken(response, cook);\n        System.out.println(user);\n        model.addAttribute(\"user\", user);\n        return \"goods_list\";\n }\n```\n\n可以看到这里为了获取这个** SpikeUser **对象并不能直接从表单中获取，需要借助 cookie 然后从 redis 里面查询，如果下面还有一些其他的 controller 需要获取这个对象，又要写很多重复的代码。这个时候我们就可以通过上面介绍的 WebMvcConfigurer 来实现简化代码。\n\n####  重写 addArgumentResolvers\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    \n    @Autowired //注入我们的参数解析器\n    SpikeUserArgumentResolver spikeUserArgumentResolver;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(spikeUserArgumentResolver);\n    }\n}\n```\n\n这里只需要实现** addArgumentResolvers **就可以了，注意加上**@Configuration **注解将 WebConfig 托付给 Spring，使我们添加的参数解析器生效。\n\n#### 实现 HandlerMethodArgumentResolver\n\n```java\n@Service\npublic class SpikeUserArgumentResolver implements HandlerMethodArgumentResolver {\n\n    @Autowired\n    SpikeUserService userService;\n\n    public boolean supportsParameter(MethodParameter parameter) {\n        Class<?> clazz = parameter.getParameterType();\n        //处理 SpikeUser 类型的\n        return clazz==SpikeUser.class;\n    }\n\n    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\n        String paramToken = request.getParameter(SpikeUserService.COOK1_NAME_TOKEN);\n        String cookieToken = getCookieValue(request, SpikeUserService.COOK1_NAME_TOKEN);\n        if(StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {\n            return null;\n        }\n        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;\n        return userService.getUserByToken(response,token);\n    }\n\n    private String getCookieValue(HttpServletRequest request, String cookiName) {\n        Cookie[]  cookies = request.getCookies();\n        for(Cookie cookie : cookies) {\n            if(cookie.getName().equals(cookiName)) {\n                return cookie.getValue();\n            }\n        }\n        return null;\n    }\n}\n```\n\n然后就可以直接在在控制器中拿到 SpikeUser 了，代码变得清爽简洁\n\n```java\n\t@RequestMapping(\"/to_list\")\n    public String tolist(Model model,SpikeUser spikeUser) {\n        if (spikeUser==null) {\n            return \"login\";\n        }\n        model.addAttribute(\"user\", spikeUser);\n        return \"goods_list\";\n    }\n\n\t//未优化\n    @SuppressWarnings(\"all\")\n    @RequestMapping(\"/to_list0\")\n    @Deprecated\n    public String tolist0(HttpServletResponse response, Model model,\n                         @CookieValue(value = SpikeUserService.COOK1_NAME_TOKEN, required = false) String cookie,\n                         @RequestParam(value = SpikeUserService.COOK1_NAME_TOKEN, required = false) String param) {\n                            //手机浏览器，有可能将 cookie 放在参数中\n        System.out.println(\"cookie:\" +cookie);\n        System.out.println(\"param \" +param);\n        if (param == null && cookie == null) {\n            return \"login\";\n        }\n        String cook = cookie != null ? cookie : param;\n        SpikeUser user = spikeUserService.getUserByToken(response, cook);\n        System.out.println(user);\n        model.addAttribute(\"user\", user);\n        return \"goods_list\";\n    }\n\n```\n\n这也算是对 SpringMVC 原理的初次接触吧，后面关于框架还是多看源码啊。\n\n关于** Spring-Session **的内容后面用到再来介绍。\n\n### 拦截器\n\n依然是 SpringBoot2，所以还是实现的** WebMvcConfigurer **接口\n\n先看下拦截器的执行流程\n\n![来自慕课](http://static.imlgw.top/image/20190609/vUv7FDoickvl.png?imageslim)\n\n#### 自定义注解\n\n```java\npackage top.imlgw.spike.intercept;\n\nimport java.lang.annotation.*;\n\n/**\n * @author imlgw.top\n * @date 2019/6/9 15:13\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface NeedLogin {\n    boolean needLogin() default true;\n}\n```\n\n#### 重写 HandlerInterceptor\n\n```java\npackage top.imlgw.spike.intercept;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.method.HandlerMethod;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport top.imlgw.spike.entity.SpikeUser;\nimport top.imlgw.spike.service.SpikeUserService;\nimport top.imlgw.spike.utils.UserContext;\n\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author imlgw.top\n * @date 2019/6/8 23:22\n */\n@Component\npublic class LoginIntercept implements HandlerInterceptor {\n\n    @Autowired\n    SpikeUserService spikeUserService;\n\n    /**\n     * @param request\n     * @param response\n     * @param handler\n     * @return 在登陆前拦截\n     * @throws Exception\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        if(!(handler instanceof HandlerMethod)){\n            return true;\n        }\n        HandlerMethod hm=(HandlerMethod) handler;\n        SpikeUser spikeUser = getSpikeUser(request, response);\n        //有的页面不需要登陆（二次登陆）但是需要用户信息（订单页面。..)，所以需要先存进去\n        UserContext.setUser(spikeUser);\n        //获取方法上的注解\n        NeedLogin needLogin = hm.getMethodAnnotation(NeedLogin.class);\n        if(needLogin==null || ! needLogin.needLogin()){\n            //没有注解后者注解为 false, 就直接放过\n            return true;\n        }\n        //有注解，没登陆\n        if(spikeUser==null){\n            return false;\n        }\n        return true;\n    }\n\n    /** 视图渲染完毕后调用（收尾工作）\n     * @param request\n     * @param response\n     * @param handler\n     * @param ex\n     * @throws Exception\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        //删除 ThreadLocal 中的 User 否则会产生错乱\n        UserContext.removeUser();\n    }\n\n\t\n    private SpikeUser getSpikeUser(HttpServletRequest request,HttpServletResponse response){\n        //拿参数中的 token\n        String paramToken = request.getParameter(SpikeUserService.COOK_NAME_TOKEN);\n        //拿 cookie 中的 token\n        String cookieToken = getCookieValue(request, SpikeUserService.COOK_NAME_TOKEN);\n        if(StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {\n            //没登陆 cookie 为空\n            return null;\n        }\n        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;\n        SpikeUser user = spikeUserService.getUserByToken(response, token);\n        return user;\n    }\n\n    /*\n     * 获取 cookie 中的 User\n     * */\n    private String getCookieValue(HttpServletRequest request, String cookieName) {\n        Cookie[]  cookies = request.getCookies();\n        if(cookies == null || cookies.length <= 0){\n            return null;\n        }\n        for(Cookie cookie : cookies) {\n            if(cookie.getName().equals(cookieName)) {\n                return cookie.getValue();\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### WebConfig 里面添加拦截器\n\n```java\npackage top.imlgw.spike.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\nimport top.imlgw.spike.intercept.LoginIntercept;\nimport java.util.List;\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer{\n\t//自动装配或者 手动创建 bean, 加到 Ioc 容器中，否则取不到 service\n    @Autowired\n    SpikeUserArgumentResolver spikeUserArgumentResolver;\n\n    @Autowired\n    LoginIntercept loginIntercept;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(spikeUserArgumentResolver);\n    }\n    \n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(loginIntercept).addPathPatterns(\"/**\").\n            excludePathPatterns(\"/login/*\");\n    }\n}\n```\n\n### 视图解析器\n\n不用为了跳转页面而专门写一个** controller**\n\n```java\n@Override\npublic void addViewControllers(ViewControllerRegistry registry) {\n    //这里如果是用的模板引擎，就只能是模板引擎 template 里面的文件\n    //这里后面默认指的是 static 里面的文件，后缀为 html\n    registry.addViewController(\"/\").setViewName(\"login\");\n    registry.addViewController(\"/goodslist\").setViewName(\"goods_list\");\n    registry.addViewController(\"/register\").setViewName(\"register\");\n}\n```\n\n> 其他的以后用到会继续补充\n","tags":["SpringMVC"],"categories":["Web"]},{"title":"JSR303-参数检验","url":"/2019/05/13/e9f4032f/","content":"\n## JSR303\n\n目前最新的规范已经是 JSR380 了，也就是 Bean Validation 2.0.\n\n![mark](http://static.imlgw.top///20190513/qa5DNu5Nsq26.png?imageslim)\n\n参数校验是一个成熟的网站必须的功能，然而有的时候为了校验参数也要费好大的劲，免不了写很多 if-else，一点也不优雅。\n\n## 上手\n\n### 引入依赖\n\n```java\n <!--SpringBootWeb 这个包里面自带了 hibernate 的校验包-->\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n### JSR 提供的注解\n\n```java\n@Null   被注释的元素必须为 null    \n@NotNull    被注释的元素必须不为 null    \n@AssertTrue     被注释的元素必须为 true    \n@AssertFalse    被注释的元素必须为 false    \n@Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值    \n@Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值    \n@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值    \n@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值    \n@Size(max=, min=)   被注释的元素的大小必须在指定的范围内    \n@Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内    \n@Past   被注释的元素必须是一个过去的日期    \n@Future     被注释的元素必须是一个将来的日期    \n@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式\n```\n\n### Hibernate 提供的\n\n```\n@NotBlank(message =)   验证字符串非 null，且长度必须大于 0    \n@Email  被注释的元素必须是电子邮箱地址    \n@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内    \n@NotEmpty   被注释的字符串的必须非空    \n@Range(min=,max=,message=)  被注释的元素必须在合适的范围内\n```\n\n### 自定义校验注解\n\n**@IsMobile 注解**\n\n```java\npackage top.imlgw.spike.validator;\nimport javax.validation.Constraint;\nimport javax.validation.Payload;\nimport java.lang.annotation.*;\n/**\n * @author imlgw.top\n * @date 2019/5/13 17:50\n */\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Constraint(\n        validatedBy = {IsMobileValidator.class} //指定真正校验的类\n)\npublic @interface IsMobile {\n    boolean required() default true;\n\n    String message() default \"号码格式错误\";\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n}\n```\n\n**IsMobileValidator 类**\n\n> 自定义的校验器要实现 ConstraintValidator 接口\n\n```java\npackage top.imlgw.spike.validator;\n\nimport org.apache.commons.lang3.StringUtils;\nimport top.imlgw.spike.utils.ValidatorUtil;\n\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\n/**\n * @author imlgw.top\n * @date 2019/5/13 18:12\n */\npublic class IsMobileValidator implements ConstraintValidator<IsMobile, String> {\n\n    private boolean required=false;\n\n    @Override\n    public void initialize(IsMobile constraintAnnotation) {\n        required=constraintAnnotation.required();\n    }\n\n    @Override\n    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {\n        if(required){\n            return  ValidatorUtil.isMobile(s);\n        }else {\n            if(StringUtils.isEmpty(s)){\n                return true;\n            }else {\n                return  ValidatorUtil.isMobile(s);\n            }\n        }\n    }\n}\n```\n\n### 字段上加注解\n\n```java\npackage top.imlgw.spike.entity;\nimport org.hibernate.validator.constraints.Length;\nimport javax.validation.constraints.NotNull;\n/**\n * @author imlgw.top\n * @date 2019/5/11 15:56\n */\npublic class User {\n    @NotNull(message = \"id 不能为空\")\n    private Integer id;\n    @NotNull(message = \"名字不能为空\")\n    private String name;\n    private Integer age;\n    @Length(min = 6,message = \"密码长度至少 6 位\")\n    private String password;\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", password='\" + password + '\\'' +\n                '}';\n    }\n\n    public User(Integer id, String name, Integer age, String password) {\n        this.name = name;\n        this.age = age;\n        this.password = password;\n        this.id=id;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n}\n```\n\n**@Valid 加 BindingResult**\n\n![mark](http://static.imlgw.top///20190513/ILDAz6Bdj3cz.png?imageslim)\n\n在 Controlle 层待校验的的参数上加上`@Valid`注解，然后在后面紧跟一个 `BindingResult`，校验的结果会封装在这个对象里面，BindingResult 的作用是当参数不合法时能够捕捉到错误，不会直接抛异常，感觉还是有点麻烦。\n\n**@Valid 加全局异常捕获**\n\n上面的方法如果不加后面的 BindingResult 在校验失败后就会抛一个 BindException\n\n```java\norg.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors\nField error in object 'user' on field 'id': rejected value [null]; codes [NotNull.user.id,NotNull.id,NotNull.long,NotNull]; arguments .......\n```\n\n那我们就可以利用`@ControllerAdvice+@ExceptionHandler`来定义一个全局的异常处理器来处理这个异常，`@ExceptionHandle`，针对的仅仅是单个 controller，加上`@ControllerAdvice`就可以对所有的 Controller 层异常进行捕获，这里的全局仅仅指的是 controller 层。\n\n### 自定义异常\n\n```java\npackage top.imlgw.spike.exception;\nimport top.imlgw.spike.result.CodeMsg;\n\n/**\n * 全局通用异常\n * @author imlgw.top\n * @date 2019/5/14 20:51\n */\npublic class GlobalException extends RuntimeException {\n    private static final long serialVersionUID = 1L;\n    private CodeMsg cm;\n\n    public GlobalException(CodeMsg cm) {\n        super(cm.toString());\n        this.cm = cm;\n    }\n\n    public CodeMsg getCm() {\n        return cm;\n    }\n\n}\n\n```\n\n### 全局异常处理器\n\n```java\n/**\n * Controller 层异常处理器\n *\n * @author imlgw.top\n * @date 2019/5/13 18:21\n */\n@ControllerAdvice\n@ResponseBody //直接返回给客户端，需要 json 的转换\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(value = Exception.class) //处理 controller 层所有异常\n    public Result<String> exceptionHandle(HttpServletRequest request, Exception e) {\n        e.printStackTrace();\n        if (e instanceof GlobalException) {\n            //全局异常\n            GlobalException ex = (GlobalException) e;\n            return Result.error(ex.getCm());\n        } else if (e instanceof BindException) {\n            //@Validated 检验器的异常\n            BindException ex = (BindException) e;\n            List<ObjectError> errors = ex.getAllErrors();\n            ObjectError error = errors.get(0);\n            String msg = error.getDefaultMessage();\n            return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));\n        } else {\n            return Result.error(CodeMsg.SERVER_ERROR);\n        }\n    }\n\n    //测试 Demo 看先处理那个\n    @ExceptionHandler(value = GlobalException.class) //处理 controller 层所有异常\n    public Result<String> GLe(HttpServletRequest request, Exception e) {\n        System.out.println(\"优先处理了这个 GlobalException\");\n        e.printStackTrace();\n        //全局异常\n        GlobalException ex = (GlobalException) e;\n        return Result.error(ex.getCm());\n    }\n}\n```\n\n这里也做了个小测试，可以看到我定义了两个@ExceptionHandle，一个是另一个的子类，看会先处理那个，测试后发现会先处理小异常，那个最大的异常其实相当于''兜底''的。其实后面我为了跟精细的处理，将绑定异常和自定义的异常分开处理了。\n\n> @ControllerAdvice :\n>\n> It is typically used to define {@link ExceptionHandler **@ExceptionHandler**},\n>\n> {@link InitBinder **@InitBinder**}, and {@link ModelAttribute **@ModelAttribute**}\n>\n> methods that **apply to all** {@link RequestMapping **@RequestMapping**} methods.\n>\n> @author Rossen Stoyanchev\n>\n> @since 3.2\n\n### 分组校验\n\n只需要在 vo 里加上对应分组的接口然后在注解上加上就可以了\n\n```java\npublic class LoginVo {\n    @NotNull(message = \"手机号不能为空\")\n    @IsMobile(groups = Test1.class) //只有在 Test1 分组下才生效\n    private String mobile;\n\n    @NotNull(message = \"密码不能为空\")\n    @Length(min=6 ,groups = Test2.class,message = \"密码长度过短\") //只有在 Test2 分组下才生效\n    private String password;\n\n    public String getMobile() {\n        return mobile;\n    }\n    public void setMobile(String mobile) {\n        this.mobile = mobile;\n    }\n    public String getPassword() {\n        return password;\n    }\n    public void setPassword(String password) {\n        this.password = password;\n    }\n    @Override\n    public String toString() {\n        return \"LoginVo [mobile=\" + mobile + \", password=\" + password + \"]\";\n    }\n\n    public interface Test1{}\n\n    public interface Test2{}\n}\n```\n\n使用时注意用`@Validated`，这个其实是 Spring 对 Hibernate 的二次封装，增加了一些功能。\n\n```java\n@RequestMapping(\"/jsr303-2\")\n@ResponseBody\npublic void testJSR(@Validated({LoginVo.Test2.class}) LoginVo vo){\n\t  //........\t\n}\n```\n\n这样在这个 Controller 里 post 密码就没有长度的限制了。\n\n> 其实还有一些校验的方法，基于方法校验，基于少量参数的校验，以后用到再来记录\n","tags":["参数校验","JSR"],"categories":["Web"]},{"title":"LeetCode 数组","url":"/2019/05/04/a9999be0/","content":"\n## LeetCode 数组\n\n> 善用 ctrl+f\n\n## [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n\n给定一个已按照**升序排列** 的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2*。*\n\n**说明：**\n\n- 返回的下标值（index1 和 index2）不是从零开始的。\n- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n**示例：**\n\n```java\n输入：numbers = [2, 7, 11, 15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n```\n\n两数之和的变种，看见**有序**其实也可以使用二分来做，但是时间复杂度是`O(NlogN)`，相对较高\n\n```java\npublic int[] twoSum(int[] numbers, int target) {\n    if(numbers==null||numbers.length<=0){\n        return null;\n    }\n    int left=0,right=numbers.length-1;\n    while(right>left){\n        int sum=numbers[right]+numbers[left];\n        if(sum==target){\n            return new int[]{left+1,right+1};\n        }if(sum<target){\n            left++;\n        }else{\n            right--;\n        }\n    }\n    return null;\n}\n```\n\n**对撞指针**，很基础的题。\n\n## [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n\n给定 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。\n\n**说明：**你不能倾斜容器，且 *n* 的值至少为 2。\n\n![mark](http://static.imlgw.top///20190505/1uze479AHHLo.png?imageslim)\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n**示例：**\n\n```java\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n```\n\n**解法一**\n\n```java\npublic int maxArea(int[] height) {\n        int len=height.length;\n        if(len==0){\n            return 0;\n        }\n        int max=Integer.MIN_VALUE;\n        for(int i=0;i<len-1;i++){\n            for(int j=i+1;j<len;j++){\n                int minHight=height[i]>height[j]?height[j]:height[i];\n                max=max>(j-i)*minHight ? max:(j-i)*minHight;\n            }\n        }\n        return max;\n }\n```\n\n522ms，13% 垫底了，别问，问就是暴力🤣\n\n```java\npublic int maxArea(int[] height) {\n        int len=height.length;\n        if(len==0){\n            return 0;\n        }\n        int head=0,tail=len-1;\n        int max=Integer.MIN_VALUE;\n        while(head<len){\n            tail=len-1; //开始改的时候这一句忘了加\n            while(head!=tail){\n                int minHight=height[tail]>height[head]?height[head]:height[tail];\n                max=max>(tail-head)*minHight ? max:(tail-head)*minHight;\n                if(height[head]<=height[tail]){\n                    break;\n                }else{\n                    tail--;\n                }\n            }\n            head++;\n        }\n        return max;\n}\n```\n\n212ms，40%，利用双指针稍微优化了下，依然是遍历找每个柱的最大值，但是尾指针在移动时先判断下，如果比头指针大就直接 break，因为**已经是最大值**了，tail 是从右向左移动的\n\n> 开始改的时候忘了将尾指针归位，结果还对了，而且 90%的 beats..... 哈哈哈，误打误撞搞了个最优解出来。\n\n**解法二**\n\n上面两种其实都是暴力，时间复杂度都很高\n\n```java\n//update: 2020.4.18\npublic int maxArea(int[] height) {\n    if(height==null || height.length<=0) return 0;\n    int left=0,right=height.length-1;\n    int max=0;\n    while(left<right){\n        max=Math.max((right-left)*Math.min(height[left],height[right]),max);\n        //if(left<right){ 隐约记得之前也这样写过。没想到这次又在这里 WA 了\n        if(height[left]<height[right]){\n            left++;\n        }else{\n            right--;\n        }\n    }\n    return max;\n}\n```\n\n**标准**的最优解，这题主要考察的就是双指针，两个指针一头一尾，先算出这个头尾的面积大小，然后下一步思考怎么扩大这个区域的面积，结合题上面的图（最左边为头，最右边为尾）\n\n![mark](http://static.imlgw.top///20190505/1uze479AHHLo.png?imageslim)\n\n这个时候如果移动尾指针，明显面积只可能减小，所以只有移动头指针才有可能增大这个区域的面积，这样一来就可以省掉很多没必要的计算，有点像贪心，时间复杂度 O(N)\n\n## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![rainwatertrap.png](https://i.loli.net/2019/05/14/5cda71129045d93180.png)\n\n上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n**示例：**\n\n```java\n输入：[0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n```\n\n**解法一**\n\n> 我最开始思路是填满后用总面积减数组和，跑过了 130+个，有一种特殊的跑不过了，懒得去处理那个边界了，不太优雅\n\n这个题目的关键就是每个柱子能接的水是**左右最长柱子（都大于当前柱子）中的较小的那个减去当前柱子**。\n\n所以我们可以用两个数组分别存储每个柱子左右的最长柱子（做预处理），这样就得到了一种有点动态规划意思的解法\n\n```java\npublic static int trap(int []height){\n    if (height==null || height.length<=0) {\n        return 0;\n    }\n    int len=height.length;\n    int[] leftMax=new int[len];\n    leftMax[0]=height[0];\n    int[] rightMax=new int[len];\n    rightMax[len-1]=height[len-1];\n    int res=0;\n    //左右最大柱子包含当前柱子\n    for (int i=1;i<len;i++) {\n        leftMax[i]=Math.max(leftMax[i-1],height[i]);\n    }\n    for (int i=len-2;i>=0;i--) {\n        rightMax[i]=Math.max(rightMax[i+1],height[i]);\n    }\n    for (int i=0;i<len;i++) {\n        res+=Math.min(rightMax[i],leftMax[i])-height[i];\n    }\n    return res;\n}\n```\n\n利用**双指针**就行空间的优化\n\n```java\npublic static int trap(int []height){\n    if (height==null || height.length<=0) {\n        return 0;\n    }\n    int len=height.length;\n    int leftMax=0,rightMax=0;\n    int left=0,right=len-1,res=0;\n    while(left<=right){\n        leftMax=Math.max(leftMax,height[left]);\n        rightMax=Math.max(rightMax,height[right]);\n        //leftMax 小于 rightMax, 那么靠近 leftMax 的柱子 left 可以接的雨水就可以确定了\n        if (leftMax<rightMax) {\n            res+=leftMax-height[left]; \n            left++;\n        }else{ //反之 leftMax 大于 rightMax, 那么考近 rightMax 的柱子 right 可以接的最多的雨水就可以 i 确定了\n            res+=rightMax-height[right];\n            right--;\n        }\n    }\n    return res;\n}\n```\n\n个人感觉这个是最好理解的版本，我这里最开始的哪个版本不是这样写的，当时自己肯定也没搞懂，包括现在我也没搞懂那种写法\n\n![[图片来自 liweiwei1419 大佬](https://leetcode-cn.com/u/liweiwei1419/)](http://static.imlgw.top/blog/20200129/Dy8M19G4XwSn.png?imageslim)\n\n这两种情况对应的就是循环中的 if 的两个分支，双指针向中间靠拢，当`leftMax`小于`rightMax`的时候我们不用去考虑当前`left`柱子右边实际的最大的右边的柱子是谁，我们只需要知道`left`柱子 左边最大值`leftMax`的值就 ok，因为此时`left` 柱子能接水的量是由`leftMax`决定的，反之对应第二种情况，`right`柱子的接水量则是由`rightMax` 决定的，最后遍历完所有的柱子就可以确定整体的接水量\n\n> 这里的 if 分支的条件有的解法中写的是 leftMax < nums[right] 甚至 nums[left] < nums[right] 这也是我上面说的不理解的地方，因为这样写也是可以 AC 的😅，后面有时间再回头看看吧\n\n**解法二**\n\n还有一种很巧妙的方法，也比较好理解，找到最大值，然后分别对两边的柱子进行遍历，如果当前的柱子小于前面柱子的最大值，就说明一定可以接到水，这个过程中需要记录柱子左边和右边的最大值，用于计算可以接水的量，最后计算总和\n\n```java\npublic static int trap5(int []height){\n    //\n    int n=height.length,idx=0,lefth=0,righth=0,area=0;\n    for (int i=0;i<n;i++) idx=height[idx]<=height[i]?i:idx;\n    for (int i=0;i<idx;i++){\n        if(height[i]<lefth) area+=lefth-height[i]; \n        else lefth=height[i]; //更新最大值\n    }\n    for (int i=n-1;i>idx;i--){\n        if(height[i]<righth) area+=righth-height[i]; \n        else righth=height[i]; //更新最大值\n    }\n    return area;\n}\n```\n\n**解法三**\n\n利用栈的\n\n```java\npublic static int trap6(int[] height) {\n    if (height == null || height.length == 0) return 0;\n    Deque<Integer> stack = new ArrayDeque<>(); //栈里面维护一个递减序列\n    int res = 0;\n    for (int i = 0; i < height.length; i++){\n        while ( ! stack.isEmpty() && height[stack.peek()] < height[i]) { //当遍历的元素大于栈顶元素\n            int tmp = stack.pop(); //栈顶弹出来\n            if (stack.isEmpty()) break;\n            res += (Math.min(height[i],height[stack.peek()]) - height[tmp]) * (i - stack.peek() - 1);\n        }\n        //维护递减序列\n        stack.push(i);\n    }\n    return res;\n}\n```\n\n这种有点不好理解，其实是按照层来计算的，栈里面是递减的元素，如果读到比栈顶大的元素就**按层**计算递减栈**底部元素**到**当前元素**能蓄水的面积。\n\n> 2020/1/29 回顾\n>\n> 这个解法其实就是单调栈😂，当时还是菜鸟根本就不懂，现在回头一看就懂了 hahaha~ \n>\n> 放到 [单调栈专题](http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/#%E5%8D%95%E8%B0%83%E6%A0%88) 里面解释了\n\n## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)\n\n给定一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？找出所有满足条件且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n```java\n例如，给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n**解法一**\n\n想太多了，没做出来，看了评论才做出来。\n\n```java\npublic static List<List<Integer>> threeSum(int[] nums) {\n    List<List<Integer>> list = new ArrayList();\n    Arrays.sort(nums);\n    // 先排序  o(nlogn)\n    int len = nums.length;\n    if(nums == null || len < 3) return list;\n    // 完备性\n    for (int i = 0; i < len-2; i++) {\n        if(nums[i]>0){\n            //大于 0 了，后面的和加起来肯定>0 了\n            break;\n        }\n        //遍历数组，相同的元素只需要遍历一遍，不然会重复\n        if(i > 0 && nums[i] == nums[i-1]) continue;\n        // 一次去重优化\n        //当前元素的下一个元素。\n        int L = i+1;\n        //尾元素\n        int R = len-1;\n        while(L<R){\n            int sum = nums[i] + nums[L] + nums[R];\n            if(sum == 0){\n                list.add(Arrays.asList(nums[i],nums[L],nums[R]));\n                //-4 -1 -1 0 1 2\n                while (L<R && nums[L] == nums[L+1]) L++;\n                //二次去重优化\n                while (L<R && nums[R] == nums[R-1]) R--;\n                L++;\n                R--;\n            } else if (sum < 0){ //小于 0 所以要增大 L, 逼近 0 else R--;\n                 L++;   \n            } else R--; //大于 0 就减小 R\n        }\n    }\n    return list;\n}\n```\n\n代码思路就是遍历数组，然后从** i **位置后面的数组中找能和** i **凑成一对的元素，这里关键就是这里怎么找这两个元素 满足 nums[L]+nums[R]=-nums[i]，问题就转化成了上面的**两数之和**，但是这里用暴力法肯定是过不了的，hashMap 这里也不好用，所以这里我们可以先给数组排个序，然后利用**双指针对撞**，逐渐逼近 0，还有一个很需要注意的地方就是二次去重，如下图\n\n![mark](http://static.imlgw.top///20190505/5YlNbCLe57fb.png?imageslim)\n\n当找到一组时有可能 L，R 的下一个位置的值没变这样就会导致重复。\n\n## [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)\n\n给定一个包括 *n* 个整数的数组 `nums` 和 一个目标值 `target`。找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n```java\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n```\n\n**解法一**\n\n跟上面的题其实是一样的，这里主要时为了检测下自己上面的搞懂了没\n\n```java\npublic int threeSumClosest(int[] nums, int target) {\n    int len=nums.length;\n    if(nums==null||len<3) return 0;\n    Arrays.sort(nums);\n    int closest=nums[0]+nums[1]+nums[2];\n    for (int i=0;i<len-2;i++) {\n        if(i!=0&&nums[i]==nums[i-1])continue;\n        //跳过重复元素提高效率\n        int L=i+1;\n        int R=len-1;\n        while(L<R){\n            int sum=nums[L]+nums[R]+nums[i];\n            closest=Math.abs(closest-target)>Math.abs(sum-target)?sum:closest;\n            if(sum==target){\n                return target;\n            } else if(sum>target){\n                while(L<R && nums[R]==nums[R-1])R--;\n                R--;\n            } else{\n                while(L<R && nums[L]==nums[L+1])L++;\n                L++;\n            }\n        }\n    }\n    return closest;\n}\n```\n\n一遍** bugfree**，其实都挺简单，这两题我一直在考虑别的算法，我想的是排序后从两遍向中间然后。.. 就不 bb 了，反之很多没考虑到的地方。\n\n## [18. 四数之和](https://leetcode-cn.com/problems/4sum/)\n\n给定一个包含 n 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 a，b，c 和 d ，使得 `a + b + c + d` 的值与 `target` 相等？找出所有满足条件且不重复的四元组。\n\n**注意：**\n\n答案中不可以包含重复的四元组。\n\n**示例：**\n\n```java\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n```\n\n**解法一**\n\n和三数之和一样，但是更加繁琐了，提交了 5，6 次才 AC，还是看了别人的代码的\n\n```java\npublic static List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> res=new ArrayList<>();\n    Arrays.sort(nums);\n    int n=nums.length;\n    //0 0 -1 1\n    for (int i=0;i<n-3;i++) {\n        //这里我开始写的是和后一个比较，0，0，0，0 这种过不了\n        if(i>0 && nums[i]==nums[i-1])continue;\n        if (nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\n        if (nums[i]+nums[n-1]+nums[n-2]+nums[n-3]<target) continue;\n        for (int j=i+1;j<n-2;j++) {\n            //同上\n            if(j>i+1&&nums[j]==nums[j-1])continue;\n            if (nums[i]+nums[j]+nums[j+2]+nums[j+1]>target) break;\n            if (nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\n            int two=nums[i]+nums[j];\n            //左右边界\n            int left=j+1,right=n-1;\n            while(left<right){\n                if (target-two==nums[left]+nums[right]) {\n                    res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));\n                    //想清楚什么时候跳，放外面就错了\n                    while(left<right && nums[left]==nums[left+1]){left++;};\n                    while(left<right && nums[right]==nums[right-1]){right--;};\n                    left++;\n                    right--;\n                }else if (target-two>nums[left]+nums[right]) {\n                    left++;\n                }else{\n                    right--;\n                }\n            }\n        }\n    }\n    return res;\n}\n```\n\n## [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n\n给定一个排序数组，你需要在**原地**删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。\n\n**示例 1:**\n\n```java\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2:**\n\n```java\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**解法一**\n\n实不相瞒，这题一开始我暴力做的，冒泡的思想，太蠢了😅 ，注意题目要求空间复杂度 O(1)\n\n```java\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            nums[i++] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n双指针，真的用的挺多的。\n\n## [80. 删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)\n\n给定一个排序数组，你需要在**原地**删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。\n\n**示例 1:**\n\n```java\n给定 nums = [1,1,1,2,2,3],\n\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2:**\n\n```java\n给定 nums = [0,0,1,1,1,1,2,3,3],\n\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**说明：**\n\n为什么返回数值是整数，但输出的答案是数组呢？\n\n请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下：\n\n```java\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度，它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n**解法一**\n\n上面题目加一点，在前后相等的时候判断 index 前是否已经有两个相等\n\n```java\npublic int removeDuplicates(int[] nums) {\n    int index=2;\n    for (int i=2;i<nums.length;i++){\n        if(nums[i]!=nums[i-1] || (nums[i]==nums[i-1] && nums[index-2]!=nums[index-1])){\n            nums[index++]=nums[i];\n        }\n    }\n    return index;\n}\n```\n\n## [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)\n\n给定一个数组 *nums* 和一个值 *val*，你需要**原地**移除所有数值等于 *val* 的元素，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n**示例 1:**\n\n```java\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2:**\n\n```java\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**解法一**\n\n目标元素多时\n\n```java\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i++] = nums[j];\n        }\n    }\n    return i;\n}\n```\n\n目标元素少时\n\n```java\npublic int removeElement2(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[--n];\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n```\n\n## [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**示例：**\n\n```java\n输入：[0,1,0,3,12]\n输出：[1,3,12,0,0]\n```\n\n**说明**:\n\n- 必须在原数组上操作，不能拷贝额外的数组。\n\n- 尽量减少操作次数。\n\n**解法一**\n\n```java\npublic void moveZeroes(int[] nums) {\n    if(nums==null||nums.length<=1){\n        return;\n    }\n    int index=0;\n    for(int i=0;i<nums.length;i++){\n        if(nums[i]!=0){\n            nums[index++]=nums[i];\n        }\n    }\n    for(int i=index;i<nums.length;i++){\n        nums[i]=0;\n    }\n}\n```\n\n其实就是借助上面题目的思路，最后再补 0 就 ok 了，其实也还可以优化下\n\n**解法二**\n\n保持`[0,m)` 为非 0 元素，遇到非 0 元素就和右边界进行交换\n\n```java\npublic void moveZeroes(int[] nums) {\n    int m=0; //[0,m) 为非 0 元素\n    for(int i=0;i<nums.length;i++){\n        if(nums[i]!=0){\n            if(i!=m){\n                int temp=nums[i];\n                nums[i]=nums[m];\n                nums[m]=temp;   \n            }\n            m++;\n        }\n    }\n}\n```\n\n## [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)\n\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须**原地**修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n\n```java\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n```\n\n**解法一**\n\n直接上最优解吧，这题暴力法 O(N!)，空间也超过了\n\n```java\npublic void nextPermutation(int[] nums) {\n    int len=nums.length;\n    if(nums==null||len<=1){\n        return;\n    }\n    for (int i=len-2;i>=0;i--) {\n        while(i>=0 &&nums[i]>=nums[i+1]){\n            //找到第一个峰值左相邻的元素（从左到右）\n            i--;\n        }\n        //逆序的，没有最大值\n        if(i==-1){\n            reverse(nums,0);\n            return;\n        }\n        //找到峰值右边 [i+1 , len-1] 最后一个比 i 大的元素\n        for (int j=len-1;j>i;j--) {\n            if(nums[j]>nums[i]){\n                swap(nums,j,i);\n                reverse(nums,i+1);\n                return;\n            }\n        }\n    }\n}\n\n//翻转数组\nprivate void reverse(int[] nums, int start) {\n    for (int i=start,j=nums.length-1;i<j;i++,j--) {\n        swap(nums,i,j);\n    }\n}\n\nprivate  static void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n```\n\n- 第一步，逆序找到第一个峰值的左边第一个元素 `a[i-1]`。\n\n- 将峰值右边的**最小的**比`a[i-1]`大的`a[j]`（其实就是`右边最后一个比它大的元素`) 元素与** a[i-1] **交换。\n- 翻转刚刚调整过`a[i-1]`后面的逆序的数组 (`a[i]-->a[len-1]`)。\n\n![mark](http://static.imlgw.top/blog/20190728/G6uqlPyjPLdV.png?imageslim)\n\n至于为什么这样做自己模拟下就懂了，逆序部分是没有下一个比它大的排列的，所以如果想让整个排列变大只能从这个逆序的排列里面选一个比逆序前最后一个''稍微''大一点的元素与之交换，然后将整个逆序的部分翻转就是下一个排列，这题看了题解后处理边界又处理了半天，**循环里面的循环边界条件一定要注意**\n\n## [556. 下一个更大元素 III](https://leetcode-cn.com/problems/next-greater-element-iii/)\n\n给定一个 32 位正整数 n，你需要找到最小的 32 位整数，其与 n 中存在的位数完全相同，并且其值大于 n。如果不存在这样的 32 位整数，则返回-1。\n\n**示例 1:**\n\n```java\n输入：12\n输出：21\n```\n\n**示例 2:**\n\n```java\n输入：21\n输出：-1\n```\n\n**解法一**\n\n和上面那一题一样，权当复习了一下\n\n```java\npublic int nextGreaterElement(int n) {\n    StringBuilder sb=new StringBuilder();\n    while(n/10>0){\n        sb.append(n%10);\n        n/=10;\n    }\n    sb.append(n);\n    System.out.println(sb);\n    char[] nums=sb.reverse().toString().toCharArray();\n    int len=nums.length;\n    for (int i=len-1;i>0;i--) {\n        if (nums[i]>nums[i-1]) { //逆序的峰值 i\n            if (i==0) return -1; \n            for (int j=len-1;j>=i;j--) {\n                if (nums[j]>nums[i-1]) {\n                    swap(nums,j,i-1);\n                    reverse(nums,i,len-1);\n                    return Long.valueOf(new String(nums))>Integer.MAX_VALUE?-1:Integer.valueOf(new String(nums));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\npublic void reverse(char[] nums,int begin,int end){\n    for (int i=begin,j=end;i<j;i++,j--) {\n        swap(nums,i,j);\n    }\n}\n\npublic void swap(char[] nums,int a,int b){\n    char temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n## [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n**示例 1:**\n\n```java\n输入：[3,2,3]\n输出：3\n```\n\n**示例 2:**\n\n```java\n输入：[2,2,1,1,1,2,2]\n输出：2\n```\n\n**解法一**\n\n分治法， (`HashMap`或者排序什么的方法就不说了，笔试可以那样写，面试就不能这样了）\n\n```java\npublic int majorityElement(int[] nums) {\n    return majorityElement(nums,0,nums.length-1);\n}\n\npublic int majorityElement(int[] nums,int lo,int hi) {\n    if (lo==hi) {\n        return nums[lo];\n    }\n    int mid=lo+(hi-lo)/2;\n    int leftMode=majorityElement(nums,lo,mid);\n    int rightMode=majorityElement(nums,mid+1,hi);\n    if (leftMode==rightMode) {\n        return rightMode;\n    }\n    return countMode(nums,lo,mid,leftMode)>countMode(nums,mid+1,hi,rightMode)?leftMode:rightMode;\n}\n\npublic int countMode(int[] nums,int left,int right,int mode){\n    int count=0;\n    for (int i=left;i<=right;i++) {\n        if (mode==nums[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n并不是最优解，时间复杂度`O(NlogN)`，只是一种思路吧，而且是通用的求众数的方法\n\n**解法二**\n\n摩尔投票法\n\n```java\npublic int majorityElement(int[] nums) {\n    int sum=1;\n    int res=nums[0]; \n    for (int i=1;i<nums.length;i++) {\n        if (sum==0) {\n            res=nums[i];\n        }\n        //将众数看做 1, 其他的看作-1, 最后和一定是大于 0 的\n        if (res!=nums[i]) {\n            sum--;\n        }else{\n            sum++;\n        }\n    }\n    return res;\n}\n```\n**解法三**\n\n刚刚看见一种解法，当作求第 k 大，用快选就行了，时间复杂度`O(N)`\n\n## [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)\n\n给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。\n\n**说明：** 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。\n\n**示例 1:**\n\n```java\n输入：[3,2,3]\n输出：[3]\n```\n\n**示例 2:**\n\n```java\n输入：[1,1,1,3,3,2,2,2]\n输出：[1,2]\n```\n\n**解法一**\n\n和上面的方法一样，抵消去除三个不同的元素对众数没有任何影响，但是最后需要判断是否都是符合条件的\n\n```go\n//update：2020.4.23 用 go 在 web 上随手写了一个，感觉比之前 java 写的哪个好理解\nfunc majorityElement(nums []int) []int {\n    var res []int\n    //超过 n/3 的元素最多 2 个\n    cand1:=-1 //设置成 nums 中不存在的值比较好，比如-1\n    count1:=0\n    cand2:=-1\n    count2:=0\n    for _,num:=range nums{\n        if num==cand1{ //投 1\n            count1++\n        }else if num==cand2{ //投 2\n            count2++\n        }else { //都不投\n            if count1==0 {\n                cand1=num\n                count1=1\n            }else if count2==0{\n                cand2=num\n                count2=1\n            }else{\n                count1--\n                count2--\n            }\n        }\n    }\n    temp1:=0\n    temp2:=0\n    for _,num:= range nums{\n        if num==cand1{\n            temp1++\n        }\n        if num==cand2{\n            temp2++\n        }\n    }\n\n    if temp1>len(nums)/3 {\n        res=append(res,cand1)\n    }\n    if temp2>len(nums)/3 {\n        res=append(res,cand2)\n    }\n    return res\n}\n```\n\n## [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)\n\n给定一个未排序的整数数组，找出其中没有出现的最小的正整数。\n\n**示例 1:**\n\n```java\n输入：[1,2,0]\n输出：3\n```\n\n**示例 2:**\n\n```java\n输入：[3,4,-1,1]\n输出：2\n```\n\n**示例 3:**\n\n```java\n输入：[7,8,9,11,12]\n输出：1\n```\n\n**解法一**\n\nHead 题，想到了桶排序，但是空间不符合要求，看了评论扣了半天边界也没抠出来\n\n```java\npublic int firstMissingPositive(int[] nums) {\n    if(nums==null||nums.length<=0){\n        return 1;\n    }\n    for (int i=0;i<nums.length;++i){\n        //将每个元素归位，我开始只有一层循环，那样会漏掉很多元素（可能被交换的元素后面也需要交换），这样的就是一次直接到位。\n        while(nums[i]>=1&&nums[i]<=nums.length&&nums[nums[i]-1]!=nums[i])\n        {\n            int temp=nums[nums[i]-1];\n            nums[nums[i]-1]=nums[i];\n            nums[i]=temp;\n        }\n    }\n    for (int i=0;i<nums.length;++i){\n        if(nums[i]!=i+1)\n            return i+1;\n    }\n    return nums.length+1;\n}\n```\n\n其实也是桶排序的思想，不过这里是利用交换来定位每个元素，首相我们将原数组看作桶，题目要求的正整数，所以我们桶中存的应该是`【1，nums.length】`，也就是 0 位置应该存放的是 1，1 位置存放的应该是 2.... 再归位后重新遍历数组，如果某个位置的`nums[i]!=i+1` 就说明这个是第一个缺失的正数，遍历完了之后没有找到，全部对应上了，那就说明我们缺少的第一个正数是`nums.length+1`\n\n**Update:2020.6.27**\n```golang\nfunc firstMissingPositive(nums []int) int {\n    for i:=0;i<len(nums);i++{\n        for nums[i]>0 && nums[i]<len(nums) && nums[i]!=i+1 && nums[nums[i]-1]!=nums[i]{\n            nums[nums[i]-1],nums[i]=nums[i],nums[nums[i]-1]\n        }\n    }\n    for i,n := range nums{\n        if n!=i+1{\n            return i+1\n        }\n    }\n    return len(nums)+1\n}\n```\n\n**解法二**\n\n不考虑空间复杂度利用桶排序的思想\n\n```java\npublic int firstMissingPositive2(int[] nums) {\n        if(nums==null||nums.length<=0){\n            return 1;\n        }\n        int [] bucket=new int[nums.length];\n        for(int i=0;i<nums.length;++i){\n            if(nums[i]>0 && nums[i]<=nums.length){\n                bucket[nums[i]-1]=1; //代表这个桶有元素了\n            }\n        }\n        for(int i=0;i<bucket.length;++i){\n            if(bucket[i]==0)\n                return i+1;\n        }\n        return nums.length+1;\n}\n```\n\nlc 上提交后的空间消耗居然比上面的还小一点😂\n\n## [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)\n\n给定一个整数数组 a，其中 1 ≤ a[i] ≤ n （n 为数组长度）, 其中有些元素出现两次而其他元素出现一次。\n\n找到所有出现两次的元素。\n\n你可以不用到任何额外空间并在 O(n) 时间复杂度内解决这个问题吗？\n\n**示例：**\n\n```java\n输入：\n[4,3,2,7,8,2,3,1]\n\n输出：\n[2,3]\n```\n\n**解法一**\n\n同上，抽屉原理，直接秒掉这三题 hard，mid，easy\n\n```java\npublic List<Integer> findDuplicates(int[] nums) {\n    for (int i=0;i<nums.length;i++) {\n        while(nums[i]!=i+1 && nums[i]!=nums[nums[i]-1]){\n            int temp=nums[nums[i]-1];\n            nums[nums[i]-1]=nums[i];\n            nums[i]=temp;\n        }\n    }\n    List<Integer> res=new LinkedList<>();\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]!=i+1) {\n            res.add(nums[i]);\n        }\n    }\n    return res;\n}\n```\n\n**解法二**\n\n技巧性的思路，和上一题一样，将对应位置置反，如果遇到已经置反的就说明当前位置重复了\n\n```java\n//5 1 1 3 2\npublic List<Integer> findDuplicates(int[] nums) {\n    List<Integer> res=new LinkedList<>();\n    for (int i=0;i<nums.length;i++) {\n        if (nums[Math.abs(nums[i])-1]<0) {\n            res.add(Math.abs(nums[i]));\n        }\n        nums[Math.abs(nums[i])-1]=-Math.abs(nums[Math.abs(nums[i])-1]);\n    }\n    return res;\n}\n```\n\n## [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)\n\n给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n\n您能在不使用额外空间且时间复杂度为 O(n) 的情况下完成这个任务吗？你可以假定返回的数组不算在额外空间内。\n\n**示例：**\n\n```java\n输入：\n[4,3,2,7,8,2,3,1]\n\n输出：\n[5,6]\n```\n\n**解法一**\n\n首先想到的解法，利用的和上面缺失的第一个正数一样的思路，抽屉原理，归位每个数字，最后没有归为的 index 就是消失的数字\n\n```java\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    //nums[i]=i+1\n    for (int i=0;i<nums.length;i++) {\n        while(nums[i]!=i+1 && nums[nums[i]-1]!=nums[i]){\n            int temp=nums[i];\n            nums[i]=nums[temp-1];\n            nums[temp-1]=temp;\n            //nums[i]=nums[nums[i]-1]; 最开始的错误写法\n            //nums[nums[i]-1]=temp;\n        }\n    }\n    List<Integer> res=new LinkedList<>();\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]!=i+1) {\n            res.add(i+1);\n        }\n    }\n    return res;\n}\n```\n\n中间写出了一个小`bug`，交换两个元素的时候先交换了`nums[i]`，导致了后面的`nums[nums[i]+1]` 发生了变化，然后就死循环了😂，调试了一下才看出来，太菜了\n\n**解法二**\n\n很巧妙的方法\n\n```java\n//很巧妙\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    //nums[i]=i+1\n    //5 1 4 2 3\n    for (int i=0;i<nums.length;i++) {\n        nums[Math.abs(nums[i])-1]=-Math.abs(nums[Math.abs(nums[i])-1]);\n    }\n    List<Integer> res=new LinkedList<>();\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]>0) {\n            res.add(i+1);\n        }\n    }\n    return res;\n}\n```\n\n题目给定了数值的范围就是`[1,n]`所以可以遍历每个元素，将该元素正确位置的值取反置为负数\n\n比如 `5 1 1 3 2` 遍历到 5 的时候就会将末尾的 2 变为-2，依次类推，最后得到的就是`[-5,-1,-1,3,-2]` ，最后再遍历一遍，其中值为正数的元素的索引+1 就是消失的数字\n\n## [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)\n\n给定一个包含红色、白色和蓝色，一共 *n* 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n**注意：**\n不能使用代码库中的排序函数来解决这道题。\n\n**示例：**\n\n```java\n输入：[2,0,2,1,1,0]\n输出：[0,0,1,1,2,2]\n```\n\n**进阶：**\n\n- 一个直观的解决方案是使用计数排序的两趟扫描算法。\n  首先，迭代计算出 0、1 和 2 元素的个数，然后按照 0、1、2 的排序，重写当前数组。\n- 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n**解法一**\n\n题目上已经有了提示，很直观的做法就是利用桶排序的方法\n\n```java\npublic static void sortColors(int[] nums) {\n    int [] bucket=new int[3];\n    //基于桶排序\n    for (int i=0;i<nums.length;i++){\n        bucket[nums[i]]++;\n    }\n    int index=0;\n    //重新构造出来\n    for (int i=0;i<nums.length;i++) {\n        while (bucket[index]<=0) {\n            index++;\n        }\n        nums[i]=index;\n        bucket[index]--;\n    }\n}\n```\n\n当然还有更优秀的做法，利用**三向切分快排**的思想（荷兰国旗问题）\n\n```java\npublic static void sortColors(int[] nums) {\n    int less=-1,more=nums.length-1;\n    int l=0;\n    while(l<=more){\n        if(nums[l]<1){\n            swap(nums,++less,l++);\n        } else if(nums[l]>1){\n            swap(nums,more--,l);\n        } else{ \n            l++;\n        }\n    }\n}\n\npublic static swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n## [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n**说明：**本题中，我们将空字符串定义为有效的回文串。\n\n**示例 1:**\n\n```java\n输入：\"A man, a plan, a canal: Panama\"\n输出：true\n```\n\n**示例 2:**\n\n```java\n输入：\"race a car\"\n输出：false\n```\n\n**解法一**\n\neasy 题，对撞指针\n\n```java\npublic Boolean isPalindrome(String s) {\n    if(s==null||s.length()<=1){\n        return true;\n    }\n    s=s.toLowerCase();\n    int left=0,right=s.length()-1;\n    while(left<right){\n        char lch=s.charAt(left);\n        char rch=s.charAt(right);\n        if(isNumOrchar(lch) && isNumOrchar(rch)){\n            //System.out.println(lch+\",\"+rch);\n            if(lch==rch){\n                left++;\n                right--;\n            } else{\n                return false;\n            }\n        } else if((!isNumOrchar(lch)) && isNumOrchar(rch)){\n            left++;\n        } else if(isNumOrchar(lch) && !isNumOrchar(rch)){\n            right--;\n        } else{\n            left++;\n            right--;\n        }\n    }\n    return true;\n}\n\npublic Boolean isNumOrchar(char ch){\n    if((ch>='0' && ch<='9') || (ch>='a' && ch<='z') || (ch>='A' &&  ch<='Z')){\n        return true;\n    }\n    return false;\n}\n```\n\n代码写多了，不够简洁，其实可以直接用** Character **的 API\n\n```java\npublic Boolean isPalindrome(String s) {\n    if (s == null) return false;\n    if (s.length() == 0) return true;\n    int i = 0;\n    int j = s.length() - 1;\n    while (i < j) {\n        while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n        while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n        if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))){\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n```\n\n## [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)\n\nWrite a function that takes a string as input and reverse only the vowels of a string.\n\n**Example 1:**\n\n```\nInput: \"hello\"\nOutput: \"holle\"\n```\n\n**Example 2:**\n\n```\nInput: \"leetcode\"\nOutput: \"leotcede\"\n```\n\n**Note:**\nThe vowels does not include the letter \"y\".\n\n```java\npublic String reverseVowels(String s) {\n    if(s==null||s.length()<=0){\n        return s;\n    }\n    char[] ss=s.toCharArray();\n    int left=0,right=s.length()-1;\n    while(left<right){\n        while(left<right && !isYy(ss[left])){\n            left++;\n        }\n        while(left<right && !isYy(ss[right])){\n            right--;\n        }\n        swap(left++,right--,ss);\n    }\n    return new String(ss);\n}\n\npublic Boolean isYy(char ch){\n    char temp=Character.toLowerCase(ch);\n    return temp=='a'|| temp=='e'||temp=='i'||temp=='o'||temp=='u';\n}\n\npublic void swap(int a,int b,char[] s){\n    char temp=s[a];\n    s[a]=s[b];\n    s[b]=temp;\n}\n```\n\n很简单的对撞指针题\n\n## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)\n\nGiven two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.\n\n**Note:**\n\n- The number of elements initialized in *nums1* and *nums2* are *m* and *n* respectively.\n- You may assume that *nums1* has enough space (size that is greater or equal to *m* + *n*) to hold additional elements from *nums2*.\n\n**Example:**\n\n```java\nInput:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\nOutput: [1,2,2,3,5,6]\n```\n\n**解法一**\n\n典型的二路归并\n\n```java\npublic static void merge(int[] nums1, int m, int[] nums2, int n) {\n    if(nums1.length<=0||nums2.length<=0){\n        return;\n    }\n    int []res=new int[m+n];\n    int i1=0,i2=0;\n    for (int i=0;i1<m&&i2<n;i++) {\n        if(nums1[i1]<=nums2[i2]) {\n            res[i]=nums1[i1++];\n        } else if(nums1[i1]>nums2[i2] ){\n            res[i]=nums2[i2++];\n        }\n    }\n    if(i1>=m){\n        System.arraycopy(nums2,i2,res,i2+m,n-i2);\n    } else{\n        System.arraycopy(nums1,i1,res,i1+n,m-i1);\n    }\n    System.arraycopy(res,0,nums1,0,res.length);\n}\n```\n\n1ms ，98%beats.\n\n**解法二**\n\n看了下评论区发现自己还是太年轻了，原来这题是可以在** O(1) **的空间复杂度下完成的\n\n```java\npublic static void merge3(int[] nums1, int m, int[] nums2, int n) {\n    if(nums1.length<=0||nums2.length<=0){\n        return;\n    }\n    int i1=m-1,i2=n-1;\n    for (int i=m+n-1;i>=0;i--) {\n        if(i1<0){\n            nums1[i]=nums2[i2--];\n        } else if(i2<0){\n            nums1[i]=nums1[i1--];\n        } else if(nums1[i1]>nums2[i2]) {\n            nums1[i]=nums1[i1--];\n        } else if(nums1[i1]<=nums2[i2] ){\n            nums1[i]=nums2[i2--];\n        }\n    }\n}\n```\n\n合并后的长度确定，nums1 的空间也足够，所以完全可以从后往前，从大到小，从而避免了使用额外的空间储存结果，学到了学到了👏\n\n**解法三**\n\n时隔多年，LeetCode 打卡又做了一遍，这次直接想到了最优解，而且代码很简洁\n\n```java\npublic void merge(int[] A, int m, int[] B, int n) {\n    if(n==0 )  return;\n    int len=A.length,ai=m-1,bi=n-1,i=len-1;\n    while(ai>=0 && bi>=0) A[i--]=A[ai] > B[bi] ? A[ai--]:B[bi--];\n    while(bi>=0) A[i--]=B[bi--];\n    //ai 剩余的不用管\n}\n```\n## [532. 逆序对](https://www.lintcode.com/problem/reverse-pairs/description)\n\n（来自领扣）\n\n在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。给你一个数组，求出这个数组中逆序对的总数。\n概括：如果 a[i] > a[j] 且 i < j， a[i] 和 a[j] 构成一个逆序对。\n\n**样例 1**\n\n```java\n输入：A = [2, 4, 1, 3, 5]\n输出：3\n解释：\n(2, 1), (4, 1), (4, 3) 是逆序对\n```\n\n**样例 2**\n\n```java\n输入：A = [1, 2, 3, 4]\n输出：0\n解释：\n没有逆序对\n```\n\n**解法一**\n\n```java\npublic long reversePairs(int[] A) {\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    return reversePairs(A,0,A.length-1);\n}\n\npublic long reversePairs(int[] A,int left,int right) {\n    if (left == right) {\n        return 0;\n    }\n    int mid=left+(right-left)/2;\n    long l=reversePairs(A,left,mid);\n    long r=reversePairs(A,mid+1,right);\n    return merge(A,left,mid,right)+l+r;\n}\n\npublic long merge(int[] nums,int left,int mid,int right){\n    long res=0;\n    int[] help=new int[right-left+1];\n    int i=left,j=mid+1;\n    int index=0;\n    while(i<=mid && j<=right){\n        //小于等于的时候让 i 先进栈\n        //help[index++]=nums[i]<=nums[j] ? nums[i++]:nums[j++];\n        if (nums[i]<=nums[j]) {\n            help[index++] = nums[i++];\n        }else{\n            help[index++] = nums[j++];\n            res+= mid-i+1; //j 和 i-mid 间的所有元素形成逆序对\n        }\n    }\n    while(i<=mid){\n        help[index++]=nums[i++];\n    }\n    while(j<=right){\n        help[index++]=nums[j++];\n    }\n\n    for (int k=0;k<help.length;k++) {\n        nums[left+k]=help[k];\n    }\n    return res;\n}\n```\n\n归并排序的思路，最开始我是在每次 i>j 和最后收尾的时候 res++，然后结果总是不对，然后取查了答案才意识到不能这样算，当`nums[i] > nums[j]` 的时候，`i~j` 形成的逆序对其实不只一个，而是`[i,mid]` 区间的所有元素，如果你只是+1 的话就会漏掉许多情况，因为下一步 `j++` 就会将 `j` 向后移动，那些情况就考虑不到了\n\n## [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)\n\n给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。\n\n**示例：**\n\n```java\n输入：[5,2,6,1]\n输出：[2,1,1,0] \n解释：\n5 的右侧有 2 个更小的元素 (2 和 1).\n2 的右侧仅有 1 个更小的元素 (1).\n6 的右侧有 1 个更小的元素 (1).\n1 的右侧有 0 个更小的元素。\n```\n\n**错误解法一**\n\n这个 bug 我大概看了有两三个小时，人都看傻了，必须放上来纪念下\n\n```go\nimport(\n    \"fmt\"\n)\ntype Element struct{\n    idx int\n    val int\n}\n\nfunc countSmaller(nums []int) []int {\n    n:=len(nums)\n    count:=make([]int,n)\n    elements:=make([]Element,n)\n    for i,num:=range nums{\n        elements[i].idx=i\n        elements[i].val=num\n    }\n    fmt.Println(elements);\n    mergeSort(elements,0,n-1,count)\n    return count\n}\n\nfunc mergeSort(num []Element,left int,right int,count []int){\n    if left>=right{\n        return\n    }\n    mid:=left+(right-left)/2\n    mergeSort(num,left,mid,count)\n    mergeSort(num,mid+1,right,count)\n    merge(num,left,mid,right,count)\n}\n\nfunc merge(num []Element,left int,mid int,right int,count []int){\n    help:=make([]int,right-left+1)\n    i:=left\n    j:=mid+1\n    index:=0\n    for i<=mid && j<=right {\n        if num[i].val<=num[j].val{ //说明 j 前面的元素都小于 i\n            count[num[i].idx]+=(j-mid-1)\n            help[index]=num[i].val\n            i++\n        }else{\n            help[index]=num[j].val\n            j++\n        }\n        index++\n    }\n    for i<=mid{\n        count[num[i].idx]+=(j-mid-1)\n        help[index]=num[i].val\n        index++\n        i++\n    }\n    for j<=right{\n        help[index]=num[j].val\n        index++\n        j++\n    }\n    for i:=left;i<=right;i++{\n        num[i].val=help[i-left]\n    }\n}\n```\n\n一开始用 go 写的，调了半天没调出来，我以为是 go 的啥问题（刚学 go 不太熟）然后用 Java 又写了一遍\n\n```java\nclass Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        Pair[] pair=new Pair[nums.length];\n        for(int i=0;i<nums.length;i++){\n            pair[i]=new Pair(i,nums[i]);\n        }\n        int[] count=new int[nums.length];\n        mergeSort(pair,0,nums.length-1,count);\n        List<Integer> res=new ArrayList<>();\n        for(int i=0;i<count.length;i++){\n            res.add(count[i]);\n        }\n        return res;\n    }\n\n    public void mergeSort(Pair[] nums,int left,int right,int[] count){\n        if(left>=right){\n            return;\n        }\n        int mid=left+(right-left)/2;\n        mergeSort(nums,left,mid,count);\n        mergeSort(nums,mid+1,right,count);\n        merge(nums,left,mid,right,count);\n    }\n\n    public void merge(Pair [] nums,int left,int mid,int right,int[] count){\n        int i=left,j=mid+1;\n        //出 Bug 的地方，应该用 Pair[] \n        int[] helper=new int[right-left+1];\n        int index=0;\n        while(i<=mid && j<=right){\n            if(nums[i].value>nums[j].value){\n                helper[index++]=nums[j++].value;\n            }else{\n                count[nums[i].index]+=j-mid-1;\n                helper[index++]=nums[i++].value;\n            }\n        }\n        while(i<=mid){\n            count[nums[i].index]+=j-mid-1;\n            helper[index++]=nums[i++].value;\n        }\n        while(j<=right){\n            helper[index++]=nums[j++].value;\n        }\n        for(int k=0;k<helper.length;k++){\n            //这里无形之中将索引和数据的对应关系打乱了。\n            nums[left+k].value=helper[k];\n        }\n    }\n\n    class Pair{\n        int index;\n        int value;\n        public Pair(int i,int v){\n            index=i;\n            value=v;\n        }\n    }\n}\n```\n\n还是不对，和之前 go 的结果是一样的，这段代码我反复地看了 3 个小时，楞是没看出来哪里写错了，我是真的菜啊！！！！！！！！！\n\n**解法一**\n\n其实和逆序对的解法是类似的，思路都在注释中\n\n```java\npublic List<Integer> countSmaller(int[] nums) {\n    Pair[] pair=new Pair[nums.length];\n    for(int i=0;i<nums.length;i++){\n        pair[i]=new Pair(i,nums[i]);\n    }\n    int[] count=new int[nums.length];\n    mergeSort(pair,0,nums.length-1,count);\n    List<Integer> res=new ArrayList<>();\n    for(int i=0;i<count.length;i++){\n        res.add(count[i]);\n    }\n    return res;\n}\n\npublic void mergeSort(Pair[] nums,int left,int right,int[] count){\n    if(left>=right){\n        return;\n    }\n    int mid=left+(right-left)/2;\n    mergeSort(nums,left,mid,count);\n    mergeSort(nums,mid+1,right,count);\n    merge(nums,left,mid,right,count);\n}\n\npublic void merge(Pair [] nums,int left,int mid,int right,int[] count){\n    int i=left,j=mid+1;\n    Pair[] helper=new Pair[right-left+1];\n    int index=0;\n    while(i<=mid && j<=right){\n        if(nums[i].value>nums[j].value){\n            helper[index++]=nums[j++];\n        }else{\n            //i<=j 那么 mid+1~j-1 的肯定都比 i 小\n            //(j-1)-(mid+1)+1=j-mid-1\n            count[nums[i].index]+=j-mid-1;\n            helper[index++]=nums[i++];\n        }\n    }\n    while(i<=mid){\n        //j 没了，那么所有的 j 的元素都比 i 小\n        //等价于 right-mid\n        count[nums[i].index]+=j-mid-1;\n        helper[index++]=nums[i++];\n    }\n    while(j<=right){\n        helper[index++]=nums[j++];\n    }\n    for(int k=0;k<helper.length;k++){\n        nums[left+k]=helper[k];\n    }\n}\n\nclass Pair{\n    int index;\n    int value;\n    public Pair(int i,int v){\n        index=i;\n        value=v;\n    }\n}\n```\n\n> 这题还可以用**树状数组**解，但是我暂时还不会，后面有时间学了再来补充，其实还可以用线段树，二叉搜索树等等，有点麻烦，算了\n\n## [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)\n\nGiven a non-negative integer *numRows*, generate the first *numRows* of Pascal's triangle.\n\n![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\n\n**Example:**\n\n```java\nInput: 5\nOutput:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n```\n\n递归专题里面的题目，所以直接用递归来实现了下。\n\n```java\npublic static List<List<Integer>> generate(int numRows) {\n    if(numRows<=0) {\n        return new ArrayList();\n    }\n    List<List<Integer>> res = new ArrayList<>();\n    res.add(new ArrayList<Integer>() {\n        {\n            add(1);\n        }\n    }\n    );\n    generate(1, res.get(0), res, numRows);\n    return res;\n}\n\npublic static void generate(int numRow, List<Integer> preRow, List<List<Integer>> res, int rowMax) {\n    if (rowMax == numRow) {\n        return;\n    }\n    List<Integer> row = new ArrayList<>();\n    row.add(1);\n    for (int i = 1; i < preRow.size(); i++) {\n        row.add(preRow.get(i - 1) + preRow.get(i));\n    }\n    row.add(1);\n    res.add(row);\n    generate(numRow + 1,row,res,rowMax);\n}\n```\n\n尾递归，很鸡肋。\n\n## [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\nGiven a non-negative index *k* where *k* ≤ 33, return the *k*th index row of the Pascal's triangle.\n\nNote that the row index starts from 0.\n\n![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\n\n**Example:**\n\n```java\nInput: 3\nOutput: [1,3,3,1]\n```\n\n**Follow up:**\n\nCould you optimize your algorithm to use only *O*(*k*) extra space?\n\n```java\n public List<Integer> getRow(int rowIndex) {\n        List<Integer> res=new ArrayList<>();\n        long cur=1;\n        res.add((int)cur);\n        for(int i=1;i<=rowIndex;i++){\n            cur=cur*(rowIndex-i+1)/i;\n            res.add((int)cur);\n        }\n        return res;\n }\n```\n\n直接利用组合数的公式，m 列第 n 个元素等于 C(n-1,M-1)\n\n## [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)\n\n给定一个包含 m x n 个元素的矩阵（m 行，n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n\n**示例 1:**\n\n```java\n输入：\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n输出：[1,2,3,6,9,8,7,4,5]\n```\n\n**示例 2:**\n\n```java\n输入：\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n**解法一**\n\n这题很久之前做过，这次又来做的时候还是没做出来，忘了之前咋做的了，用模拟的方法搞了半天，没搞出来，然后瞄了一眼之前写的才写出来。...\n\n```java\npublic static List<Integer> spiralOrder2(int[][] matrix) {\n    List<Integer> res=new ArrayList<>();\n    if(matrix.length<=0){\n        return res;\n    }\n    //a: 行\n    //b: 列\n    int la=0,lb=0,ra=matrix.length-1,rb=matrix[0].length-1;\n    //终止条件\n    while(lb<=rb && la<=ra){\n        //缓存各个坐标\n        int tla=la,tlb=lb,tra=ra,trb=rb;\n        //特殊情况，特殊处理\n        if(tla==tra){//同一行\n            while(tlb<=trb){\n                res.add(matrix[tla][tlb++]);\n            }\n            return res;\n        }else if(tlb==trb){//同一列\n            while(tla<=tra){\n                res.add(matrix[tla++][tlb]);\n            }\n            return res;\n        }else{\n            //向左\n            while(tlb<rb){\n                res.add(matrix[tla][tlb++]);\n            }\n\t\t\t//向下\n            while(tla<ra){\n                res.add(matrix[tla++][tlb]);\n            }\n\t\t\t//向右\n            while(trb>lb){\n                res.add(matrix[tra][trb--]);\n            }\n\t\t\t//向上\n            while(tra>la){\n                res.add(matrix[tra--][trb]);\n            }\n        }\n        //向内靠拢（缩圈）\n        la++;\n        lb++;\n        ra--;\n        rb--;\n    }\n    return res;\n}\n```\n\n模拟的方式相对要复杂点，需要记录每个节点是否访问然后在选择，这里的方式就很巧妙，直接按层遍历，由外到内，不用考虑那么多。时间复杂度`O(NM)`空间复杂度`O(NM)`。\n\n## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)\n\n给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n\n**示例：**\n\n```java\n输入：3\n输出：\n[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]\n```\n\n**解法一**\n> UPDATE(2020.12.17)：更新了通用的解法，对应 [AcWing756. 蛇形矩阵](https://www.acwing.com/problem/content/description/758/)，美化了下代码\n```java\nimport java.io.*;\nimport java.util.*;\n\nclass Main {\n\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int v = 1;\n        int[][] res = new int[n][m];\n        int la = 0, lb = 0;\n        int ra = n-1, rb = m-1;\n        while (la <= ra && lb <= rb) {\n            int tla = la, tlb = lb;\n            int tra = ra, trb = rb;\n            if (la == ra) {\n                while (tlb <= rb) res[la][tlb++] = v++;\n                break;\n            }\n            if (lb == rb) {\n                while (tla <= ra) res[tla++][rb] = v++;\n                break;\n            }\n            while (tlb < rb) res[la][tlb++] = v++;\n            while (tla < ra) res[tla++][rb] = v++;\n            while (trb > lb) res[ra][trb--] = v++;\n            while (tra > la) res[tra--][lb] = v++;\n            la++; lb++;\n            ra--; rb--;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                System.out.print(res[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    } \n}\n```\n\n上一题的简化版，2020.2.11 白板写的，还行\n\n## [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)\n\n给定一个 *n* × *n* 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 90 度。\n\n**说明：**\n\n你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。\n\n**Example 1:**\n\n```java\nGiven input matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\nrotate the input matrix in-place such that it becomes:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n\n**Example 2:**\n\n```java\nGiven input matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\nrotate the input matrix in-place such that it becomes:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n```\n\n**解法一**\n\n这题和上面哪一题放在一起很有必要，很类似的题型\n\n```java\npublic void rotate(int[][] matrix) {\n    if (matrix==null || matrix.length==0) {\n        return;\n    }\n    int len=matrix.length-1;\n    int lx=0,ly=0,rx=len,ry=len;\n    while(lx<=rx){\n        //len=ry-ly;\n        for (int i=0;i<len;i++) {\n            int temp=matrix[lx][ly+i];\n            matrix[lx][ly+i]=matrix[rx-i][ly];\n            matrix[rx-i][ly]=matrix[rx][ry-i];\n            matrix[rx][ry-i]=matrix[lx+i][ry];\n            matrix[lx+i][ry]=temp;\n        }\n        //缩圈\n        len-=2; //写 ry-ly 可能会好一点，无所谓\n        lx++;ly++;\n        rx--;ry--;\n    }\n}\n```\n和上一题一样，都是从整体出发，从外层到内层，考虑每一层的前`n-1`个节点的旋转过程，这个过程需要自己在纸上画一画，空想容易搞错\n\n**解法二**\n\n新学到的解法，挺有意思的，整体沿对角线交换，然后每行沿中点交换，这个其实可以通过观察数组结构得到\n\n```java\npublic void rotate(int[][] matrix) {\n    if(matrix==null || matrix.length<=0) return;\n    int N=matrix.length;\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            int temp=matrix[i][j];\n            matrix[i][j]=matrix[j][i];\n            matrix[j][i]=temp;\n        }\n    }\n\n    for(int i=0;i<N;i++){\n        for(int j=0,k=N-1;j<k;j++,k--){\n            int temp=matrix[i][j];\n            matrix[i][j]=matrix[i][k];\n            matrix[i][k]=temp;\n        }\n    }\n}\n```\n\n## [498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)\n\n给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。\n\n**示例：**\n\n```\n输入：\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\n输出：[1,2,4,7,5,3,6,8,9]\n```\n\n ![JXlfOg.png](https://s1.ax1x.com/2020/05/01/JXlfOg.png)\n\n**说明：**\n\n1. 给定矩阵中的元素总数不会超过 100000 。\n\n**解法一**\n\n因为是先做的下面的那一题，所以我这里直接延用了前面的思路，借助了 map 额外的空间，其实做复杂了\n\n```go\n//借助额外空间\nfunc findDiagonalOrder(matrix [][]int) []int {\n    var res []int\n    m := len(matrix)\n    if matrix == nil || m == 0 {\n        return res\n    }\n    n := len(matrix[0])\n    hmap := make(map[int][]int)\n    flagRow := false //行开头标志位\n    for i, row := range matrix {\n        flagColumn := flagRow //列标志位\n        for j, num := range row {\n            if flagColumn {\n                hmap[i+j] = append(hmap[i+j], num)\n            } else {\n                hmap[i+j] = append([]int{num}, hmap[i+j]...)\n            }\n            flagColumn = !flagColumn\n        }\n        flagRow = !flagRow\n    }\n    for i := 0; i <= m*n; i++ {\n        res = append(res, hmap[i]...)\n    }\n    return res\n}\n```\n\n**解法二**\n\n模拟，不过是从整体上模拟，比较好的解法，不借助 map\n\n```go\n//比较好的解法\nfunc findDiagonalOrder(matrix [][]int) []int {\n    var res []int\n    m := len(matrix)\n    if matrix == nil || m == 0 {\n        return res\n    }\n    n := len(matrix[0])\n    leftX := 0\n    leftY := 0\n    rightX := 0\n    rightY := 0\n    flag := true\n    //左右端点沿着矩形边缘移动就行了\n    for leftX < m && leftY < n {\n        help(matrix, leftX, leftY, rightX, rightY, flag, &res)\n        if leftX == m-1 { //左端点到达边界\n            leftY++\n        } else {\n            leftX++\n        }\n        if rightY == n-1 { //右端点到达边界\n            rightX++\n        } else {\n            rightY++\n        }\n        flag = !flag //反转\n    }\n    return res\n}\n\n//获取 (lx,ly) 和 (rx,ry) 之间的点\nfunc help(matrix [][]int, lx, ly, rx, ry int, flag bool, res *[]int) {\n    for lx >= rx && ly <= ry {\n        if flag {\n            *res = append(*res, matrix[lx][ly])\n            lx--\n            ly++\n        } else {\n            *res = append(*res, matrix[rx][ry])\n            rx++\n            ry--\n        }\n    }\n}\n```\n\n## [1424. 对角线遍历 II](https://leetcode-cn.com/problems/diagonal-traverse-ii/)\n\n给你一个列表 `nums` ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 `nums` 中对角线上的整数。\n\n \n\n**示例 1：**\n\n![JOOOEt.png](https://s1.ax1x.com/2020/05/01/JOOOEt.png)\n\n```java\n输入：nums = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,4,2,7,5,3,8,6,9]\n```\n\n**示例 2：**\n\n![JOXkEq.png](https://s1.ax1x.com/2020/05/01/JOXkEq.png)\n\n```go\n输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\n输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n```\n\n**示例 3：**\n\n```go\n输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]\n输出：[1,4,2,5,3,8,6,9,7,10,11]\n```\n\n**示例 4：**\n\n```go\n输入：nums = [[1,2,3,4,5,6]]\n输出：[1,2,3,4,5,6]\n```\n\n**提示：**\n\n- `1 <= nums.length <= 10^5`\n- `1 <= nums[i].length <= 10^5`\n- `1 <= nums[i][j] <= 10^9`\n- `nums` 中最多有 `10^5` 个数字。\n\n**解法一**\n\n186th 周赛的 t3，还是挺有意思的，这题我拿到的第一想法其实是找一下关系直接排序，但是实际上有更好的方法\n\n```go\nfunc findDiagonalOrder(nums [][]int) []int {\n    //最大的行列值\n    n := 0\n    m := make(map[int][]int)\n    for i, row := range nums {\n        for j, num := range row {\n            //逆序添加\n            m[i+j] = append([]int{num}, m[i+j]...)\n            n = max(n, i+j)\n        }\n    }\n    //res := make([]int, n)\n    var res []int\n    for i := 0; i <= n; i++ {\n        res = append(res, m[i]...)\n    }\n    return res\n}\n\nfunc max(a, b int) int {\n    if a < b {\n        return b\n    }\n    return a\n}\n```\n\n上面的解法其实和 N 皇后里面对行列的处理是一样的，两条对角线，一条行列和相等，一条行列差相等\n\n> 这题我还看到了至少 3 种不同的方法，有一种把这个数组旋转一下，然后当成二叉树，直接做 BFS 层次遍历😂，脑洞挺大的\n\n## [215. 数组中的第 K 个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\nFind the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\n**Example 1:**\n\n```\nInput: [3,2,1,5,6,4] and k = 2\nOutput: 5\n```\n\n**Example 2:**\n\n```\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\nOutput: 4\n```\n\n**Note:** \nYou may assume k is always valid, 1 ≤ k ≤ array's length.\n\n> 这题必须多说几句\n\n**解法一**\n\n大根堆的做法（首先想到的方法，不是常规用堆的做法）\n\n```java\npublic static int findKthLargest(int[] nums, int k) {\n    //构建了大根堆\n    for (int i=0;i<nums.length;i++){\n        siftUp(nums,i);\n    }\n    int size=nums.length-1;\n    for (int i=0;i<k-1;i++) {\n        swap(nums,0,size);//和堆顶交换 K 次\n        siftDown(nums,0,--size);//重新调整堆\n    }\n    return nums[0];\n}\n\npublic static void siftUp(int[] nums,int i){\n    while(nums[i]>nums[(i-1)/2]){\n        swap(nums,i,(i-1)/2);\n        i=(i-1)/2;\n    }\n}\n\n//i 变小 下沉\npublic static void siftDown(int[] nums,int i,int size){\n    //判断有没有子节点（左孩子）\n    int left=i*2+1;\n    while(left<size){\n        int right=left+1;\n        //左右节点最大值\n        int larger=left+1<size && nums[left]<nums[left+1] ?left+1:left;\n        if(nums[larger]>nums[i]){\n            swap(nums,larger,i);\n            i=larger;\n            left=larger*2+1;\n        } else{\n            break;\n        }\n    }\n}\n\npublic static  void  swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n70%左右的 beat，当时感觉还行，时间复杂度应该是`O(KlogN)`，后来越想越不对，又去看了下堆排序，发现我之前写的堆排序都是有问题的\n\n**优化后的大根堆做法**\n\n```java\npublic static int findKthLargest(int[] nums, int k) {\n    int last=nums.length-1;\n    for (int i=nums.length/2-1;i>=0;i--) {\n        siftDown(nums,i,last);\n    }\n    for (int i=0;i<k-1;i++) {\n        swap(nums,0,last);\n        siftDown(nums,0,--last);\n    }\n    return nums[0];\n}\n\n//i 变小 下沉\npublic static void siftDown(int[] nums,int i,int last){\n    //判断有没有子节点（左孩子）\n    int left=i*2+1;\n    while(left<=last){\n        int right=left+1;\n        //左右节点最大值\n        int larger=right<=last && nums[right] > nums[left]?right:left;\n        if(nums[larger]>nums[i]){\n            swap(nums,larger,i);\n            i=larger;\n            left=larger*2+1;\n        } else{\n            break;\n        }\n    }\n}\n\npublic static  void  swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n95% beat，比上面的要快很多，相比之前的方法，构造堆的方式发生了变化，上面那种通过自上而下的 insert 方式时间复杂度是 O(NlogN)，其实想想，这两种方式是完全相反的，insert 的方式，最后一层每个元素最坏都可能调整`logN`次，而最后一层也是元素最多的一层，这样一来复杂度就会大大增加，相反如果采用从底向上的`swim`方式最后一层都只需要调整`1`次，而根节点需要调整`logN`次，而根节点只有一个，时间复杂度就会大大降低，最终的时间复杂度就是`O(N)`，[具体推算可以看这篇文章](https://www.zhihu.com/question/20729324)， 现在的时间复杂度才真的是`O(KlogN)`\n\n![mark](http://static.imlgw.top/image/20190617/kVuvnMfjuSns.png?imageslim)\n\n> 💥💥 上面这两种做法是有问题的，失去了用堆的优势，大根堆的做法必须要阿将整个堆构建完成后才能去找 topk 这样的话内存消耗比较大，应该维护一个小根堆，这样如果数据量很大的时候不用全读入内存中，  这题因为是我自己实现的堆，所以建堆的复杂度是 O(N)（如果使用官方的 API，建堆的时间复杂度就是 NlogN），最终大根堆小根堆复杂度取决于 K 和 N 的大小关系，但是面试的时候最好不要说用大根堆的做法\n\n**解法二**\n\n小根堆的做法\n\n```java\npublic int findKthLargest(int[] nums, int k) {\n    int size=nums.length;\n    //先维护一个大小为 k 的小根堆 , 这里要注意 k 不是下标，k=index+1\n    for (int i = k/2; i >=0; i--) {\n        heapIfy(nums,i,k);\n    }\n\t//再从 k 开始向里面插入元素\n    for (int i=k;i<size;i++) {\n        if(nums[i]>nums[0]) { //大于小根堆堆顶，进取代它\n            //小根堆求第 K 大，保证这个堆的元素是整个堆的前 k 大的元素，堆顶就是第 k 大\n            swap(nums,i,0);\n            heapIfy(nums,0,k);\n        }\n        //小于堆顶就不用管了\n    }\n    return nums[0];\n}\n\n//小根堆调整\npublic  void heapIfy(int[] nums, int i, int size) {\n    int left = 2 * i + 1;\n    while (left < size) {\n        int right = left + 1;\n        int small = right < size && nums[right] < nums[left] ? right: left;\n        if(nums[small]<nums[i]) {\n            swap(nums,small,i);\n            i=small;\n            left=2*i+1;\n        } else {\n            return;\n        }\n    }\n}\n\nprivate  void swap(int[] nums, int l, int r) {\n    int temp = nums[l];\n    nums[l] = nums[r];\n    nums[r] = temp;\n}\n```\n\n2ms，99%beat，一般情况下的 topK 问题，如果用堆解决的话应该都是采用**小根堆**这种做法来做，时间复杂度为`O(NlogK)`，维护一个大小为 k 的小根堆，然后再遍历后面 n-k 个元素，依次和当前最小堆的堆顶比较（当前 topK 中的最小元素，堆顶），如果比它小就和它交换然后调整堆，这样就始终保持了这个堆是当前的 topK 小，最后的堆顶就是第 K 大的元素。\n\n_关于节省空间的问题，其实很好理解，去找一个 OJ 试一下就懂了_\n\n```java\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int K=sc.nextInt();\n        PriorityQueue<Integer> queue=new PriorityQueue<>((a,b)->b-a);\n        for(int i=0;i<N;i++){\n            int num=sc.nextInt(); //一个个的读入，而不是一起读入\n            queue.add(num);\n            if(queue.size()>K){\n                queue.poll();\n            }\n        }\n        System.out.println(queue.peek());\n    }\n}\n```\n\n**解法三**\n\n其实还有一类做法，利用`快排+二分`的思想，一般也被称为快选\n\n```java\npublic static int findKthLargest(int[] nums, int k) {\n    int n=nums.length;\n    int left=0,right=nums.length-1;\n    while(left<=right){\n        //分治\n        int base=partion(nums,left,right); //拿到划分点\n        if(base<n-k){\n            left=base+1;\n        } else if(base>n-k){\n            right=base-1;\n        } else{\n            return nums[base];\n        }\n    }\n    return -1;\n}\n\npublic static int partion(int []nums,int left,int right){\n    //随机取值\n    swap(nums,left,left+(int) (Math.random() * (right - left + 1)));\n    int base=left;\n    while(left<right){\n        while(left<right&&nums[right]>nums[base]){\n            right--;\n        }\n        while(left<right&&nums[left]<=nums[base]){\n            left++;\n        }\n        if(left<right){\n            swap(nums,left,right);\n        }\n    }\n    //归位\n    swap(nums,left,base);\n    return left;\n}\n\npublic static  void  swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n这里最好用**随机**的** partition**，我试了下**不随机**大概`50+ms 30%beat`，这种随机的大概`3ms 97%beats `，差距还是很大的，时间复杂度是** O(N)**\n\n> 至于为什么是 O(N)，我们可以来分析下，这里**假设每次划分都是差不多中点的位置**，如果是快排，那么在** partition **之后依然需要两边的子数组进行** partition**，分治整个递归栈的高度就是`logN`，每层都是 N，所以整体的复杂度就** O(NlogN)**.... 扯远了，回到正题\n>\n> 来说说我们这里为什么是 O(N)，这里我们沿用前面的分析过程，递归栈深度依然是`logN`，但是我们在这里第一次确定划分点的相对** k **的位置后，下一步**只需要划分其中一边的元素，不用对另一边的元素继续**，也就是 n/2，再往下就是 n/4，n/8，n/16 ....   而 `(1+1/2+1/4+1/8+......1/2^n)n <=2n` ，也就是说整体的复杂度是低于 O(2N) 的，所以这里复杂度就是 O(N)\n\n**三切分快排优化**\n\nACWing 上交的，wa 了好几次，发现是二分写错了，哎，二分真难，其实还可以做一下随机处理\n\n```java\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int K=sc.nextInt()-1;\n        int[] nums=new int[N];\n        for(int i=0;i<N;i++) nums[i]=sc.nextInt();\n        int left=0,right=N-1;\n        while(left<right){\n            int[] equ=partition(nums,left,right);\n            if(K>equ[1]){\n                left=equ[1]+1;\n            }else if(K<equ[0]){\n                right=equ[0]-1;\n            }else{\n                System.out.println(nums[equ[0]]);\n                return;\n            }\n        }\n        System.out.println(nums[left]);\n    }\n\n    public static int[] partition(int[] nums,int left,int right){\n        int less=left-1,more=right,base=nums[right];\n        int i=left;\n        while(i<more){\n            if(nums[i]<base){\n                swap(nums,++less,i++);\n            }else if(nums[i]>base){\n                swap(nums,--more,i);\n            }else{\n                i++;\n            }\n        }\n        //归位\n        swap(nums,right,more++);\n        return new int[]{less+1,more-1}; //返回等于区域\n    }\n\n    public static void swap(int[] nums,int a,int b){\n        int temp=nums[a];\n        nums[a]=nums[b];\n        nums[b]=temp;\n    }\n}\n```\n\n**Update: 2020.6.28**\n\n用 go 重写下，又写了半天。真的菜，主要是最后划分元素的时候，区间只有 1 也应该继续划分，也就是`left <= right`，上面的解法就没考虑这个，而是在循环退出后返回 left，实际上并不是好方法。（后面还是会再写的，尽量缩短 code 时间）\n```golang\n//1 2 3 4 5 6\nfunc findKthLargest(nums []int, k int) int {\n    k = len(nums) - k //转换下\n    var left = 0\n    var right = len(nums)-1\n    for left <= right{ //第一个 WA 点，这里是最容易写错的\n        mid := partition(nums, left, right)\n        if mid[1] < k{\n            left = mid[1]+1 //WA 点\n        }else if mid[0] > k{\n            right = mid[0]-1 //WA 点\n        }else{\n            return nums[mid[0]]\n        }\n    }\n    return -1\n}\n\nfunc partition(nums []int, left int, right int) []int{\n    base := left\n    var less = left\n    var more = right+1 //WA 点\n    var i = left\n    for i < more{ //WA 点\n        if nums[i] < nums[base]{\n            less++\n            nums[less], nums[i] = nums[i], nums[less]\n            i++\n        }else if nums[i] > nums[base]{\n            more--\n            nums[more], nums[i] = nums[i], nums[more]\n        }else{\n            i++\n        }\n    }\n    nums[less], nums[base] = nums[base], nums[less]\n    return []int{less,more-1} //WA 点，注意配合上面的二分\n}\n```\n\n**解法四**\n\n[BFPRT 算法](https://zhuanlan.zhihu.com/p/31498036) 大佬们提出来的根据上面快排改进而来，其实面试把小根堆和快排的解法答出来应该就差不多了，这个解法还是有些不容易写出来\n\n```java\npublic static int findKthLargest(int []nums,int k){\n    return findKthLargest(nums,0,nums.length-1,k);\n}\n\npublic static int findKthLargest(int[] nums,int l,int r,int k) {\n    int mid=findMid(nums,l,r);\n    swap(nums,mid,l);\n    int m=partition(nums,l,r);\n    if(m==nums.length-k){\n        return nums[m];\n    }\n    //下面的类似了\n    if(m>nums.length-k){\n        return findKthLargest(nums,l,m-1,k);\n    }\n    return findKthLargest(nums,m+1,r,k);\n}\n\n//中位数的中位数，主要的核心就是在这里\npublic static int  findMid(int []nums,int l,int r){\n    int leftSub=l;\n    //分组求中位数，5 等分\n    for (int i=l;i<r-4;i+=5) {\n        insertSort(nums,i,i+4);\n        //将每一组的中位数统一放到左侧，用于递归\n        swap(nums,leftSub++,i+2);\n    }\n    //处理剩下的不足 5 个的\n    if (r-l<4) {\n        insertSort(nums,l,r);\n        swap(nums,leftSub,l+(r-l)/2);\n    }\n    //找到了\n    if(l==leftSub){\n        return l;\n    }\n    return findMid(nums,l,leftSub);\n}\n\n//五等分的插入\npublic static void insertSort(int []nums,int l,int r){\n    for (int i=0;i<r;i++) {\n        for (int j=i+1;j>=l&&nums[j]<nums[i];j--) {\n            swap(nums,j,i);\n        }\n    }\n}\n\n//快排 partition\npublic static int partition(int []nums,int left,int right){\n    int base=left;\n    while(left<right){\n        while(left<right&&nums[right]>nums[base]){\n            right--;\n        }\n        while(left<right&&nums[left]<=nums[base]){\n            left++;\n        }\n        if(left<right){\n            swap(nums,left,right);\n        }\n    }\n    //归位\n    swap(nums,left,base);\n    return left;\n}\n\npublic static void swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n[具体的时间复杂度证明](https://zhuanlan.zhihu.com/p/31498036)，当 n 取 5 时候，在划分的时候**至少**会大于** 3n/10 **的元素，避免了极端情况，保证在最坏情况下也不会太坏。\n\n![mark](http://static.imlgw.top/image/20190617/Lc4M5f2qkegH.png?imageslim)\n\n如上图，每一列为分好的一组元素，中间黄色部分为每组的中位数，红色块为**中位数的中位数**，这个中位数至少会大于等于左上角黑框框住的部分，所以在划分的时候会保证至少减小大约 3n/10 的规模。\n\n所以时间复杂度   `T(N)<=T(n/5)+T( 7n/10)+c*n`  总体时间复杂度** O(N)**，至于为什么不用其他的元素可以看看上面的那篇文章。\n\n## [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n\n给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\n\n**示例 1:**\n\n```java\n输入：nums = [1,1,1,2,2,3], k = 2\n输出：[1,2]\n```\n\n**示例 2:**\n\n```java\n输入：nums = [1], k = 1\n输出：[1]\n```\n\n**说明：**\n\n```java\n你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。\n```\n\n也是 TopK 问题，但是这题其实还有个条件，`不会给出有歧义的数据` ，举个例子\n\n`nums=[1,1,1,2,2,2,3,3,3] ，k=2` 这样的就是有歧义的\n\n但是题目中也没有规定这样的如何处理，经过测试，发现官方的解在遇到这种情况会抛一个异常。\n\n**解法一**\n\n大根堆的做法\n\n```java\npublic static List<Integer> topKFrequent(int[] nums, int k) {\n    if(nums==null||nums.length<=0){\n        return null;\n    }\n    HashMap<Integer,Integer> fre=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        //fre.get(i) nums[i] 出现的频次\n        fre.put(nums[i],fre.getOrDefault(nums[i],0)+1);\n    }\n    //1:3,2:3,3:1\n    PriorityQueue<HashMap.Entry<Integer,Integer>> pq=new PriorityQueue(new ComparatorMap());\n    for (HashMap.Entry ent:fre.entrySet()) {\n        pq.add(ent);\n    }\n    ArrayList<Integer> res=new ArrayList<>();\n    for (int i=0;i<k;i++) {\n        res.add(pq.poll().getKey());\n    }\n    return res;\n}\n\n//比较器\nstatic class ComparatorMap implements Comparator<HashMap.Entry<Integer,Integer>>{\n    @Override\n    public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {\n        return o2.getValue()-o1.getValue();\n    }\n}\n```\n用大根堆不太好，容易爆内存，但是在这一题可以保证顺序，`但是题目并没有要求顺序`，时间复杂度~~O(KlogN)~~\n\n这里错了，建堆的时间复杂度就是`O(NlogN)`了，只有自己手写的堆，采用自底向上的方式建堆时间复杂度才是 O(N) ，可以参考 [之前的文章](http://imlgw.top/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%9B%B4%E4%BC%98%E7%9A%84%E5%81%9A%E6%B3%95) ，这也是上面 topK 问题中提到的\n\n**解法二**\n\n小根堆的做法\n\n```java\n//UPDATE：2020.9.7 之前的解法太丑陋了\npublic int[] topKFrequent(int[] nums, int k) {\n    HashMap<Integer,Integer> freq = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        freq.put(nums[i], freq.getOrDefault(nums[i], 0)+1);\n    }\n    //int[0]: count int[1]: val \n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->a[0]-b[0]);\n    //freq.forEach();\n    for (int key : freq.keySet()) {\n        pq.offer(new int[]{freq.get(key), key});\n        if (pq.size() > k) {\n            pq.poll();\n        }\n    }\n    int[] res = new int[k];\n    int i = 0;\n    while (!pq.isEmpty()) {\n        res[i++] = pq.poll()[1];\n    }\n    return res;\n}\n```\n\n时间复杂度`O(NlogK)`因为只维护了一个 K 大小的小根堆 ，时间复杂度和大根堆~~O(KlogN)~~ `O(NlogN)`相比会快很多，除此之外，如果 N 和 K 很接近的话可以考虑`O(Nlog(N-K))` 的做法，维护一个 N-K 的大根堆，里面存频率最低的那些元素，最后返回其他的元素（no code， just talk）\n\n**解法三**\n\n桶排序，这题的最优解应该就是桶排序\n\n```java\npublic static List<Integer> topKFrequent(int[] nums, int k) {\n    if(nums==null||nums.length<=0){\n        return null;\n    }\n    HashMap<Integer,Integer> fre=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        //记录 nums[i] 出现的频次\n        fre.put(nums[i],fre.getOrDefault(nums[i],0)+1);\n    }\n    ArrayList<Integer> [] bucket=new ArrayList[nums.length+1];\n    for (Integer num:fre.keySet()) {\n        if(bucket[fre.get(num)]==null){\n            bucket[fre.get(num)]=new ArrayList<>();\n        }\n        //桶排序\n        bucket[fre.get(num)].add(num); //所有出现 fre.get(num) 次的元素构成一条链表\n    }\n    ArrayList<Integer> res=new ArrayList<>();\n    int topk=bucket.length-1;\n    while (true) {\n        //从后向前遍历（从频次大到小）\n        //指针移动到合适的位置\n        while(bucket[topk]==null&&topk>0){\n            topk--;\n        }\n        res.addAll(bucket[topk--]);\n        if(res.size()==k){\n            return res;\n        }\n    }\n}\n```\n\n桶排序的思路，时间复杂度`O(N)`，空间复杂度也是`O(N)`，在 leetcode 提交三种方法的差距不大，可能是数据量太少了\n\n**解法四** (UPDATE:2020.9.7)\n\n基于快选的做法，时间复杂度 O(N)，之前一直懒得写，今天补一下\n```golang\ntype Node struct {\n    Val   int\n    Count int\n}\n\nfunc topKFrequent(nums []int, k int) []int {\n    var n = len(nums)\n    var freq = make(map[int]int)\n    for i := 0; i < n; i++ {\n        freq[nums[i]]++\n    }\n    var nodes []*Node\n    for val, count := range freq {\n        nodes = append(nodes, &Node{val, count})\n    }\n    //7 0 1 2 9 10\n    var res []int\n    var left, right = 0, len(nodes) - 1\n    for left <= right {\n        mid := partition(nodes, left, right)\n        if mid == k-1 {\n            for i := 0; i <= mid; i++ {\n                res = append(res, nodes[i].Val)\n            }\n            return res\n        }\n        if mid > k-1 {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return res\n}\n\nfunc partition(nums []*Node, i int, j int) int {\n    //7 9 10 0 1 2\n    //随机下会好一点\n    var base = i\n    for i < j {\n        for i < j && nums[j].Count <= nums[base].Count {\n            j--\n        }\n        for i < j && nums[i].Count >= nums[base].Count {\n            i++\n        }\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    nums[i], nums[base] = nums[base], nums[i]\n    return i\n}\n```\n\n## [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)\n\n中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。\n\n例如，\n\n[2,3,4] 的中位数是 3\n\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n\n设计一个支持以下两种操作的数据结构：\n\n- void addNum(int num) - 从数据流中添加一个整数到数据结构中。\n- double findMedian() - 返回目前所有元素的中位数。\n\n**示例：**\n\n```java\naddNum(1)\naddNum(2)\nfindMedian() -> 1.5\naddNum(3) \nfindMedian() -> 2\n```\n\n**进阶：**\n\n- 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？\n- 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？\n\n**解法一**\n\n这题很久之前就听人讲过，不过忘记了，最佳策略就是利用小根堆+大根堆，分别维护前半部分和后半部分的最值\n\n```java\n/** initialize your data structure here. */\nPriorityQueue<Integer> minQue=null;\n\nPriorityQueue<Integer> maxQue=null;\n\npublic MedianFinder295() {\n    minQue=new PriorityQueue<>();\n    maxQue=new PriorityQueue<>((a,b)->b-a);\n}\n\npublic void addNum(int num) {\n    minQue.add(num);\n    maxQue.add(minQue.poll());\n    if(minQue.size()<maxQue.size()){\n        minQue.add(maxQue.poll());\n    }\n}\n\npublic double findMedian() {\n    if(minQue.size()==maxQue.size()){\n        return (minQue.peek()+maxQue.peek())/2.0;\n    }\n    return minQue.peek();\n}\n```\n\n前半部分用大跟堆，后半部分小根堆，每次将一个堆的最值放到另一个堆中，这样保证了大跟堆的最大值一定小于小根堆的最小值，另外我们还需要保证两个堆的差距不能大于 1，这里我将多的放到小根堆中，最后在奇数的时候将小根堆的堆顶弹出就可以了\n\n## [66. 加一](https://leetcode-cn.com/problems/plus-one/)\n\n给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n**示例 1:**\n\n```java\n输入：[1,2,3]\n输出：[1,2,4]\n解释：输入数组表示数字 123。\n```\n\n**示例 2:**\n\n```java\n输入：[4,3,2,1]\n输出：[4,3,2,2]\n解释：输入数组表示数字 4321。\n```\n\n**解法一**\n\n模拟进位\n\n```go\nfunc plusOne(digits []int) []int {\n    n := len(digits) - 1\n    carry := 1\n    for n >= 0 {\n        digits[n] += carry\n        carry = digits[n] / 10\n        digits[n] %= 10\n        n--\n    }\n    if carry == 1 {\n        digits = append([]int{1}, digits...)\n    }\n    return digits\n}\n```\n\n## [67. 二进制求和](https://leetcode-cn.com/problems/add-binary/) \n\n给定两个二进制字符串，返回他们的和（用二进制表示）。\n\n输入为非空字符串且只包含数字 1 和 0。\n\n**示例 1:**\n\n```java\n输入：a = \"11\", b = \"1\"\n输出：\"100\"\n```\n\n**示例 2:**\n\n```java\n输入：a = \"1010\", b = \"1011\"\n输出：\"10101\"\n```\n\n**解法一**\n\n这题和下面的题目是我有意放在一起的，这题也可以作为大数相加的模板\n\n```java\npublic String addBinary(String a, String b) {\n    StringBuilder res=new StringBuilder(); \n    int idxA=a.length()-1;\n    int idxB=b.length()-1;\n    boolean carry=false;\n    //int carry=0;\n    while(idxA >=0 || idxB >=0){\n        char bina=idxA>=0?a.charAt(idxA):'0';\n        char binb=idxB>=0?b.charAt(idxB):'0';\n        if(bina == '1' && binb =='1'){\n            res.append(carry?1:0);\n            carry=true;\n        }else if((bina == '1' && binb =='0') ||(bina == '0' && binb =='1')){\n            res.append(carry?0:1);\n        }else{\n            res.append(carry?1:0);\n            carry=false;\n        }\n        idxA--;idxB--;\n    }\n    if(carry) res.append(1);\n    return res.reverse().toString();\n}\n```\n\n**解法二**\n\n上面的解法是完全的模拟解法，不够优雅\n```java\npublic String addBinary(String a, String b) {\n    StringBuilder res=new StringBuilder(); \n    int idxA=a.length()-1;\n    int idxB=b.length()-1;\n    int carry=0;\n    while(idxA >=0 || idxB >=0){\n        int sum=carry;\n        sum+=idxA>=0?a.charAt(idxA)-48:0;\n        sum+=idxB>=0?b.charAt(idxB)-48:0;\n        res.append(sum%2);\n        carry=sum/2;\n        idxA--;idxB--;\n    }\n    if(carry==1) res.append(1);\n    return res.reverse().toString();\n}\n```\n## [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)\n\n给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。\n\n**注意：**\n\n1. num1 和 num2 的长度都小于 5100.\n2. num1 和 num2 都只包含数字 0-9.\n3. num1 和 num2 都不包含任何前导零。\n4. 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。\n\n**解法一**\n\n一开始没找到这题，后面偶然发现的，随手写一下\n\n```java\npublic String addStrings(String num1, String num2) {\n    StringBuilder sb=new StringBuilder();\n    int m=num1.length()-1;\n    int n=num2.length()-1;\n    int carry=0;\n    while(n>=0 || m>=0){\n        int a= m>=0?num1.charAt(m)-48:0;\n        int b= n>=0?num2.charAt(n)-48:0;\n        int sum=a+b+carry;\n        carry=sum/10;\n        sb.append(sum%10);\n        m--;n--;\n    }\n    if (carry==1) {\n        sb.append(\"1\");\n    }\n    return sb.reverse().toString();\n}\n```\n\n## [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)\n\n给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n\n**示例 1:**\n\n```java\n输入：num1 = \"2\", num2 = \"3\"\n输出：\"6\"\n```\n\n**示例 2:**\n\n```java\n输入：num1 = \"123\", num2 = \"456\"\n输出：\"56088\"\n```\n\n**说明：**\n\n1. num1 和 num2 的长度小于 110。\n2. num1 和 num2 只包含数字 0-9。\n3. num1 和 num2 均不以零开头，除非是数字 0 本身。\n4. 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。\n\n**解法一**\n\n```java\npublic static String multiply2(String num1, String num2) {\n    // 1 2 3 \n    // 4 5 6\n    // 501 6\n    int n1=num1.length();\n    int n2=num2.length();\n    //n1*n2 结果最长为 n1+n2\n    int[] res=new int[n1+n2];\n    for (int i=n1-1;i>=0;i--) {\n        for (int j=n2-1;j>=0;j--) {\n            //主要就是对这个 i+j+1 的理解\n            res[i+j+1]+=(num1.charAt(i)-48)*(num2.charAt(j)-48);\n        }\n    }\n    //处理进位\n    for(int i=res.length-1;i>=0;i--) {\n        if(res[i]>=10){\n            res[i-1]+=res[i]/10;\n            res[i]%=10;\n        }\n    }\n    //去掉前面多余的 0\n    int index=0;\n    while (index<res.length-1&&res[index]==0) { \n        index++;\n    }\n    StringBuilder sb=new StringBuilder();\n    for (int i=index;i<res.length;i++) {\n        sb.append(res[i]);\n    }\n    return sb.toString();\n}\n```\n其实就是模拟的手算的过程，关键的地方就是 `i+j+1` 的理解\n\n![mark](http://static.imlgw.top/blog/20190928/4xnHi4yd4hwA.png?imageslim)\n\n**解法二**\n\n其实仔细分析，会发现上面的代码其实有很多多余的操作，比如去掉前面的 0，因为两个**非 0 的数相乘**，最后的结果最多 n1+n2 位，最少 n1+n2-1 位，所以前面的 0 **最多就一个**\n\n```java\npublic static String multiply(String num1, String num2) {\n    if (num1.equals(\"0\") || num2.equals(\"0\")) {\n        return \"0\";\n    }\n    int n1=num1.length();\n    int n2=num2.length();\n    int[] res=new int[n1+n2];\n    for (int i=n1-1;i>=0;i--) {\n        for (int j=n2-1;j>=0;j--) {\n            //注意这里的 i+j+1\n            res[i+j+1]+=(num1.charAt(i)-48)*(num2.charAt(j)-48);\n        }\n    }\n    //处理进位（其实这里 res[0] 是不可能大于 10 的），模拟下知道了\n    for(int i=res.length-1;i>=0;i--) {\n        if(res[i]>=10){\n            res[i-1]+=res[i]/10;\n            res[i]%=10;\n        }\n    }\n    StringBuilder sb=new StringBuilder();\n    for (int i=0;i<res.length;i++) {\n        //前面最多只有一个 0（除了两个数中有一个为 0 的时候）\n        if (i==0 && res[i]==0) continue;\n        sb.append(res[i]);\n    }\n    return sb.toString();\n}\n```\n**解法三**\n\n其实上面的进位和计算对应位置的值可以同时处理，这是最接近人手算的思路了\n\n```java\n//update: 2020.4.16 在 web 上重新推了一遍\n//idx : 0 1 2\n//i :   4 5 6\n//j :   1 2 3\n//   ——————————\n//    1 3 6 8 (i+j+1)\n//    9 1 2\n//  4 5 6\n//  ——————————\n//0 1 2 3 4 5\n//0 5 6 0 8 8  \npublic String multiply(String num1, String num2) {\n    if(num1==null || num2==null) return num1;\n    int n1=num1.length(),n2=num2.length();\n    int[] res=new int[n1+n2];\n    //如果想同时处理进位的话就必须倒推\n    for(int i=n1-1;i>=0;i--){\n        for(int j=n2-1;j>=0;j--){\n            int sum=res[i+j+1]+(num1.charAt(i)-48)*(num2.charAt(j)-48);\n            res[i+j+1]=sum%10;\n            //res[i+j] 会超过 10, 但是由于我们是倒推的，所以这个会在下一轮进行处理，否则就无法处理了\n            res[i+j]+=sum/10; \n        }\n    }   \n    //n*m 位数 乘积应该是 (m+n-1 ~ m+n) 位\n    //前两个为 0 一定是 0\n    if(res[0]==0 && res[1]==0) return \"0\";\n    //去除前导 0（最多一个）\n    StringBuilder sb=new StringBuilder();\n    for(int i=0;i<res.length;i++){\n        if(res[i]==0 && i==0)continue;\n        sb.append(res[i]);\n    }\n    return sb.toString();\n}\n```\n\n## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)\n\n请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。\n\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n\n**说明：**\n\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 `[−231,  231 − 1]`。如果数值超过这个范围，请返回  `INT_MAX (231 − 1)` 或 `INT_MIN (−231)` \n\n**示例 1:**\n\n```java\n输入：\"42\"\n输出：42\n```\n\n**示例 2:**\n\n```java\n输入：\"   -42\"\n输出：-42\n解释：第一个非空白字符为 '-', 它是一个负号。\n     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n```\n\n**示例 3:**\n\n```java\n输入：\"4193 with words\"\n输出：4193\n解释：转换截止于数字 '3' ，因为它的下一个字符不为数字。\n```\n\n**解法一**\n\n之前一直很排斥这道题，知道这次朋友阿里面试问了这道题。\n\n```java\npublic int myAtoi(String str) {\n    if(str==null || str.length()<=0) return 0;\n    int MAX=Integer.MAX_VALUE,MIN=Integer.MIN_VALUE;\n    int res=0,index=0;\n    //过滤空格\n    while(index<str.length()&&str.charAt(index)==' ')index++;\n    if(index==str.length()) return 0;\n    //取正负号\n    char firstChar=str.charAt(index);\n    boolean positive=true;\n    if(!isDigit(firstChar)){\n        if(firstChar!='+'&&firstChar!='-') return 0;\n        index++;\n        positive = firstChar!='-';\n    }\n    //正负数的边界\n    int limit=positive?-MAX:MIN;\n    //过滤 0\n    while(index<str.length()&&str.charAt(index)=='0')index++;\n    //取每一位，在非字符截止\n    while(index<str.length()&&isDigit(str.charAt(index))){\n        int digit=str.charAt(index++)-'0';\n        if(res<(limit+digit)/10){\n            return positive?MAX:MIN;\n        }\n        //这里的 res>=limit\n        res=res*10-digit;\n    }\n    //if(index!=str.length()) return 0; //中途遇到非数字（也是合法的）\n    return positive?-res:res;\n}\n\npublic boolean isDigit(char c){\n    return c>='0' && c<='9';\n}\n```\n\n参考了`Integer.parseInt(String s, int radix)`方法对边界的处理方式，**用负数来表示正负数的边界**\n\n1. 这样正数的边界就是`-INT_MAX`, 负数是`INT_MIN`\n\n2. 然后我们同样也用负数来保存结果，`res=res\\*10-digit`\n\n3. 我们需要保证这个值是在`INT`范围内的，也就是 res*10-digit>=limit （负边界）\n\n4. 所以我们需要对`res`做判断，但是直接判断可能会溢出，所以进行移项，变换为 `res<(limit+digit)/10`\n\n5. 最后如果是正数就返回 `-res`, 负数就返回`res`\n\n还是十分巧妙的 👏👏\n\n## [1071. 字符串的最大公因子](https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/)\n\n对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。\n\n返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。\n\n**示例 1：**\n\n```java\n输入：str1 = \"ABCABC\", str2 = \"ABC\"\n输出：\"ABC\"\n```\n\n**示例 2：**\n\n```java\n输入：str1 = \"ABABAB\", str2 = \"ABAB\"\n输出：\"AB\"\n```\n\n**示例 3：**\n\n```java\n输入：str1 = \"LEET\", str2 = \"CODE\"\n输出：\"\"\n```\n\n**解法一**\n\n首先想到的方法，其实也是根据辗转相除法来的（这种好像叫更相减损术 ?）\n\n```java\n//6 4 gcd(6,4)=gcd(4,2)=gcd(2,0) return 2\npublic String gcdOfStrings(String str1, String str2) {\n    if(str1.equals(str2)){\n        return str1;\n    }\n    int index1=0,index2=0;\n    //用减法替代除法求余数\n    while(str1.length()>=str2.length() && index1<str1.length() && index2<str2.length()){\n        if(str1.charAt(index1)!=str2.charAt(index2)) return \"\";\n        index2++;\n        index1++;\n    }\n    //gcd(str2, 余数）\n    return gcdOfStrings(str2,str1.substring(index1,str1.length()));\n}\n```\n**解法二**\n\n数学方法，比较巧妙\n\n```java\npublic String gcdOfStrings(String str1, String str2) {\n    if(!(str1+str2).equals(str2+str1)){\n        return \"\";\n    }\n    return str1.substring(gcd(str1.length(),str2.length()));\n}\n\npublic int gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n```\n第一个条件充分性的证明还是有点不太理解，不过后面的最大公因子的长度就是 str1 和 str2 长度倒是可以通过反证来证明出来，这里直接 copy 题解 [大佬](https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/tan-tan-zheng-ming-wei-shi-yao-liang-zi-fu-chuan-c/) 的证明\n\n假设两字符串的长度分别为 l1, l2, 他们的最大公约数是 k。\n现已知道两字符串存在最大公因子（第一行代码），假设该字串的长度为`k'`。\n\n下面开始反证，\n若`k' < k`，而根据题意`k'`也为`l1, l2` 的公约数，则`k'`必能被`k`整除，这说明我们可以将该字串的长度扩充到`k`，同时保持它仍然为`str1`和`str2`的公因子，所以这种情况下这个长度为`k`的公因子就不是最大公因子。\n若`k' > k`， 根据题意`k'`为`l1`, `l2` 的公约数， 而 k 为最大公约数，而这时出现了一个比最大公约数还大的公约数，这是矛盾的，所以这种情况也是不可能的。\n\n综合以上，最大公因子的长度必然等于两串长度的最大公约数。\n\n## [914. 卡牌分组](https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/)\n\n给定一副牌，每张牌上都写着一个整数。\n\n此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n\n- 每组都有 X 张牌。\n- 组内所有的牌上都写着相同的整数。\n\n仅当你可选的 X >= 2 时返回 true。\n\n**示例 1：**\n\n```java\n输入：[1,2,3,4,4,3,2,1]\n输出：true\n解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\n```\n\n**示例 2：**\n\n```java\n输入：[1,1,1,2,2,2,3,3]\n输出：false\n解释：没有满足要求的分组。\n```\n\n**示例 3：**\n\n```java\n输入：[1]\n输出：false\n解释：没有满足要求的分组。\n```\n\n**示例 4：**\n\n```java\n输入：[1,1]\n输出：true\n解释：可行的分组是 [1,1]\n```\n\n**示例 5：**\n\n```java\n输入：[1,1,2,2,2,2]\n输出：true\n解释：可行的分组是 [1,1]，[2,2]，[2,2]\n```\n\n**提示：**\n\n- `1 <= deck.length <= 10000`\n- `0 <= deck[i] < 10000`\n\n**解法一**\n\n```java\npublic boolean hasGroupsSizeX(int[] deck) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for(int i=0;i<deck.length;i++){\n        map.put(deck[i],map.getOrDefault(deck[i],0)+1);\n    }\n    int g=-1;\n    for (Integer key:map.keySet()) {\n        int freq=map.get(key);\n        if(g==-1) {\n            g=freq;\n        }else{\n            if(freq<2) return false;\n            g=gcd(freq,g);\n        }\n    }\n    return g>=2;\n}\n\npublic int gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n```\nwa 一次就知道咋做了，一开始以为只要所有元素出现次数可以整除就行了，wa 了之后就意识到只要求一个最大公约数就可以了\n\n**解法二**\n\n给定了范围，直接用数组模拟\n\n```java\npublic int gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n\npublic boolean hasGroupsSizeX2(int[] deck) {\n    int[] hash=new int[10001];\n    for(int i=0;i<deck.length;i++){\n        hash[deck[i]]++;\n    }\n    int g=-1;\n    for (int i=0;i<hash.length-1;i++) {\n        if(hash[i]!=0){\n            if(hash[i]<2) return false;\n            g= g!=-1?gcd(g,hash[i]):hash[i];\n            if(g==1) return false; //优化，提前终止\n        }\n    }\n    return g>=2;\n}\n```\n## [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)\n\n比较两个版本号 version1 和 version2。\n如果 `version1 > version2` 返回 1，如果 `version1 < version2` 返回 -1， 除此之外返回 0。\n\n你可以假设版本字符串非空，并且只包含数字和 . 字符。\n\n . 字符不代表小数点，而是用于分隔数字序列。\n\n例如，`2.5`  不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。\n\n你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。\n\n**示例 1:**\n\n```java\n输入：version1 = \"0.1\", version2 = \"1.1\"\n输出：-1\n```\n\n**示例 2:**\n\n```java\n输入：version1 = \"1.0.1\", version2 = \"1\"\n输出：1\n```\n\n**示例 3:**\n\n```java\n输入：version1 = \"7.5.2.4\", version2 = \"7.5.3\"\n输出：-1\n```\n\n**示例 4：**\n\n```java\n输入：version1 = \"1.01\", version2 = \"1.001\"\n输出：0\n解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。\n```\n\n**示例 5：**\n\n```java\n输入：version1 = \"1.0\", version2 = \"1.0.0\"\n输出：0\n解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。\n```\n\n**提示：**\n\n1. 版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。\n2. 版本字符串不以点开始或结束，并且其中不会有两个连续的点。\n\n**解法一**\n\n貌似笔试喜欢出这题，挺简单的，用 java 分割的时候要注意 `\".\"` 是一个正则表达式，匹配任意单个字符，我们如果要将它看作一个普通字符需要加上双斜线`\"\\\\.\"`\n\n```java\npublic int compareVersion(String version1, String version2) {\n    String[] v1=version1.split(\"\\\\.\");\n    String[] v2=version2.split(\"\\\\.\");\n    int len1=v1.length,len2=v2.length;\n    int i=0,j=0;\n    while(i<len1 || j<len2) {\n        int a=Integer.valueOf(i<len1?v1[i++]:\"0\");\n        int b=Integer.valueOf(j<len2?v2[j++]:\"0\");\n        if (a<b) {\n            return -1;\n        }else if (a>b){\n            return 1;\n        }\n    }\n    return 0;\n}\n```\n\n## [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 `\"LEETCODEISHIRING\"` 行数为 3 时，排列如下：\n\n```java\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n```java\nstring convert(string s, int numRows);\n```\n\n**示例 1:**\n\n```java\n输入：s = \"LEETCODEISHIRING\", numRows = 3\n输出：\"LCIRETOESIIGEDHN\"\n```\n\n**示例 2:**\n\n```java\n输入：s = \"LEETCODEISHIRING\", numRows = 4\n输出：\"LDREOEIIECIHNTSG\"\n解释：\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n```\n\n**解法一**\n\n比较脑残，但是勉强还是过了\n\n```java\npublic String convert(String s, int numRows) {\n    if (s==null || s.length()<=0 || numRows==1) {\n        return s;\n    }\n    int len=s.length();\n    //足够的空间\n    int[][] strs=new int[((len/((numRows-1)*2))+1)*(numRows-1)][numRows];\n    int index=0,x=0,y=0;\n    boolean flag=false;\n    while(index < s.length()) {\n        if (!flag) {\n            strs[x][y++]=s.charAt(index++);\n            if (y==numRows-1) {\n                flag=true;\n            }\n        }else{\n            strs[x++][y--]=s.charAt(index++);\n            if (y==0) {\n                flag=false;\n            }\n        }\n    }\n    StringBuilder sb=new StringBuilder();\n    for (int j=0;j<strs[0].length;j++) {\n        for (int i=0;i<strs.length;i++) {\n            if (strs[i][j]!=0) {\n                sb.append((char)strs[i][j]);\n            }\n        }\n    }\n    return sb.toString();\n}\n```\n\n就是将字符按照之字形填入一个二维数组中，然后按规则取出来就 ok，最优解看了，明天再来写！\n\n**解法二**\n\n今天还是不够清晰，后天再写\n\n## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`\"ace\"`是`\"abcde\"`的一个子序列，而`\"aec\"`不是）。\n\n**示例 1:**\n\n```java\ns = \"abc\", t = \"ahbgdc\"\n返回 true.\n```\n\n**示例 2:**\n\n```java\ns = \"axc\", t = \"ahbgdc\"\n返回 false.\n```\n\n**后续挑战 :**\n\n如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n**解法一**\n\n```java\npublic boolean isSubsequence(String s, String t) {\n    if (s==null || t==null) {\n        return false;\n    }\n    int sindex=0,tindex=0;\n    while(sindex<s.length()) {\n        while(tindex<t.length() && sindex<s.length()){\n            if (s.charAt(sindex)==t.charAt(tindex)) {\n                sindex++;\n            }\n            tindex++;\n        }\n        if (tindex==t.length()) {\n            break; \n        }\n    }\n    return sindex==s.length();\n}\n```\n可以改成递归（多练习递归）\n\n```java\npublic boolean isSubsequence(String s,String t){\n    return subsequence(s,t,0,0);\n}\n\npublic boolean subsequence(String s,String t,int sindex,int tindex){\n    if (sindex == s.length()) {\n        return true;\n    }\n    //上下 if 不能交换，可能最后一个才相等\n    if (tindex == t.length()) {\n        return false;\n    }\n    return s.charAt(sindex)==t.charAt(tindex)?subsequence(s,t,sindex+1,tindex+1):subsequence(s,t,sindex,tindex+1);\n}\n```\n**解法二**\n\n```java\n//大量的 s 字符串 处理\npublic boolean isSubsequence3(String s, String t) {\n    //预处理\n    ArrayList<ArrayList<Integer>> hash=new ArrayList<>();\n    for (int i=0;i<26;i++) {\n        hash.add(new ArrayList());\n    }\n    for (int i=0;i<t.length();i++) {\n        hash.get(t.charAt(i)-'a').add(i);\n    }\n    //经过上面的预处理，后面的处理就会很快，不用再遍历 t 字符串\n    int lastIndex=-1;\n    for (int i=0;i<s.length();i++) {\n        List<Integer> indexList=hash.get(s.charAt(i)-'a');\n        int temp=binarySearch(indexList,lastIndex);\n        if (temp==indexList.size()) {\n            return false;\n        }\n        lastIndex=indexList.get(temp);\n    }\n    return true;\n}\n\n//找到第一个比 target 大的元素\npublic int binarySearch(List<Integer> list,int target){\n    int left=0,right=list.size()-1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if (list.get(mid)>target) {\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return left;\n}\n```\n\n## [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)\n\n给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n\n**示例 1:**\n\n```java\n输入：[1,2,3,4,5,6,7] 和 k = 3\n输出：[5,6,7,1,2,3,4]\n解释：\n向右旋转 1 步：[7,1,2,3,4,5,6]\n向右旋转 2 步：[6,7,1,2,3,4,5]\n向右旋转 3 步：[5,6,7,1,2,3,4]\n```\n\n**示例 2:**\n\n```java\n输入：[-1,-100,3,99] 和 k = 2\n输出：[3,99,-1,-100]\n解释：\n向右旋转 1 步：[99,-1,-100,3]\n向右旋转 2 步：[3,99,-1,-100]\n```\n\n**说明：**\n\n- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n- 要求使用空间复杂度为 O(1) 的 **原地** 算法 \n\n**解法一**\n\n常规解法，每次保留数组最后一个元素，从后往前将每个元素赋值为前一个元素的值，这样就相当于将数组整体向后循环移动一次，循环移动 k 次就是最后的结果\n\n```java\npublic void rotate(int[] nums, int k) {\n    if(nums==null||nums.length<=1||k==0){\n        return;\n    }\n    int len=nums.length;\n    k=k%len;\n    for (int i=0;i<k;i++) {\n        int temp=nums[len-1];\n        for (int j=len-1;j>=0;j--) {\n            nums[j]=nums[j-1];\n        }\n        nums[0]=temp;\n    }\n}\n```\n时间复杂度较高，`O(NK)` Java 可以过，但是 C/C++可能过不了\n\n**解法二**\n\n这个做法就相当巧妙了，三次翻转🐂🍺\n\n```java\n//翻转的方法\npublic void rotate(int[] nums, int k) {\n    if(nums==null||nums.length<=1||k==0){\n        return;\n    }\n    int len=nums.length;\n    k=k%len;\n    if(k==0)return;\n    reverse(nums,0,len-k-1);\n    reverse(nums,len-k,len-1);\n    reverse(nums,0,nums.length-1);\n}\n\npublic void reverse(int []nums,int left,int right){\n    while(left<right){\n        swap(nums,left++,right--);\n    }\n}\n\npublic void swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n`O(N)` 应该是最优解了\n\n## [1232. 缀点成线](https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/)\n\n在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。\n\n请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 `true`，否则请返回  `false`\n\n**解法一**\n\n10.20 竞赛第一题，判断给定的点是不是再一条直线上，判断和前两个点是不是在一条直线上，注意不要直接除算斜率，那样是不准确的\n\n```java\npublic boolean checkStraightLine(int[][] coordinates) {\n    for (int i=2;i<coordinates.length;i++) {\n        if((coordinates[i][1]-coordinates[i-1][1])*(coordinates[i-1][0]-coordinates[i-2][0])!=\n           (coordinates[i][0]-coordinates[i-1][0])*(coordinates[i-1][1]-coordinates[i-2][1])){\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## [1233. 删除子文件夹](https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/)\n\n你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。\n\n我们这样定义「子文件夹」：\n\n- 如果文件夹 `folder[i]` 位于另一个文件夹 `folder[j]` 下，那么 `folder[i]` 就是 `folder[j]` 的子文件夹。\n  文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：\n\n- `/` 后跟一个或者多个小写英文字母。\n  例如，`/leetcode` 和 `/leetcode/problems` 都是有效的路径，而空字符串和 `/` 不是。\n\n **示例 1：**\n\n```java\n输入：folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n输出：[\"/a\",\"/c/d\",\"/c/f\"]\n解释：\"/a/b/\" 是 \"/a\" 的子文件夹，而 \"/c/d/e\" 是 \"/c/d\" 的子文件夹。\n```\n\n**示例 2：**\n\n```java\n输入：folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"]\n输出：[\"/a\"]\n解释：文件夹 \"/a/b/c\" 和 \"/a/b/d/\" 都会被删除，因为它们都是 \"/a\" 的子文件夹。\n```\n\n**示例 3：**\n\n```java\n输入：folder = [\"/a/b/c\",\"/a/b/d\",\"/a/b/ca\"]\n输出：[\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\n```\n\n**提示：**\n\n- 1 <= folder.length <= 4 * 10^4\n- 2 <= folder[i].length <= 100\n- folder[i] 只包含小写字母和 /\n- folder[i] 总是以字符 / 起始\n- 每个文件夹名都是唯一的\n\n**解法一**\n\n`2019.10.20`的竞赛题，当时没做出来。一直超时，太菜了\n\n```java\npublic List<String> removeSubfolders(String[] folder) {\n    Arrays.sort(folder);\n    List<String> res=new LinkedList<>();\n    int root=0;\n    res.add(folder[0]);\n    for (int i=1;i<folder.length;i++) {\n        if (!folder[i].startsWith(folder[root]+\"/\")) {\n            res.add(folder[i]);\n            root=i;\n        }\n    }\n    return res;\n}\n```\n当时我想到了排序，但是并没处理好，排序之后还是傻傻的一个个去对比，其实排序后就很清楚了\n\n`folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]` 题目其实也在暗示我们要排序，给的 case 都是排好序的\n\n当然这里很精髓的一步就是在对比的时候在 `folder[root]` 后面加上一个 `\"/\"` ，这样就不会将 `a/b/c` 判断为 `a/b/ca` 的根目录了~\n\n## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n**示例 1：**\n\n```java\n输入：\"babad\"\n输出：\"bab\"\n注意：\"aba\" 也是一个有效答案。\n```\n\n**示例 2：**\n\n```java\n输入：\"cbbd\"\n输出：\"bb\"\n```\n\n**解法一**\n\n是面试经常考的一题，还是挺有意思的，除了这个还有几道回文的题我放在动态规划专题中\n\n```java\npublic String longestPalindrome(String s) {\n    if (s==null || s.length()<=0) {\n        return \"\";\n    }\n    String res=s.charAt(0)+\"\";//只有 1 个字符\n    for (int i=1;i<s.length();i++) {\n        String even=palindrome(s,i-1,i); //偶数长度回文，从两个字符中间开始扩散\n        String odd=palindrome(s,i,i); //奇数长度回文，从某一个字符开始扩散\n        String temp=odd.length()>even.length()?odd:even;\n        if (temp.length()>res.length()) {\n            res=temp;\n        }\n    }\n    return res;\n}\n\npublic String palindrome(String s,int i,int j){\n    while(i>=0 && j<=s.length()-1 && s.charAt(i)==s.charAt(j)){\n        i--;\n        j++;\n    }\n    return s.substring(i+1,j);\n}\n```\n如果采用暴力法的话就是枚举所有子串，判断是不是回文串，最后求个最长的，时间复杂度`O(N^3)` ，但是我们可以利用回文的特征，利用中心扩散法，以`str`的**各个位置**作为中心，向两边扩散，最后求得最大值，注意得这里说的是**各个位置**，这个里面其实就包含了元素之间的间隙，其实整体思路还是挺简单的，但经过我们小小的转换思路，时间复杂度就降低到了`O(N^2)`，当然，这里还不是最优解，最优应该是 [Manacher](https://oi-wiki.org/string/manacher/) （马拉车）算法，等后面有时间我再来研究这种算法\n\n## [336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)\n\nDifficulty: **困难**\n\n给定一组 **互不相同** 的单词， 找出所有**不同**的索引对`(i, j)`，使得列表中的两个单词， `words[i] + words[j]` ，可拼接成回文串。\n\n**示例 1：**\n\n```go\n输入：[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n输出：[[0,1],[1,0],[3,2],[2,4]] \n解释：可拼接成的回文串为 [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"]\n```\n\n**示例 2：**\n\n```go\n输入：[\"bat\",\"tab\",\"cat\"]\n输出：[[0,1],[1,0]] \n解释：可拼接成的回文串为 [\"battab\",\"tabbat\"]\n```\n\n**解法一**\n\n枚举单词的所有前缀 or 后缀，如果除了前缀 or 后缀剩余部分是回文串，并且在 dict 中存在前缀 or 后缀的翻转，那么这两个单词就能构成回文对\n```golang\nfunc palindromePairs(words []string) [][]int {\n    var dict = make(map[string]int)\n    for i := 0; i < len(words); i++ {\n        dict[reverse(words[i])] = i\n    }\n    var res [][]int\n    for i := 0; i < len(words); i++ {\n        for j := 0; j <= len(words[i]); j++ {\n            if idx, ok := dict[words[i][:j]]; ok && idx != i && isPalindrome(words[i][j:]) {\n                res = append(res, []int{i, idx})\n            }\n            //这里需要判断下 j!=0，避免重复的判断，s[0:] == s[:len(s)]\n            if idx, ok := dict[words[i][j:]]; j != 0 && ok && idx != i && isPalindrome(words[i][:j]) {\n                res = append(res, []int{idx, i})\n            }\n        }\n    }\n    return res\n}\n\nfunc reverse(s string) string {\n    var bs = []byte(s)\n    for i, j := 0, len(bs)-1; i < j; i, j = i+1, j-1 {\n        bs[i], bs[j] = bs[j], bs[i]\n    }\n    return string(bs)\n}\n\nfunc isPalindrome(s string) bool {\n    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n        if s[i] != s[j] {\n            return false\n        }\n    }\n    return true\n}\n```\n属于比较暴力的解法，这题也可以使用马拉车&字典树，这里我就不多写了\n## [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)\n\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n\n在构造过程中，请注意区分大小写。比如 `\"Aa\"` 不能当做一个回文字符串。\n\n**注意：**\n假设字符串的长度不会超过 1010。\n\n**示例 1:**\n\n```java\n输入：\n\"abccccdd\"\n\n输出：\n7\n\n解释：\n我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。\n```\n\n**解法一**\n\n和上面的题目名字一样，但是请注意审题！！！\n\n```java\npublic int longestPalindrome(String s) {\n    if(s==null || s.length()<=0) return 0;\n    int[] hash=new int[128];\n    for(int i=0;i<s.length();i++){\n        hash[s.charAt(i)]++;\n    }\n    //Arrays.sort(hash);\n    int res=0;boolean flag=false;\n    for(int i=hash.length-1;i>=0;i--){\n        if(hash[i]!=0){\n            if(hash[i]%2==0){\n                res+=hash[i]; //偶数直接加\n            }else{\n                flag=true;\n                res+=(hash[i]-1); //奇数减一再加\n            }\n        }\n    }\n    return flag?res+1:res;\n}\n```\n\n## [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)\n\n给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。\n\n**示例 1:**\n\n```java\n输入：\"aba\"\n输出：True\n```\n\n**示例 2:**\n\n```java\n输入：\"abca\"\n输出：True\n解释：你可以删除 c 字符。\n```\n\n**注意：**\n\n1. 字符串只包含从 a-z 的小写字母。字符串的最大长度是 50000。\n\n**解法一**\n\n模拟就行了\n\n```java\npublic boolean validPalindrome(String s) {\n    if(s==null || s.length()<=0) return true;\n    int left=0,right=s.length()-1;\n    while(left<right){\n        if(s.charAt(left)==s.charAt(right)){\n            left++;right--;\n        }else{\n            return valid(s,left+1,right) || valid(s,left,right-1);\n        }\n    }\n    return true;\n}\n\npublic boolean valid(String s,int left,int right){\n    while(left<=right){\n        if(s.charAt(left)==s.charAt(right)){\n            left++;right--;\n        }else{\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## [1332. 删除回文子序列](https://leetcode-cn.com/problems/remove-palindromic-subsequences/)\n\n给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 **子序列**。\n\n返回删除给定字符串中所有字符（字符串为空）的最小删除次数。\n\n「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。\n\n「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 \n\n**示例 1：**\n\n```java\n输入：s = \"ababa\"\n输出：1\n解释：字符串本身就是回文序列，只需要删除一次。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"abb\"\n输出：2\n解释：\"abb\" -> \"bb\" -> \"\". \n先删除回文子序列 \"a\"，然后再删除 \"bb\"。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"baabb\"\n输出：2\n解释：\"baabb\" -> \"b\" -> \"\". \n先删除回文子序列 \"baab\"，然后再删除 \"b\"。\n```\n\n**示例 4：**\n\n```java\n输入：s = \"\"\n输出：0\n```\n\n**提示：**\n\n- `0 <= s.length <= 1000`\n- `s` 仅包含字母 'a'  和 'b'\n\n**解法一**\n\n某一次周赛的第一题，乍一看最长回文子串？最长回文序列？这题当时还是难到了不少人，我那次没参加，后台听说了第一题是个坑，然后这里审题的时候就很注意，没踩坑😁\n\n```java\npublic int removePalindromeSub(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    for(int i=0,j=s.length()-1;i<=j;i++,j--){\n        if (s.charAt(i)!=s.charAt(j)) {\n            return 2;\n        }\n    }\n    return 1;\n}\n```\n\n题目说了只有两个字母 a 和 b，而且要删除的是**回文子序列**，这样一说就清楚了，这才是简单题的水准呐~还是挺有意思的，脑筋急转弯 hahaha\n\n## [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)\n\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n注意：\n\n- 可以认为区间的终点总是大于它的起点。\n- 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n**示例 1:**\n\n```java\n输入：[ [1,2], [2,3], [3,4], [1,3] ]\n\n输出：1\n\n解释：移除 [1,3] 后，剩下的区间没有重叠。\n```\n\n**示例 2:**\n\n```java\n输入：[ [1,2], [1,2], [1,2] ]\n\n输出：2\n\n解释：你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n```\n\n**示例 3:**\n\n```java\n输入：[ [1,2], [2,3] ]\n\n输出：0\n\n解释：你不需要移除任何区间，因为它们已经是无重叠的了。\n```\n\n**解法一**\n\n动态规划，其实和最长递增子序列是一样的\n\n```java\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals==null || intervals.length<=0) {\n        return 0;\n    }\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    int[]dp=new int[intervals.length];\n    int max=-1;\n    for (int i=0;i<intervals.length;i++) {\n        dp[i]=1;\n        for (int j=0;j<i;j++) {\n            if(intervals[i][0]>=intervals[j][1]){\n                dp[i]=Math.max(dp[j]+1,dp[i]);\n            }\n        }\n        max=Math.max(max,dp[i]);\n    }\n    return intervals.length-max;\n}\n```\n171ms，8%，感觉快要过不了了。本来是是写的记忆化递归的，结果过不了。卡在倒数第二个 case 上\n\n```java\nHashMap<Pair,Integer> cache=new HashMap<>();//TLE\n\npublic int eraseOverlapIntervals2(int[][] intervals) {\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    return intervals.length-dfs(intervals,0,Integer.MIN_VALUE);\n}\n\n//背包问题，返回最多可以留下的区间\npublic int dfs(int[][] intervals,int index,int prev) {\n    if (index==intervals.length) {\n        return 0;\n    }\n    Pair key=new Pair(index,prev);\n    if (cache.containsKey(key)) {\n        return cache.get(key);\n    }\n    int res=dfs(intervals,index+1,prev);\n    if (intervals[index][0]>=prev) {\n        res=Math.max(res,dfs(intervals,index+1,intervals[index][1])+1);\n    }\n    cache.put(key,res);\n    return res;\n}\n```\n**解法二**\n\n贪心，时间复杂度降低为线性\n\n```java\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals==null || intervals.length<=0) {\n        return 0;\n    }\n    //按照起点排序，重叠的时候选择保留结尾小的那一个\n    //Arrays.sort(intervals,(a,b)->a[0]-b[0]); lambda 初始化效率会低一点\n    Arrays.sort(intervals,new Comparator<int[]>(){\n        @Override\n        public int compare(int[] a,int[] b){\n            return a[0]-b[0];\n        }\n    });\n    int res=1;\n    int prev=0;\n    for (int i=1;i<intervals.length;i++) {\n        if (intervals[i][0]>=intervals[prev][1]) {\n            res++;\n            prev=i;\n        }else if(intervals[i][1]<intervals[prev][1]){\n            prev=i; //选择结尾小的那一个\n        }\n    }\n    return intervals.length-res;\n}\n```\n按照起点排序，在重叠的时候优先选择结尾小的哪一个，这样就可能得到更多的区间组合，关于这个算法的正确性我就不证明了\n\n## [263. 丑数](https://leetcode-cn.com/problems/ugly-number/)\n\n编写一个程序判断给定的数是否为丑数。\n\n丑数就是只包含质因数 2, 3, 5 的正整数。\n\n**示例 1:**\n\n```java\n输入：6\n输出：true\n解释：6 = 2 × 3\n```\n\n**示例 2:**\n\n```java\n输入：8\n输出：true\n解释：8 = 2 × 2 × 2\n```\n\n**示例 3:**\n\n```java\n输入：14\n输出：false \n解释：14 不是丑数，因为它包含了另外一个质因数 7。\n```\n\n**说明：**\n\n1. `1` 是丑数。\n2. 输入不会超过 `32` 位有符号整数的范围：`[−231,  231 − 1]`。\n\n**解法一**\n\n直接暴力，还是比较简单\n\n```java\npublic boolean isUgly(int num) {\n    if (num<=0) {\n        return false;\n    }\n    if(num==1) {\n        return true;\n    }\n    return num%2==0?isUgly(num/2):false || num%3==0?isUgly(num/3):false || num%5==0?isUgly(num/5):false;\n}\n```\n\n## [1333. 餐厅过滤器](https://leetcode-cn.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/)\n\n给你一个餐馆信息数组 `restaurants`，其中  `restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]`。你必须使用以下三个过滤器来过滤这些餐馆信息。\n\n其中素食者友好过滤器 `veganFriendly` 的值可以为 `true` 或者 `false`，如果为 `true` 就意味着你应该只包括 `veganFriendlyi` 为 `true` 的餐馆，为 `false` 则意味着可以包括任何餐馆。此外，我们还有最大价格 `maxPrice` 和最大距离 `maxDistance` 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。\n\n过滤后返回餐馆的 `id`，按照 `rating` 从高到低排序。如果 `rating` 相同，那么按 `id` 从高到低排序。简单起见， `veganFriendlyi` 和 `veganFriendly` 为 `true` 时取值为 1，为 `false` 时，取值为 0 。\n\n**示例一**\n\n```java\n输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\n输出：[3,1,5] \n解释： \n这些餐馆为：\n餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\n餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\n餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\n餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\n餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \n在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance = 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。 \n```\n\n**示例 2：**\n\n```java\n输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\n输出：[4,3,2,1,5]\n解释：餐馆与示例 1 相同，但在 veganFriendly = 0 的过滤条件下，应该考虑所有餐馆。\n```\n\n**示例 3：**\n\n```java\n输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\n输出：[4,5]\n```\n\n**提示：**\n\n- `1 <= restaurants.length <= 10^4`\n- `restaurants[i].length == 5`\n- `1 <= idi, ratingi, pricei, distancei <= 10^5`\n- `1 <= maxPrice, maxDistance <= 10^5`\n- `veganFriendlyi` 和 `veganFriendly` 的值为 0 或 1 。\n- 所有 `idi` 各不相同。\n\n**解法一**\n\n看到这个题，javaer 不用 stream 可太可惜了 hahaha\n\n```java\npublic List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n    return Stream.of(restaurants)\n        .filter(r-> (veganFriendly==1?r[2]==veganFriendly:true) && r[4]<=maxDistance && r[3]<=maxPrice)\n        .sorted((r1,r2)->r1[1]!=r2[1]?r2[1]-r1[1]:r2[0]-r1[0])\n        .map(r->r[0])\n        .collect(Collectors.toList());\n}\n```\n\n## [5313. 时钟指针的夹角](https://leetcode-cn.com/problems/angle-between-hands-of-a-clock/)\n\n给你两个数 `hour` 和 `minutes` 。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60 单位制）。\n\n这题就懒得 copy 了，19 场双周赛的第三题，不应该是 mid 题的。\n\n**解法一**\n\n```java\npublic double angleClock(int hour, int minutes) {\n    double m=minutes/60.0 * 360;\n    double h=((hour/12.0)*360)%360 + 30*minutes/60.0;\n    return Math.min(Math.abs(m-h),360-Math.abs(m-h));\n}\n```\n\n化简一下是 **h 时 m 分的夹角为：5.5m-30h**\n\n## [5169. 日期之间隔几天](https://leetcode-cn.com/problems/number-of-days-between-two-dates/)\n\n请你编写一个程序来计算两个日期之间隔了多少天。\n\n日期以字符串形式给出，格式为 `YYYY-MM-DD`。\n\n**解法一**\n\n177 周赛的 T1\n\n```java\nimport java.time.*;\nimport java.time.temporal.ChronoUnit;\nclass Solution {\n    public int daysBetweenDates(String date1, String date2) {\n        return (int)Math.abs(LocalDate.parse(date1).until(LocalDate.parse(date2),ChronoUnit.DAYS));\n    }\n}\n```\n\n做 LeetCode 少数导包了的题🤣\n\n**解法二**\n\ncopy 大佬的原生解法\n\n```java\n\nprivate int[] months = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\npublic int daysBetweenDates(String date1, String date2) {\n    String[] d1 = date1.split(\"-\");\n    String[] d2 = date2.split(\"-\");\n    int day1 = getYears(Integer.valueOf(d1[0]) - 1) + getMonths(Integer.valueOf(d1[0]), Integer.valueOf(d1[1]) - 1) + Integer.valueOf(d1[2]);\n    int day2 = getYears(Integer.valueOf(d2[0]) - 1) + getMonths(Integer.valueOf(d2[0]), Integer.valueOf(d2[1]) - 1) + Integer.valueOf(d2[2]);\n    return Math.abs(day1 - day2);\n}\n\nprivate int getYears(int year) {\n    int sum = (year - 1971) * 365;\n    for (int i = 1971; i <= year; ++i) {\n        if (isRun(i)) {\n            ++sum;\n        }\n    }\n    return sum;\n}\n\nprivate int getMonths(int year, int month) {\n    int sum = 0;\n    for (int i = 1; i <= month; ++i) {\n        sum += months[i];\n    }\n    if (isRun(year) && month >= 2) {\n        ++sum;\n    }\n    return sum;\n}\n\nprivate boolean isRun(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n```\n\n## [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)\n\n给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。\n\n**示例 1:**\n\n```java\n输入：\"Let's take LeetCode contest\"\n输出：\"s'teL ekat edoCteeL tsetnoc\" \n```\n\n**注意：**在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格\n\n**解法一**\n\n原生的做法\n\n```java\npublic String reverseWords(String s) {\n    s+=\" \";//统一操作\n    char[] cs=s.toCharArray();\n    int start=0;\n    for (int i=0;i<cs.length;i++) {\n        if (cs[i]==' ') {\n            reverse(cs,start,i-1);\n            start=i+1;\n        }\n    }\n    return new String(cs,0,cs.length-1);\n}\n\npublic void reverse(char[] s,int left,int right){\n    for (int i=left,j=right;i<j;i++,j--) {\n        char temp=s[i];\n        s[i]=s[j];\n        s[j]=temp;\n    }\n}\n```\n\n## [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)\n\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n**示例 1：**\n\n```java\n输入：\"the sky is blue\"\n输出：\"blue is sky the\"\n```\n\n**示例 2：**\n\n```java\n输入：\"  hello world!  \"\n输出：\"world! hello\"\n解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n```\n\n**示例 3：**\n\n```java\n输入：\"a good   example\"\n输出：\"example good a\"\n解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n```\n\n**说明：**\n\n- 无空格字符构成一个单词。\n- 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n- 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n**进阶：**\n\n请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。\n\n**解法一**\n\n```java\npublic String reverseWords(String s) {\n    if(s==null || s.length()<=0) return \"\";\n    Deque<String> stack=new ArrayDeque<>();\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)==' '){\n            continue;\n        }\n        int j=i;\n        while(i<s.length() && s.charAt(i)!=' '){\n            i++;\n        }\n        stack.push(s.substring(j,i));\n    }\n    if(stack.isEmpty()) return \"\";\n    StringBuilder sb=new StringBuilder();\n    sb.append(stack.pop());\n    while(!stack.isEmpty()){\n        sb.append(\" \"+stack.pop());\n    }\n    return sb.toString();\n}\n```\n比较原生的做法，最开始写的借助 split 等方法的，比较简单就不多说了\n\n**解法二**\n\n原地的做法，比较繁琐，后面有时间再来实现下\n\n1. 翻转整个字符\n2. 翻转单个字符\n3. 去除多余空格\n\n## [面试题 01.06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)\n\n字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串 aabcccccaaa 会变为 a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a 至 z）。\n\ncase 就不粘了\n\n**解法一**\n\n直接写就行了\n\n```java\npublic String compressString(String S) {\n    StringBuilder sb=new StringBuilder();\n    int index=0;\n    while(index<S.length()){\n        sb.append(S.charAt(index));\n        int r=1;\n        while(index<S.length()-1&&S.charAt(index)==S.charAt(index+1)){\n            ++index;\n            r++;\n        }\n        sb.append(r);\n        index++;\n    }\n    return sb.length()<S.length()?sb.toString():S;\n}\n```\n## [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)\n\n给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n**示例：**\n\n```java\n输入：[1,2,3,4]\n输出：[24,12,8,6]\n说明：请不要使用除法，且在 O(n) 时间复杂度内完成此题。\n```\n\n**进阶：**\n你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）\n\n**解法一**\n\n还行，独立的想到了解法，没啥好说的\n\n```java\npublic int[] productExceptSelf(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return new int[0];\n    }\n    int[] left=new int[nums.length+1]; \n    left[0]=1;//left[i]: [0 ~ i-1] 的累积\n    int[] right=new int[nums.length+1];\n    right[nums.length]=1; //right[i]: [i ~ nums.length-1] 的累积\n    for (int i=1;i<=nums.length;i++) {\n        left[i]=left[i-1]*nums[i-1];\n    }\n    for (int i=nums.length-1;i>=0;i--) {\n        right[i]=right[i+1]*nums[i];\n    }\n    int[] res=new int[nums.length];\n    //1 2 3\n    res[0]=right[1];\n    for (int i=1;i<nums.length;i++) {\n        res[i]=left[i]*right[i+1];\n    }\n    return res;\n}\n```\n\n**解法二**\n\nO(1) 进阶版有时间再来补\n\n## [5341. 最后 K 个数的乘积](https://leetcode-cn.com/problems/product-of-the-last-k-numbers/)\n\n请你实现一个「数字乘积类」`ProductOfNumbers`，要求支持下述两种方法：\n\n1. add(int num)\n\n- 将数字 num 添加到当前数字列表的最后面。\n\n2. getProduct(int k)\n\n- 返回当前数字列表中，最后 k 个数字的乘积。\n- 你可以假设当前列表中始终 至少 包含 k 个数字。\n- 题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。\n\n**示例：**\n\n```java\n输入：\n[\"ProductOfNumbers\",\"add\",\"add\",\"add\",\"add\",\"add\",\"getProduct\",\"getProduct\",\"getProduct\",\"add\",\"getProduct\"]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]\n\n输出：\n[null,null,null,null,null,null,20,40,0,null,32]\n\n解释：\nProductOfNumbers productOfNumbers = new ProductOfNumbers();\nproductOfNumbers.add(3);        // [3]\nproductOfNumbers.add(0);        // [3,0]\nproductOfNumbers.add(2);        // [3,0,2]\nproductOfNumbers.add(5);        // [3,0,2,5]\nproductOfNumbers.add(4);        // [3,0,2,5,4]\nproductOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20\nproductOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40\nproductOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0\nproductOfNumbers.add(8);        // [3,0,2,5,4,8]\nproductOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 \n```\n\n**提示：**\n\n```java\nadd 和 getProduct 两种操作加起来总共不会超过 40000 次。\n0 <= num <= 100\n1 <= k <= 40000\n```\n\n**解法一**\n\n176 周赛的第二题，思路倒是很容易想到，维护一个前缀积，然后用全积除以对应 k 位置的就行了，但是细节的处理出了大问题 haha~\n\n```java\nLinkedList<Integer> product=null;\n\npublic ProductOfNumbers() {\n    product=new LinkedList<>();\n    product.add(1);\n}\n\npublic void add(int num) {\n    if(num==0){ //重新构建\n        product=new LinkedList<>();\n        product.add(1);\n    }else{\n        product.add(num*product.getLast());\n    }\n}\n\n//1| 1 0 2 3  k=3\npublic int getProduct(int k) {\n    if(k>=product.size()){\n        return 0;\n    }\n    return product.getLast()/product.get(product.size()-k-1);\n}\n```\n一开始维护了所有的前缀积，结果后面的 case 过不了，出现了除 0 异常，很显然把 0 换成 1，后面的 case 大了之后累乘的结果太大了，溢出为 0 了。\n\n上面代码的处理方式是参考了大佬的解法，遇到 0 的时候就直接重置队列，最后如果 k 大于队列长度说明这个序列肯定是包含了 0，直接返回 0 就可以了\n\n## [面试题 64. 求 1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)\n\n求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。\n\n**示例 1：**\n\n```java\n输入：n = 3\n输出：6\n```\n\n**示例 2：**\n\n```java\n输入：n = 9\n输出：45\n```\n\n**限制：**\n\n- 1 <= n <= 10000\n\n**解法一**\n\n我一开始想的是把 `n*(n-1)/2`  展开，变成平方，用 pow 代替，除 2 用移位代替，但是想了想感觉 pow 底层应该也是用了乘\n\n所以还是得用递归，但是递归必须有出口，这里的关键就是怎么停止\n\n```java\npublic int sumNums(int n) {\n    int sum = n;\n    //逻辑与短路\n    boolean ans = (n > 0) && ((sum += sumNums(n - 1)) > 0);\n    return sum;\n}\n```\n\n## [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)\n\n已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n\n不要使用系统的 Math.random() 方法。\n\n**解法一**\n\n拒绝采样，两次 Rand7() 拒绝大于 40 的情况\n\n```java\npublic int rand10() {\n    int a,b,idx;\n    do{\n        a=rand7();\n        b=rand7();\n        idx=a+(b-1)*7;\n    }while(idx>40);\n    return 1+(idx-1)%10;\n}\n```\n\n概率论里面学过的，都忘了\n\n![38nhYn.png](https://s2.ax1x.com/2020/02/24/38nhYn.png)\n\n期望其实还可以更低，这里后面有时间再来研究\n\n## [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)\n\n打乱一个没有重复元素的数组。\n\n**示例：**\n\n```java\n// 以数字集合 1, 2 和 3 初始化数组。\nint[] nums = {1,2,3};\nSolution solution = new Solution(nums);\n\n// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3] 的排列返回的概率应该相同。\nsolution.shuffle();\n\n// 重设数组到它的初始状态 [1,2,3]。\nsolution.reset();\n\n// 随机返回数组 [1,2,3] 打乱后的结果。\nsolution.shuffle();\n```\n\n**解法一**\n\n洗牌算法，确保至少会出现`N!`种情况，且每种情况出现的概率是相同的\n\n```java\nint[] origin=null;\n\nint[] nums=null;\n\nRandom random=new Random();\n\npublic Solution(int[] nums) {\n    this.nums=nums;\n    origin=nums.clone();\n}\n\n/** Resets the array to its original configuration and return it. */\npublic int[] reset() {\n    return origin;\n}\n\n/** Returns a random shuffling of the array. */\npublic int[] shuffle() {\n    for (int i=nums.length-1;i>=0;i--) {\n        //从尾部开始这样对于 Java 会简单一点点\n        int rand=(int)(random.nextInt(i+1)); //随机【0,i】的元素\n        swap(nums,i,rand);\n    }\n    return nums;\n}\n\npublic void swap(int[] nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n## [面试题 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)\n\n从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2～10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。\n\n**示例 1:**\n\n```java\n输入：[1,2,3,4,5]\n输出：True\n```\n\n**示例 2:**\n\n```java\n输入：[0,0,1,2,5]\n输出：True\n```\n\n**限制：**\n\n数组长度为 5 \n\n数组的数取值为 [0, 13] .\n\n**解法一**\n\n只有 5 张牌，先排除对子，然后求最大和最小的牌面之差就行了，小于等于 4 就肯定是顺子\n\n```java\npublic boolean isStraight(int[] nums) {\n    int[] bucket=new int[14];\n    for(int i=0;i<5;i++){\n        bucket[nums[i]]++;\n        //有非 0 的对子，直接 false\n        if(nums[i]!=0 && bucket[nums[i]] >1 ){\n            return false;\n        }\n    }\n    //记录起手牌和最大牌\n    int start=-1,end=-1;\n    for(int i=1,j=13;end==-1||start==-1;i++,j--){\n        if(bucket[i]==1 && start==-1) start=i;\n        if(bucket[j]==1 && end==-1) end=j;\n    }\n    //小于等于 4 就行，多的用 0 补\n    return end-start<=4;\n}\n```\n代码可以优化成一个循环内\n\n```java\n//缩减成一个循环\npublic boolean isStraight(int[] nums) {\n    int[] bucket=new int[14];\n    int min=14,max=-1;\n    for(int i=0;i<nums.length;i++){\n        if(nums[i]==0) continue;\n        if(bucket[nums[i]]==1) return false;\n        bucket[nums[i]]++;\n        min=Math.min(min,nums[i]);\n        max=Math.max(max,nums[i]);\n    }\n    return max-min<=4;\n}\n```\n## [1103. 分糖果 II](https://leetcode-cn.com/problems/distribute-candies-to-people/)\n\n排排坐，分糖果。\n\n我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。\n\n给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。\n\n然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。\n\n重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。\n\n返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。\n\n**示例 1：**\n\n```java\n输入：candies = 7, num_people = 4\n输出：[1,2,3,1]\n解释：\n第一次，ans[0] += 1，数组变为 [1,0,0,0]。\n第二次，ans[1] += 2，数组变为 [1,2,0,0]。\n第三次，ans[2] += 3，数组变为 [1,2,3,0]。\n第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。\n```\n\n**示例 2：**\n\n```java\n输入：candies = 10, num_people = 3\n输出：[5,2,3]\n解释：\n第一次，ans[0] += 1，数组变为 [1,0,0]。\n第二次，ans[1] += 2，数组变为 [1,2,0]。\n第三次，ans[2] += 3，数组变为 [1,2,3]。\n第四次，ans[0] += 4，最终数组变为 [5,2,3]。\n```\n\n**提示：**\n\n- `1 <= candies <= 10^9`\n- `1 <= num_people <= 1000`\n\n**解法一**\n\n```java\n//暴力模拟\npublic int[] distributeCandies(int candies, int num_people) {\n    int[] res=new int[num_people];\n    int index=0;\n    for (int i=1;candies>0;i++) {\n        res[index%num_people]+=Math.min(candies,i);\n        candies-=i;\n        index++;\n    }\n    return res;\n}\n```\n数学的方法：每个人得到的糖果分批次的都是一个等差数列，可以通过求和公式直接算，过程有点繁琐，后面有时间再来研究\n\n## [1013. 将数组分成和相等的三个部分](https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/) \n\n  给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。\n\n形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。\n\n **示例 1：**\n\n```java\n输出：[0,2,1,-6,6,-7,9,1,2,0,1]\n输出：true\n解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n```\n\n**示例 2：**\n\n```java\n输入：[0,2,1,-6,6,7,9,-1,2,0,1]\n输出：false\n```\n\n**示例 3：**\n\n```java\n输入：[3,3,6,5,-2,2,5,1,-9,4]\n输出：true\n解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n```\n\n**提示：**\n\n1. 3 <= A.length <= 50000\n2. -10^4 <= A[i] <= 10^4\n\n**解法一**\n\n这个解法算是被群友误导了的，群里面有人说这题是前缀和，然后我就往哪个上面想的，其实没必要\n\n```java\npublic boolean canThreePartsEqualSum(int[] A) {\n    int[] preSum=new int[A.length+1];\n    preSum[0]=0;\n    for(int i=1;i<=A.length;i++){\n        preSum[i]=preSum[i-1]+A[i-1];\n    }\n    for(int i=1;i<preSum.length-2;i++){ //保证剩下 2 个\n        if(preSum[A.length]-preSum[i]==preSum[i]*2){\n            for(int j=i+1;j<preSum.length-1;j++){ //保证剩下 1 个\n                if(preSum[A.length]-preSum[i]==(preSum[j]-preSum[i])*2){\n                    //System.out.println(i+\" \"+j);\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    return false;\n}\n```\n**解法二**\n\n这才是正常的思路\n\n```java\npublic boolean canThreePartsEqualSum(int[] A) {\n    int sum=0;\n    for(int i=0;i<A.length;i++) sum+=A[i];\n    if(sum%3!=0) return false;\n    int count=0,tempSum=0;\n    //i 到达 A.length-1 保证有第 3 段，否则有可能 target=0 只分为两段就没了\n    for(int i=0;i<A.length-1;i++){ \n        tempSum+=A[i];\n        if(tempSum==sum/3){\n            ++count;\n            if(count==2) return true;\n            tempSum=0;\n        }\n    }\n    return false;\n}\n```\n这题的 WA 点就是 sum=0 的时候，有可能按照划分的逻辑只将数组划分为两段，所以要注意边界\n\n## [调整数组顺序使奇数位于偶数前面（牛客）](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&&tqId=11166&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking)\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n\n**解法一**\n\n其实就是稳定的排序，插入，冒泡，归并都可以\n\n```java\npublic void reOrderArray(int [] array) {\n    for(int i=0;i<array.length;i++){\n        for(int j=i;j>=1;j--){\n            if(array[j]%2==1 && array[j-1]%2==0){\n                swap(array,j,j-1);\n            }\n        }\n    }\n}\n\npublic void swap(int[] array,int a,int b){\n    int temp=array[a];\n    array[a]=array[b];\n    array[b]=temp;\n}\n```\n## [836. 矩形重叠](https://leetcode-cn.com/problems/rectangle-overlap/)\n\n矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标，`(x2, y2)` 是右上角的坐标。\n\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n\n给出两个矩形，判断它们是否重叠并返回结果。\n\n**示例 1：**\n\n```java\n输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n输出：true\n```\n\n**示例 2：**\n\n```java\n输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n输出：false\n```\n\n**提示：**\n\n1. 两个矩形 `rec1` 和 `rec2` 都以含有四个整数的列表的形式给出。\n2. 矩形中的所有坐标都处于 `-10^9` 和 `10^9` 之间。\n3. `x` 轴默认指向右，`y` 轴默认指向上。\n4. 你可以仅考虑矩形是正放的情况。\n\n**解法一**\n\n憨憨解法，最后还被一个大 case 越界给卡了\n\n```java\npublic boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n    int x=Math.max(rec2[2]-rec1[0],rec1[2]-rec2[0]);\n    int y=Math.max(rec2[3]-rec1[1],rec1[3]-rec2[1]);\n    long maxX=((long)rec1[2]-(long)rec1[0]+(long)rec2[2]-(long)rec2[0]);\n    long maxY=((long)rec1[3]-(long)rec1[1]+(long)rec2[3]-(long)rec2[1]);\n    return x<maxX && y <maxY;\n}\n```\n**解法二**\n\n```java\npublic boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n    return !(rec1[3]<=rec2[1]||rec2[3]<=rec1[1]||rec1[2]<=rec2[0]||rec2[2]<=rec1[0]);\n}\n```\n## [892. 三维形体的表面积](https://leetcode-cn.com/problems/surface-area-of-3d-shapes/)\n\n在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。\n\n每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。\n\n请你返回最终形体的表面积。\n\n**示例 1：**\n\n```java\n输入：[[2]]\n输出：10\n```\n\n**示例 2：**\n\n```java\n输入：[[1,2],[3,4]]\n输出：34\n```\n\n**示例 3：**\n\n```java\n输入：[[1,0],[0,2]]\n输出：16\n```\n\n**示例 4：**\n\n```java\n输入：[[1,1,1],[1,0,1],[1,1,1]]\n输出：32\n```\n\n**示例 5：**\n\n```java\n输入：[[2,2,2],[2,1,2],[2,2,2]]\n输出：46\n```\n\n**提示：**\n\n- `1 <= N <= 50`\n- `0 <= grid[i][j] <= 50` \n\n**解法一**\n\n做加法\n\n```java\n//加法思路\npublic int surfaceArea(int[][] grid) {\n    if(grid==null || grid.length<=0 ) return 0;\n    int N=grid.length;\n    int res=0;\n    for (int i=0;i<N;i++) {\n        for (int j=0;j<N;j++) {\n            //正面，背面暴露的面积\n            res+= Math.max(j<N-1?grid[i][j+1]-grid[i][j]:grid[i][j],0);\n            res+= Math.max(j>0?grid[i][j-1]-grid[i][j]:grid[i][j],0);\n            //左和右边暴露的面积\n            res+= Math.max(i<N-1?grid[i+1][j]-grid[i][j]:grid[i][j],0);\n            res+= Math.max(i>0?grid[i-1][j]-grid[i][j]:grid[i][j],0);\n            //上和下的面积\n            res+= grid[i][j]!=0?2:0;\n        }\n    }\n    return res;\n}\n```\n我太蠢了，开始直接分别算 6 个面，然后发现有坑，又去算坑的面积。结果就陷进去了\n\n**解法二**\n\n巧妙的减法思路，算贴合的时候的重合的面积\n\n```java\n//巧妙的减法思路\npublic int surfaceArea(int[][] grid) {\n    if(grid==null || grid.length<=0 ) return 0;\n    int N=grid.length;\n    int x=0,y=0,count=0;\n    for (int i=0;i<N;i++) {\n        for (int j=0;j<N;j++) {\n            if(grid[i][j]!=0){\n                x+=grid[i][j]-1;\n                count+=grid[i][j];\n            }\n            if(i>=1 && grid[i-1][j]!=0){\n                y+=Math.min(grid[i][j],grid[i-1][j]);\n            }\n            if(j>=1 && grid[i][j-1]!=0){\n                y+=Math.min(grid[i][j],grid[i][j-1]);\n            }\n        }\n    }\n    return count*6-2*x-2*y;\n}\n```\n## [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)\n\n给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。\n\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n\n**示例 :**\n\n```java\n输入：\n[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n\n输出：16\n```\n\n**解法一**\n\n偶然翻到的题，发现和上面的是一样的\n\n```java\n//和 892 类似的解法，简化版\npublic int islandPerimeter(int[][] grid) {\n    int count=0;\n    int left=0,up=0;\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]==1){\n                if(i-1>=0 && grid[i-1][j]==1){\n                    up++;\n                }\n                if(j-1>=0 && grid[i][j-1]==1){\n                    left++;\n                }\n                count++;\n            }\n        }\n    }\n    return count*4-(up+left)*2;\n}\n```\n> 看到题解区有大佬 dfs 的，通过方格的变化统计有效的边，比如从 1->0 就可以增加一条边，而从 1->边界又可以增加一条边，还是挺秒的\n\n## [999. 车的可用捕获量](https://leetcode-cn.com/problems/available-captures-for-rook/)\n\n题目太长，不想复制了，模拟题，题目意思搞清楚就行了\n\n```java\npublic int numRookCaptures(char[][] board) {\n    int[][] direction=new int[][]{{-1,0},{0,-1},{1,0},{0,1}};\n    int res=0;\n    for (int i=0;i<board.length;i++) {\n        for (int j=0;j<board[0].length;j++) {\n            if(board[i][j]=='R'){\n                for (int k=0;k<4;k++) {\n                    int nx=i+direction[k][0];\n                    int ny=j+direction[k][1];\n                    while(nx>=0 && nx<board.length && ny>=0 && ny<board[0].length){\n                        if(board[nx][ny]=='B'){\n                            break;\n                        }\n                        if(board[nx][ny]=='p'){\n                            res++;\n                            break;\n                        }\n                        nx+=direction[k][0];\n                        ny+=direction[k][1];\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    return 0;\n}\n```\n## [289. 生命游戏](https://leetcode-cn.com/problems/game-of-life/)\n\n根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。\n\n给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n\n1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；\n\n2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；\n\n3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；\n\n4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；\n\n根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。\n\n**示例：**\n\n```java\n输入： \n[\n  [0,1,0],\n  [0,0,1],\n  [1,1,1],\n  [0,0,0]\n]\n输出：\n[\n  [0,0,0],\n  [1,0,1],\n  [0,1,1],\n  [0,1,0]\n]\n```\n\n**进阶：**\n\n- 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。\n- 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？\n\n**解法一**\n\nbugfree\n\n```java\nint[][] dir={{1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,-1},{-1,1},{1,-1}};\n\npublic void gameOfLife(int[][] board) {\n    if(board==null || board.length<=0) return;\n    int m=board.length,n=board[0].length;\n    boolean[][] change=new boolean[m][n];\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if(board[i][j]==0 && aliveCell(board,i,j,change)==3){\n                board[i][j]=1;\n                change[i][j]=true;\n            }else if(board[i][j]==1){\n                int alive=aliveCell(board,i,j,change);\n                if(alive<2 || alive>3){\n                    board[i][j]=0;\n                    change[i][j]=true;\n                }\n            }\n        }\n    }\n}\n\npublic int aliveCell(int[][] board,int x,int y,boolean[][] change){\n    int alive=0;\n    for(int k=0;k<dir.length;k++){\n        int nx=x+dir[k][0];\n        int ny=y+dir[k][1];\n        if(valid(board,nx,ny)&&(board[nx][ny]==1 && !change[nx][ny] || (board[nx][ny]==0 && change[nx][ny]))){\n            alive++;\n        }\n    }\n    return alive;\n}\n\npublic boolean valid(final int[][] board,int x,int y){\n    return x>=0 && x<board.length && y>=0 && y<board[0].length;\n}\n```\n我理解的原地就是在原数组上做修改，但是并没有说不能用额外空间吧。但是看了评论区大佬们都不是这样写的，都是用的位运算，用 int 空的位保存状态，最后移位，懒得写了，感觉没啥意思，水题\n\n## [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)\n\n统计所有小于非负整数 *n* 的质数的数量。\n\n**示例：**\n\n```java\n输入：10\n输出：4\n解释：小于 10 的质数一共有 4 个，它们是 2, 3, 5, 7 。\n```\n\n**解法一**\n\n[厄拉多塞筛法](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) 简称埃式筛\n\n```java\npublic int countPrimes(int n) {\n    boolean[] prime=new boolean[n];\n    //为了不那么别扭\n    Arrays.fill(prime,true);\n    for(int i=2;i*i<n;i++){\n        if(prime[i]){\n            //从 i*i 开始，i*(i-1) 已经被前面的统计了\n            for(int j=i*i;j<n;j+=i){\n                prime[j]=false;\n            }\n        }\n    }\n    int res=0;\n    for(int i=2;i<prime.length;i++){\n        if(prime[i]) res++;\n    }\n    return res;\n}\n```\n## [171. Excel 表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)\n\n给定一个 Excel 表格中的列名称，返回其相应的列序号。\n\n例如，\n\n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 \n    ...\n**示例 1:**\n\n```java\n输入：\"A\"\n输出：1\n```\n\n**示例 2:**\n\n```java\n输入：\"AB\"\n输出：28\n```\n\n**示例 3:**\n\n```java\n输入：\"ZY\"\n输出：701\n```\n\n**解法一**\n\n朋友作业帮面试问了这道题，其实就是进制的转换，写了个回转的\n\n```java\n//26 进制转 10 进制\npublic int titleToNumber(String s) {\n    if(s==null || s.length()<=0) return 0;\n    int res=0,n=s.length();\n    int temp=1;\n    for (int i=n-1;i>=0;i--) {\n        res+=(s.charAt(i)-'A'+1)*temp;\n        temp*=26;\n    }\n    return res;\n}\n\n//10 进制转 26 进制\npublic String numberToTitle(int s) {\n    StringBuilder res=new StringBuilder();\n    while(s!=0){\n        //这个 s-1 要注意啊 woc\n        res.append((char)((s-1)%26+65));\n        s=(s-1)/26;\n    }\n    return res.reverse().toString();\n}\n```\n## [168. Excel 表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)\n\n给定一个正整数，返回它在 Excel 表中相对应的列名称。\n\n例如，\n\n```java\n1 -> A\n2 -> B\n3 -> C\n...\n26 -> Z\n27 -> AA\n28 -> AB \n...\n```\n**示例 1:**\n\n```java\n输入：1\n输出：\"A\"\n```\n\n**示例 2:**\n\n```java\n输入：28\n输出：\"AB\"\n```\n\n**示例 3:**\n\n```java\n输入：701\n输出：\"ZY\"\n```\n\n**解法一**\n\n```java\npublic String numberToTitle(int s) {\n    StringBuilder res=new StringBuilder();\n    while(s!=0){\n        //这个 s-1 要注意啊 woc\n        res.append((char)((s-1)%26+65));\n        s=(s-1)/26;\n    }\n    return res.reverse().toString();\n}\n```\n\ngo 写法\n\n```go\nfunc convertToTitle(n int) string {\n    var res string\n    for n>0{\n        res=string((n-1)%26+'A')+res\n        n=(n-1)/26\n    }\n    return res\n}\n```\n\n## [724. 寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)\n\n给定一个整数类型的数组 `nums`，请编写一个能够返回数组**“中心索引”**的方法。\n\n我们是这样定义数组**中心索引**的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n**示例 1:**\n\n```java\n输入：\nnums = [1, 7, 3, 6, 5, 6]\n输出：3\n解释：\n索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。\n同时，3 也是第一个符合要求的中心索引。\n```\n\n**示例 2:**\n\n```java\n输入：\nnums = [1, 2, 3]\n输出：-1\n解释：\n数组中不存在满足此条件的中心索引。\n```\n\n**说明：**\n\n- `nums` 的长度范围为 `[0, 10000]`。\n- 任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。\n\n**解法一**\n\n唉，不知道为啥，直接写了个前缀后缀和判断的，很暴力直白的思路，咋就想不到简单的思路？\n\n```go\nfunc pivotIndex(nums []int) int {\n    //前缀和，后缀和\n    n:=len(nums)\n    if n==0{\n        return -1\n    }\n    pre:=make([]int,n+1) //i 之前的元素和，不包含 i\n    pre[0]=0\n    last:=make([]int,n+1) //(i-1) 之后元素和，不包含 (i-1)\n    last[n]=0\n    for i,j := 1,n-1;i<=n && j>=0; i,j = i+1,j-1 {\n        //这里其实只要代入值验证第一次的转移是正确的就行了，不用考虑太多\n        pre[i]=pre[i-1]+nums[i-1]\n        last[j]=last[j+1]+nums[j]\n    }\n    for i:=0;i<n;i++{\n        //联系上面数组的定义思考这里的判断\n        if pre[i]==last[i+1]{\n            return i;\n        }\n    }\n    return -1\n}\n```\n\n**解法二**\n\n简单的思路，脑子瓦特了一下没想到\n\n```go\nfunc pivotIndex(nums []int) int {\n    n:=len(nums)\n    if n==0{\n        return -1\n    }\n    sum:=0\n    for _,num:= range nums{\n        sum+=num\n    }\n    temp:=0 //包含了边界 0\n    for i:=0;i<n;i++{\n        if temp*2+nums[i]==sum{\n            return i\n        }\n        temp+=nums[i]\n    }\n    return -1\n}\n```\n\n## [945. 使数组唯一的最小增量](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)\n\n给定整数数组 A，每次 *move* 操作将会选择任意 `A[i]`，并将其递增 `1`。\n\n返回使 `A` 中的每个值都是唯一的最少操作次数。\n\n**示例 1:**\n\n```java\n输入：[1,2,2]\n输出：1\n解释：经过一次 move 操作，数组将变为 [1, 2, 3]。\n```\n\n**示例 2:**\n\n```java\n输入：[3,2,1,2,1,7]\n输出：6\n解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。\n可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。\n```\n\n**提示：**\n\n1. `0 <= A.length <= 40000`\n2. `0 <= A[i] < 40000`\n\n**解法一**\n\n之前写了，没记录，这次 PDD 笔试考了这题\n\n```java\npublic int minIncrementForUnique(int[] A) {\n    Arrays.sort(A);\n    int move=0;\n    for(int i=1;i<A.length;i++){\n        if(A[i]<=A[i-1]){\n            move+=A[i-1]-A[i];\n            A[i]=A[i-1]+1;\n        }\n    }\n    return move;\n}\n```\n\n暴力的解法很好想，首先肯定要排序，然后遇到小于等于前面的时候就`move+1`，直到不相等，但是这里是可以优化的，一次次的加没有啥意义，可以直接一步到位直接从`A[i]`增加到`A[i-1]+1`\n\n> 这题还有一些方法优化，首先是排序可以用桶排序，然后还可以用并查集（比较麻烦），或者也有数学分析找规律的方法\n\n## [面试题 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)\n\n请实现一个函数，把字符串 `s` 中的每个空格替换成\"%20\"。\n\n**示例 1：**\n\n```java\n输入：s = \"We are happy.\"\n输出：\"We%20are%20happy.\"\n```\n\n**限制：**\n\n```java\n0 <= s 的长度 <= 10000\n```\n\n**解法一**\n\n这题的标准做法\n\n```java\npublic String replaceSpace(String s) {\n    char[] res=new char[s.length()*3];\n    int idx=0;\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)==' '){\n            res[idx++]='%';\n            res[idx++]='2';\n            res[idx++]='0';\n        }else{\n            res[idx++]=s.charAt(i);\n        }\n    }\n    return new String(res,0,idx);\n}\n```\n\n**解法二**\n\n原题是要求 O(1) 空间的，这里虽然无法做到，但是可以模拟下\n\n```java\n//原题目的要求应该是在 O(1) 空间下，但是 Java 的 String 是不可变的\n//所以不可能 O(1), 我们需要改一下函数签名\npublic String replaceSpace(/*StringBuilder*/ String ss) {\n    StringBuilder s=new StringBuilder(ss); //这里是为了验证\n    int oldLen=s.length();\n    for (int i=0;i<oldLen;i++) {\n        if(s.charAt(i)==' ') s.append(\"xx\"); //扩充字符长度\n    }\n    int newLen=s.length();\n    //逆序，避免覆盖\n    int i=oldLen-1,j=newLen-1;\n    while(i>=0){\n        char c=s.charAt(i--);\n        if(c==' '){\n            s.setCharAt(j--,'0');\n            s.setCharAt(j--,'2');\n            s.setCharAt(j--,'%');\n        }else{\n            s.setCharAt(j--,c);\n        }\n    }\n    return s.toString();\n}\n```\n\n## [面试题 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)\n\n输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n\n**示例 1:**\n\n```java\n输入：[10,2]\n输出：\"102\"\n```\n**示例 2:**\n\n```java\n输入：[3,30,34,5,9]\n输出：\"3033459\"\n```\n\n**提示：**\n- `0 < nums.length <= 100`\n\n**说明：**\n\n输出结果可能非常大，所以你需要返回一个字符串而不是整数；拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0\n\n**解法一**\n\n一开始贼 sb，想了一大堆有的没的😅\n![UTOOLS1592838604659.png](https://upload.cc/i1/2020/06/22/zOQcTL.png)\n```java\npublic String minNumber(int[] nums) {\n    String[] strs=new String[nums.length];\n    for(int i=0;i<nums.length;i++) strs[i]=nums[i]+\"\";\n    Arrays.sort(strs,(a,b)->(a+b).compareTo(b+a));\n    StringBuilder sb=new StringBuilder();\n    for(String i:strs) sb.append(i);\n    return sb.toString();\n}\n```\n虽然绕了一大圈，所幸还是自己做出来了，但是为什么这样就是对的呢？其实这里我也是想当然了，严谨的应该对这个排序规则的传递性进行证明，也就是`xy>yx && yz>zy ==> xz>xz ?`这个成立，排序的结果才是对的，这里我就不 copy 了，证明也不是很难，大家可以去原题 [题解区](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/378553) 看看\n\n## [179. 最大数](https://leetcode-cn.com/problems/largest-number/)\n\n给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。\n\n**示例 1:**\n\n```java\n输入：[10,2]\n输出：210\n```\n**示例 2:**\n\n```java\n输入：[3,30,34,5,9]\n输出：9534330\n说明：输出结果可能非常大，所以你需要返回一个字符串而不是整数。\n```\n**解法一**\n\n和上一题一摸一样，借机学习下 golang 的自定义排序\n```golang\ntype StringSlice []string\n\nfunc (p StringSlice) Len() int           { return len(p) }\nfunc (p StringSlice) Less(i, j int) bool { return p[i]+p[j] > p[j]+p[i] }\nfunc (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n\nfunc largestNumber(nums []int) string {\n    strs := make([]string, len(nums))\n    for i, n := range nums {\n        strs[i] = strconv.Itoa(n)\n    }\n    sort.Sort(StringSlice(strs))\n    //return strings.Join(strs,\"\") 要去前导 0...\n    // var res = \"\"\n    // var idx = 0\n    // for idx < len(strs)-1 && strs[idx] == \"0\" {\n    //     idx++\n    // }\n    // for idx < len(strs) {\n    //     res += strs[idx]\n    //     idx++\n    // }\n    res := strings.Join(strs, \"\")\n    if res[0] == '0' { //第一个为 0 肯定就全部是 0 了。.. 前面的写法明显没动脑子\n        return \"0\"\n    }\n    return res\n}\n```\n看了大佬们的提交记录发现 go 1.8 在 sort 包中引入了\n\n`func Slice(slice interface{}, less func(i, j int) bool)`\n\n通过这个就不用很麻烦的去实现 3 个函数了，只需要实现`Less`比较器就可以了（其实这才是正常的做法，其他语言中也都是类似的，其他两个`len`和`swap`感觉意义不大，一般不会改这两个函数，完全可以自动生成）\n> 看评论区又看到一个很好的 [反证的思路](https://leetcode-cn.com/problems/largest-number/solution/zui-da-shu-bi-jiao-gui-ze-chuan-di-xing-yi-ji-suan/344160)，大致意思就是：假设存在序列`\"...ab...\"`为最大数，且不满足该排序规则`ab>ba`，也就是说`ab<ba`，那我们交换序列中 ab 的位置变为`\"...ba...\"`很明显`\"...ba...\"`>`\"...ab...\"`，与假设矛盾，所以最大数一定满足该排序规则\n\n## [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)\n\nDifficulty: **中等**\n\n给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。\n\n数学表达式如下：\n\n> 如果存在这样的 _i, j, k, _ 且满足 0 ≤ _i_ < _j_ < _k_ ≤ _n_-1，  \n> 使得 _arr[i]_ < _arr[j]_ < _arr[k]_ ，返回 true ; 否则返回 false 。\n\n**说明：** 要求算法的时间复杂度为 O(_n_)，空间复杂度为 O(_1_) 。\n\n**示例 1:**\n\n```go\n输入：[1,2,3,4,5]\n输出：true\n```\n\n**示例 2:**\n\n```go\n输入：[5,4,3,2,1]\n输出：false\n```\n\n**解法一**\n\n题目限制了空间复杂度 O(1) 时间复杂度 O(N)，所以利用额外空间的方案就不适用了，我们只需要记录当前元素**之前的最小值**，和最小值**右边的次小值**就 ok 了，在循环中不断的更新这两个值\n```golang\nfunc increasingTriplet(nums []int) bool {\n    var INT_MAX = int(^uint(0)>>1)\n    var n = len(nums)\n    var a = INT_MAX\n    var b = INT_MAX\n    for i := 0; i < n; i++{\n        if nums[i] <= a{\n            a = nums[i]\n            //b = a 这里不用更新次小值，因为我们要保证 a 在 b 前面\n        }else if nums[i] <= b{\n            b = nums[i]\n        }else{\n            return true\n        }\n    }\n    return false\n}\n```\n很可惜是在看了题解区才明白，真的菜啊，一开始想劈叉了，我一直在考虑中间的元素，想怎么求左右的最小最大值。\n\n## [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)\n\nDifficulty: **简单**\n\n给定一个整数 _n_，返回 _n_! 结果尾数中零的数量。\n\n**示例 1:**\n\n```go\n输入：3\n输出：0\n解释：3! = 6, 尾数中没有零。\n```\n\n**示例 2:**\n\n```go\n输入：5\n输出：1\n解释：5! = 120, 尾数中有 1 个零。\n```\n\n**说明：** 你算法的时间复杂度应为 _O_(log _n_)。\n\n**解法一**\n\n首先需要明确题目要求什么，`n!`结尾 0 的个数，直接算阶乘的值显然是不可能的，值会很大很容易溢出，而且大数相乘的时间复杂度也很高\n\n我们考虑下末尾的 0 是怎么来的，我们知道一个数 x10，末尾就会多一个 0，这里也一样，所以我们要求的就是在阶乘的过程中乘了多少个 10，那么 10 从哪里来呢？\n\n我们将 10 拆解成`2*5`，问题就又转化成了，阶乘中产生了多少对`2*5`的因子，注意这个并不是单纯指 1~n 中某一个值 2，或者 5，而是中间每个数拆分出来的因子，比如 15 就拆分成 3*5，中间就有一个 5 的因子，现在问题明确了，我们如何去求 2 或者 5 的因子个数呢？\n\n根据**短板理论**，很明显这两个因子我们只需要求其中**个数较少**的那一个就可以了，少的那个一定可以找到配对的另一个因子，举个例子，假设我们`n!`中产生了 2 个** 5 的因子**，和 5 个** 2 的因子**，那么很明显最后我们最后配对的`2x5`只有 2 对，也就是结尾会有 2 个 0，那么 2 和 5 我们求哪一个呢？或者说 2 和 5 的因子数量一定会有固定的大小关系么？\n\n其实上面的问题凭直觉就能看出来，明显 5 的个数会少一些，应该求 5 的个数，但是秉承着严谨的态度，我们还是应该实际的算一算，而且后面 code 的时候也是需要算的\n\n首先看 2 的个数，我们每隔 2 个数就会产生一个 2 的因子，比如 2，4，6，8，10...，但是同时有的数会有多个因子，这个里面也会产生 2，比如 4 就可以拆解成`2x2`，也就是每隔`4`个元素，抛开原来每隔`2`个元素产生的 2，会额外的再产生一个 2 的因子，同理 8 可以拆解成`2x2x2`，也就是所每隔 8 个元素又会产生一个额外的 2，所以总体的 n! 中，包含 2 的因子个数是 `n/2 + n/4 + n/8 + ...`，同理也可推出 5 的因子个数，如下：\n![mark](http://static.imlgw.top/blog/20200630/lFrypQIJu57J.png?imageslim)\n很明显同样项数 m 的情况下，5 的因子的个数要更少，所以我们直接求因子 5 的个数就行了\n\n有了上面的结论，代码就很容易写了，直接模拟就行了，时间复杂度`O(log(5,N))`\n```golang\nfunc trailingZeroes(n int) int {\n    var count = 0\n    for n > 0{\n        n /= 5\n        count += n\n    }\n    return count\n}\n```\n\n## [793. 阶乘函数后 K 个零](https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function/)\n\nDifficulty: **困难**\n\n `f(x)` 是 `x!` 末尾是 0 的数量。（回想一下 `x! = 1 * 2 * 3 * ... * x`，且`0! = 1`）\n\n例如， `f(3) = 0` ，因为 3! = 6 的末尾没有 0；而 `f(11) = 2` ，因为 11!= 39916800 末端有 2 个 0。给定 `K`，找出多少个非负整数`x` ，有 `f(x) = K` 的性质。\n\n```golang\n示例 1:\n输入：K = 0\n输出：5\n解释：0!, 1!, 2!, 3!, and 4! 均符合 K = 0 的条件。\n\n示例 2:\n输入：K = 5\n输出：0\n解释：没有匹配到这样的 x!，符合 K = 5 的条件。\n```\n\n**注意：**\n\n*   `K`是范围在 `[0, 10^9]` 的整数**。**\n\n**解法一**\n\n上一题的逆向，挺有意思的，可惜了，一开始没想出来，我知道答案肯定是 0 or 5 但是不知道咋验证了。明明上一题之前就做过了，真菜啊，看了评论区才恍然大悟\n```golang\n//ans: 0 or 5\nfunc preimageSizeFZF(K int) int {\n    //n/5 + n/25 + ... +  = K ==> n < 5*K\n    var left = 0 \n    var right = 5*K+1\n    for left <= right {\n        mid := left + (right-left)/2\n        var zero = trailingZeroes(mid)\n        if zero == K {\n            return 5\n        }\n        if zero > K {\n            right = mid - 1\n        }else{\n            left = mid + 1\n        }\n    }\n    return 0\n}\n​\n//172. 阶乘后的 0\nfunc trailingZeroes(n int) int {\n    var count = 0\n    for n > 0 {\n        n/=5\n        count += n\n    }\n    return count\n}\n```\n\n## [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)\n\nDifficulty: **中等**\n\n给定一个 m*n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。\n\n**示例 1:**\n\n```go\n输入：\n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n输出：\n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n```\n\n**示例 2:**\n\n```go\n输入：\n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\n输出：\n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n```\n\n**进阶：**\n\n*   一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。\n*   一个简单的改进方案是使用 O(m+n) 的额外空间，但这仍然不是最好的解决方案。\n*   你能想出一个常数空间的解决方案吗？\n\n**解法一**\n\n傻逼题\n```golang\nfunc setZeroes(matrix [][]int)  {\n    r, c := false, false\n    for j := 0; j < len(matrix[0]); j++{\n        if matrix[0][j] == 0{\n            r = true\n            break\n        }\n    }\n    for i := 0; i < len(matrix); i++{\n        if matrix[i][0] == 0{\n            c = true\n            break\n        }\n    }\n    \n    for i :=1; i < len(matrix); i++{\n        for j := 1; j < len(matrix[0]); j++{\n            if matrix[i][j] == 0{\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n    for j :=1; j < len(matrix[0]); j++{\n        if matrix[0][j] == 0{\n            for i :=0; i < len(matrix);i++{\n                matrix[i][j] = 0\n            }\n        }\n    }\n    for i :=1; i < len(matrix); i++{\n        if matrix[i][0] == 0{\n            for j :=0; j < len(matrix[0]); j++{\n                matrix[i][j] = 0   \n            }\n        }\n    }\n    if r {\n        for j :=0; j < len(matrix[0]); j++{\n            matrix[0][j] = 0\n        }\n    }\n    if c {\n        for i :=0; i < len(matrix); i++{\n            matrix[i][0] = 0\n        }\n    }\n}\n```\n\n## [面试题 16.11. 跳水板](https://leetcode-cn.com/problems/diving-board-lcci/)\n\nDifficulty: **简单**\n\n你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为`shorter`，长度较长的木板长度为`longer`。你必须正好使用`k`块木板。编写一个方法，生成跳水板所有可能的长度。\n\n返回的长度需要从小到大排列。\n\n**示例：**\n\n```go\n输入：\nshorter = 1\nlonger = 2\nk = 3\n输出： {3,4,5,6}\n```\n\n**提示：**\n\n*   0 < shorter <= longer\n*   0 <= k <= 100000\n\n**解法一**\n\ntag 里面有递归，记忆化什么的。加上看见群友的讨论，又先入为主了，唉，写了半天的回溯，想着怎么去重，突然意识到直接一个循环就能解决了。菜啊\n```golang\nfunc divingBoard(shorter int, longer int, k int) []int {\n    if k == 0{\n        return []int{}\n    }\n    if shorter == longer{\n        return []int{ k * shorter}\n    }\n    var res []int\n    for i := 0; i <= k; i++{\n        res = append(res, i * longer + (k - i) * shorter)\n    }\n    return res\n}\n```\n\n## [NC82. 苹果树](https://www.nowcoder.com/practice/145b8d917c1e44c0b2b2462433b3029d?tpId=110&&tqId=33503&rp=1&ru=/ta/job-code&qru=/ta/job-code/question-ranking)\n牛牛有一个苹果园。又到了一年一度的收获季，牛牛现在要去采摘苹果买给市场的摊贩们。\n牛牛的果园里面有 n 棵苹果树，第 i 棵苹果树上有 a[i] 个果子。\n牛牛为了保证果子的新鲜程度，每天都会去苹果树上采摘果子。\n牛牛特意安排一个计划表：\n\n计划 m 天去采摘果子。对于第 i 天，它会去所有果树上轮流采摘 b[i] 个果子。\n如果对于第 i 天，某棵果树上没有 b[i] 个果子，那么它只会把当前果树上的果子采摘完。\n\n牛牛想知道它每天能供应多少个苹果给市场的摊贩们。\n\n**输入**\n\n- 1 <= a[i] , b[i] <= 1e9\n- 1 <= len(a), len(b) <= 1e5\n\n**示例 1**\n```go\n输入 : [10,20,10],[5,7,2]\n输出 : [15,17,2]\n说明 :\n苹果树上的果子变化 [10,20,10]-->[5,15,5]-->[0,8,0]-->[0,6,0]\n```\n\n**解法一**\n\n在牛客看见是头条二面的一道题，找到了牛客对应的题目，尝试了下，首先写了楼主的 前缀和+二分的解法\n\n很可惜通过率 0，报错的数据很大，一看就知道溢出了\n```java\n//前缀和+二分的做法（容易溢出，random 稍微调大点就溢出了，过不了 OJ）\npublic static long[] solve2 (int[] a, int[] b) {\n    if(a==null || a.length==0){\n        return new long[0];\n    }\n    // write code here\n    Arrays.sort(a);\n    int d = b.length;\n    int al = a.length;\n    long sum = 0;\n    long[] preSum = new long[al];\n    preSum[0] = a[0];\n    for(int i = 1; i < al; i++){\n        preSum[i] = preSum[i-1] + a[i];\n    }\n    long[] res = new long[d];\n    int sb = 0;\n    for(int i = 0; i < d; i++){\n        sb += b[i];\n        int idx = search(a, sb);\n        if(idx == -1){\n            res[i] = sb * al - sum;\n        }else{\n            res[i] = preSum[idx] + sb * (al-idx-1) - sum;\n        }\n        sum += res[i];\n    }\n    return res;\n}\n\n//小于 target 的最后一个\npublic static int search(int[] a, int target){\n    int left = 0;\n    int right = a.length-1;\n    int res = -1;\n    while(left <= right){\n        int mid = left + (right - left)/2;\n        if(a[mid] < target){\n            res = mid;\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\n双指针的解法，还是很巧妙的，这题如果考虑去减掉每棵树的果子其实就走远了，那样时间复杂度肯定是 O(N^2) 的，其实我们完全不用每次都把果子的数量给减掉，首先我们对果树进行排序，这样方便进行区间的摘取，对整体分区变为 `无剩余 | 剩余不足 | 剩余足够`三个区间\n\n每次摘取都是将前 n 天的合并起来一起摘，然后看**剩余不足**和**剩余足够**分界线在哪里，剩余不足的部分就直接加起来，然后减去前`n-1`天在该果树上采摘的数量，得到就是剩下的当天可以采摘的数量，之后这部分**剩余不足**的就变成了**无剩余**\n\n最后，在分界线以后的部分就都是剩余足够的部分，直接乘法计算就行了（小心溢出）\n\n```java\n//正解 双指针，时间复杂度 O(m+n)\npublic static long[] solve (int[] a, int[] b) {\n    Arrays.sort(a);\n    int p = 0;\n    int sb = 0;\n    long[] res = new long[b.length];\n    for (int i = 0; i < b.length; i++) {\n        sb += b[i];\n        while(p < a.length && a[p] < sb){\n            //该果树果子不够了，拿取剩下所有的\n            res[i] += (a[p] - (sb - b[i]));\n            //下一颗果树\n            p++;\n        }\n        //后面的都够\n        res[i]+=(a.length - p) * (long)b[i];\n    }\n    return res;\n}\n```\n> 其实和解法一的思路类似，但是这种做法不考虑溢出且时间复杂度更低\n\n## [453. 最小移动次数使数组元素相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/)\n\nDifficulty: **简单**\n\n给定一个长度为 _n_ 的**非空**整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 _n_ - 1 个元素增加 1。\n\n**示例：**\n\n```go\n输入：\n[1,2,3]\n\n输出：\n3\n\n解释：\n只需要 3 次移动（注意每次移动会增加两个元素的值）：\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\n```\n\n**解法一**\n\nn-1 个元素+1，就相当于 1 个元素-1，思维的转换，题目就变得简单了\n```golang\nfunc minMoves(nums []int) int {\n    var min = math.MaxInt32\n    for i := 0; i < len(nums); i++ {\n        if nums[i] < min {\n            min = nums[i]\n        }\n    }\n    var res = 0\n    for i := 0; i < len(nums); i++ {\n        res += (nums[i]-min)\n    }\n    return res\n}\n```\n\n## [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)\n\nDifficulty: **简单**\n\n给定一个字符串 `s`，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是组合在一起的。\n\n重复出现的子串要计算它们出现的次数。\n\n**示例 1 :**\n\n```golang\n输入：\"00110011\"\n输出：6\n解释：有 6 个子串具有相同数量的连续 1 和 0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。\n\n请注意，一些重复出现的子串要计算它们出现的次数。\n\n另外，“00110011”不是有效的子串，因为所有的 0（和 1）没有组合在一起。\n```\n\n**示例 2 :**\n\n```golang\n输入：\"10101\"\n输出：4\n解释：有 4 个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续 1 和 0。\n```\n\n**注意：**\n\n*   `s.length` 在 1 到 50,000 之间。\n*   `s` 只包含“0”或“1”字符。\n\n**解法一**\n\n将字符转换为连续字符个数的排列，比如 111100011000-->4323，然后我们将相邻两个数的最小值加入结果集就行了，3+2+2=7，下面的解法合并了两步操作\n```golang\nfunc countBinarySubstrings(s string) int {\n    var n = len(s)\n    var last, cur = 0, 0\n    var res = 0\n    var Min = func (a, b int) int {if a<b {return a};return b}\n    var p = 0\n    for p < n {\n        c := s[p]\n        for p < n && s[p] == c {\n            p++\n            cur++\n        }\n        res += Min(cur, last)\n        last = cur\n        cur = 0\n    }\n    return res\n}\n```\n\n## [844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)\n\nDifficulty: **简单**\n\n给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p>\n\n<p>\n\n给定 `S` 和 `T` 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 `#` 代表退格字符。\n\n**注意**：如果对空文本输入退格字符，文本继续为空。\n\n**示例 1：**\n\n```go\n输入：S = \"ab#c\", T = \"ad#c\"\n输出：true\n解释：S 和 T 都会变成 “ac”。\n```\n\n**示例 2：**\n\n```go\n输入：S = \"ab##\", T = \"c#d#\"\n输出：true\n解释：S 和 T 都会变成 “”。\n```\n\n**示例 3：**\n\n```go\n输入：S = \"a##c\", T = \"#a#c\"\n输出：true\n解释：S 和 T 都会变成 “c”。\n```\n\n**示例 4：**\n\n```go\n输入：S = \"a#c\", T = \"b\"\n输出：false\n解释：S 会变成 “c”，但 T 仍然是 “b”。\n```\n\n**提示：**\n\n1.  `1 <= S.length <= 200`\n2.  `1 <= T.length <= 200`\n3.  `S` 和 `T` 只含有小写字母以及字符 `'#'`。\n\n**进阶：**\n\n*   你可以用 `O(N)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？\n\n**解法一**\n\nO（N）空间的就不写了，随便搞搞就行了，关键是 O(1) 空间的解法，这里核心就是双指针从后想前扫描，然后注意边界就 ok 了\n```java\npublic boolean backspaceCompare(String S, String T) {\n    int i = S.length()-1;\n    int j = T.length()-1;\n    while (i >= 0 || j >= 0) {\n        i = back(S, i);\n        j = back(T, j);\n        //都匹配完了\n        if (i < 0 && j < 0) {\n            return true;\n        }\n        //只有一个匹配完了，两个对位字符不匹配\n        if (i < 0 || j < 0 || S.charAt(i) != T.charAt(j)) {\n            return false;\n        }\n        i--; j--;\n    }\n    //都匹配完了\n    return i < 0 && j < 0;\n}\n\npublic int back(String s, int i) {\n    if (i < 0 || s.charAt(i) != '#') {\n        return i;\n    }\n    int cnt = 0;\n    while (i >= 0) {\n        if (s.charAt(i) == '#') {\n            cnt++;\n        } else {\n            if (cnt==0) break;\n            cnt--;\n        }\n        i--;\n    }\n    return i;\n}\n```","tags":["LeetCode","数组"],"categories":["算法"]},{"title":"JNI 初探","url":"/2019/05/02/f8b3ee4a/","content":"\n## JNI 简介\n\n> JNI 是** Java Native Interface **的缩写，它提供了若干的 API 实现了 Java 和其他语言的通信（主要是 [C](https://baike.baidu.com/item/C/7252092)&[C++](https://baike.baidu.com/item/C%2B%2B)）。从 Java1.1 开始，JNI 标准成为 java 平台的一部分，它允许 Java 代码和其他语言写的代码进行交互。JNI 一开始是为了本地已编译语言，尤其是 C 和 C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。使用 java 与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI 标准至少要保证本地代码能工作在任何 Java 虚拟机环境。\n\n相信大家在看源码的时候都看见过用** native **修饰的方法，这些方法就是用 C/C++语言实现的，那到底 java 是如何调用的这些方法的呢？\n\n## 上手\n\n**准备工作**\n\n> 文中环境为 Linux 下 Centos6 版本\n\n✅ 首先需要有`JDK`（我的是 jdk1.7)，编译 java\n\n✅ 然后需要`gcc` 用来编译 C/C++\n\n**Java 代码**\n\n```java\npublic class JniTest {\n\n    public static void main(String[] args) {\n        new JniTest().hi();\n    }\n\t\n    static {\n        //加载一个动态链接库\n        System.loadLibrary(\"jniTest\");\n    }\n\n    private native void hi();\n}\n```\n\n在静态代码块里面加载了一个 [动态链接库](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%96%87%E4%BB%B6)\n\n编写完之后直接`javac JniTest.java`编译一下，然后执行`javah -jni  JniTest`，会在当前目录下生成一个`JniTest.h`的头文件如下\n\n```c\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class JniTest */\n\n#ifndef _Included_JniTest\n#define _Included_JniTest\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     JniTest\n * Method:    hi\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_JniTest_hi\n  (JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n**C 代码**\n\n```java\n#include<stdio.h>\n#include \"JniTest.h\"\n#include <jni.h>\n//这一段来自上面的头文件\nJNIEXPORT void JNICALL Java_JniTest_hi\n  (JNIEnv *env, jobject o){\n        printf(\"you  successfully called the c code\\n\");\n}\n```\n\n- `JNIEnv*`：用于引用 JNI 环境，该指针变量可以访问所有 JNI 函数\n- `jobject`：引用`this` Java 对象，也就是可以用来访问当前 java 调用者\n\n写完之后执行如下命令编译它\n\n```java\ngcc -fPIC -D_REENTRANT  -I\"$JAVA_HOME/include\"  -I\"$JAVA_HOME/include/linux\" -c JniTest.c\n```\n\n会在当前目录下生成一个`JniTest.o`的可执行文件。\n\n然后执行\n\n`gcc -shared JniTest.o -o libjniTest.so`\n\n注意`linux`上动态链接库必须以`lib`开头，所以这里是`libjniTest`后面的是前面`java`代码中加载的哪个动态链接库名称`jniTest`，最后会在当前目录下生成一个`libjniTest.so`的动态库\n\n**执行**\n\n首先给`libjniTest.so`赋予可执行权限\n\n`chmod 777 libjniTest.so`\n\n因为我这里没有设置`java.library.path`所以需要在运行的时候加上路径\n\n`java -Djava.library.path=/usr/jnitest JniTest`\n\n**结果**\n\n![mark](http://static.imlgw.top///20190502/rKdNPEwUmstf.png?imageslim)\n\n>  篇文章中只是简单的调用了 C 语言的代码，关于如何传递参数，如何返回值，后面遇到之再做记录","tags":["JNI"],"categories":["JVM"]},{"title":"Volatile 关键字详解","url":"/2019/04/29/1b898227/","content":"\n## JMM&CPU 缓存\n\n### CPU 缓存\n\n其实这个并不是指某一个具体的部件，`寄存器 (Register)`，`高速缓存 (Cache)`，`写缓冲器 (Store Buffer)`，`无效化队列 (Invalidate Queue)`等等都可以称为 CPU 缓存。\n\n#### 为什么要有 CPU 缓存？\n\n`缓存`通常意义下都是为了加快速度，这里同样也是，因为 CPU 的速度比`主内存 (RAM)`快很多，`主内存`会拖 CPU 后腿影响整体的效率，所以缓存就出现了，缓存的速度比`主内存`快很多（造价高）CPU 会直接通过缓存来对主内存进行读写操作，所以缓存里面实际上相当于是`主内存`的副本。\n\n#### 使用 CPU 缓存带来的问题\n\n正常情况下 CPU 执行计算的过程如下\n\n1️⃣程序以及数据被加载到主内存\n\n2️⃣指令和数据被加载到 CPU 缓存\n\n3️⃣CPU 执行指令，把结果写到高速缓存\n\n4️⃣高速缓存中的数据写回主内存\n\n如果是单核 CPU，上面的步骤没有任何问题，但如果是多核 CPU 就可能会出现一些意料之外的问题，假设有两个核\n\n下面这种情况也是有可能发生的\n\n1️⃣核 0 读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核 0 的缓存\n\n2️⃣核 1 做了上面同样的工作，这样核 0 与核 1 的缓存拥有同样的数据\n\n3️⃣核 0 修改了那个字节，被修改后，那个字节被写回核 0 的缓存，但是该信息并没有写回主存\n\n4️⃣核 1 访问该字节，由于核 0 并未将数据写回主存，数据不同步\n\n#### 解决方案\n\n🔶LOCK# 总线锁，效率很低，同时只能有一个 CPU 对内存操作，其他的 CPU 只能干等着\n\n🔶缓存一致性`协议`，缓存一致性协议有多种，`MESI`协议是当前最主流的缓存一致性协议\n\n![MESI 状态](http://static.imlgw.top///20190411/GYdTPdVBGCQB.png?imageslim) 日常处理的大多数计算机设备都属于`嗅探 (snooping)`协议，CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去`读写内存`时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一`写内存`，其它处理器马上知道这块内存在它们的缓存段中`已失效 (Invaid)`，如果这个时候有处理器想`读内存`（会被立即察觉到，因为一直在嗅探总线），那么已修改的缓存行 (Cache line) 就会立即刷新到主存中，然后设置为`Share`状态，这样一来读取到的数据就不是脏数据了。\n\n再放一张 处理器&缓存&主内存交互的图（来自组成原理书上的图）\n\n![Cache 基本结构](http://static.imlgw.top///20190415/lJzPTl3yQWBn.jpg?imageslim)\n\n既然有了 MESI 协议，是不是就不需要 volatile 的可见性语义了？当然不是\n\n- **并不是所有的硬件架构都提供了相同的一致性保证，JVM 需要 volatile 统一语义**（就算是 MESI，也只解决 CPU 缓存层面的问题，没有涉及其他层面）。\n- 可见性问题不仅仅局限于 CPU 缓存内，JVM 自己维护的`内存模型`中也有可见性问题。使用 volatile 做标记，可以解决 JVM 层面的可见性问题。\n- [这个回答应该很好的解释了](https://www.zhihu.com/question/277395220) 大概就是缓存一致性协议并不能保证实时性，而有时候我们需要保证严格的实时性\n\n### Java 内存模型 (JMM)\n\n> 为了屏蔽各个操作系统和硬件的差异，使得 Java 程序在所有平台下都能达到一致的内存访问效果，所以 Java 虚拟机定义了一种 Java 内存模型。\n\nJava 内存模型（即 Java Memory Model，简称 JMM) 本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。（这里的变量不包括局部变量和方法参数，因为那是线程私有的，不会产生竞争）\n\nJava 虚拟机规定所有的变量都存储在主内存（Main Memory），每个线程都有自己的工作线程（Work Memory 有些地方称为线程栈）。\n\n线程的工作内存中保存了使用到的变量的主内存副本拷贝，线程对变量的操作是在自己的工作内存中，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，而不能直接对主内存的变量进行读取赋值。\n\n不同线程之间无法直接访问对方工作内存中的变量，需要通过主内存来进行传递。\n\n![JMM](http://static.imlgw.top///20190411/PjL8vV724vXx.png?imageslim)\n\n（来自 [zejian](https://blog.csdn.net/javazejian/article/details/72772461)）\n\n工作内存实际上就是对上面** CPU 缓存**的抽象。\n\n#### 内存间交互\n\nJava 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。\nread：把一个变量的值从主内存传输到工作内存中\nload：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中\nuse：把工作内存中一个变量的值传递给执行引擎\nassign：把一个从执行引擎接收到的值赋给工作内存的变量\nstore：把工作内存的一个变量的值传送到主内存中\nwrite：在 store 之后执行，把 store 得到的值放入主内存的变量中\nlock：作用于主内存的变量\nunlock：对应 lock\n\n**JMM **还定义了一些关于`happens-before`关系的规则如下\n\n- 代码的执行顺序，编写在前面的发生在编写在后面的。\n\n- unlock 必须发生在 lock 之后\n\n- volatile 修饰的 写操作先发生在读之前\n\n- 传递规则 ，A 先于 B B 先于 C A 肯定先于 C\n\n- 线程启动规则，start 肯定现场发生与 run\n\n- 线程中断方法，interrupt 必须发生在捕获之前\n\n- 对象的初始化必须发生在 finalize 前\n\n- 线程终结规则，所有操作都发生在线程死亡前\n\n[参考](https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html)\n\n## Volatile 干了什么？\n\n### 保证可见性\n\n这里我们来看一个具体的 Demo。\n\n```java\n//线程 1\nboolean stop = false;\nwhile(!stop){\n    //doSomething();\n}\n \n//线程 2\nstop = true;\n```\n\n其实在上一篇 [Java 多线程基础](<http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/>) 里面 \"优雅的结束线程\" 里面有类似的代码\n\n![mark](http://static.imlgw.top///20190428/LQuwmhuMiwxp.png?imageslim)\n\n当时没有说明为啥要加`Volatile`，其实这里上面的代码如果不给状态量加上 `volatile`  并且用`server`模式运行有可能就会陷入死循环，即使在主线程里面将`isCancel`修改为`true`仍然无法结束，线程陷入了死循环，永远无法停止！！! 为什么会这样？？？\n\n![mark](http://static.imlgw.top///20190410/nCcFbqyGiqIz.png?imageslim)\n\n🔸 在`server`模式下 JIT 对我们的代码进行了优化（这也是为什么要用 server 模式运行的原因，**Client VM 的编译器没有像 Server VM 一样执行许多复杂的优化算法**）。它会将代码优化为类似下面这样的效果\n\n```java\nif(!stop){\n \twhile (stop){\n\t\t//do something....\n \t}\n}\n```\n\n`JIT`认为只有一个线程对其进行访问，所以为了避免重复的读取状态变量`stop`就将代码进行了 [循环不变表达式外提](https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E4%BB%A3%E7%A0%81%E5%A4%96%E6%8F%90)（wikipedia），而这恰恰导致了死循环\n\n🔸另一方面，也和计算机的储存系统有关，也就是上面`CPU 缓存`的问题中提到的，这里 `stop`就是共享变量，当线程①和②运行的时候先将主内存的`stop`拷贝了一份到`工作内存`中，其中一个线程修改了`stop`的值但是其他的线程无法感知到这个变化就可能会陷入死循环。\n\n📢 `volatile`在这里起到的作用就是\n\n① 阻止`JIT`的异常优化\n\n② 在一个线程修改了`volatile`修饰的共享变量后会**立即刷新到主内存**当中，这个过程称为_冲刷处理器缓存_。如果一个线程在读`voaltile`修饰的变量就会使相应的处理器**必须从主内存中进行同步**，这个过程称之为_刷新处理器缓存_，从而保证了可见性，通俗的讲就是`读必须从主内存中读，写必须同步到主内存中`。\n\n### 保证有序性\n\n**重排序**\n\n提到有序性就不得不说重排序，先来看一个`Demo`\n\n```java\nprivate boolean isReady=false;\n\npublic void writer(){\n    int data=getFromXxx(); //①\n    isReady=true \t\t//②\n}\n\npublic void reader(){\n    if(isReady){\n        //doSth\n    }\n}\n```\n\n这一看似乎没有什么问题，writer 线程完成后开始 read，问题就出来这里，**有可能 data 数据还没获取到，isReady 就已经是 true 了**也就是说②和①的执行交换了顺序，也就是所谓的**重排序**，这样的重排序将会导致不可预知的错误，而导致这种现象的来源很多，比如编译器 (JIT)，处理器和存储子系统 (Cache)，至于为什么要重排序，主要还是为了提升性能，当然重排序对单线程来讲是没有影响的（有影响那还得了😂)\n\n**其实不只是上面那种比较显而易见的重排序，还有下面这种比较隐含的**\n\n```java\npublic class SingletonObjectPlus {\n    private static  SingletonObjectPlus singletonObjectPlus =null;\n    public static SingletonObjectPlus getSingletonObject3(){\n    \tif(singletonObjectPlus==null){\n        \tsynchronized(SingletonObject.class){\n            \tif(singletonObjectPlus==null){\n                \tsingletonObjectPlus= new SingletonObjectPlus();\n            \t}\n        \t}\n    \t}\n     \treturn singletonObjectPlus;\n\t}\n}\n```\n\n熟悉的朋友可能看出来了，这是一个 DCL 单例，那它有什么问题呢？它也会被重排序么？那么会在哪里重排序呢？\n\n上述代码确实有问题，问题在** new SingletonObjectPlus(); **里面，实际上 new 这个操作可以划分为如下好几步\n\n1. 分配对象所需的空间 `objRef=allocate(SingleObjectPlus.class);`\n2. 初始化引用的对象 `invokeConstructor(objRef);`\n3. 设置`singletonObjectPlus`指向刚分配的内存地址`singletonObjectPlus=objRef`\n\n而这些步骤有可能就会被重排序，比如将③排到②之前，也就是对象还没有初始化完成就会被返回（已经分配空间了，就不为 null 了），这样在`最外层 if`判断的时候就可能会直接返回一个初始化未完成的对象\n\n> 发生这样重排序的概率很低，并不是必然出现的，重排序也不是随意的顺序调整，而是按照一定的规则去重排序，保证不会对单线程程序运行结果造成影响，显而易见，如果两条语句之间存在依赖关系，肯定是不会重排序的，具体就是两条语句访问同一个变量地址，至少有一条为写操作，那么这两条指令就存在依赖关系就不会被重排序比如 x=1;x=2; 这样的 就不会被重排序。\n\n其实上面的问题都很好解决，只要在** isReady **和** singletonObjectPlus **上加上`volatile`就 ok 了，在这里 volatile 会禁止指令的重排序（底层通过调用处理器提供的内存屏障）\n\n### 保障 Long/Double 变量写的原子性\n\n这一点其实很容易被遗忘，实际上 Java 对所有除了 Long 和 Double 的变量的**读写**操作都是原子性的，包括基础类型 (byte，boolean，short，float，和 int) 和引用类型。因为 Double 和 Long 类型的变量会占用 64 位，如果在`32 位机器`上 JVM 对这种变量的读写可能就是会被分解为两个操作而在多线程的情况下就会出现问题，这里就不做演示了，知道有这么个事就行了。在加上`Volatile`之后就可以保证该操作的原子性了。\n\n### 注意\n\n> volatile 在保障可见性的时候仅仅只能保障能够读取到该共享变量的相对新值，对于引用类型变量和数组类型的变量，volatile 能保证的也仅仅是该变量本身的可见性，而对于数组中的元素，引用类型中的字段（实例变量，静态变量）则无法保证其可见性，对于这些变量可见性的保障可以利用 JUC 工具包中的`Atomic 原子类`。\n\n## 内存屏障\n\n先简单了解两个指令：\n\n- Store：将处理器缓存的数据刷新到内存中。\n- Load：将内存存储的数据拷贝到处理器的缓存中。\n\n| 屏障类型            | 指令示例                   | 说明                                                         |\n| ------------------- | -------------------------- | ------------------------------------------------------------ |\n| LoadLoad Barriers   | Load1;`LoadLoad`;Load2     | 该屏障确保 Load1 数据的装载先于 Load2 及其后所有装载指令的的操作 |\n| StoreStore Barriers | Store1;`StoreStore`;Store2 | 该屏障确保 Store1 立刻刷新数据到内存（使其对其他处理器可见）的操作先于 Store2 及其后所有存储指令的操作 |\n| LoadStore Barriers  | Load1;`LoadStore`;Store2   | 确保 Load1 的数据装载先于 Store2 及其后所有的存储指令刷新数据到内存的操作 |\n| StoreLoad Barriers  | Store1;`StoreLoad`;Load2   | 该屏障确保 Store1 立刻刷新数据到内存的操作先于 Load2 及其后所有装载指令的操作。它会使该屏障之前的所有内存访问指令（存储指令和访问指令）完成之后，才执行该屏障之后的内存访问指令 |\n\nStoreLoad Barriers 同时具备其他三个屏障的效果，因此也称之为`全能屏障`（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵\n\n- 按照可见性划分，内存屏障可以分为**加载屏障** (Load Barrier)，和**存储屏障** (Store Barrier)\n\n- 按照有序性划分可分为**获取屏障** (Acquire Barrier) 和**释放屏障** (Release Barrier)\n\n具体那个充当加载屏障，那个充当存储屏障，我并不想讨论，各种博客各种资料各有各的说法，其实关于究竟底层是如何实现，如何插入，插入的哪一种这些细节我们不用去关心，不同的 CPU 不同的架构实现的方式都不一样，太过深入也没有多大的意义，很多博客介绍的也`完全不同`，我们只需要知道大概的原理就行了。如果想了解更多可以参考下列文章\n\n[聊聊原子变量、锁、内存屏障那点事](http://www.0xffffff.org/2017/02/21/40-atomic-variable-mutex-and-memory-barrier/)\n\n[一文解决内存屏障](https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/)\n\n[面试必问的 volatile，你了解多少？](https://www.jianshu.com/p/506c1e38a922)\n\n[深入理解 Java 内存模型（四）——volatile](https://www.infoq.cn/article/java-memory-model-4/?utm_source=infoq&%253Butm_medium=related_content_link&%253Butm_campaign=relatedContent_articles_clk)\n\n### 锁与内存屏障\n\n用** OneNote **画了几张图\n\n![mark](http://static.imlgw.top///20190428/EUPpWHTPnlH8.png?imageslim)\n\n实际上锁就是通过**内存屏障**来保证了有序性和可见性，通过**互斥排它**来保证了原子性\n\n### Volatile 和内存屏障\n\n**Volatile 写操作和内存屏障**\n\n![volatile 变量的写操作](http://static.imlgw.top///20190428/PImPUeLGqau6.png?imageslim)\n\n🔔 写线程对于`volatile 变量的写操作`会产生类似于`锁释放`的效果。在写完成后会`冲刷处理器缓存`将结果立即刷新到主存中让其他处理器对应的缓存行失效，让其他处理器可同步该数据\n\n> volatile 变量在原子性方面仅仅保证对被修饰的变量的读写`本身`的原子性。也就是说这个操作不能涉及任何共享变量（包括 volatile 变量本身）的访问，比如 volatile1=volatile2+1，volatile++ 这样的操作无法保证它的原子性，另外，voaltile 可以保证`long`和`double`变量在`32 位`机上写的原子性\n\n这里我们再回头看看前面的单例的例子\n\n①分配对象所需的空间 objRef=allocate(SingleObjectPlus.class);\n\n②初始化引用的对象 invokeConstructor(objRef);\n\n③设置 singletonObjectPlus 指向刚分配的内存地址 singletonObjectPlus=objRef\n\n虽然这里 volatile 子保证了子操作③的原子性 但是①②操作只涉及到了局部变量没有涉及到共享变量，由于内存屏障的作用①②操作不可能重排序到③之后，所以可以保证在得到返回之前对象一定已经初始化完毕了，不会出现没初始化完毕就返回的情况\n\n**Volatile 读操作和内存屏障**\n\n![volatile 变量的读操作](http://static.imlgw.top///20190428/tJcC98zgp532.png?imageslim)\n\n🔔 读线程对于`volatile 变量的读操作`会产生类似于`获得锁`的效果。读 volatile 变量前会先`刷新处理器缓存`从主存或其他处理器缓存中`同步`该数据\n\n> volatile 只能保证读线程读到共享变量的相对新值，对于引用类型和数组类型的并不能保证实例的字段或数组的元素的相对新值，只是保障了`引用地址`的相对新值 (`相对新值`表示读的过程中其他线程有可能更改了这个值，对应的还有`最新值`，读的过程中写线程无法更改）\n\n### Volatile 变量的开销&场景\n\n**开销**\n\nvolatile 变量的读写都不会导致上下文切换，所以开销比锁要小，从上面的介绍中可以看出 写一个 voaltile 会使该操作和该操作前的所有写操作对后面的线程是可见的，所以它的成本会比普通变量大一些但是比锁小一点，读一个 volatile 变量也会比锁小，但是会比普通变量大因为变量都会从内存或其他处理器高速缓存中去拿无法直接从寄存器中去拿，但是也很快了。\n\n**应用场景**\n\n🔶 使用 volatile 变量作为状态标志位，应用程序的某个状态由一个线程设置，其他线程会读取该状态作为后面操作的依据，此时用 volatile 作为同步机制好处就是一个线程可以及时\"通知\"另一个线程某种事件（例如掉线重连）而避免使用锁造成较大开销\n\n🔶使用 volatile 保障可见性，一个线程更新了共享变量其他线程无需加锁也可以看到该更新\n\n🔶volatile bean 模式（下面是我的个人理解可以直接跳过）\n\n```java\npublic class Person {\n    private volatile String firstName;\n    private volatile String lastName;\n    private volatile int age;\n    \n    public Person(String firstName,String lastName,int age){\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.age = age;\n    }\n\tpublic String getFirstName() { return firstName; }\n\tpublic String getLastName() { return lastName; }\n\tpublic int getAge() { return age; }\n \n\tpublic void setFirstName(String firstName) { \n    \tthis.firstName = firstName;\n\t}\n \n\tpublic void setLastName(String lastName) { \n    \tthis.lastName = lastName;\n\t}\n \n\tpublic void setAge(int age) { \n    \tthis.age = age;\n\t}\n}\n```\n\n关于这个场景的我理解的就是会保证类似 volatile Person  preson=new Person(xx,xx,xx,xx); 这样的操作具有可见性或者说完整性，不会初始化一半就返回对象要么为 null 要么就初始化完毕，类似于上面的提到的 dcl 单例的例子。\n\n🔶简易读写锁\n\n允许读线程读取的时候写线程进行更新，典型的例子就是实现一个计数器如下\n\n```java\npublic class Counter {\n    private volatile int value;\n    public int getValue() { return value; }\n    public synchronized int increment() {\n        return value++;\n    }  \t\n}\n```\n\n想了解更多去看看 IBM 这篇文章 [Java 理论与实践：正确使用 Volatile 变量](https://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 一个小问题\n\n![可见性的例子](http://static.imlgw.top///20190428/4CYfervOyHH3.png?imageslim)\n\n上面可见性的问题，图中的代码如果循环里面加上图中框内类似的代码，会发现即使共享变量上面不加** volatile **程序依然可以正常退出，上面出现的死循环并没有出现 （我的 JDK 版本是 1.8，不同的版本情况可能不一样），那是不是说这些操作也达到了保证可见性的作用呢？其实仔细分析这几行代码，后面三种都会刷新或冲刷处理器缓存 (print 里面也是加锁了的），我一开始觉得可能是这个原因导致的，但是按道理应该是只会保证同步块内部的变量的可见性，但是 sleep 并没有加锁，是个本地方法为啥还是会导致这样的结果呢？这里我也不想深究了，我感觉也没啥必要了，具体的场景下该加** volatile **还是老老实实加** volatile**，如果继续探究下可以看下 [这篇文章 ](http://www.importnew.com/19434.html)。\n\n## 参考资料\n\n- 《Java 多线程编程实战指南：核心篇》\n\n- [javazejian](https://blog.csdn.net/javazejian/article/details/72772461)\n\n- ...","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"CAS 与原子变量","url":"/2019/04/22/2c91a79/","content":"\n## CAS\n\n_这个** CAS **可不是单点登陆的那个 CAS😄!!!_\n\n> CAS（Compare-and-Swap），是对一种处理器指令的称呼，很多 Java 多线程相关的类库的最终实现都会借助 CAS\n\n​\t从所周知，类似`i++`自增这样的操作并不是原子的，是一个`read-modify-write`的操作 ，如果要保证这种操作的原子性按照之前的做法可以使用`synchronized`内部锁来解决，但是这样似乎有点太小题大做了，锁确实可以解决这个问题，但是前面的文章也提到过，锁是很消耗性能的，并不是最好的做法，比较好的做法就是** CAS**，它能够将这些操作转换为原子操作。\n\n​\tCompare and Swap，比较并交换，顾名思义是一种`if-then-act`的操作，而这个操作的原子性由`处理器`保证（硬件锁），如果一个线程想要将变量 V 的值由 A 变为 B，借助 CAS 就会产生类似下面代码的作用\n\n```java\nboolean comapreAndSet(Variable V,Object A,Objext B){\n    if(V.get()==A){ //判断是否和当前 V 的值相同（是否被修改）\n        V.set(B);   //没被修改就更新\n        return true;\n    }\n    return false; //被修改过就直接 return\n}\n```\n\n这样一来就是先下手为强了，当你最先修改了 V 的值，后面的所有线程都会直接失败，所以实际上也是一种快速失败策略，当然你也可以尝试再次请求直到成功为止。\n\n## 原子变量类\n\n_原子变量类_是基于 CAS 实现的一组保证共享变量`read-modify-write`操作（例如自增）原子性的工具类\n\n| 分组         | 类                                                           |\n| ------------ | ------------------------------------------------------------ |\n| 基础数据类型 | AtomicInteger，AtomicLong，AtomicBoolean                     |\n| 数组类       | AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray    |\n| 字段更新器   | AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater |\n| 引用型       | AtomicReference，AtomicStampedReference，AtomicMarkableReference |\n\n关于怎么使用就不多介绍，API 上都写的明明白白，这里有个地方需要注意，数组类单纯的 GET/SET 并不是原子操作。\n\n### 利用 CAS 写一个锁\n\n[前面的文章](http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/)  利用内部锁实现过一个** BooleanLock**，这里利用 CAS 再实现一个简易的锁\n\n**getLockException**\n\n```java\npublic class GetLockException extends Exception{\n    public GetLockException(String message) {\n        super(message);\n    }\n\n    public GetLockException() {\n        super();\n    }\n}\n```\n\n**CASLock** \n\n```java\npublic class CASLock {\n    private static final AtomicInteger value = new AtomicInteger();\n\n    private Thread lockedThread;\n\n    public void trylock() throws GetLockException {\n        boolean success = value.compareAndSet(0, 1);\n        if (!success) {\n            throw new GetLockException(\"获得锁失败\");\n        }\n        lockedThread = Thread.currentThread();\n    }\n\n    public void unlock() {\n        if (0 == value.get()) {\n            return;\n        }\n        if (lockedThread == Thread.currentThread()) {\n            //解铃还须系铃人\n            boolean success = value.compareAndSet(1, 0);\n            System.out.println(Thread.currentThread().getName() + \" 释放了锁\");\n        }\n    }\n}\n```\n\n其实挺简单的，值得注意的地方就是释放锁的时候别忘了判断是不是当前线程加的锁，解铃还须系铃人😂\n\n### ABA 问题\n\n> 从所周知，CAS 成立的条件就是共享变量当前值和当前线程所提供的旧值相同，我们就可以认为这个变量没有被修改过，那么问题来了，对于一个共享变量** V**，如果当前线程看到它的时候它的值是 A，当它想执行 CAS 修改这个变量的时候，另一个线程将** V **的值从 A-->B-->A，那么这时当前线程再来执行 CAS 的时候，是否可以认为变量** V **没有被修改过呢？这里执行肯定是会成功的，但是这样结果是否可以接受呢 ?\n\n#### 无法接受的例子\n\n![mark](http://static.imlgw.top///20190423/vakfPgUQChGb.png?imageslim)\n\n上图为用**单链表**实现的栈结构，若 T2 先抢到了执行权，将 A，B 弹出栈，然后依次`push`了 D，C，A，然后 T1 执行，利用 CAS，head.compareAndSet(A，B)，执行成功，栈顶变为 B，然而 B 就是个孤儿节点，这样一来 C，D 节点就被莫名其妙被丢掉了这显然是有问题的\n\n#### 如何解决 ABA 问题\n\n其实 ABA 问题并非完全无法接受，要考虑具体的场景，当然 Java 中也提供了解决的方案：\n\n`AtomicStampedReference` 这个类看名字就知道是带了戳的，带了一个类似版本号的东西，直接上源码吧。\n\n```java\npublic class AtomicStampedReference<V> {\n    private static class Pair<T> {\n        final T reference;\n        final int stamp;\n        private Pair(T reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <T> Pair<T> of(T reference, int stamp) {\n            return new Pair<T>(reference, stamp);\n        }\n    }\n\n    private volatile Pair<V> pair;\n\n    public AtomicStampedReference(V initialRef, int initialStamp) {\n        pair = Pair.of(initialRef, initialStamp);\n    }\n\n    /**\n     * Returns the current value of the reference.\n     *\n     * @return the current value of the reference\n     */\n    public V getReference() {\n        return pair.reference;\n    }\n\n    public int getStamp() {\n        return pair.stamp;\n    }\n\n    public V get(int[] stampHolder) {\n        Pair<V> pair = this.pair;\n        stampHolder[0] = pair.stamp;\n        return pair.reference;\n    }\n\n    public boolean weakCompareAndSet(V   expectedReference,\n                                     V   newReference,\n                                     int expectedStamp,\n                                     int newStamp) {\n        return compareAndSet(expectedReference, newReference,\n                             expectedStamp, newStamp);\n    }\n\n    /**\n     * Atomically sets the value of both the reference and stamp\n     * to the given update values if the\n     * current reference is {@code ==} to the expected reference\n     * and the current stamp is equal to the expected stamp.\n     *\n     * @param expectedReference the expected value of the reference\n     * @param newReference the new value for the reference\n     * @param expectedStamp the expected value of the stamp\n     * @param newStamp the new value for the stamp\n     * @return {@code true} if successful\n     */\n    public boolean compareAndSet(V   expectedReference,\n                                 V   newReference,\n                                 int expectedStamp,\n                                 int newStamp) {\n        Pair<V> current = pair;\n        return\n            expectedReference == current.reference && //期望值和当前值相等\n            expectedStamp == current.stamp &&\t//期望的戳和当前的戳一致\n            ((newReference == current.reference && //新的值是不是和当前的值一样\n              newStamp == current.stamp) ||\t\t//新的戳是不是和当前的戳一样\n             casPair(current, Pair.of(newReference, newStamp))); //如果不一样就利用 CAS 设置新值\n    }\n\n    public void set(V newReference, int newStamp) {\n        Pair<V> current = pair;\n        if (newReference != current.reference || newStamp != current.stamp)\n            this.pair = Pair.of(newReference, newStamp);\n    }\n\n    public boolean attemptStamp(V expectedReference, int newStamp) {\n        Pair<V> current = pair;\n        return\n            expectedReference == current.reference &&\n            (newStamp == current.stamp ||\n             casPair(current, Pair.of(expectedReference, newStamp)));\n    }\n\n    // Unsafe mechanics 底层调用 unsafe 的方法\n    private static final sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();\n    private static final long pairOffset =objectFieldOffset(UNSAFE, \"pair\", AtomicStampedReference.class);\n    //cas 设置新值\n    private boolean casPair(Pair<V> cmp, Pair<V> val) {\n        return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);\n    }\n\n    static long objectFieldOffset(sun.misc.Unsafe UNSAFE,\n                                  String field, Class<?> klazz) {\n        try {\n            return UNSAFE.objectFieldOffset(klazz.getDeclaredField(field));\n        } catch (NoSuchFieldException e) {\n            // Convert Exception to corresponding Error\n            NoSuchFieldError error = new NoSuchFieldError(field);\n            error.initCause(e);\n            throw error;\n        }\n    }\n}\n```\n\n这里删掉了部分注释， 可以看到里面封装了一个`Pair`里面有对象的引用和一个戳，在进行 CAS 的时候会判断`期望的引用`（传进来的引用）和`当前实际的引用`是不是一致，`期望的戳`（传进来的戳）和`当前实际的戳`是不是一致的，不一致就会直接`fail`，关键的 CAS 代码：\n\n```java\npublic boolean compareAndSet(V   expectedReference,\n                                 V   newReference,\n                                 int expectedStamp,\n                                 int newStamp) {\n        Pair<V> current = pair;\n        return  \n            expectedReference == current.reference && //期望值和当前值相等\n            expectedStamp == current.stamp &&\t//期望的戳和当前的戳一致\n            ((newReference == current.reference && //新的值是不是和当前的值一样\n              newStamp == current.stamp) ||\t\t//新的戳是不是和当前的戳一样\n             casPair(current, Pair.of(newReference, newStamp))); //如果不一样就利用 CAS 设置新值\n }\n```\n\n**测试 AtomicStampedReference**\n\n```java\npublic class AtomicRefStampedTest {\n   static AtomicStampedReference<Integer> reference=new AtomicStampedReference<>(100,0);\n\n    public static void main(String[] args) {\n        //第一个线程进行 ABA 操作\n        new Thread(()->{\n            try {\n                TimeUnit.SECONDS.sleep(1);\n                System.out.println(\"t1 \"+reference.compareAndSet(100, 101, reference.getStamp(), reference.getStamp()+1));\n                System.out.println(reference.getStamp()+\",\"+reference.getReference());\n                System.out.println(\"t1 \"+ reference.compareAndSet(101, 100,reference.getStamp() , reference.getStamp()+1));\n            } catch (InterruptedException e) {\n\n            }\n\n        }).start();\n\n\t\t//第二个线程等待第一个线程执行完\n        new Thread(()->{\n            try {\n                int stamp = reference.getStamp();\n                //假设执行到这里发生上下文切换\n                System.out.println(\"Before sleep:stamp=\"+stamp);\n                TimeUnit.SECONDS.sleep(5);\n                System.out.println(\"After sleep:stamp=\"+reference.getStamp());\n                boolean b = reference.compareAndSet(100, 101, stamp, stamp + 1);\n                System.out.println(b);\n            } catch (InterruptedException e) {\n\n            }\n        }).start();\n    }\n}\n/**\n\tBefore sleep:stamp=0\n\tt1 true\n\t1,101\n\tt1 true\n\tAfter sleep:stamp=2\n\tfalse\n**/\n```\n\n结果肯定是 t2 执行失败了，毕竟戳不一样了，就算引用一样也没用。\n\n#### 小插曲 (Integer 缓存）\n\n这里一开始发生了一个小插曲，首先这里是的引用类型是 `Integer`类型的，然后我在进行 CAS 的时候从 100--->200 , 然后又从 200-->100，可能细心的朋友已经知道啥问题了，后面的从 200-->100 会失败，为啥？这个 200 和前面的 200 不是一个对象，引用不一样，那为啥 101 就可以呢？对，Integer 有一个缓冲池，大小在-128--127 之间的数，可以直接从缓冲池中拿，我开始在这里纠结了好一会儿😂\n\n### 字段更新器\n\n如果我们只需要某个类里的某个字段，也就是说让普通的变量也享受原子操作，可以使用原子更新字段类，如在某些时候由于项目前期考虑不周全，项目需求又发生变化，使得某个类中的变量需要执行多线程操作，由于该变量多处使用，改动起来比较麻烦，而且原来使用的地方无需使用线程安全，只要求新场景需要使用时，可以借助原子更新器处理这种场景，Java 中提供了几种字段更新器`AtomicIntegerFieldUpdater`，`AtomicLongFieldUpdater`，`AtomicReferenceFieldUpdater`，看名字就知道是对应啥的\n\n#### AtomicIntegerFieldUpdater 测试\n\n```java\npublic class AtomicIntegerFieldUpdaterTest {\n    public static void main(String[] args) {\n        AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(TestUpdate.class, \"num\");\n        TestUpdate testUpdate = new TestUpdate();\n        Stream.of(\"t1\", \"t2\", \"t3\", \"t4\", \"t5\").forEach(s -> {\n            new Thread(() -> {\n                int MAX = 100;\n                for (int i = 0; i < MAX; i++) {\n                    System.out.println(updater.getAndIncrement(testUpdate));\n                }\n            }, s).start();\n        });\n    }\n\n    static class TestUpdate {\n        volatile int num;\n    }\n}\n```\n\n这样就保证了 Integer 字段自增操作的原子性，另外两个与之类似。\n\n**需要注意的地方**\n\n- 操作的字段不能是 static 类型。\n\n- 操作的字段不能是 final 类型的，因为 final 根本没法修改。\n\n- 字段必须是 volatile 修饰的，也就是数据本身是读一致的。\n\n- 属性必须对当前的 Updater 所在的区域是可见的，也就是说无论何时都应该保证操作类与被操作类间的可见性。\n\n![mark](http://static.imlgw.top///20190430/hIuzU4rePaAe.png?imageslim)\n\n> 使用字段更新器比起直接使用原子类要节约内存，但是操作起来不方便\n\n## Unsafe 双刃剑\n\n**Unsafe **类，看名字就知道不安全，并不是它写的不安全，而是用起来不安全，因为它可以像 c/c++一样去操作内存地址，**unsafe **里面的所有方法都是** native **的，底层都是 c/c++实现的，直接与操作系统底层交互，上面 CAS 执行也依赖于** unsafe **类中的方法，其实整个并发包里的类都依赖于** unsafe**，但是官方并不建议用户使用这个类\n\n- Unsafe 有可能在未来的 Jdk 版本移除或者不允许 Java 应用代码使用，这一点可能导致使用了 Unsafe 的应用无法运行在高版本的 Jdk\n- Unsafe 的不少方法中必须提供原始地址（内存地址）和被替换对象的地址，偏移量要自己计算，一旦出现问题就是 JVM 崩溃级别的异常，会导致整个 JVM 实例崩溃，表现为应用程序直接崩掉。\n- Unsafe 提供的直接内存访问的方法中使用的内存不受 JVM 管理（无法被 GC)，需要手动管理，一旦出现疏忽很有可能成为内存泄漏的源头。\n\n### 获取 Unsafe\n\n```java\n    //获取 Unsafe\n    public static Unsafe getUnsafe() {\n        Field f = null;\n        try {\n            f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            f.setAccessible(true);\n            return (Unsafe)f.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException();\n        }\n    }\n```\n\n### CAS 相关\n\nJava 中的 CAS 实现调用的就是三个本地方法，第一个参数代表的就是实例对象，第二个参数代表需要 CAS 字段在该实例上的偏移量（不用自己计算，Unsafe 提供了方法计算偏移量），第三个参数就是期望值，最后一个参数就是更新的值\n\n```java\npublic final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);\n\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n\npublic final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);\n```\n\n### 利用 Unsafe 自己写一个原子 Counter\n\n```java\nclass CASCounter implements Counter {\n    private volatile long counter = 0;\n\n    public CASCounter() throws NoSuchFieldException {\n        unsafe = getUnsafe();\n        //获取 counter 字段的内存偏移量\n        offset= unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(\"counter\"));\n        System.out.println(offset);\n    }\n\t\n    private Unsafe unsafe;\n    private long offset;\n    \n    public static Unsafe getUnsafe() {\n        Field f = null;\n        try {\n            f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            f.setAccessible(true);\n            return (Unsafe)f.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException();\n        }\n    }\n\n    @Override\n    public void increment() {\n        long current=counter;\n        while (!unsafe.compareAndSwapLong(this,offset,current,current+1)){\n            current=counter;\n        }\n    }\n\n    @Override\n    public long getCounter() {\n        return counter;\n    }\n}\n\ninterface Counter {\n    void increment();\n\n    long getCounter();\n}\n```\n\n### Unsafe 的骚操作\n\n**绕过构造器创建对象**\n\n```java\npublic class UnsafeFooTest {\n    public static void main(String[] args) throws ClassNotFoundException,InstantiationException, NoSuchFieldException {\n        Unsafe unsafe = UnsafeTest.getUnsafe();\n        //绕过构造器创建对象\n        Simple simple = (Simple) unsafe.allocateInstance(Simple.class);\n        System.out.println(simple.get()); //null\n        System.out.println(simple.getClass().getClassLoader());\n    }\n\n    static class Simple {\n        private String a = \"a\";\n        public Simple() {\n            a = \"new\";\n            System.out.println(\"============== \");\n        }\n\n        public String get() {\n            return a;\n        }\n        static {\n            System.out.println(\"静态代码块\");\n        }\n    }\n}\n```\n\n**修改字段在内存中的值**\n\n```java\npublic class UnsafeFooTest {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, NoSuchFieldException {\n        Unsafe unsafe = UnsafeTest.getUnsafe();\n        Permission permission = new Permission();\n        permission.doSth();\n        //通过反射也可以做到，但是 unsafe 直接是到内存地址中将值修改了\n        Field access_allow = permission.getClass().getDeclaredField(\"ACCESS_ALLOW\");\n        //获取字段再对象中的内存偏移量，可以简单理解为指针（内存地址）\n        unsafe.putLong(permission,unsafe.objectFieldOffset(access_allow),-1);\n        permission.doSth();\n    }\n}\n\nclass Permission {\n    private int ACCESS_ALLOW = 0;\n\n    private boolean isAllow() {\n        return  ACCESS_ALLOW==-1;\n    }\n\n    public void doSth() {\n        if (isAllow()) {\n            System.out.println(\"i am workind\");\n        }\n    }\n}\n```\n\n**defindClass 加载类文件**\n\n```java\npublic class UnsafeFooTest {\n\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n        Unsafe unsafe = UnsafeTest.getUnsafe();\n        byte[] bytes = loadClassContent();\n        Class<?> aClass = unsafe.defineClass(null, bytes, 0, bytes.length, ClassLoader.getSystemClassLoader(), null);\n        int get = (int) aClass.getMethod(\"get\").invoke(aClass.newInstance(), null);\n        System.out.println(get);\n    }\n    \n    //将 class 字节码加载到内存中\n    public static byte[] loadClassContent() {\n        File f = new File(\"D:\\\\ClassLoaderTest\\\\Res.class\");\n        FileInputStream stream = null;\n        byte[] bytes=null;\n        try {\n            stream = new FileInputStream(f);\n             bytes = new byte[(int) f.length()];\n            stream.read(bytes);\n            stream.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return bytes;\n    }\n}\n```\n\n将编译好的 class 文件放到对应的目录下\n\n```java\npublic class Res {\n    private int i=0;\n\n    public Res(){\n        this.i=1;\n    }\n\n    public int get() {\n        return i;\n    }\n}\n```\n\n**结果**，是不是很牛皮？🐂🍺是🐂🍺但是这个玩意尽量的别用。\n\n![mark](http://static.imlgw.top/blog/20190720/zLJJUhQ6GAdc.png?imageslim)\n\n**Unsafe **里面的方法还有很多这里就不都列举了，毕竟暂时还用不到，如果想了解更多可以看看这几篇文章\n\n- [JAVA 中神奇的双刃剑--Unsafe](https://www.cnblogs.com/throwable/p/9139947.html)\n\n- [R 大关于 Unsafe 的使用建议](https://www.zhihu.com/question/29266773?sort=created)\n\n- [Java 魔法类：Unsafe 应用解析](https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html)","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"Java 多线程之设计模式","url":"/2019/04/09/22c0ee69/","content":"\n## 观察者模式\n\n>  观察者订阅被观察者的状态，当被观察者状态改变的时候会通知所有订阅的观察者的过程\n\n**观察者接口**\n\n```java\npublic  abstract class Observer {\n    protected Subject subject;\n\n    public Observer(Subject subject){\n        this.subject=subject;\n        subject.attach(this);\n    }\n\n    public  abstract  void update();\n}\n```\n\n**观察者 1**\n\n```java\npublic class BinaryObserver extends Observer{\n\n    public BinaryObserver(Subject subject) {\n        super(subject);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"Binarry String :\"+ Integer.toBinaryString(subject.getState()));\n    }\n}\n```\n\n**观察者 2**\n\n```java\npublic class OctalOberver extends Observer{\n    public OctalOberver(Subject subject) {\n        super(subject);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"Octal String:\"+Integer.toOctalString(subject.getState()));\n    }\n}\n```\n\n**被观察者**\n\n```java\npublic class Subject {\n    //观察者们\n    private  List<Observer> observers = new ArrayList<>();\n\n    private int state;\n\n    public int getState(){\n        return this.state;\n    }\n\t\n    //注册观察者\n    public void attach(Observer observer){\n        observers.add(observer);\n    }\n\n    public void setState(int state){\n        if(state==this.state){\n            return;\n        }\n        this.state=state;\n        notifyAllObserver();\n    }\n    //通知所有观察者线程\n    private  void  notifyAllObserver(){\n        observers.stream().forEach(Observer::update);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class ObserverCLi {\n    public static void main(String[] args) {\n        final Subject subject=new Subject();\n        BinaryObserver binary=new BinaryObserver(subject);\n        OctalOberver octalOberver = new OctalOberver(subject);\n        System.out.println(\"==================\");\n        subject.setState(10);\n        System.out.println(\"==================\");\n        subject.setState(12);\n    }\n}\n```\n\n## 读写锁分离模式\n\n```java\npublic class ReadWriteLock {\n    private int readingR = 0;\n    private int waitingR = 0;\n    private int writingW = 0;\n    private int waitingW = 0;\n\n    public synchronized void readLock() throws InterruptedException{\n        this.waitingR++;\n        try {\n            //如果有线程在写就不能读\n            while (writingW > 0) {\n                this.wait();\n            }\n            this.readingR++;\n        }finally {\n            this.waitingR--;\n        }\n    }\n\n    public synchronized void readUnlock() throws InterruptedException{\n        this.readingR--;\n        notifyAll();\n    }\n\n    public synchronized void writeLock() throws InterruptedException{\n        this.waitingW++;\n        try {\n            while (readingR>0||writingW>0){\n                this.wait();\n            }\n            this.writingW++;\n        }finally {\n            this.waitingW--;\n        }\n    }\n\n    public synchronized void writeUnlock() throws InterruptedException{\n        this.writingW--;\n        notifyAll();\n    }\n\n}\n```\n\n只有读的时候不加锁，其他的时候加锁，在读的操作多于写的操作时，效率提升明显。\n\n## 不可变对象设计模式\n\n这个设计模式还是很重要也很常见的，`不可变`顾名思义，一个对象在被创建后对象所有的状态和属性都在其生命周期内都不会发生任何变化。\n\n> 不可变对象一定是线程安全的（里面的任何属性或者应用类型的都不能被修改），可变对象不一定是线程安全的 (SrtingBuffer)。J2EE 里面，Servlet 就不是线程安全的，struts1 的 Action 也不是线程安全的。\n\n通常来说，创建不可变类原则有以下几条：\n\n① 所有成员变量必须是`private`\n\n② 最好同时用`final`修饰（非必须）\n\n③ 不提供能够修改原有对象状态的方法\n\n- 最常见的方式是不提供 setter 方法\n\n- 如果提供修改方法，需要新创建一个对象，并在新创建的对象上进行修改\n\n④ 通过构造器初始化所有成员变量，引用类型的成员变量必须进行深拷贝 (deep copy)\n\n⑤ getter 方法不能对外泄露 this 引用以及成员变量的引用\n\n⑥ 最好不允许类被继承（非必须）\n\n　　JDK 中提供了一系列方法方便我们创建不可变集合，如：\n\n`Collections.unmodifiableList(List<? extends T> list)`\n\n```java\nfinal public class Person {\n    //定义成 final\n    private final String name;\n    private final String address;\n\n    public Person(final String name,final String address) {\n        this.name = name;\n        this.address = address;\n    }\n\n    public String getAddress() {\n\n        return address;\n    }\n\n    public String getName() {\n\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n虽然说是不可变对象，但是其实通过反射等方法还是可以改变的。\n\n```java\npublic class StringTest {\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n        /*String s=\"Hello\";\n        String s1=s.replace(\"l\",\"K\");\n        System.out.println(s.hashCode());\n        System.out.println(s1.hashCode());*/\n        String s = \"Hello World\";\n        System.out.println(\"s = \" + s);//Hello World\n\t\t//String 类里面的 char[]\n        Field valueFieldOfString = String.class.getDeclaredField(\"value\");\n        valueFieldOfString.setAccessible(true);\n\n        char[] value = (char[]) valueFieldOfString.get(s);\n        value[5] = '_';\n        System.out.println(\"s = \" + s); //Hello_World\n    }\n}\n```\n\n## Future 设计模式（异步）\n\n`Future`接口\n\n```java\npublic interface Future<T> {\n    T get() throws InterruptedException;\n}\n\n```\n\n`FutureTask`接口\n\n```java\npublic interface FutureTask<T> {\n    T call();\n}\n```\n\n`AsynFuture`异步\n\n```java\npublic class AsynFuture<T> implements Future<T> {\n    private volatile boolean done = false;\n\n    private T result;\n\n    public void done(T result) {\n        synchronized (this) {\n            this.result = result;\n            this.done = true;\n            //完成任务通知调用者\n            this.notifyAll();\n        }\n    }\n\n    @Override\n    public T get() throws InterruptedException {\n        synchronized (this) {\n            while (!done) {\n                this.wait();\n            }\n        }\n        return result;\n    }\n}\n```\n\n`FutureService`连接`Future`和`FutureTask`\n\n```java\npublic class FutureService {\n\n    public <T> Future<T> submit(final FutureTask<T> task) {\n        AsynFuture<T> asynFuture = new AsynFuture<>();\n        new Thread(() -> {\n            T result = task.call();\n            asynFuture.done(result);\n        }).start();\n        return asynFuture;\n    }\n\n    //java8 回调 callback\n    public <T> Future<T> submit(final FutureTask<T> task, final Consumer<T> consumer) {\n        AsynFuture<T> asynFuture = new AsynFuture<>();\n        new Thread(() -> {\n            T result = task.call();\n            asynFuture.done(result);\n            consumer.accept(result);\n        }).start();\n        return asynFuture;\n    }\n}\n```\n测试`Future`\n\n```java\npublic class SyncInvoker {\n    public static void main(String[] args) throws InterruptedException {\n\n        FutureService futureService = new FutureService();\n        Future<String> submit = futureService.submit(() -> {\n            try {\n                Thread.sleep(10000l);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"FINISH\";\n        },System.out::println);\n\n        System.out.println(\"===========\");\n        System.out.println(\" do other thing.\");\n        Thread.sleep(1000);\n        System.out.println(\"===========\");\n    }\n\n    private static String get()\n            throws InterruptedException {\n        Thread.sleep(10000l);\n        return \"FINISH\";\n    }\n}\n```\n\n> Future   ->未来的票据\n>\n> FutureTask   ->实际执行的任务\n>\n> FutureService  ->桥接 Future 和 FutureTask\n\n## Guarded Suspension 设计模式\n\n`保护性暂挂模式`\n\nGuarded 是被守护的意思。Suspension 是暂停的意思，Guarded Suspension 模式通过让线程等待来保证实例的安全性。\n\n> 核心思想：如果某个线程执行特定的操作前需要满足一定的条件，则在该条件未满足时将线程暂停运行（即暂挂线程，使其处于等待（waiting）状态，直到该条件满足时才继续运行）\n\n**Request 对象**\n\n```java\npublic class Request {\n    final private String value;\n\n    public Request(String value) {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```\n\n**RequestQueue**\n\n```java\npublic class RequestQueue {\n    private final LinkedList<Request> queue = new LinkedList<>();\n\n    public Request getRequest() {\n        synchronized (queue) {\n            while (queue.size() <= 0) {\n                try {\n                    //队列为空等一下\n                    queue.wait();\n                } catch (InterruptedException e) {\n                    return null;\n                }\n            }\n            Request request = queue.removeFirst();\n            return request;\n        }\n    }\n\n    public void putRequest(Request request) {\n        synchronized (queue) {\n            queue.addLast(request);\n            queue.notifyAll();\n        }\n    }\n}\n```\n\n**Server**\n\n```java\npublic class ServerThread extends Thread{\n    private final RequestQueue queue;\n\n    private final Random random;\n\n    private volatile boolean closed = false;\n\n    public ServerThread(RequestQueue queue) {\n        this.queue = queue;\n        random = new Random(System.currentTimeMillis());\n    }\n\n    @Override\n    public void run() {\n        while (!closed) {\n            Request request = queue.getRequest();\n            //get 可能会返回 null\n            if (null == request) {\n                System.out.println(\"Received the empty request.\");\n                break;\n            }\n            System.out.println(\"Server ->\" + request.getValue());\n            try {\n                Thread.sleep(random.nextInt(1000));\n            } catch (InterruptedException e) {\n                //打断后直接 return\n                return;\n            }\n        }\n    }\n\n    public void close() {\n        this.closed = true;\n        this.interrupt();\n    }\n}\n```\n\n**Client**\n\n```java\npublic class ClientThread extends Thread {\n    private final RequestQueue queue;\n\n    private final Random random;\n\n    private final String sendValue;\n\n    public ClientThread(RequestQueue queue, String sendValue) {\n        this.queue = queue;\n        this.sendValue = sendValue;\n        random = new Random(System.currentTimeMillis());\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"Client -> request \" + sendValue);\n            //客户端发送请求\n            queue.putRequest(new Request(sendValue));\n            try {\n                Thread.sleep(random.nextInt(1000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class SuspensionClient {\n    public static void main(String[] args) throws InterruptedException {\n        final RequestQueue queue = new RequestQueue();\n        new ClientThread(queue, \"Shaw\").start();\n        ServerThread serverThread = new ServerThread(queue);\n        serverThread.start();\n        //serverThread.join(); join 住了后面还咋 close？？？\n        Thread.sleep(10000);\n        serverThread.close();\n    }\n}\n```\n\n## ThreadLocal\n\n线程局部变量，线程保险箱，以`Thread`作为`key`\n\n> This class provides `thread-local variables`. These variables differ from their normal counterparts in that each thread that accesses one (via its `get` or `set` method) has its own, independently initialized copy of the variable.\n\n模拟`ThreadLocal`\n\n```java\npublic class ThreadLocalSimulator<T> {\n    private final Map<Thread,T> threadMap=new HashMap<>();\n\n    public void set(T t){\n        Thread currentThread=Thread.currentThread();\n        synchronized (threadMap){\n            threadMap.put(currentThread,t);\n        }\n    }\n\n    public T get(){\n        Thread currentThread =Thread.currentThread();\n        if(threadMap.get(currentThread)==null){\n             threadMap.put(currentThread,initVal());\n        }\n        return threadMap.get(currentThread);\n    }\n\n    protected T initVal() {\n        return null;\n    }\n}\n```\n\n## Balking 设计模式\n\n>核心思想：当不再适合或者没有必要进行这个操作时，就直接放弃进行这个操作而直接返回，不需要就算了\n\n```java\npublic class BalkingData {\n    private final String fileName;\n\n    private String content;\n\n    private boolean changed;\n\n    public BalkingData(String fileName, String content, boolean changed) {\n        this.fileName = fileName;\n        this.content = content;\n        this.changed = changed;\n    }\n\n    public synchronized void change(String newContent) {\n        this.content = newContent;\n        this.changed = true;\n    }\n\n    public synchronized void save() throws IOException {\n        if (!changed) {\n            //顾客没有服务请求，那么放弃提供服务操作，直接返回。\n            return;\n        }\n        doSave();\n        this.changed = false;\n    }\n\n    private void doSave() throws IOException {\n        System.out.println(Thread.currentThread().getName() + \" call  do save content\");\n        try(Writer writer = new FileWriter(fileName, true)) {\n            writer.write(content);\n            writer.write(\"\\n\");\n            writer.flush();\n        }\n    }\n}\n```\n\n**CustomerThread**\n\n```java\npublic class CustomerThread extends Thread {\n\n    private final BalkingData balkingData;\n\n    private final Random random = new Random(System.currentTimeMillis());\n\n    public CustomerThread(BalkingData balkingData) {\n        super(\"Customer\");\n        this.balkingData = balkingData;\n    }\n\n    @Override\n    public void run() {\n        try {\n            balkingData.save();\n            for (int i = 0; i < 20; i++) {\n                balkingData.change(\"No.\" + i);\n                Thread.sleep(random.nextInt(1000));\n                balkingData.save();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**WaiterThread**\n\n```java\npublic class WaiterThread extends Thread {\n\n    private final BalkingData balkingData;\n\n    public WaiterThread(BalkingData balkingData) {\n        super(\"Waiter\");\n        this.balkingData = balkingData;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 200; i++) {\n            try {\n                balkingData.save();\n                Thread.sleep(1_000L);\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## CountDown 设计模式\n\n**CountDown**\n\n```java\npublic class CountDown {\n    private final int total;\n\n    //计数器\n    private int counter;\n\n    public CountDown(int total) {\n        this.total = total;\n    }\n\n    public void down(){\n        synchronized (this){\n            this.counter++;\n            this.notifyAll();\n        }\n    }\n\n    public void await() throws InterruptedException {\n        synchronized (this){\n            while (counter!=total){\n                this.wait();\n            }\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class JDKCountDown {\n\n    private static final Random random = new Random(System.currentTimeMillis());\n\n    public static void main(String[] args) throws InterruptedException {\n        //JDK 的 CountDown\n        //final CountDownLatch latch=new CountDownLatch(5);\n        final CountDown latch=new CountDown(5);\n\n        System.out.println(\"准备多线程处理任务\");\n        //the first phase\n        IntStream.range(0,5).forEach(i->{\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+\" is working\");\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                latch.down();\n            },String.valueOf(i)).start();\n        });\n        latch.await();\n        //the second phase\n        System.out.println(\"多线程任务全部结束，准备第二阶段任务\");\n        System.out.println(\"........\");\n        System.out.println(\"Finish\");\n    }\n}\n```\n\n## 单例模式\n\n### Double check\n\n```java\npublic class SingletonObjectPlus {\n    private static volatile  SingletonObjectPlus singletonObjectPlus =null;\n    public static SingletonObjectPlus getSingletonObject3(){\n    \tif(singletonObjectPlus==null){\n        \tsynchronized(SingletonObject.class){\n            \tif(singletonObjectPlus==null){\n                \tsingletonObjectPlus= new SingletonObjectPlus();\n            \t}\n        \t}\n    \t}\n     \treturn singletonObjectPlus;\n\t}\n}\n```\n\n> 这种方式在实例对象上要加上 `volatile`，避免实例对象没有初始化完成就返回\n\n### InstanceHolder\n\n```java\npublic class SingleGraceful {\n    private SingleGraceful(){\n\n    }\n    //private 静态内部类\n    private static class InstanceHolder{\n        //只会被初始化一次\n        private final static SingleGraceful instance=new SingleGraceful();\n    }\n\n    public static SingleGraceful getInstance(){\n        return SingleGraceful.InstanceHolder.instance;\n    }\n}\n```\n\nJVM 只会为 static 变量分配一次内存，也就是只会初始化一次，而内部类不会在其外部类被加载的同时被加载，所以这也是一种很简洁很优秀的单例\n\n### Enum\n\n```java\npublic class SingleGraceful2 {\n    private SingleGraceful2() {}\n    \n    private enum Singleton {\n        INSTANCE;\n        \n        private final SingleGraceful2 instance;\n\n        Singleton() {\n            instance = new SingleGraceful2();\n        }\n\n        public SingleGraceful2 getInstance() {\n            return instance;\n        }\n    }\n    public static SingleGraceful2 getInstance() {\n        return Singleton.INSTANCE.getInstance();\n    }\n}\n```\n\n- 枚举类构造函数是`private`类型的\n- 枚举类的域 (field)(`INSTANCE`) 其实是相应的 enum 类型 (`Singleton`) 的一个静态实例对象，所以只会被初始化一次，构造器也只会被调用一次\n- 枚举单例可以防止`反序列化` ，`反射`，`克隆`对单例的破坏，所以是一种极其优秀的单例实现。\n\n> 这里其实还有很多没有介绍出来，设计模式这些东西没有实际的场景去用确实难以体会到它的精髓，需要慢慢的积累经验才行。\n","tags":["多线程","设计模式"],"categories":["并发"]},{"title":"Java 多线程基础","url":"/2019/04/07/32b13d92/","content":"## 1. 线程与进程区别\n\n每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。\n\n使用线程可以把占据时间长的程序中的任务放到后台去处理，程序的运行速度可能加快，在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。\n\n如果有大量的线程，会影响性能，因为操作系统需要在它们之间切换，更多的线程需要更多的内存空间，线程的中止需要考虑其对程序运行的影响。通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。\n\n总结：进程是所有线程的集合，每一个线程是进程中的一条执行路径。\n\n## 2. 为什么要使用多线程？多线程应用场景？\n\n答：主要能体现到多线程提高程序效率。\n\n举例：迅雷多线程下载、数据库连接池、分批发送短信等。\n\n## 3. 线程创建方式\n\n### 继承 Thread 类重写 run 方法\n\n```java\nclass PlayGame extends Thread {\n\tpublic void run() {\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tSystem.out.println(\"PlayGame\" + (i + 1));\n\t\t}\n\t}\n\t//void say() {}\n}\n\nclass ListenMusic extends Thread {\n\tpublic void run() {\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tSystem.out.println(\"ListenMusic\" + (i + 1));//底层操作居然是用的 StringBuilder\n\t\t}\n\t}\n}\n\npublic class ThreadDemo {\n\tpublic static void main(String[] args)\n\t{\n\t\tThread music = new ListenMusic();\n\t\tThread pg = new PlayGame();\n\t\tmusic.start(); //三个线程同时运行抢占资源\n\t\ttry {\n\t\t\tpg.start();\n\t\t\tfor (int i = 0; i < 50; i++) {\n\t\t\t\tSystem.out.println(\"    main 方法：\" + (i + 1));\n\t\t\t}\n\t\t\tpg.start();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"出现了 IllegalThreadStateException 异常\");\t  //线程只能启动一次\n\t\t}\n\t}\n}\n\n```\n这种方法官方也不推荐使用因为 Java 是单继承的继承了 Thread 类之后就不能继承其他的类\n\n### 实现 Runnable 接口\n\n```java\nclass CreateRunnable implements Runnable {\n\n\t@Override\n\tpublic void run() {\n\t\tfor (inti = 0; i< 10; i++) {\n\t\t\tSystem.out.println(\"i:\" + i);\n\t\t}\n\t}\n\n}\n\npublic class ThreadDemo2 {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"-----多线程创建开始-----\");\n\t\t// 1. 创建一个线程\n\t\tCreateRunnable createThread = new CreateRunnable();\n\t\t// 2. 开始执行线程 注意 开启线程不是调用 run 方法，而是 start 方法\n\t\tSystem.out.println(\"-----多线程创建启动-----\");\n\t\tThread thread = new Thread(createThread);\n\t\tthread.start();\n\t\tSystem.out.println(\"-----多线程创建结束-----\");\n\t}\n}\n\n```\n### 匿名内部类\n\n```java\npublic class InClass {\n\tpublic static void main(String[] args) {\n\t\t Thread thread = new Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor (int i = 0; i< 100; i++) {\n\t\t\t\t\t\tSystem.out.println(\"i:\" + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\tthread.start();\n\n\t\t //lambda 表达式还是比较简洁\n\t\t new Thread(()-> {for (int i = 0; i <100; i++) {System.out.println(\"lambda:\" +i);}}).start();\n\t}\n}\n\n```\n线程创建方式不只这些还有很多，后面再介绍\n\n### Thread 类中的 start() 和 run() 方法有什么区别？\n\n这个问题经常被问到，但还是能从此区分出面试者对 Java 线程模型的理解程度。`start()`方法被用来启动新创建的线程，而且`start()`内部 native 方法`start0()`调用了 run() 方法，这和直接调用`run()`方法的效果不一样。当你调用`run()`方法的时候，只会是在原来的线程中调用，没有新的线程启动，`start()`方法才会启动新线程\n\n## 4.Thread 构造函数\n\n| **常用线程 api 方法**| |\n|:--|---|\n| start()| 启动线程|\n| currentThread()| 获取当前线程对象|\n| getID()| 获取当前线程 ID   Thread-编号 该编号从 0 开始|\n| getName()| 获取当前线程名称|\n| sleep(long mill)| 休眠线程|\n| Stop（）| 停止线程，|\n| **常用线程构造函数** | |\n| Thread（）| 分配一个新的 Thread 对象|\n| Thread（String name）| 分配一个新的 Thread 对象，具有指定的 name 正如其名。|\n| Thread（Runnable r）| 分配一个新的 Thread 对象|\n| Thread（Runable r, String name）| 分配一个新的 Thread 对象，具有指定的 name 正如其名。|\n| Thread(ThreadGroup group, Runnable target) | 分配一个新的 Thread 对象，如果不传`ThreadGroup`默认加入当前线程的`ThreadGroup`中 |\n| Thread(ThreadGroup group, Runnable target, String name) | 分配一个新的 `Thread`对象，使其具有  `target`作为其运行对象，具有指定的 `name`作为其名称，属于  `group`引用的线程组。 |\n| Thread(ThreadGroup group, Runnable target, String name,  long stackSize) | 分配一个新的 `Thread`对象，以便它具有  `target`作为其运行对象，将指定的 `name`正如其名，以及属于该线程组由称作  `group` ，并具有指定的 *堆栈大小* |\n\n### Thread 构造方法的一些细节\n\n直接上源码\n\n```java\nprivate void init(ThreadGroup g, Runnable target, String name,\n                  long stackSize, AccessControlContext acc,\n                  boolean inheritThreadLocals) {\n    if (name == null) {\n        throw new NullPointerException(\"name cannot be null\");\n    }\n\n    this.name = name;\n\n    Thread parent = currentThread();\n    SecurityManager security = System.getSecurityManager();\n    if (g == null) {\n        /* Determine if it's an applet or not */\n\n        /* If there is a security manager, ask the security manager\n               what to do. */\n        if (security != null) {\n            g = security.getThreadGroup();\n        }\n\n        /* If the security doesn't have a strong opinion of the matter\n               use the parent thread group. */\n        if (g == null) {\n            g = parent.getThreadGroup();\n        }\n    }\n\n    /* checkAccess regardless of whether or not threadgroup is\n           explicitly passed in. */\n    g.checkAccess();\n\n    /*\n         * Do we have the required permissions?\n         */\n    if (security != null) {\n        if (isCCLOverridden(getClass())) {\n            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n        }\n    }\n\n    g.addUnstarted();\n    this.group = g;\n    //这里继承了父类的一些属性\n    this.daemon = parent.isDaemon();\n    this.priority = parent.getPriority();\n\n    if (security == null || isCCLOverridden(parent.getClass()))\n        this.contextClassLoader = parent.getContextClassLoader();\n    else\n        this.contextClassLoader = parent.contextClassLoader;\n    this.inheritedAccessControlContext =\n        acc != null ? acc : AccessController.getContext();\n    //传入的 Runnable 接口\n    this.target = target;\n    setPriority(priority);\n    if (inheritThreadLocals && parent.inheritableThreadLocals != null)\n        this.inheritableThreadLocals =\n        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n    /* Stash the specified stack size in case the VM cares */\n    this.stackSize = stackSize;\n\n    /* Set thread ID */\n    tid = nextThreadID();\n}\n```\n\n① 创建的线程会继承父线程的一些属性，是否是守护线程 ，和优先级。\n\n②使用 Thread(Runnable r) 创建线程时`this.target = target`传入的`Runnable`接口在这里赋值然后会在`run 方法`中被调用。\n\n③`stacksize`这个参数会影响`虚拟机栈`的大小，这个值越大能存放的`栈帧`就越多，可达到的递归深度越深，但是这个参数不一定有效，有的平台可能并没有效果，具体的`JVM`底层的知识等后面学到再来细化\n\n④一种奇怪的写法，这里只会执行重写`Thread`的`run`方法，这里从源码上可以看出来，传递`Runnable`接口其实是在 Thread 的 run 方法中调用了`target`的`run`方法，如果同时再`继承`Thread 类，重写`run`方法，调用的就不再是 Thread 类的 run 方法，而是匿名 Thread 子类重写的 run 方法\n\n```java\nThread t = new Thread(() -> {\n    System.out.println(\"Runnable\");\n}) {\n    @Override\n    public void run() {\n        System.out.println(\"Thread\");\n    }\n};\n```\n\n④线程`tid`通过`threadSeqNumber`从 0 自增的来，main 线程是第`10`个线程因为会有一些守护线程会在 main 启动前启动。\n\n## 5. 守护线程\n\nJava 中有两种线程，一种是用户线程，另一种是守护线程。\n\n用户线程是指用户自定义创建的线程，主线程停止，用户线程不会停止\n\n- 守护线程顾名思义当父线程结束时，守护线程也会被停止。\n- JVM 只有在最后一个非守护线程结束后才会退出\n- 在线程 start 前`setDaemon(true)`方法设置为守护线程，否则就会报错\n- 父线程是守护线程，子线程默认是守护线程。\n\n```java\nclass Daemon implements Runnable {\n    public void run() {\n        for(int i=0;i<500;i++) {\n            System.out.println(Thread.currentThread().getName()+i);\n        }\n    }\n}\n\npublic class DaemonDemo {\n    public static void main(String[]args) {\n        System.out.println(Thread.currentThread().getPriority());\n        Thread r1=new Thread(new Daemon(),\"后台线程\");     //设置该线程为后台线程\n        r1.setDaemon(true);                        //前台线程挂掉后，后台线程就会挂掉\n        for(int i=0;i<50;i++) {                   \n            System.out.println(\"main\"+i);\n            if(i==10) {\n                r1.start();\n            }\n        }\n        System.out.println(\"主线程执行完毕\");\n    }\n}\n```\n\n### 应用场景\n\n`心跳检测`，在通信过程中会需要判断对方是否在线，会需要创建一条线程去做这些事情，但是如果这样会导致`主线程停止工作`了，但是检测心跳的线程仍然在继续工作，JVM 就无法停下来，显然这样时不合理的，这时就可以把检测心跳的线程设置为`守护线程`，这样当它主线程停止工作时它的守护线程也会随之停止。\n\n```java\n//心跳检测 MOCK\npublic static void main(String[] args) throws InterruptedException {\n        Thread t = new Thread(() -> {\n            Thread inThread = new Thread(() -> {\n                while (true) {\n                    System.out.println(\"start heart check\");\n                    try {\n                        Thread.sleep(1_00);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            //将子线程设置为守护线程\n            inThread.setDaemon(true);\n            inThread.start();\n            try {\n                Thread.sleep(1_000);\n                System.err.println(\"Thread finish done...\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        t.start();\n        //主线程 (main)-->t-->inThread\n    }\n```\n\n## 6. 线程的状态\n\n线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。\n\n![mark](http://static.imlgw.top///20181226/WXPYz3SiidMT.png?imageslim)\n\n- 新建状态\n  当用 new 操作符创建一个线程时， 例如 new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码\n\n- 就绪状态\n  一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的 start() 方法。当线程对象调用 start() 方法即启动了线程，start() 方法创建线程运行的系统资源，并调度线程运行 run() 方法。当 start() 方法返回后，线程就处于就绪状态。\n  处于就绪状态的线程并不一定立即运行 run() 方法，线程还必须同其他线程竞争 CPU 时间，只有获得 CPU 时间才可以运行线程。因为在单 CPU 的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由`Java`运行时系统的线程调度程序 (*thread scheduler*) 来调度的。\n\n- 运行状态\n  当线程获得 CPU 时间后，它才进入运行状态，真正开始执行 run() 方法。\n\n- 阻塞状态\n  线程运行过程中，可能由于各种原因进入阻塞状态：\n  1>线程通过调用 sleep 方法进入睡眠状态；\n  2>线程调用一个在 I/O 上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；\n  3>线程试图得到一个锁，而该锁正被其他线程持有；\n  4>线程在等待某个触发条件；\n\n- 死亡状态\n\n  有两个原因会导致线程死亡：\n\n  1) run 方法正常退出而自然死亡，\n\n  2) 一个未捕获的异常终止了 run 方法而使线程猝死。 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用`isAlive`方法。如果是可运行或被阻塞，这个方法返回 true； 如果线程仍旧是 new 状态且不是可运行的， 或者线程死亡了，则返回 false.\n\n## 7.join() 方法\n\n### 源码解析\n\n```java\n public final synchronized void join(long millis) throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n        if (millis == 0) {\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {\n            while (isAlive()) {\n                long delay = millis - now;\n                if (delay <= 0) {\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n```\n\n①`thread.join()`没有参数会默认调用`join(0)`然后回轮询检查调用`join()`的线程也就是是`thread`线程是否`isAlive()`如果 thread 依然存活就回释放`当前线程`的 CPU 执行权，然后继续轮询，知道`thread`进入终止状态。\n\n②`join(long millis)` 参数的作用就是当前线程最多等待时间，限时等待，避免无止境的等待。\n\n③一个线程自己调用自己的`join`方法该线程就回一直`wait`下去因为他自己要一直等自己😄\n\n### 应用场景\n\n>  多线程同时采集数据，最后将统计的总时间等信息存到数据库中，如果不 jion 就无法统一结束的时间\n\n```java\npublic class ThreadJoin3 {\n    public static void main(String[] args) throws InterruptedException {\n        long l1 = System.currentTimeMillis();\n        Thread t0 = new Thread(new CaptureMachine(\"M0\", 1000));\n        Thread t1 = new Thread(new CaptureMachine(\"M1\", 2000));\n        Thread t2 = new Thread(new CaptureMachine(\"M2\", 4000));\n        t0.start();\n        t1.start();\n        t2.start();\n        //让主线程等待子线程结束然后统计最后总体结束的时间\n        t0.join();\n        t1.join();\n        t2.join();\n        long l = System.currentTimeMillis();\n        System.out.println(\"end save begin timestamp:\" + l1 + \"end timestamp\" + l);\n    }\n}\n\nclass CaptureMachine implements Runnable {\n    private String machineId;\n\n    private long spentTime;\n\n    public CaptureMachine(String machineId, long spentTime) {\n        this.machineId = machineId;\n        this.spentTime = spentTime;\n    }\n\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(spentTime);\n            System.out.println(machineId + \" capture done\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 8. 优先级\n\n现代操作系统基本采用时分的形式调度运行的线程，线程分配得到的时间片的多少决定了线程使用处理器资源的多少，也对应了线程优先级这个概念。在 JAVA 线程中，通过一个 int priority 来控制优先级，范围为 1-10，其中 10 最高，默认值为 5。下面是 Demo（基于 1.8）中关于 priority 的一些量和方法。\n\n```java\npublic class ThreadSimpleAPI2 {\n    public static void main(String[] args) {\n        Thread t0 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                Optional.of(Thread.currentThread().getName() + \"-index\" + i).ifPresent(System.out::println);\n            }\n        });\n        t0.setPriority(Thread.MAX_PRIORITY);\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                Optional.of(Thread.currentThread().getName() + \"-index\" + i).ifPresent(System.out::println);\n            }\n        });\n        t1.setPriority(Thread.NORM_PRIORITY);\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                Optional.of(Thread.currentThread().getName() + \"-index\" + i).ifPresent(System.out::println);\n            }\n        });\n        t2.setPriority(Thread.MIN_PRIORITY);\n        t0.start();\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n## 9.Interrupt 方法 \n\n### 看看源码\n\n```java\npublic void interrupt() {\n        if (this != Thread.currentThread())\n            checkAccess();\n\n        synchronized (blockerLock) {\n            Interruptible b = blocker;\n            if (b != null) {\n                interrupt0();           // Just to set the interrupt flag\n                b.interrupt(this);\n                return;\n            }\n        }\n        interrupt0();\n}\n```\n\n在知乎上看见一个好的回答：首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己`自行停止`。所以，`Thread.stop()` ,`Thread.suspend()`,`Thread.resume()`都已经被废弃了。而`Thread.interrupt()`的作用也不是中断线程，_而是通知线程该结束了_ 具体中断还是继续运行还是由被通知的线程自己处理。具体来说，当对一个线程调用`interrupt()`时\n\n①如果线程处于阻塞状态 (sleep,wait,join 等），那么线程将~~立即退出被阻塞状态~~并抛出一个异常 (2019.8.10 fix)\n\n> 这里其实是有点问题的，在有同步锁存在的情况下，并不一定会立即退出被阻塞的状态，即使抛出异常也要等到再次拿到锁之后才能抛出，同时也不是所有的阻塞操作都会响应中断信号，比如 IO 操作之类的都不会响应中断信号\n\n**验证 Demo**\n\n```java\npublic class WaitNotify {\n\n    public static void main(String[] args) {\n\n        Object object = new Object();\n\n        Thread thread1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (object) {\n                    System.out.println(\"线程 1 获取到监视器锁\");\n                    try {\n                        object.wait();\n                        System.out.println(\"线程 1 恢复啦。我为什么这么久才恢复，因为 notify 方法虽然早就发生了，可是我还要获取锁才能继续执行。\");\n                    } catch (InterruptedException e) {\n                        System.out.println(\"线程 1 wait 方法抛出了 InterruptedException 异常，即使是异常，我也是要获取到监视器锁了才会抛出\");\n                    }\n                }\n            }\n        }, \"线程 1\");\n        thread1.start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (object) {\n                    System.out.println(\"线程 2 拿到了监视器锁。为什么呢，因为线程 1 在 wait 方法的时候会自动释放锁\");\n                    System.out.println(\"线程 2 设置线程 1 中断\");\n                    thread1.interrupt();\n                    System.out.println(\"线程 2 执行完了 中断，先休息 3 秒再说。\");\n                    try {\n                        Thread.sleep(3000);\n                        System.out.println(\"线程 2 休息完啦。注意了，调 sleep 方法和 wait 方法不一样，不会释放监视器锁\");\n                    } catch (InterruptedException e) {\n\n                    }\n                    System.out.println(\"线程 2 休息够了，结束操作\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\n②如果线程处于正常活动状态，那么会将该线程的`中断标志位`设置为 true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响。\n\n③对已经结束的线程调用`interupt`没有任何效果\n\n上面只是简单的分析，其实情况还是很复杂的，后面再来总结\n\n**具体的小案例**\n\n```java\npublic class ThreadInterrup2 {\n    public static void main(String[] args) {\n        Thread main=Thread.currentThread();\n\n        Thread t=new Thread(()->{\n            while (true){\n\n            }\n        });\n        t.start();\n\t\n        Thread t2 = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            //t.interrupt(); 这里打断的是 t 线程但是阻塞的是 main 线程所以打断不了，捕获不到异常\n            main.interrupt();\n            System.out.println(\"打断 main 线程\");\n        });\n        t2.start();\n\n        try {\n            //这里阻塞的是 main 线程\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n看懂这个小案例应该就理解 interrupt 了。\n\n### 如何优雅的结束线程\n\n**1. 使用“开关”**\n\n```java\npublic class ThreadCloseGraceful {\n    public static void main(String[] args) throws InterruptedException {\n        Worker worker=new Worker();\n        worker.start();\n        Thread.sleep(10000); //等待 10s\n        worker.shutdown();\n    }\n}\n\nclass Worker extends Thread{\n    //优雅的停止线程-----开关\n    private volatile boolean start = true;\n\n    @Override\n    public void run() {\n        while (start){\n\n        }\n    }\n\n    public void shutdown(){\n        this.start=false;\n    }\n}\n```\n\n> 为了及时的感知到开关的变化 start 需要声明为 volatile（后面讲 Volatile 的时候会说到）\n\n**2. 轮询中断标志位**\n\n```java\npublic class ThreadCloseGraceful2 {\n    public static void main(String[] args) throws InterruptedException {\n        Worker2 worker2 = new Worker2();\n        worker2.start();\n        Thread.sleep(5000);\n        worker2.interrupt();\n    }\n}\n\nclass Worker2 extends Thread{\n    //优雅的停止线程 2-----打断\n    @Override\n    public void run() {\n        while (true){\n            /*try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                break; //return 会直接退出\n            }*/\n            //代码有可能在执行 isInterrupted 之前就 Block 了\n            if(isInterrupted()){\n                break;\n            }\n        }\n        //-----------\n    }\n}\n```\n\n**3. 利用守护线程**\n\n上面的代码已经提到了，有可能在轮询`开关` 或者 轮询`中断标志位`之前就堵塞了，这时也不能一直等该下去所以就需要强制结束线程的方法，`（当然不会是 stop）` 这里就可以利用守护线程的特性去完成这件事\n\n```java\npublic class ThreadService {\n    private  Thread executeThread;\n\n    private  volatile  boolean finished=false;\n\n    public void execute(Runnable task){\n        executeThread =new Thread(()->{\n            //子线程\n            Thread t=new Thread(()->{\n                task.run();\n            });\n            t.setDaemon(true);\n            t.start();\n\n            try {\n                t.join(); //这里阻塞的是 executeThread\n                finished=true;\n                //到这里说明 executeThread 已经不阻塞了，子线程已经执行完了，没有超时\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                System.out.println(\"TLE，executeThread execution was interrupted\");\n            }\n        });\n        executeThread.start();\n    }\n\n    public void shutdown(long mills){\n        long base=System.currentTimeMillis();\n        while (!finished){ //轮询检查标志位，看是否已经结束\n            if(System.currentTimeMillis()-base>=mills){\n                //超时了没有完成\n                System.out.println(\"TLE, will end it now\");\n                executeThread.interrupt(); //打断 executeThread\n                break;\n            }\n            //没超时\n            try {\n                executeThread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                System.out.println(\"executeThread was interrupted when shutdown\");\n            }\n        }\n        //标志位复原\n        finished=false;\n    }\n}\n```\n\n将待执行的`task`传递到`ThreadService`中然后会创建一个`executeThread`的线程，在线程中创建一个子线程去执行`task`的`run`方法然后将子线程设置为`executeThread`的守护线程然后`join`阻塞`executeThread`线程，同时会调用`ThreadService`的`shutdown`方法传入一个最长等待时间然后`轮询标志位`检查是否结束，如果超时就会打断`executeThread`进而结束`executeThread`的子线程也就是`task`\n\n### Thread.interrupted()\n\n这个方法和`isInterrupt()`类似但是他会清除中断标志位为`false`方便之后的中断操作而且这个是`静态方法`，所以你用线程实例去调用这个方法没有任何意义，它这里是用来判断**当前执行线程**是否 `interrupt` ，并且设置中断标志位为`false`\n\n```html\n/**\n * Tests whether the current thread has been interrupted.  The\n * <i>interrupted status</i> of the thread is cleared by this method.  In\n * other words, if this method were to be called twice in succession, the\n * second call would return false (unless the current thread were\n * interrupted again, after the first call had cleared its interrupted\n * status and before the second call had examined it).\n *\n * <p>A thread interruption ignored because a thread was not alive\n * at the time of the interrupt will be reflected by this method\n * returning false.\n *\n * @return  <code>true</code> if the current thread has been interrupted;\n *          <code>false</code> otherwise.\n * @see #isInterrupted()\n * @revised 6.0\n */\n```\n\n同时在抛出`InterruptedException` 之后中断状态也会被自动清除为 false\n\n> if any thread has interrupted the current thread. The <i>interrupted status</i> of the current thread is cleared when this exception is thrown.     ----Thread.sleep 注释\n\n## 10.Yield 方法\n\nThread.yield() 方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）\nyield() 让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用 yield() 的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证 yield() 达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。\n结论：大多数情况下，yield() 将导致线程从运行状态转到可运行状态，但有可能没有效果。\n\n## 11.Synchronized 关键字 \n\n### 线程安全问题\n\n```java\npublic class TicketRunnable implements Runnable {\n    \n    private final static int MAX_NO = 500;\n\n    private int index = 1;\n\n    @Override\n    public void run() {\n        while (true) {\n                if (index > MAX_NO) {\n                    return;\n                }\n                try {\n                    Thread.sleep(5);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"第：\" + index++);\n        }\n    }\n}\n```\n\n用这个创建多个`Thread`然后运行\n\n> 二号窗口第：497\n> 三号窗口第：499\n> 一号窗口第：498\n> 一号窗口第：500\n> 二号窗口第：`502`\n> 三号窗口第：`501`\n\n可以看出打印出了 501，502 明显不对为什么会出现这种问题呢？其实仔细想想也很容易理解\n\n![mark](http://static.imlgw.top///20190326/zSGNeiCW2zc1.png?imageslim)\n\n当两个线程如图所示的情况，2 号线程`index=500`然后`index++`然后 1 号线程读取到`index`的值就会产生这个问题。\n\n### 同步代码块\n\n**解决线程安全问题**\n\n```java\npublic class TicketRunnable implements Runnable {\n\n    private final static int MAX_NO = 500;\n    \n    private int index = 1;\n\n    private final Object MONITOR = new Object();\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (MONITOR) {\n                //单线程\n                if (index > MAX_NO) {\n                    return;\n                }\n                try {\n                    Thread.sleep(5);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"第：\" + index++);\n            }\n        }\n    }\n}\n```\n\n利用`MONITOR`对象作为同步锁同步之后的部分就相当于单线程，`MONITOR`锁对象一般设置为`final`的避免在执行过程中对`MONITOR`对象进行改变而产生无法预料的后果\n\n### 同步方法\n\n```java\npublic class SynchronizeRunnable implements Runnable {\n\n    private final static int MAX_NO = 500;\n\n    private int index = 1;\n\n    @Override\n    public  void run() {\n        //this 锁\n        while (true) {\n            if (ticket()) {\n                return;\n            }\n\n        }\n    }\n\n    private synchronized boolean ticket(){\n        //synchronized (this) {\n            //1.getFiled\n            if (index > MAX_NO) {\n                return true;\n            }\n            try {\n                Thread.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            // getFiled index\n            // index=index+1\n            // putFiled index\n            //同步代码块就是保护共享数据 index, MAX_NO 不是，他是只读数据\n            System.out.println(Thread.currentThread().getName() + \"第：\" + index++);\n            return false;\n       // }\n    }\n}\n```\n\n默认加的是`this`锁\n\n**证明 this 锁的存在**\n\n```java\npublic class SynchronizedThis {\n    public static void main(String[] args) {\n        ThisLock thisLock = new ThisLock();\n        Thread thread = new Thread(() -> thisLock.m1(), \"Thread0\");\n        thread.start();\n        Thread thread1 = new Thread(() -> thisLock.m2(), \"Thread1\");\n        thread1.start();\n        Thread thread2 = new Thread(() -> thisLock.m3(), \"Thread2\");\n        thread2.start();\n    }\n}\n\nclass ThisLock {\n\n    private final Object LOCK = new Object();\n\n    public synchronized void m1() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public synchronized void m2() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void m3() {\n        synchronized (LOCK) {\n            System.out.println(Thread.currentThread().getName());\n            try {\n                Thread.sleep(10_000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n运行上面的代码会发现`Thread0`和`Thread2`会先打印出来因为他们不是同一个锁不用等待对方，而`Thread1`会等待一段时间后才会执行因为它需要等待`Thread0`释放锁而这个锁只能是`this 锁`\n\n**证明 class 锁的存在**\n\n```java\npublic class SynchronizedClass {\n    public static void main(String[] args) {\n        Thread thread0 = new Thread(() -> ClassLock.m1(), \"Thread0\");\n        thread0.start();\n        Thread thread1 = new Thread(() -> ClassLock.m2(), \"Thread1\");\n        thread1.start();\n        Thread thread2 = new Thread(() -> ClassLock.m3(), \"Thread2\");\n        thread2.start();\n    }\n}\n\nclass ClassLock {\n    static {\n        synchronized (ClassLock.class) {\n            System.out.println(\"static\" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(10_000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static synchronized void m1() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized void m2() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void m3() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n运行上面的代码会发现最开始只有一个线程会去执行静态代码快，在静态代码快执行完之后`Thread2`会和另一个线程一起执行，说明一开始`Thread2`回和其中一个线程抢`Class 锁`执行静态代码块（静态代码块只会执行一次）\n\n### 死锁\n\n> 一个线程可以持有多个锁，而这样就可能会导致`死锁`的产生\n\n**死锁示例**\n\n```java\npublic class Service1 {\n    private  final Object LOCK=new Object();\n\n    private Service2 service2;\n\n    public  void s1(){\n        synchronized (LOCK){\n            System.out.println(\"s1==============\");\n        }\n    }\n\n    public void s2(){\n        synchronized (LOCK){\n            System.out.println(\"s2==============\");\n            service2.m2();\n        }\n    }\n\n    public void setService2(Service2 service2) {\n        this.service2 = service2;\n    }\n}\n---------------------------------------------------\npublic class Service2 {\n    private Service1 service1;\n\n    public Service2(Service1 service1) {\n        this.service1 = service1;\n    }\n\n    private  final  Object LOCK=new Object();\n\n    public  void  m1(){\n        synchronized (LOCK){\n            System.out.println(\"m1\");\n            service1.s1();\n        }\n    }\n\n    public  void  m2(){\n        synchronized (LOCK){\n            System.out.println(\"m2\");\n        }\n    }\n}\n-------------------------------------------------\npublic class DeadLockTest {\n    public static void main(String[] args) {\n        Service1 service1=new Service1();\n        Service2 service2 =new Service2(service1);\n        service1.setService2(service2);\n\n        new Thread(()->{\n            while (true){\n                service2.m1();\n            }\n        }).start();\n\n        new Thread(()->{\n            while (true){\n                service1.s2();\n            }\n        }).start();\n    }\n}\n```\n\n执行上面代码就会发现在运行一段时间后两个线程都`阻塞`了，这就是`死锁`\n\n- `jps`&`jstack`  分析死锁\n\n![mark](http://static.imlgw.top///20190328/BG9eU9Rq8ae0.png?imageslim)\n\n两个线程都需要对方手上的的锁，陷入僵持状态，就会产生死锁，也可以使用`jconsole`图形化界面来分析\n\n## 12. 线程间通讯\n\n在 Java 平台中，Object.wait()/notify() 等方法可用于实现线程的等待和通知，wait 将当前线程暂停生命周期变为 **WAITING** ，而 notify() 则可以唤醒一个被暂停的线程从而实现通知，一般来说 wait() 代码模板类似下面\n\n```java\nsynchronized(someObj){\n    while（保护条件不成立）{\n        //等待\n        someObj.wait();\n    }\n    //保护条件满足\n    doAction();\n}\n```\n\n而`notify()` 对应代码模板如下\n\n```java\nsynchronized(someObj){\n    //更新等待线程的保护条件设计的共享变量\n    updateSharedDate();\n    //唤醒其他线程\n    someObj,notify();\n}\n```\n\n### 生产者消费者模型\n\n**错误示例**\n\n```java\npublic class ProduceConsumerVersion1 {\n    public static void main(String[] args) {\n        ProduceConsumerVersion1 pc = new ProduceConsumerVersion1();\n        new Thread(() -> {\n            while (true) {\n                pc.produce();\n            }\n        }, \"Produce\").start();\n        new Thread(() -> {\n            while (true) {\n                pc.consumer();\n            }\n        }, \"Consumer\").start();\n    }\n\n    private int i = 0;\n\n    private final Object LOCK = new Object();\n\n    public void produce() {\n        synchronized (LOCK) {\n            System.out.println(\"Produce->\" + (i++));\n        }\n    }\n\n    public void consumer() {\n        synchronized (LOCK) {\n            System.out.println(\"Consumer->\" + (i));\n        }\n    }\n}\n```\n\n这种模型当生产者和消费者启动后会发现两个线程无法协作，生产者不断生产，消费者`不消费`或者`重复消费`\n\n**单生产者&单消费者**\n\n```java\npublic class ProduceConsumerVersion2 {\n    public static void main(String[] args) {\n        ProduceConsumerVersion2 pc = new ProduceConsumerVersion2();\n        Stream.of(\"Produce1\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.produce();\n                }\n            }, n).start();\n        });\n        Stream.of(\"Consumer1\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.consumer();\n                }\n            }, n).start();\n        });\n    }\n\n    private int i = 0;\n\n    private final Object LOCK = new Object();\n\n    private volatile boolean isProduced = false;\n\n    public void produce() {\n        synchronized (LOCK) {\n            if (isProduced) {\n                //已经生产了\n                try {\n                    LOCK.wait();//等待消费者唤醒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName() + \"-->\" + (++i));//produce\n            isProduced = true;\n            LOCK.notify();\n        }\n    }\n\n    public void consumer() {\n        synchronized (LOCK) {\n            if (!isProduced) {\n                try {\n                    LOCK.wait();//等待生产者唤醒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName() + \"-->\" + (i));//consumer\n            isProduced = false;\n            LOCK.notify();\n        }\n    }\n}\n```\n\n**wait()：** 当前线程`释放锁`进入该锁对象的`等待队列` \n\n> Causes the current thread to wait until another thread invokes the\n>\n> {@link java.lang.Object#notify()} method or the\n>\n> {@link java.lang.Object#notifyAll()} method for this object.\n>\n> In other words, this method behaves exactly as if it simply\n>\n> performs the call {@code `wait(0)`}.\n>\n> The current thread `must own this object's monitor.` The thread\n>\n> `releases` ownership of this monitor and waits until another thread\n>\n> notifies threads waiting on this object's monitor to wake up\n>\n> either through a call to the {@code notify} method or the\n>\n> {@code notifyAll} method. The thread then waits until it can\n>\n> re-obtain ownership of the monitor and resumes execution.\n\n**wait(long timeout)：**`wait()`的重载方法很容易想到是干啥的✔\n\n> Causes the current thread to wait until either another thread invokes the\n>\n> {@link java.lang.Object#notify()} method or the\n>\n> {@link java.lang.Object#notifyAll()} method for this object, or a\n>\n> `specified amount of time has elapsed.`\n>\n> The current thread must own this object's monitor.\n>\n> @throws  `IllegalArgumentException`  if the value of timeout is negative.\n\n**notify()：** 唤醒该`锁对象`的`等待队列`的线程，唤醒方法不同的虚拟机实现不同有的可能是`FCFS`有的可能是`SJF` 等等。... 所以唤醒的是那个线程是无法确定的\n\n> Wakes up a single thread that is `waiting on this object's`\n>\n> `monitor`. If any threads are waiting on this object, one of them\n>\n> is chosen to be awakened. `The choice is arbitrary and occurs at`\n>\n> `the discretion of the implementation`. A thread waits on an object's\n>\n> monitor by calling one of the {@code wait} methods.\n>\n> The awakened thread will not be able to proceed until the current\n>\n> thread `relinquishes` the lock on this object. The awakened thread will\n>\n> compete in the usual manner with any other threads that might be\n>\n> actively competing to synchronize on this object; for example, the\n>\n> awakened thread enjoys no reliable privilege or disadvantage in being\n>\n> the next thread to lock this object.\n\n生产者生产一个消费者消费一个，没毛病，但是上面的代码仅仅适用于`单生产者&消费者`对于多个生产者消费者就会有线程安全问题，具体问题如下\n\n**测试多消费者&生产者**\n\n沿用上面 single p&c 的代码，测试多消费者和生产者\n\n```java\n    public static void main(String[] args) {\n        ProduceConsumerVersion3 pc = new ProduceConsumerVersion3();\n        Stream.of(\"Produce1\", \"Produce2\", \"Produce3\", \"Produce4\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.produce();\n                }\n            }, n).start();\n        });\n        Stream.of(\"Consumer1\", \"Consumer2\", \"Consumer3\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.consumer();\n                }\n            }, n).start();\n        });\n    }\n```\n\n运行会发现程序进入`”死锁“`状态，用`jps&jstack`分析\n\n![mark](http://static.imlgw.top///20190328/pzXBY0ertEVV.png?imageslim)\n\n程序并没有发现死锁❎，这就是多生产者多消费者会产生的`假死`状态，实际上是所有的线程都进入了`wait()`状态都放弃了`CPU`的执行权\n\n**假死原因分析**\n\n```java\nProduce1-->1\tnotify C1 wait\nConsumer1-->1\tnotify P1 wait\nProduce1-->2    notify C2 wait\nConsumer2-->2   notify P2 wait\nProduce2-->3\tnotify P1 wait ---> Produce1-->wait\n```\n\n上面是其中一种情况，大致分析下：前两次生产消费都正常一个`消费者`唤醒一个`生产者`，前两次执行完之后`P1 C1 C2`都进入`wait`状态然后第三次生产的时候`P2`唤醒了一个不该唤醒的人😂 唤醒了`P1`然后`wait`了，`P1`醒来后发现已经生产了然后也`wait`去了，至此所有的线程全部进入`wait`状态就造成了假死。这个问题记得大一的时候还问过老师当时特别纠结为啥会死锁，现在看看其实也没啥，主要就是`notify`唤醒的线程是不确定的，是由`JVM`决定的每种`JDK`的实现也不太一样，无法保证消费者一定唤醒生产者，反之亦然。\n\n**多生产者&多消费者**\n\n```java\nimport java.util.stream.Stream;\npublic class ProduceConsumerVersion3 {\n    public static void main(String[] args) {\n        ProduceConsumerVersion3 pc = new ProduceConsumerVersion3();\n        Stream.of(\"Produce1\", \"Produce2\", \"Produce3\", \"Produce4\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.produce();\n                }\n            }, n).start();\n        });\n        Stream.of(\"Consumer1\", \"Consumer2\", \"Consumer3\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.consumer();\n                }\n            }, n).start();\n        });\n    }\n\n    private int i = 0;\n\n    private final Object LOCK = new Object();\n\n    private volatile boolean isProduced = false;\n\n    public void produce() {\n        synchronized (LOCK) {\n            while (isProduced) {\n                //已经生产了\n                try {\n                    LOCK.wait(); //加入 LOCK 锁的 wait 队列\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName() + \"-->\" + (++i));//produce\n            isProduced = true;\n            LOCK.notifyAll();\n        }\n    }\n\n    public void consumer() {\n        synchronized (LOCK) {\n            while (!isProduced) {\n                try {\n                    LOCK.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName() + \"-->\" + (i));//consumer\n            isProduced = false;\n            LOCK.notifyAll();\n        }\n    }\n}\n```\n\n**notifyAll()：**唤醒当前锁对象等待队列上的`所有`线程\n\n> Wakes up `all threads` that are waiting on `this object's monitor`. A\n>\n> thread waits on an object's monitor by calling one of the\n>\n> {@code wait} methods.\n>\n> The awakened threads will not be able to proceed until the current\n>\n> thread relinquishes the lock on this object. The awakened threads\n>\n> will `compete in the usual manner` with any other threads that might\n>\n> be actively competing to synchronize on this object; for example,\n>\n> the awakened threads enjoy `no reliable privilege or disadvantage` in\n>\n> being the next thread to lock this object.\n\n① 为了解决上面的`假死`问题这里使用了`notifyAll()`来唤醒`等待队列`的线程，看名字就知道这个方法会唤醒所有的线程，那么上面的假死问题就自然解决了。\n\n② 还有一点不同的是这里判断生产状态时用的是`while`而不是`if`为什么不用`if`? 其实也很好理解如果有多个生产者或者消费者同时在`等待队列`中，然后其中一个抢到锁后执行，执行完生产后唤醒了所有等待的线程，假设唤醒的是`生产者`的话，因为是`if 语句`控制的被唤醒的生产者抢到锁之后就直接顺着执行下去了，就直接去生产了，就会造成`重复的生产`当然用`else`语句貌似可以解决这个问题，但是那会影响效率（个人感觉），而且很别扭（被唤醒了直接退出？？？）. 所以这里用`while`来进行`二次检测`避免这种情况，这种 while 循环也被称为`自旋锁` 这一块后面的文章会再详细的讲。\n\n### 为什么 wait 和 notify 必须在同步方法或同步块中调用？ \n\n这是`阿里巴巴`的一道面试题\n\n① 首先从语法层面讲，如果不在同步方法和同步代码块中调用，也就是说没有加锁，自然就不用谈是不是`锁对象的持有者` ，就会报`IllegalMonitorStateException`.\n\n> @throws  `IllegalMonitorStateException`  if the current thread is not\n>\n> the owner of the object's monitor.\n\n②设想下如果不加锁可以直接调用，就会产生所谓的`竞态条件`，假设`wait()`,`notify()`,`notifyAll()`方法不需要加锁就能够被调用。此时消费者线程调用`wait()`正在进入状态变量的等待队列（译者注：可能还未进入）。在同一时刻，生产者线程调用`notify()`方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞。因此，对象的`wait()`,`notify()`,`notifyAll()`方法必须在该对象的同步方法或同步代码块中被互斥地调用。\n\n> 计算的正确性取决于多个线程的交替执行时序时就会产生竞态条件\n\n### wait() 后被唤醒会怎么样？\n\n上面说到被唤醒后会去抢锁，但是这里有人可能会有疑问，去抢锁会不会回到同步的起点去争抢锁，然后把 wait 前的逻辑再执行一遍？这里肯定事不会的，确实是要抢锁但是会有记录会继续顺着 wait 方法走下去。\n\n### notify 和中断的一个很有意思的现象\n\n```java\npublic class NotifyInter {\n\n    volatile int a = 0;\n\n    public static void main(String[] args) {\n\n        Object object = new Object();\n\n        NotifyInter waitNotify = new NotifyInter();\n\n        Thread thread1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                synchronized (object) {\n                    System.out.println(\"线程 1 获取到监视器锁\");\n                    try {\n                        object.wait();\n                        System.out.println(\"线程 1 正常恢复啦。但是 isInterrupt = \"+ Thread.currentThread().isInterrupted());\n                    } catch (InterruptedException e) {\n                        System.out.println(\"线程 1 wait 方法抛出了 InterruptedException 异常\");\n                    }\n                }\n            }\n        }, \"线程 1\");\n        thread1.start();\n\n        Thread thread2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                synchronized (object) {\n                    System.out.println(\"线程 2 获取到监视器锁\");\n                    try {\n                        object.wait();\n                        System.out.println(\"线程 2 正常恢复啦。\");\n                    } catch (InterruptedException e) {\n                        System.out.println(\"线程 2 wait 方法抛出了 InterruptedException 异常\");\n                    }\n                }\n            }\n        }, \"线程 2\");\n        thread2.start();\n\n        // 这里让 thread1 和 thread2 先起来，然后再起后面的 thread3\n       try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n        }\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (object) {\n                    System.out.println(\"线程 3 拿到了监视器锁。\");\n                    System.out.println(\"线程 3 设置线程 1 中断\");\n                    thread1.interrupt(); // 1\n                    //waitNotify.a = 1; // 这行是为了禁止上下的两行中断和 notify 代码重排序\n                    System.out.println(\"线程 3 调用 notify\");\n                    object.notify(); //2\n                    System.out.println(\"线程 3 调用完 notify 后，休息一会\");\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                    }\n                    System.out.println(\"线程 3 休息够了，结束同步代码块\");\n                }\n            }\n        }, \"线程 3\").start();\n    }\n}\n```\n\n多执行几次可能就可能会发生如下情况，线程 1 被打断后居然正常的返回了！！！！线程 2 被阻塞住了\n\n```java\n线程 1 获取到监视器锁\n线程 2 获取到监视器锁\n线程 3 拿到了监视器锁。\n线程 3 设置线程 1 中断\n线程 3 调用 notify\n线程 3 调用完 notify 后，休息一会\n线程 3 休息够了，结束同步代码块\n线程 1 正常恢复啦。但是 isInterrupt = true\n```\n\n其实这里主要问题就是 `notify()` 和`interrupt()` 执行顺序的问题\n\n- 如果先被打断，那么后续的 notify 会这个线程无效，依然会抛出异常，如果这是该锁实例上仍然有其他线程处于 wait 状态，那么这个 notify 会唤醒其中的一个，不能虚发，具体可以参考 [Java 语言规范文档 17.2.4](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.2.4)\n\n  > The above specifications allow us to determine several properties having to do with the interaction of waits, notification, and interruption.\n  >\n  > If a thread is both notified and interrupted while waiting, it may either:\n  >\n  > - return normally from `wait`, while still having a pending interrupt (in other words, a call to `Thread.interrupted` would return true)\n  > - return from `wait` by throwing an `InterruptedException`\n  >\n  > The thread may not reset its interrupt status and return normally from the call to `wait`.\n  >\n  > Similarly, notifications cannot be lost due to interrupts. Assume that a set *s* of threads is in the wait set of an object *m*, and another thread performs a `notify` on *m*. Then either:\n  >\n  > - at least one thread in *s* must return normally from `wait`, or\n  > - all of the threads in *s* must exit `wait` by throwing `InterruptedException`\n  >\n  > Note that if a thread is both interrupted and woken via `notify`, and that thread returns from `wait` by throwing an `InterruptedException`, then some other thread in the wait set must be notified.\n\n- 如果先被 notify()，那么线程会从 wait 中醒来，然后中断，设置中断标志位为 true，但不会在这个 wait 上抛出异常，而会影响后面的阻塞操作，具体可以看下面的 Demo\n\n  ```java\n  public class NotifyInter {\n      volatile int a = 0;\n      public static void main(String[] args) {\n          Object object = new Object();\n          NotifyInter waitNotify = new NotifyInter();\n          Thread thread1 = new Thread(new Runnable() {\n              @Override\n              public void run() {\n                  synchronized (object) {\n                      System.out.println(\"线程 1 获取到监视器锁\");\n                      try {\n                          object.wait();\n                          System.out.println(\"线程 1 正常恢复啦。但是 isInterrupt = \"+ Thread.currentThread().isInterrupted());\n                      } catch (InterruptedException e) {\n                          System.out.println(\"线程 1 wait 方法抛出了 InterruptedException 异常\");\n                      }\n  \n                      try {\n                          TimeUnit.SECONDS.sleep(3);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                          System.out.println(\"在 sleep 中被中断\");\n                      }\n                  }\n              }\n          }, \"线程 1\");\n          thread1.start();\n          // 这里让 thread1 和 thread2 先起来，然后再起后面的 thread3\n         try {\n              Thread.sleep(1000);\n          } catch (InterruptedException e) {\n          }\n  \n          new Thread(new Runnable() {\n              @Override\n              public void run() {\n                  synchronized (object) {\n                      System.out.println(\"线程 3 拿到了监视器锁。\");\n                      System.out.println(\"线程 3 设置线程 1 中断\");\n                      object.notify(); //2\n                      waitNotify.a = 1; // 这行是为了禁止上下的两行中断和 notify 代码重排序\n                      thread1.interrupt(); // 1\n                      System.out.println(\"线程 3 调用 notify\");\n                      System.out.println(\"线程 3 调用完 notify 后，休息一会\");\n                      try {\n                          Thread.sleep(1000);\n                      } catch (InterruptedException e) {\n                      }\n                      System.out.println(\"线程 3 休息够了，结束同步代码块\");\n                  }\n              }\n          }, \"线程 3\").start();\n      }\n  }\n  ```\n\n### wait() 和 sleep() 的区别\n\n这也是一道面试常问的题\n\n① 首先`sleep()`是线程 Thread 的静态方法，`wait()`是`Object`类的实例方法\n\n②`sleep()`不会释放锁对象，`wait()`会释放锁对象，这一点比较重要\n\n③ 承接第二点，`wait()`会释放锁，但是要是你没有锁呢？其实就是上面语法层面说到的，所以调用`wait()`必须要`持有`锁对象否则就会报`IllegalMonitorStateException`\n\n④`sleep()`不需要被唤醒`timeout`后会自动醒来，而`wait()`需要被其他线程唤醒（`wait(long time)`除外）\n\n### 线程通讯综合案例\n\n控制同一时间执行同一方法线程的数量\n\n```java\npublic class ControlThreadNum {\n\n    private static final LinkedList THREADS = new LinkedList<>();\n\n    private final static int MAX_THREAD = 5;\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        List<Thread> worker = new ArrayList();\n        //创建了十个线程，但是控制每次最多同时运行的只有 5 个\n        Arrays.asList(\"M1\", \"M2\", \"M3\", \"M4\", \"M5\", \"M6\", \"M7\", \"M8\", \"M9\", \"M10\").stream().map(ControlThreadNum::captureThread).forEach(t -> {\n            t.start();\n            worker.add(t);\n        });\n        //main 线程等待 worker 的线程都执行完\n        worker.stream().forEach(thread -> {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        Optional.of(\"All capture is done\").ifPresent(System.out::println);\n        Optional.of(System.currentTimeMillis() - start).ifPresent(System.out::println);\n    }\n\n    private static Thread captureThread(String name) {\n        return new Thread(() -> {\n            Optional.of(\"Thread \" + Thread.currentThread().getName() + \"  is begin\").ifPresent(System.out::println);\n            synchronized (THREADS) {\n                while (THREADS.size() >= MAX_THREAD) {\n                    try {\n                        THREADS.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //THREADS 只是用来控制数量&锁 元素是什么并不重要\n                THREADS.addLast(1);\n            }\n            //到这里是并行\n            Optional.of(\"Thread \" + Thread.currentThread().getName() + \"  is running\").ifPresent(System.out::println);\n            try {\n                Thread.sleep(10000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            synchronized (THREADS) {\n                Optional.of(\"Thread \" + Thread.currentThread().getName() + \"  is end\").ifPresent(System.out::println);\n                THREADS.removeLast();\n                THREADS.notifyAll();\n            }\n        }, name);\n    }\n}\n```\n\n这里一开始一共创建了 10 个线程，但是执行的时候会控制`running`的个数小于 5 个，`runnning`线程个数用一个`LinkList`记录，若`size()>=5`就进入`wait`然后如果有线程`end`就会`notifyAll`唤醒进入等待状态的线程。\n\n```java\nThread M2  is begin\nThread M3  is begin\nThread M2  is running\nThread M1  is begin\nThread M1  is running\nThread M3  is running\nThread M4  is begin\nThread M4  is running\nThread M5  is begin\nThread M6  is begin\nThread M5  is running\nThread M7  is begin\nThread M8  is begin\nThread M9  is begin\nThread M10  is begin\nThread M3  is `end`\nThread M10  is running\nThread M5  is `end`\nThread M1  is `end`\nThread M2  is `end`\nThread M4  is `end`\nThread M6  is running\nThread M7  is running\nThread M9  is running\nThread M8  is running\nThread M10  is end\nThread M8  is end\nThread M9  is end\nThread M7  is end\nThread M6  is end\nAll capture is done\n20124\n```\n\n这样就是其实就是为了提高效率，线程并不是越多越好，线程创建太多，就会达到瓶颈，效率反而会降低，因为时间都消耗在了`线程切换`上了，当然这是在没有`线程池`的情况下，后面用`线程池`就不会这么麻烦了。\n\n### wait()/notify 的开销及问题\n\n**过早唤醒** \n\n 比如生产者消费者问题中生产者生产后唤醒了生产者，其实就是过早唤醒了，过早唤醒使得那些本来无须被唤醒的等待线程也被唤醒了，从而造成资源浪费。这就好比你在人群里大喊一声“美女”，便会有许多自我感觉良好的女性回头一样——尽管你要喊的仅仅是其中某一个人，但大家却都以为你是在喊自己。过早唤醒问题可以利用 JDK\n1.5 引入的`java.util.concurrent.locks.Condition`接口来解决，后面的文章会讲到。\n\n**信号丢失**\n\n信号丢失（Missed Signal）问题。如果等待线程在执行`Object.wait()`前没有先判断保护条件是否已然成立，那么有可能出现这种情形——通知线程在该等待线程进人临界区之前就已经更新了相关共享变量，使得相应的保护条件成立并进行了通知，但是此时等待线程还没有被暂停，自然也就无所谓唤醒了。这就可能造成等待线程直接执行`Object.wait()`而被暂停的时候，该线程由于没有其他线程进行通知而一直处于等待状态。这种现象就相当于等待线程错过了一个本来“发送”给它的“信号”，因此被称为信号丢失（Missed Signal）。只要将对保护条件的判断和`Object.wait()`调用放在一个循环语句之中就可以避免上述场景的信号丢失。信号丢失的另外一个表现是在应该调用`Object.notifyAll()` 的地方却调用了`Object.notify()`。比如，对于使用同一个保护条件的多个等待线程，如果通知线程在侦测到这个保护条件成立后调用的是`Object.notify()`，那么这些等待线程最多只有一个线程能够被唤醒，甚至一个也没有被唤醒——被唤醒的线程是`Object.notify()`所属对象上使用其他保护条件的一个等待线程！也就是说，尽管通知线程在调用`Object.notify()`前可能考虑（判断）了某个特定的保护条件是否成立，但是`Object.notify()`本身在其唤醒线程时是不考虑任何保护条件的！这就可能使得通知线程执行`Object.notify()`进行的通知对于使用相应保护条件的等待线程来说丢失了。这种情形下，避免信号丢失的一个方法是在必要的时候使用`Object.notifyAll()`来通知。总的来说，信号丢失本质上是一种代码错误，而不是 Java 标准库 API 自身的问题。\n\n**欺骗性唤醒**\n\n由于莫名其妙的原因，线程有可能在没有调用过`notify()`和`notifyAll()`的情况下醒来。这就是所谓的假唤醒（spurious wakeups），无端端地醒过来了，然而此时可能保护条件并没有成立。这个问题的解决同样是讲 保护条件和 wait 放在临界区内同一个循环体内就可以了。\n\n**上下文切换**\n\n​\t首先，等待线程执行`Object.wait()`至少会导致该线程对相应对象内部锁的两次申请与释放。通知线程在执行`Object.notify()/notifyAll()`时需要持有相应对象的内部锁，因此`Object.notify()/notifyAll()`调用会导致一次锁的申请。而锁的申请与释放可能导致上下文切换。\n\n​\t其次，等待线程从被暂停到唤醒这个过程本身就会导致上下文切换。\n\n​\t再次，被唤醒的等待线程在继续运行时需要再次申请相应对象的内部锁，此时等待线程可能需要和相应对象的入口集中的其他线程以及其他新来的活跃线程（即申请相应的内部锁且处于 RUNNABLE 状态的线程）争用相应的内部锁，而这又可能导致上下文切换。\n最后，过早唤醒问题也会导致额外的上下文切换，这是因为被过早唤醒的线程仍然需要继续等待，即再次经历被暂停和唤醒的过程。\n\n[更多参考](http://ifeve.com/thread-signaling/)\n\n## 13. 手写一个 BooleanLock\n\n`Synchronized`的缺点其实很明显，当多个线程竞争锁的时候，当一个线程抢到锁后其他的线程只能傻傻的等着，这样会影响效率，所以这里可以自己简单手写一个限制等待时间的锁。\n\n### LOCK 接口\n\n```java\npublic interface Lock {\n\n    class TimeOutException extends Exception {\n        public TimeOutException(String message) {\n            super(message);\n        }\n    }\n\n    void lock() throws InterruptedException;\n\n    void lock(long time) throws InterruptedException,TimeOutException;\n\n    void unLock() throws InterruptedException;\n\n    Collection<Thread> getBlockThread();\n}\n```\n\n定义了一个`TimeOutException`\n\n### BooleanLock 实现类\n\n```java\npublic class BooleanLock implements Lock {\n\n    //false indicated free\n    private boolean initValue;\n    //加锁的线程\n    private Thread lockedThread;\n\n    private Collection<Thread> blockThreadCollection = new ArrayList<>();\n\n    public BooleanLock() {\n        this.initValue = false;\n    }\n\n    @Override\n    public synchronized void lock() throws InterruptedException {\n        while (initValue) {\n            blockThreadCollection.add(Thread.currentThread());\n            System.out.println(Thread.currentThread().getName() + \" is wait\");\n            this.wait();\n        }\n        blockThreadCollection.remove(Thread.currentThread());\n        this.initValue = true;\n        this.lockedThread = Thread.currentThread();\n    }\n\n    @Override\n    public synchronized void lock(long time) throws InterruptedException, TimeOutException {\n        if (time <= 0) lock();\n        long remainTime=time;\n        long endTime=System.currentTimeMillis()+time;\n        while (initValue){\n            if(remainTime<=0){\n                throw new TimeOutException(\"time is out\");\n            }\n            blockThreadCollection.add(Thread.currentThread());\n            this.wait(time);\n            remainTime=endTime-System.currentTimeMillis();\n        }\n        this.initValue=true;\n        this.lockedThread=Thread.currentThread();\n        blockThreadCollection.remove(Thread.currentThread());\n    }\n\n    @Override\n    public synchronized void unLock() {\n        //判断是不是加锁的线程\n        if (lockedThread == Thread.currentThread()) {\n            this.initValue = false;\n            this.notifyAll();\n            Optional.of(Thread.currentThread().getName() + \"  release the lock monitor\").ifPresent(System.out::println);\n        }\n    }\n\n    @Override\n    public Collection<Thread> getBlockThread() {\n        return Collections.unmodifiableCollection(blockThreadCollection);\n    }\n}\n```\n\n### 测试 BooleanLock 的效果\n\n```java\npublic class LockTest {\n    public static void main(String[] args) {\n        final BooleanLock booleanLock = new BooleanLock();\n        Stream.of(\"t0\", \"t1\", \"t2\").forEach(name -> {\n            new Thread(() -> {\n                try {\n                    booleanLock.lock(10);\n                    Optional.of(Thread.currentThread().getName() + \" get the lock\").ifPresent(System.out::println);\n                    doSomething();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (Lock.TimeOutException e) {\n                    System.out.println(Thread.currentThread().getName()+\" Time out\");\n                    e.printStackTrace();\n                } finally {\n                    booleanLock.unLock();\n                }\n            }, name).start();\n        });\n        //main 线程释放锁，不应该，谁加的锁应该由谁去释放锁\n        //booleanLock.unLock();\n    }\n\n    private static void doSomething() {\n        Optional.of(Thread.currentThread().getName() + \" is working...\").ifPresent(System.out::println);\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n这里设置在抢不到锁的时候，只等待`10ms`，然后`doSomething`会`sleep`5000ms，所以只有一个线程可以抢到锁后面的都会超时 throw `TimeOutException`典型的`限时等待`模型\n\n```java\nt0 get the lock\nt0 is working...\n`base_thread_study.chaper10.Lock$TimeOutException: time is out`\n\tat base_thread_study.chaper10.BooleanLock.lock(BooleanLock.java:41)\n\tat base_thread_study.chaper10.LockTest.lambda$null$0(LockTest.java:12)\n\tat java.lang.Thread.run(Thread.java:748)\n`base_thread_study.chaper10.Lock$TimeOutException: time is out`\n\tat base_thread_study.chaper10.BooleanLock.lock(BooleanLock.java:41)\n\tat base_thread_study.chaper10.LockTest.lambda$null$0(LockTest.java:12)\n\tat java.lang.Thread.run(Thread.java:748)\nt2 Time out\nt1 Time out\nt0  release the lock monitor\n```\n\n## 14. 给应用程序注入钩子 Hook\n\n关于`Hook`是什么就不多介绍了，这里的钩子和`git`,`svn`里面的是一样的，类似的在使用`Tomcat`等服务的时候，在你关闭它之后它仍然会打印日志和释放一些资源，这就是`Hook`的一种，当然`Hook`有多种，这只是其中一种。\n\n```java\npublic class ExitCap{\n\tpublic static void main(String []arg){\n\tint i=0;\n\tRuntime.getRuntime().addShutdownHook(new Thread(()->{\n   \t    System.out.println(\"The test app will shutdown\");\n\t    notifyAndRelease();\n\t}));\n\twhile(true){\n\t\ttry{\n\t\tThread.sleep(1000);\n\t\tSystem.out.println(\"i am working\");\n\t\t}catch(Exception e){\n\t\t //donothing\n\t\t}\n\t\tif(i>10){\n\t\t   throw new RuntimeException();\n\t\t}\n\t\ti++;    \n\t}\n    }\n\n    public static void notifyAndRelease(){\n\tSystem.out.println(\"notify to admin\");\n    \t\n\ttry{\n\tThread.sleep(1000);\n\t}catch(Exception e){}\n\t\n\tSystem.out.println(\"release the resources(socker. file, connection.)\");\n\t\n\ttry{\n        Thread.sleep(1000);\n        }catch(Exception e){}\n\t\n\tSystem.out.println(\"release and notify done\");\n    }\n}\n\n```\n\n这里是在`Linux`上进行的测试，因为效果比较明显，顺便也熟悉下`Linux`的命令，可以看到上面的钩子就是通过`Runtime.getRuntime().addShutdownHook()`注入了一个`Thread`进去的，这样就会检测到程序的退出并触发`Hook`做一些释放资源之类的工作。\n\n```java\ni am working\nException in thread \"main\" java.lang.RuntimeException\n\tat base_thread_study.chaper10.ExitCap.main(ExitCap.java:18)\ni am working\n`The test app will shutdown`\n`notify to admin`\n`release the resources(socker. file, connection.)`\n`release and notify done`\n```\n\n上面是在正常情况下终止线程比如 `异常`，`ctrl C`或者 `kill pid`如果使用 `kill -9 pid`就不会触发钩子，强制停止，所以一般不建议用`kill -9`\n\n## 15. 捕获线程的 Runtime 异常\n\n在 Java 多线程环境下，所有线程都不允许抛出未捕获的`checked exception`（比如 sleep 的 InterruptException)，也就是各个线程必须自己把自己的`checked exception`处理掉，但是如果是`unchecked exception `呢？主要就是指`RuntimeException`此类异常抛出时该线程会`shutdown`但是其它线程不受影响也无法感知到这个异常，就像下面的例子\n\n```java\npublic class ThreadException {\n    public static void main(String[] args) {\n        Thread thread = null;\n        try {\n            thread=new Thread(()->{\n                int res=1/0;\n            });\n            thread.start();\n        }catch (Exception e){\n            System.out.println(\"捕获到异常\");\n        }\n    }\n}\n```\n\n控制台输出`main 线程`并没有捕获到异常，其实这也是一种很好的理念，每个线程的事情应该由线程自己去处理不应该由其他线程去干扰，正如`stop/resume/suspend`这些方法被弃用的原因。但是这些异常如果不去处理可能会导致一些严重的后果，JDK1.5 之后官方也提供了 API 去处理线程的异常。setDefaultUncaughtExceptionHandler() 和 setUncaughtExceptionHandler() 前者是`Thread`的静态方法，用于给所有的线程设置默认的异常处理，后者是实例方法，针对每个线程会给每个线程加上一个异常处理器，如下 Demo\n\n```java\npublic class ThreadException {\n    private static int A = 10;\n    private static int B = 0;\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n              int res = A / B;\n            }\n        );\n        //最好在 start 前设置异常处理器，放在后面可能会起不到作用。\n        thread.setUncaughtExceptionHandler((t, e) -> {\n            System.out.println(t.getName());\n            System.out.println(e);\n        });\n        thread.start();\n    }\n}\n```\n\n> `Thread-0`\n> `java.lang.ArithmeticException: / by zero`\n\n可以看到已经捕获到了这个异常，当线程遇到未捕获的异常而结束时会调用`UncaughtExceptionHandler` 处理一些\"后事\"和释放一些宝贵的资源，`setUncaughtExceptionHandler`建议放在线程 start 之前，不然可能起不到作用。\n\n## 16.ThreadGroup 线程组\n\n### 获取线程组信息\n\n```java\npublic class ThreadGroupAPI {\n    public static void main(String[] args) {\n        ThreadGroup tgp = new ThreadGroup(\"TGP1\");\n        Thread t = new Thread(tgp, \"t0\") {\n            @Override\n            public void run() {\n                while (true) {\n                    try {\n                        System.out.println(getThreadGroup().getName());\n                        System.out.println(getThreadGroup().getParent());\n                        //可以访问，文档上说不行\n                        System.out.println(getThreadGroup().getParent().activeCount());\n                        Thread.sleep(10000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        };\n        t.start();\n\n        ThreadGroup tgp2 = new ThreadGroup(\"TGP2\");\n        Thread t1 = new Thread(tgp2, \"t0\") {\n            @Override\n            public void run() {\n                System.out.println(tgp.getName());\n                System.out.println(tgp.activeCount());\n                Thread[] threads=new Thread[tgp.activeCount()];\n                tgp.enumerate(threads);\n                //也可以访问\n                Arrays.asList(threads).forEach(System.out::println);\n            }\n        };\n        t1.start();\n        //System.out.println(tgp2.getName());\n        //System.out.println(tgp2.getParent().getName());\n    }\n}\n```\n\n文档上说的不能访问其他线程组的信息，这里测试的几个都可以，可能描述有点问题，`线程组`的创建类似于`线程`的创建，如果没有显示的指定线程组都会默认加到父线程的线程组中。\n\n### 打断线程组 interrupt()\n\n> Interrupts all threads in this thread group.\n>\n> First, the <code>checkAccess</code> method of this thread group is\n>\n> called with no arguments; this may result in a security exception.\n>\n> This method then calls the <code>interrupt</code> method on all the\n>\n> threads in this thread group and in `all of its subgroups.`\n\n打断该线程组里面所有的线程，包括子线程组的线程。\n\n### 线程组 setDaemon()\n\n和线程的`setDaemon`不一样。\n\n> Changes the daemon status of this thread group.\n>\n> First, the <code>checkAccess</code> method of this thread group is\n>\n> called with no arguments; this may result in a security exception.\n>\n> A daemon thread group is `automatically` `destroyed` when its last\n>\n> thread is stopped or its `last thread group is destroyed`.\n\n当最后一个线程执行完毕后自动销毁线程组，当然与其对应的也有手动销毁的方法`destroy()`这个方法如果线程没执行完毕就调用会抛`IllegalThreadStateException`，其他的方法详细可以参考文档。\n\n## 17. 线程池\n\n### 为什么要使用线程池\n\n 创建和销毁线程开销大，利用好线程池可以避免 cpu 花费不必要的时间在这上面，从而专注于具体的任务：)\n\n基本的线程池包括下面几部分：\n\n①任务队列\n\n②拒绝策略（抛出异常，直接丢弃，阻塞，临时队列）\n\n③`init`(`min`) 初始大小\n\n④`active`中间常态大小\n\n⑤`max`最大个数，超过就会加到任务队列中，任务队列也满就会执行拒绝策略\n\n> min<=active<=max\n\n### 手写线程池\n\n#### 临时队列\n\n```java\npublic class SimpleThreadPool {\n    //线程池大小\n    private final int size;\n    //默认大小\n    private final static int DEFAULT_SIZE = 10;\n\t//任务队列\n    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();\n\t//线程序号\n    private static volatile int seq = 0;\n\t//线程组\n    private final static ThreadGroup GROUP = new ThreadGroup(\"Pool_Group\");\n\t//线程前缀名\n    private final static String THREAD_PREFIX = \"SIMPLE_THREAD_POOL-\";\n\t//线程队列\n    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();\n\n    public SimpleThreadPool(int size) {\n        this.size = size;\n        init();\n    }\n\n    public SimpleThreadPool() {\n        this(DEFAULT_SIZE);\n    }\n\n    private void init() {\n        for (int i = 0; i < size; i++) {\n            createThreadQueue();\n        }\n    }\n\t\n    //暴露对外的接口，提交任务队列\n    public void submit(Runnable runnable) {\n        synchronized (TASK_QUEUE) {\n            TASK_QUEUE.addLast(runnable);\n            //唤醒线程池中的线程\n            TASK_QUEUE.notifyAll();\n        }\n    }\n\n    private void createThreadQueue() {\n        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));\n        thread.start();\n        THREAD_QUEUE.add(thread);\n    }\n\n    private enum ThreadState {\n        FREE, RUNNING, BLOCKED, DEAD\n    }\n\t\n    //包装的线程类\n    private static class MyThread extends Thread {\n        private volatile ThreadState threadState = ThreadState.FREE;\n\n        public ThreadState getThreadState() {\n            return this.threadState;\n        }\n\n        public MyThread(ThreadGroup group, String name) {\n            super(group, name);\n        }\n\n        @Override\n        public void run() {\n            OUTER:\n            while (this.threadState != ThreadState.DEAD) {\n                //当前线程没有 dead\n                Runnable runnable;\n                synchronized (TASK_QUEUE) {\n                    while (TASK_QUEUE.isEmpty()) {\n                        //任务队列为空，全员 wait\n                        try {\n                            this.threadState = ThreadState.BLOCKED;\n                            TASK_QUEUE.wait();\n                        } catch (InterruptedException e) {\n                            System.out.println(\"break\");\n                            break OUTER;\n                        }\n                    }\n                    runnable = TASK_QUEUE.removeFirst();\n                }\n                //这里应该并行\n                Optional.of(runnable).ifPresent(t -> {\n                    this.threadState = ThreadState.RUNNING;\n                    t.run();\n                    this.threadState = ThreadState.FREE;\n                });\n            }\n        }\n\n        public void close() {\n            this.threadState = ThreadState.DEAD;\n        }\n    }\n}\n```\n\n最开始实现的时候`synchronized`的范围太大，将具体的执行`run`的过程也同步了起来，这明显是有问题的，只需要同步共享变量就可以了，同步了后面的代码那就跟单线程一样了。\n\n#### 关闭线程池&拒绝策略\n\n```java\npublic class SimpleThreadPool {\n    //线程池大小\n    private final int size;\n\t//任务队列大小\n    private final int queueSize;\n\t//默认线程池大小\n    private final static int DEFAULT_SIZE = 10;\n\t//线程池中线程编号\n    private static volatile int seq = 0;\n\t//默认任务队列的大小\n    private final static int DEFAULT_TASK_QUEUE_SIZE = 2000;\n\t//线程组\n    private final static ThreadGroup GROUP = new ThreadGroup(\"Pool_Group\");\n\t//线程名前缀\n    private final static String THREAD_PREFIX = \"SIMPLE_THREAD_POOL-\";\n\t//任务队列\n    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();\n\t//线程队列\n    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();\n\t//拒绝策略\n    private final DiscardPolicy discardPolicy;\n\t//线程次是否销毁\n    private volatile boolean destroy = false;\n\t//默认的拒绝策略（抛异常）\n    public final static DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {\n        throw new DiscardException(\"Discard this Task!!!!(Default Policy)\");\n    };\n    public SimpleThreadPool(int size, int queueSize, DiscardPolicy discardPolicy) {\n        this.size = size;\n        this.queueSize = queueSize;\n        this.discardPolicy = discardPolicy;\n        init();\n    }\n\n    public SimpleThreadPool() {\n        this(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);\n    }\n\n    private void init() {\n        for (int i = 0; i < size; i++) {\n            createThreadQueue();\n        }\n    }\n\n    public void submit(Runnable runnable) {\n        if (destroy) {\n            throw new IllegalStateException(\"The Pool is shutdown , you can't submit now ! !\");\n        }\n        synchronized (TASK_QUEUE) {\n            if (TASK_QUEUE.size() > queueSize) {\n                discardPolicy.discard();\n            }\n            TASK_QUEUE.addLast(runnable);\n            //唤醒线程池中的线程\n            TASK_QUEUE.notifyAll();\n        }\n    }\n\n    public void shutdown() throws InterruptedException {\n        //判断任务队列是否为空\n        while (!TASK_QUEUE.isEmpty()) {\n            Thread.sleep(50);\n        }\n        int initVal = THREAD_QUEUE.size();\n        while (initVal > 0) {\n            for (MyThread thread : THREAD_QUEUE) {\n                if (thread.getThreadState() == ThreadState.BLOCKED) {\n                    thread.close();\n                    thread.interrupt();\n                    initVal--;\n                } else {\n                    Thread.sleep(10);\n                }\n            }\n        }\n        this.destroy = true;\n        System.out.println(\"My Thread pool is shutdown\");\n    }\n\n    public boolean isDestroy() {\n        return this.destroy;\n    }\n\n    private void createThreadQueue() {\n        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));\n        thread.start();\n        THREAD_QUEUE.add(thread);\n    }\n\n    private enum ThreadState {\n        FREE, RUNNING, BLOCKED, DEAD\n    }\n\n    public static class DiscardException extends RuntimeException {\n        public DiscardException(String message) {\n            super(message);\n        }\n    }\n\n    @FunctionalInterface\n    public interface DiscardPolicy {\n        void discard() throws DiscardException;\n    }\n\n    private static class MyThread extends Thread {\n        private volatile ThreadState threadState = ThreadState.FREE;\n\n        public ThreadState getThreadState() {\n            return this.threadState;\n        }\n\n        public MyThread(ThreadGroup group, String name) {\n            super(group, name);\n        }\n\n        @Override\n        public void run() {\n            OUTER:\n            while (this.threadState != ThreadState.DEAD) {\n                Runnable runnable;\n                synchronized (TASK_QUEUE) {\n                    while (TASK_QUEUE.isEmpty()) {\n                        try {\n                            this.threadState = ThreadState.BLOCKED;\n                            TASK_QUEUE.wait();\n                        } catch (InterruptedException e) {\n                            System.out.println(Thread.currentThread().getName() + \" is dead\");\n                            break OUTER;\n                        }\n                    }\n                    runnable = TASK_QUEUE.removeFirst();\n                }\n                Optional.of(runnable).ifPresent(t -> {\n                    this.threadState = ThreadState.RUNNING;\n                    t.run();\n                    this.threadState = ThreadState.FREE;\n                });\n            }\n        }\n\n        private void close() {\n            this.threadState = ThreadState.DEAD;\n        }\n    }\n}\n\n```\n\n- `shutdown`方法实现\n\n①先轮询任务队列是否为空，不为空就会让`当前线程`等待`线程队列`的线程执行完所有任务。\n\n②当任务队列为空时，遍历`线程队列`，然后打断`BLOCK`的线程并且设置为`DEAD`状态跳出循环，因为`任务队列`为空`线程队列`里面的线程都会在`TASK_QUEUE`上面`BLOCK`住，但是也存在特殊情况，可能某个线程刚拿到最后一个任务，这种情况我们可以稍微等一下，等它`BLOCK`，毕竟这是个`lg(N)-lg(N2)`的方法\n\n③设置`destory`状态为 true，然后在`submit`的时候会根据这个变量来判断是否已经销毁，如果已经销毁就会抛出一个`RunntimeException`\n\n- `拒绝策略`实现\n\n这里实现了一个·默认的拒绝策略，抛出异常，在 submit 的时候判断任务队列是不是满的，如果满了就直接抛异常，这里如果用这种方式拒绝，一但出现异常`当前线程`就会`直接结束`可能就无法关闭连接池。\n\n#### 自动扩容&闲时回收\n\n```java\npublic class SimpleThreadPool extends Thread {\n    //线程池大小\n    private int size;\n    //线程大小变化值\n    private int min;\n    private int active;\n    private int max;\n    //默认值\n    private final static int MIN = 4;\n    private final static int ACTIVE = 8;\n    private final static int MAX = 12;\n    //任务队列大小\n    private final int queueSize;\n\n    public int getMin() {\n        return min;\n    }\n\n    public int getActive() {\n        return active;\n    }\n\n    public int getMax() {\n        return max;\n    }\n\n    //线程池中线程编号\n    private static volatile int seq = 0;\n    //默认任务队列的大小\n    private final static int DEFAULT_TASK_QUEUE_SIZE = 2000;\n\n    //线程组\n    private final static ThreadGroup GROUP = new ThreadGroup(\"Pool_Group\");\n    //线程名前缀\n    private final static String THREAD_PREFIX = \"SIMPLE_THREAD_POOL-\";\n    //任务队列\n    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();\n    //线程队列\n    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();\n    //拒绝策略\n    private final DiscardPolicy discardPolicy;\n    //线程池是否销毁\n    private volatile boolean destroy = false;\n    //默认的拒绝策略（抛异常）\n    public final static DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {\n        throw new DiscardException(\"Discard this Task!!!!(Default Policy)\");\n    };\n\n    public SimpleThreadPool(int min, int active, int max, int queueSize, DiscardPolicy discardPolicy) {\n        this.queueSize = queueSize;\n        this.discardPolicy = discardPolicy;\n        this.min = min;\n        this.active = active;\n        this.max = max;\n        init();\n    }\n\n    public SimpleThreadPool() {\n        this(MIN, ACTIVE, MAX, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);\n    }\n\n    //线程池的线程，维护整个线程\n    @Override\n    public void run() {\n        while (!destroy) {\n            System.err.printf(\"Pool#min:%d,active:%d,max:%d,currentSize:%d,taskRemain:%d\\n\",\n                    this.min, this.active, this.max, this.size, TASK_QUEUE.size());\n            try {\n                Thread.sleep(5000);\n                if (TASK_QUEUE.size() > active && size < active) {\n                    for (int i = size; i < active; i++) {\n                        createThreadQueue();\n                    }\n                    System.out.println(\"increment to active success\");\n                    this.size = active;\n                } else if (TASK_QUEUE.size() > max && size < MAX) {\n                    for (int i = size; i < max; i++) {\n                        createThreadQueue();\n                    }\n                    System.out.println(\"increment to max success\");\n                    this.size = max;\n                }\n                if (TASK_QUEUE.isEmpty() && size > active) {\n                    System.out.println(\"==================reduce=================\");\n                    //防止并发修改，在 shutdown 的时候 reduce\n                    synchronized (THREAD_QUEUE) {\n                        int release = size - active;\n                        //Itertor 可以在遍历的过程中 remove\n                        for (Iterator<MyThread> it = THREAD_QUEUE.iterator(); it.hasNext(); ) {\n                            if (release <= 0)\n                                break;\n                            MyThread mt = it.next();\n                            //如果该线程在工作就不要打断它\n                            if(mt.getThreadState()==ThreadState.RUNNING){\n                                continue;\n                            }\n                            mt.close();\n                            mt.interrupt();\n                            it.remove();\n                            release--;\n                        }\n                        this.size = active;\n                    }\n\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void init() {\n        /*    for (int i = 0; i < size; i++) {\n            createThreadQueue();\n        }*/\n        for (int i = 0; i < this.min; i++) {\n            createThreadQueue();\n        }\n        this.size = min;\n        this.start();\n    }\n\n    public void submit(Runnable runnable) {\n        if (destroy) {\n            throw new IllegalStateException(\"The Pool is shutdown , you can't submit now ! !\");\n        }\n        synchronized (TASK_QUEUE) {\n            if (TASK_QUEUE.size() > queueSize) {\n                discardPolicy.discard();\n            }\n            TASK_QUEUE.addLast(runnable);\n            //唤醒线程池中的线程\n            TASK_QUEUE.notifyAll();\n        }\n    }\n\n    public void shutdown() throws InterruptedException {\n        while (!TASK_QUEUE.isEmpty()) {\n            Thread.sleep(50);\n        }\n        int initVal = THREAD_QUEUE.size();\n        synchronized (THREAD_QUEUE) {\n            while (initVal > 0) {\n                for (MyThread thread : THREAD_QUEUE) {\n                    if (thread.getThreadState() == ThreadState.BLOCKED) {\n                        //设置为 DEAD 状态\n                        thread.close();\n                        thread.interrupt();\n                        initVal--;\n                    } else {\n                        Thread.sleep(10);\n                    }\n                }\n            }\n        }\n        this.destroy = true;\n        System.out.println(\"My Thread pool is shutdown\");\n    }\n\n    public boolean isDestroy() {\n        return this.destroy;\n    }\n\n    private void createThreadQueue() {\n        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));\n        thread.start();\n        THREAD_QUEUE.add(thread);\n    }\n\n    private enum ThreadState {\n        FREE, RUNNING, BLOCKED, DEAD\n    }\n\n    public static class DiscardException extends RuntimeException {\n        public DiscardException(String message) {\n            super(message);\n        }\n    }\n\n    @FunctionalInterface\n    public interface DiscardPolicy {\n        void discard() throws DiscardException;\n    }\n\n    private static class MyThread extends Thread {\n        private volatile ThreadState threadState = ThreadState.FREE;\n\n        public ThreadState getThreadState() {\n            return this.threadState;\n        }\n\n        public MyThread(ThreadGroup group, String name) {\n            super(group, name);\n        }\n\n        @Override\n        public void run() {\n            OUTER:\n            while (this.threadState != ThreadState.DEAD) {\n                Runnable runnable;\n                synchronized (TASK_QUEUE) {\n                    while (TASK_QUEUE.isEmpty()) {\n                        try {\n                            this.threadState = ThreadState.BLOCKED;\n                            TASK_QUEUE.wait();\n                        } catch (InterruptedException e) {\n                            System.out.println(Thread.currentThread().getName() + \" is dead\");\n                            break OUTER;\n                        }\n                    }\n                    runnable = TASK_QUEUE.removeFirst();\n                }\n                Optional.of(runnable).ifPresent(t -> {\n                    this.threadState = ThreadState.RUNNING;\n                    t.run();\n                    this.threadState = ThreadState.FREE;\n                });\n            }\n        }\n\n        private void close() {\n            this.threadState = ThreadState.DEAD;\n        }\n    }\n}\n```\n\n相比上面固定的 size 这个版本\n\n① 增加了三个字段用于动态的扩容，因为需要管理这些线程，所以将整个线程池也继承了`Thread`并实现了 run 方法，主要就是判断`TASK_QUEUE.size() > active && size < active`当前任务队列任务多于`active`并且当前线程队列线程数小于`active`，就可以扩容到 active，max 同理\n\n②`TASK_QUEUE.isEmpty() && size > active` 闲时回收，任务队列没有任务，但是线程队列线程还很多，浪费了资源，所以需要`reduce`一些空闲的线程。这里有两个小细节，1. 在 reduce 和 shutdown 的时候需要同步`线程队列`不然在`reduce`的时候`shutdown`会产生`并发修改异常`（一个在遍历，一个在 remove）。\n\n### 测试线程池\n\n```java\npublic class ThreadPoolTest {\n    public static void main(String[] args) throws InterruptedException {\n        SimpleThreadPool threadPool= new SimpleThreadPool();\n        IntStream.rangeClosed(0, 40)\n                .forEach(i -> {\n                    threadPool.submit(() -> {\n                        System.out.println(\"The task \" + i + \"  runnable by thread \" + Thread.currentThread().getName() + \" start\");\n                        try {\n                            Thread.sleep(5000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"The task \" + i + \"  runnable by thread \" + Thread.currentThread().getName() + \" end\");\n                    });\n                    System.out.println(\"submit \" + i);\n                });\n        threadPool.shutdown();\n    }\n}\n```\n\n## 参考资料\n\n- 《Java 多线程编程实战指南》 \n- [并发编程网](http://ifeve.com)\n- [Java 语言规范](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.2.4)\n","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"LeetCode 链表","url":"/2019/02/27/bef97aa3/","content":"\n> 链表专题是最开始学算法的时候写的，很多代码都写得很烂，目前正在慢慢的重写，u1s1 链表的题还是很考验细心的，稍不注意就连错了\n\n##  [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers)\n\n给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。\n 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n\n输出：7 -> 0 -> 8\n\n原因：342 + 465 = 807\n\n**解法一**\n\n```java\n//比较推荐的写法，简洁一点，在 lc 上提交区别不大\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyNode=new ListNode(-1);\n    ListNode temp=dummyNode;\n    dummyNode.next=temp;\n    int carry=0;\n    while(l1!=null || l2!=null){\n        int sum= (l1!=null?l1.val:0) + (l2!=null?l2.val:0)+ carry;\n        temp.next=new ListNode(sum%10);\n        temp=temp.next;\n        carry=sum/10;\n        l1=l1!=null?l1.next:null;\n        l2=l2!=null?l2.next:null;\n    }\n    if(carry!=0) temp.next=new ListNode(1);\n    return dummyNode.next;\n}\n```\n~~很久之前写的代码了，代码很乱，用 0 补齐短的那个然后对应相加注意进位就行了~~\n\n2020.3.22 把之前的代码删了，一年前的代码，写的太丑了\n\n**解法二**\n\n2020.3.22 新增了一个解法，有点偏，没啥意思，不过熟悉下链表还是可以\n\n```java\n//这个解法有点偏了，为了不 new 节点直接在原链表上修改的\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=l1;\n    int carry=0;\n    ListNode last=l1;\n    while(l1!=null && l2!=null){\n        int sum= l1.val + l2.val+ carry;\n        l1.val=sum%10;\n        carry=sum/10;\n        last=l1;\n        l1=l1.next;\n        l2=l2.next;\n    }\n    while(l1!=null && carry!=0){\n        int sum = l1.val + carry;\n        l1.val=sum%10;\n        carry=sum/10;\n        last=l1;\n        l1=l1.next;\n    }\n    if(l2!=null){\n        last.next=l2;\n        while(l2!=null && carry!=0){\n            int sum = l2.val + carry;\n            l2.val=sum%10;\n            carry=sum/10;\n            last=l2;\n            l2=l2.next;\n        }\n    }\n    if(carry!=0) last.next=new ListNode(1);\n    return dummyNode.next;\n}\n```\n## [445. 两数相加Ⅱ](https://leetcode-cn.com/problems/add-two-numbers-ii)\n\n给定两个**非空**链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n进阶：\n如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。\n\n输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\n\n输出：7 -> 8 -> 0 -> 7\n\n```java\npublic static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    BigInteger b1 = new BigInteger(list2num(l1));\n    BigInteger b2 = new BigInteger(list2num(l2));\n    String resStr=b1.add(b2).toString();\n    //再变成字符串存到连表里面\n    ListNode res=new ListNode(1);\n    ListNode real=res;\n    for (int i=0;i<resStr.length();i++) {\n        real.next=new ListNode(Integer.valueOf(resStr.charAt(i)-48));\n        real=real.next;\n    }\n    return res.next;\n}\npublic static String  list2num(ListNode l){\n    String num=\"\";\n    while(l!=null){\n        num=num+l.val;\n        l=l.next;\n    }\n    return num;\n}\n```\n这两题方法很多，下面那题实际上是上面那一题反过来的，但是题目要求不改变链表所以可以利用栈来反转，然后就跟上面的类似了，然后这里我偷了个懒用的`BigInteger`搞的速度也还行 77%beat。\n\n**解法二**\n\n（update: 2020.4.14）上面的解法笔试这样写倒是无所谓，面试这样写肯定是不行的，咱还是得规规矩矩的写\n\n```java\npublic  ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    //用数组的话不知道有多长，需要多遍历两遍\n    Deque<Integer> stack1=new ArrayDeque<>();\n    Deque<Integer> stack2=new ArrayDeque<>();\n    ListNode res=new ListNode(-1);\n    while(l1!=null){\n        stack1.push(l1.val);\n        l1=l1.next;\n    }\n    while(l2!=null){\n        stack2.push(l2.val);\n        l2=l2.next;\n    }\n    int carry=0;\n    while(!stack1.isEmpty() || !stack2.isEmpty() || carry>0){\n        int temp=(stack1.isEmpty()?0:stack1.pop())+(stack2.isEmpty()?0:stack2.pop())+carry;\n        //头插法\n        ListNode next=res.next;\n        ListNode newNode=new ListNode(temp%10);\n        res.next=newNode;\n        newNode.next=next;\n        carry=temp/10;\n    }\n    return res.next;\n}\n```\n\n最后的头插法还是挺好的，我开始还想着翻转一下的，我看见评论区有人用递归写，我试了下，还是算了，太麻烦了，还没上面的简洁，写一大坨初始化，然后再递归，代码一点都不简洁，没啥意义\n\n## [876. 链表的中间节点](https://leetcode-cn.com/problems/middle-of-the-linked-list)\n\n```java\npublic static ListNode middleNode(ListNode head) {\n        if(head==null||head.next==null)return head;\n        ListNode fast=head;\n        ListNode slow=head;\n        // 1 2 3 4 5 6 7\n        while(fast!=null&&fast.next!=null){\n            fast=fast.next.next;\n            slow=slow.next;\n        }\n        return slow;\n}\n```\n> `快慢指针`，很常见很经典的做法后面很多题会用到这个。\n\n## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)\n反转一个单链表。\n\n**解法一**\n\n```java\n//递归\npublic static ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    ListNode newHead = reverseList(head.next);\n    //从后往前\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n}\n```\n**解法二**\n\n```java\n//三指针迭代\npublic static ListNode reverseList2(ListNode head) {\n    if(head==null)return head;\n    ListNode pre=head;\n    ListNode cur=head.next;\n    ListNode temp;\n    while(cur!=null){\n        temp=cur.next;\n        cur.next=pre;\n        pre=cur;\n        cur=temp;\n    }\n    head.next=null;\n    return pre;\n}\n```\n## [92. 反转链表Ⅱ](https://leetcode-cn.com/problems/reverse-linked-list-ii)\n反转从位置 _m_ 到 _n_ 的链表。请使用一趟扫描完成反转。\n\n**解法一**\n\n```java\npublic static ListNode reverseBetween(ListNode head, int m, int n) {\n    if(m==n) return head;\n    //用来遍历\n    ListNode pre=head;\n    ListNode mid=head.next;\n    ListNode rear=null;\n    //在遍历的中间连接这个表 时间复杂厚度 O(N)\n    //所以需要先保存 m 前的节点用于后面到 n 的时候连接 n 和前面的部分 preM\n    //还要保存 m 节点，在后面遍历到 n 的时候将 M 节点和后面的部分连接\n    //中间段的前后节点 \n    ListNode preM =null;\n    ListNode valM=head;\n    //ListNode nNext=null;\n    int count =1;\n    while(count <=n-1){\n        //count 的位置实际上是指的 pre 的位置因为只有 pre 是从 head 开始走的\n        //尾指针后移\n        rear=mid.next;\n        if(count==m-1){\n            //保存 M 点前面的节点和 M 节点\n            preM=pre;\n            valM=mid;\n            //System.out.println(\"preM :\"+preM.val);\n        }\n        if(count==n-1){\n            //连接 n 后面节点的值\n            valM.next=rear;\n            //在这里判断下 m 前有没有元素\n            if(m==1){\n                head=mid;\n            } else{\n                preM.next=mid;\n            }\n        }\n        if(count >= m && count <=n-1){\n            //只有 mid 的位置大于 m 小于等于 n 才会将节点 next 域反转\n            mid.next=pre;\n        }\n        //其他两个指针也向后移动\n        pre=mid;\n        mid=rear;\n        count++;\n    }\n    return head;\n}\n```\n代码写的比较烂但是思路还是比较清晰，只扫描了一遍链表 2ms beat 100%，但是创建的指针有点多，抠边界要细心。\n\n**解法二**\n\n被本来是像把上面的解法删掉的，想了一下还是留着，提醒下自己，上面的解法不够通用，属于一次性的解法，细节也很多，当初可能是追求在一个循环内写完，所以可能写的比较难看\n\n```go\nfunc reverseBetween2(head *ListNode, m int, n int) *ListNode {\n    dummyNode := &ListNode{\n        Val:  -1,\n        Next: head,\n    }\n    mpre := dummyNode //m 节点前的节点\n    for i := m; i > 1; i-- {\n        mpre = mpre.Next\n    }\n    pre := mpre\n    cur := mpre.Next\n    //  2   4\n    //1 2 3 4 5\n    for i := m; i <= n; i++ {\n        next := cur.Next\n        cur.Next = pre\n        pre = cur\n        cur = next\n    }\n    mpre.Next.Next = cur //2.next=5\n    mpre.Next = pre      //1.next=4\n    return dummyNode.Next\n}\n```\n\n这个解法实际上就是普通一个翻转，然后处理翻转部分的头尾节点连接，但是代码比上面的简洁多了\n\n**解法三**\n\n头插法的应用，将翻转部分节点用头插法插入 pre 后，也挺不错\n\n```go\n//头插法\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\n    dummyNode := &ListNode{\n        Val:  -1,\n        Next: head,\n    }\n    mpre := dummyNode //m 节点前的节点\n    for i := m; i > 1; i-- {\n        mpre = mpre.Next\n    }\n    cur := mpre.Next\n    //1 |2 3 4| 5\n    for i := m; i < n; i++ {\n        //除非 m=n=len 不然 next 肯定不为空，但是这种情况已经被循环的条件过滤了\n        next := cur.Next\n        cur.Next = next.Next\n        next.Next = mpre.Next\n        mpre.Next = next\n    }\n    return dummyNode.Next\n}\n```\n\n## [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)\n\nGiven a (singly) linked list with head node `root`, write a function to split the linked list into `k` consecutive linked list \"parts\".\n\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.\n\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n\nReturn a List of ListNode's representing the linked list parts that are formed.\n\nExamples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]\n\n**Example 1:**\n\n```java\nInput: \nroot = [1, 2, 3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe input and each element of the output are ListNodes, not arrays.\nFor example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but it's string representation as a ListNode is [].\n```\n\n**Example 2:**\n\n```java\nInput: \nroot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\nOutput: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n```\n\n**Note:**\n\nThe length of `root` will be in the range `[0, 1000]`.\n\nEach value of a node in the input will be an integer in the range `[0, 999]`.\n\n`k` will be an integer in the range `[1, 50]`.\n\n**解法一**\n\n```java\npublic static ListNode[] splitListToParts(ListNode root, int k) {\n    //先要获取下链表的长度\n    ListNode temp=root;\n    ListNode next=root;\n    ListNode [] result=new ListNode[k];\n    int count=0;\n    while(temp!=null){\n        temp=temp.next;\n        count++;\n    }\n    temp=root;\n    //任意两部分差距不能大于 1，大的在前，小的在后面\n    //其实就是对 count 进行分配\n    //注意：有 null 的情况一定是 k>count 直接按 1 切分就完事了\n    //k<count 的情况只要在 count/k 的前几个元素上加上 count/k 的余数就行了\n    int size=count/k;\n    int num=count%k;\n    result[0]=root;\n    int index=1;\n    if(k<=count){\n        for (int i=1;temp!=null && index < k;i++){\n            next=temp.next;\n            if(i<=(size+1)*num && i%(size+1)==0){\n                //前几个 res 的分割点\n                result[index++]=next;\n                //切断\n                temp.next=null;\n            } else if(i>(size+1)*num && (i-num)%size==0){\n                result[index++]=next;\n                temp.next=null;\n            }\n            temp=next;\n        }\n    } else{\n        //剩下的情况就是后面要补 null 的情况\n        // 这里两种情况应该是可以合并的，但是 k>count num>0 懒得去抠边界\n        for (int i=1;i<k;i++){\n            if(temp==null){\n                //这个 if 其实没必要\n                result[i]=null;\n            } else{\n                next=temp.next;\n                result[i]=next;\n                temp.next=null;\n                temp=next;\n            }\n        }\n    }\n    return result;\n}\n```\n3ms beat 89% 这题也比较简单主要是边界要抠好\n\n## [86. 分隔（割）链表](https://leetcode-cn.com/problems/partition-list)\n给定一个链表和一个特定值`x`，对链表进行分隔，使得所有小于`x`的节点都在大于或等于`x`的节点之前。\n\n你应当保留两个分区中每个节点的初始相对位置。\n\n**输入：** head = 1->4->3->2->5->2, _x_ = 3\n\n**输出：** 1->2->2->4->3->5\n\n**解法一**\n\n```java\npublic ListNode partition(ListNode head, int x) {\n    //先在头部加一个 dummy 节点统一操作\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    //分割点\n    ListNode pre=cutNode=dummyNode;\n    ListNode cur=head;\n    int cut=0;\n    while(cur!=null){\n        if(cur.val>=x&&cut==0){\n            //只会执行一次在找到第一个 val>=x 的节点的时候---保存分割点\n            cutNode=pre;\n            cut=1;\n        } else if(cur.val<x && cut==1){\n            //找到分割点后 遍历到 val<x 的节点的情况---将 cur 连接到 cutNode 的后面 处理好 cur 相邻的两个节点\n            //先处理好 cur 相邻的节点\n            pre.next=cur.next;\n            //连接 cutNode\n            cur.next=cutNode.next;\n            cutNode.next=cur;\n            //cutNode 后移\n            cutNode=cur;\n        }\n        pre=cur;\n        cur=cur.next;\n    }\n    return dummyNode.next\n}\n```\n这题也挺简单和上面的那题名字一样是在整理这篇博客的时候现场做的 (2019.2.27) 前后大概半个小时 orz。比较菜，但是这个我没有在本地跑直接在 LeetCode 上提交的然后就过了 1ms beat84% 感觉思路比较清晰就没有本地跑，提交记录上最快的居然是用了额外空间 new 了两个链表然后连起来的。醉了可能是测试用例太少了。\n\n## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)\n编写一个程序，找到两个单链表相交的起始节点。\n如下面的两个链表：\n![mark](http://static.imlgw.top///20190303/NVEXndTcF1R6.png?imageslim)\n\n在节点 c1 开始相交。\n\n**示例 1：**\n\n![mark](http://static.imlgw.top///20190303/ymln2djUVieT.png?imageslim)\n\n**输入**: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n**输出**: Reference of the node with value = 8\n**输入解释**: 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n**示例 2：**\n\n![mark](http://static.imlgw.top///20190303/2F7qqhkUIWog.png?imageslim)\n**输入**:intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n**输出**:Reference of the node with value = 2\n**输入解释**: 相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n**示例 3：**\n\n![mark](http://static.imlgw.top///20190303/hKSAelGSE1TY.png?imageslim)\n\n**输入**:intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n**输出**:null\n**输入解释**: 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n**解释**: 这两个链表不相交，因此返回 null。\n\n**注意：**\n\n*   如果两个链表没有交点，返回 `null`.\n*   在返回结果后，两个链表仍须保持原有的结构。\n*   可假定整个链表结构中没有循环。\n*   程序尽量满足 O(_n_) 时间复杂度，且仅用 O(_1_) 内存。\n\n**解法一：**\n\n```java\npublic static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode pA=headA;\n    ListNode pB=headB;\n    //计算两个链表长度然后计算差距然后向后对齐\n    int lenA=0;\n    int lenB=0;\n    while(pA!=null){\n        pA=pA.next;\n        lenA++;\n    }\n    while(pB!=null){\n        pB=pB.next;\n        lenB++;\n    }\n    int dis=lenB>lenA?lenB-lenA:lenA-lenB;\n    if(lenB>lenA){\n        while(dis-->0){\n            headB=headB.next;\n        }\n    } else{\n        while(dis-->0){\n            headA=headA.next;\n        }\n    }\n    //不相等就一直向后移\n    while(headA!=headB){\n        //如果有一条为空说明没有交点\n        if(headA.next==null){\n            return null;\n        }\n        headA=headA.next;\n        headB=headB.next;\n    }\n    return headA;\n}\n```\n这种方法比较直接直接计算两个链表的长度然后计算差值然后将长的那个移动到对应的位置让`两条链表尾对齐`然后一起向后移动\n**解法二：**\n\n```java\n//方法二 \npublic static ListNode getIntersectionNode2(ListNode headA, ListNode headB) {\n    //当一个指针到结尾时转到另一个链表头再向后移动 ，这样做的目的和就是可以直接消除链表之间的长度差，向后对齐，方法还是很巧妙的。\n    ListNode pA=headA;\n    ListNode pB=headB;\n    if(headB==null || headA==null)\n                 return null;\n    //while(pA!=null && pB!=null ){\n    while(pA!=pB){\n        //要保证两个==null 的时候都只能执行一次不然如果没有交点就会死循环\n        //改变 while 的条件\n        //改变 pA，pB 跳转的条件\n        //这样就可以保证最后没交点的时候 第二遍循环 pA 和 pB 最后会同时等于 null 会有出口不会死循环\n        pA=pA==null?headB:pA.next;\n        pB=pB==null?headA:pB.next;\n    }\n    return pA;\n}\n```\n>  同时遍历两个链表，当一个指针到结尾时转到另一个链表头再向后移动 ，这样做的目的和就是可以直接消除链表之间的长度差，使之尾对齐，方法还是很巧妙的，代码也比较简洁。\n\n## [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list)\n请判断一个链表是否为回文链表。\n\n**示例 1:**\n\n**输入：** 1->2\n**输出：** false\n\n**示例 2:**\n\n**输入：** 1->2->2->1\n**输出：** true\n\n**进阶：**\n你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n\n```java\npublic boolean isPalindrome(ListNode head) {\n    if(head==null || head.next==null){\n        return true;\n    }\n    // 利用快慢指针找到中点\n    ListNode fast = head;\n    ListNode slow = head;\n    while (fast.next != null) {\n        fast = fast.next.next == null ? fast.next : fast.next.next;\n        slow = slow.next;\n    }\n    // 如果是偶数节点，slow 就是偏右的那个 奇数就是正中间的 奇数在正中间不用管\n    // fast 是尾节点 1 1 1 1 1 1\n    resverList(slow);\n    //slow.next==null\n    // check\n    while (fast != null && head != null) {\n        if (fast.val != head.val) {\n            return false;\n        }\n        fast = fast.next;\n        head = head.next;\n    }\n    return true;\n\n}\n\npublic static void resverList(ListNode node) {\n    ListNode cur = node;\n    ListNode pre = null;\n    ListNode next = node;\n    while (cur != null) {\n        next = next.next;\n        cur.next = pre;\n        pre = cur;\n        cur = next;\n    }\n}\n```\n这题就用到了上面的翻转链表的方法，不过这里只翻转了一半，翻转了后半段然后从两边到中间逐个节点对比\n\n## [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)\n请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。\n\n现有一个链表 -- head = [4,5,1,9]，它可以表示为：\n\n![mark](http://static.imlgw.top///20190303/9MUvMzlcAN0G.png?imageslim)\n\n**示例 1:**\n\n**输入：** head = [4,5,1,9], node = 5\n**输出：** [4,1,9]\n**解释：** 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n\n**示例 2:**\n\n**输入：** head = [4,5,1,9], node = 1\n**输出：** [4,5,9]\n**解释：** 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n**说明：**\n\n*   链表至少包含两个节点。\n*   链表中所有节点的值都是唯一的。\n*   给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n*   不要从你的函数中返回任何结果。\n\n**二货做法**\n\n```java\npublic  static void deleteNodelow(ListNode node) {\n    //思路就是和 node 后面的元素一直交换，就像冒泡排序一样\n    ListNode next;\n    ListNode temp=new ListNode(0);\n    ListNode pre=temp;\n    while(node.next!=null){\n        next=node.next;\n        if(node.next.next==null){\n            pre=node;\n        }\n        //先保存最后一个节点前的节点\n        //交换当前节点和后一个节点\n        temp.val=node.val;\n        node.val=next.val;\n        next.val=temp.val;\n        node=next;\n    }\n    pre.next=null;\n}\n```\n首先想到的愚蠢的做法，怎么这么蠢？？？？\n\n**正确做法**\n\n```java\n  public  static void deleteNode(ListNode node) {\n        node.val=node.next.val;\n        node.next=node.next.next;\n  }\n```\n\n## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements)\n删除链表中等于给定值 val 的所有节点。\n\n**示例：**\n\n**输入：** 1->2->6->3->4->5->6, _**val**_ = 6\n**输出：** 1->2->3->4->5\n\n**解法一：**\n双指针 + 虚拟头节点\n\n```java\n public static ListNode removeElements(ListNode head, int val) {\n        if (head == null) return null;\n        ListNode dummyHead = new ListNode(0);\n        //再头接待你之前加了新的节点\n        dummyHead.next = head;\n        ListNode pre = dummyHead, cur = head;\n        while (cur != null) {\n            if (cur.val == val) {\n                pre.next = cur.next;\n            } else {\n                //不是相等的值就向后移动\n                pre = cur;\n            }\n            cur = cur.next;\n        }\n        return dummyHead.next;\n    }\n```\n**解法二：**\n\n递归方法比较简洁\n\n```java\n//递归\npublic static ListNode removeElements2(ListNode head, int val){\n    if (head == null)\n       return null;\n    //将下一个元素放进递归如果是==val 的就会把下一个的下一个元素返回连接到当前元素\n    head.next = removeElements2(head.next, val);\n    return head.val == val ? head.next : head;\n}\n```\n\n## [19. 删除链表的倒数第 N 个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n给定一个链表：1->2->3->4->5, 和 n = 2.\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n说明：\n给定的 n 保证是有效的。\n进阶：\n你能尝试使用一趟扫描实现吗？\n\n**解法一**\n\n```java\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    if(head==null&&head.next==null) return null;\n    //双指针 主要是头和尾的删除需要抠一下边界\n    //  -1 | 1 2 3 4 5 6\n    ListNode fast=head;\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    ListNode slow=dummyNode;\n    //加了哑节点，直接先加 1\n    int count=1;\n    while(fast!=null){\n        fast=fast.next;\n        slow=count<n?slow:slow.next;\n        count++;\n        if(fast.next==null){\n            //slow 到达需要删除的位置的前一个\n            slow.next=slow.next.next;\n            return dummyNode.next;\n        }\n    }\n    return dummyNode.next;\n}\n```\n看了评论才知道咋一遍循环，主要就是控制 slow 指针走`length-n`步，让快指针先走 n 步，然后快慢一起走，快指针到头时慢指针就到`length-n`的位置了，这题也可以用 List 保存每个节点让然后把待删除的节点的前一个拿出来操作，遍历两遍的方法比较简单就不写了，感觉这种方法比较好 , 这题的 OJ case 比较少所以没什么可比性 , 前几个都是跑了两遍的，我把最快的拷过来跑的比我还慢。然后我又提交了一次 beat 90%.......\n\n## [82. 删除排序链表中的重复元素Ⅱ](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)\n给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中**没有重复出现**的数字。\n\n**示例 1:**\n\n输入：1->2->3->3->4->4->5\n输出：1->2->5\n\n**示例 2:**\n\n输入：1->1->1->2->3\n输出：2->3\n\n**解法一**\n\n乍一看跟上面那一题一样？这题是排序链表上面那题是无序的，而且这题不给定元素\n\n```java\npublic  static ListNode deleteDuplicates(ListNode head) {\n    if(head==null)return null;\n    //首先想到的思路是 3 指针，然后遍历的过程中后面的指针遇到==val 的情况就让后面的指针一直后移走到！=val\n    //先添加个哑节点\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    ListNode cur=head;\n    ListNode next=head.next;\n    ListNode pre=dummyNode;\n    while(next!=null){\n        while(next.val==cur.val){\n            next=next.next;\n            if(next==null){\n                pre.next=null;\n                return dummyNode.next;\n            }\n            if(next.val!=cur.val){\n                pre.next=next;\n                //cur 跟上\n                cur=next;\n                break;\n            }\n        }\n        //关键就是 pre 移动这里有坑 不能直接将 pre 移到 cur, 因为会有连续的连续存在\n        pre=cur.next!=null&&cur.val==cur.next.val?pre:cur;\n        cur=next;\n        next=next.next;\n    }\n    return dummyNode.next;\n}\n```\n整体来说还是挺简单的只跑了一趟 1ms beta98%，评论里面大都只用了两个指针我用了三个这样感觉比较清晰\n怎么好理解怎么来。貌似最快的是一个递归的，递归写起来确实玄学还要多练练啊\n\n**解法二**\n\n2020.4.2 重写了一个递归的，感觉良好\n\n```java\npublic ListNode deleteDuplicates(ListNode head) {\n    if(head==null || head.next==null) return head;\n    if(head.val==head.next.val){\n        while(head!=null && head.next!=null && head.val==head.next.val){\n            head=head.next;\n        }\n        return deleteDuplicates(head.next); //去重\n    }\n    head.next=deleteDuplicates(head.next);\n    return head;\n}\n```\n## [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)\n\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n**示例 1:**\n\n```java\n输入：1->1->2\n输出：1->2\n```\n\n**示例 2:**\n\n```java\n输入：1->1->2->3->3\n输出：1->2->3\n```\n\n**解法一**\n\n老题新写\n\n```java\n//递归\npublic ListNode deleteDuplicates(ListNode head) {\n    if(head==null || head.next==null) return head;\n    ListNode node=deleteDuplicates(head.next);\n    if(head.val==node.val) {\n        head.next=node.next;\n    }\n    return head;\n}\n```\n**解法二**\n\n```java\n//迭代\npublic ListNode deleteDuplicates(ListNode head) {\n    ListNode temp = head;\n    while (temp != null){\n        if (temp.next == null){\n            break;\n        }\n        if (temp.next.val == temp.val){\n            temp.next = temp.next.next;\n        }else {\n            temp = temp.next;\n        }\n\n    }\n    return head;\n}\n```\n\n## [面试题 02.01\\. 移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)\n\n编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。\n\n**示例 1:**\n\n```java\n 输入：[1, 2, 3, 3, 2, 1]\n 输出：[1, 2, 3]\n```\n\n**示例 2:**\n\n```java\n 输入：[1, 1, 1, 1, 2]\n 输出：[1, 2]\n```\n\n**提示：**\n\n1.  链表长度在 [0, 20000] 范围内。\n2.  链表元素在 [0, 20000] 范围内。\n\n**进阶：**\n\n如果不得使用临时缓冲区，该怎么解决？\n\n**解法一**\n\n无序链表，和前面不太一样，开个 20000 的数组判断是否重复就行了\n```golang\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeDuplicateNodes(head *ListNode) *ListNode {\n    var set = make([]bool,20001)\n    var dummyNode = &ListNode{Next:head}\n    var pre = dummyNode\n    for head!=nil{\n        if !set[head.Val]{\n            set[head.Val]=true\n            pre=head\n        }else{\n            pre.Next=head.Next\n        }\n        head=head.Next\n    }\n    return dummyNode.Next\n}\n```\n> 这个进阶或许应该称之为退阶。进阶的应该只能暴力 O(N^2) 而且这个数据量肯定会 T，排序的话并没有合适的排序方法\n\n## [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)\n\n给定一个单链表 _L_：L0→L1→…→Ln-1→Ln \n将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n**示例 1:**\n\n给定链表 1->2->3->4, 重新排列为 1->4->2->3.\n\n**示例 2:**\n\n给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.\n\n> 这题和上面的回文链表有点类似，都是快慢指针不过这题稍微复杂点\n\n**解法一**\n\n```java\npublic static void reorderList(ListNode head) {\n    if(head==null){\n        return;\n    }\n    ListNode right = head;\n    ListNode slow = head;\n    // 1 1 1 1 1 1 1\n    while (right.next != null) {\n        right = right.next.next != null ? right.next.next : right.next;\n        slow = slow.next;\n    }\n    // 从 slow 开始翻转\n    res(slow);\n    //左半部分\n    ListNode left = head;\n    //下一个节点\n    ListNode rnext = right;\n    ListNode lnext = left;\n    // 1 2 3 4 5 6 7 8 \n    // 1 8 2 7 3 6 4 5\n    while (right != null && left != null) {\n        // 要保存 right 的下一个节点 , left 也需要，不然无法导航到下一个节点\n        lnext = lnext.next;\n        rnext = rnext.next;\n        // 偶数个数节点，如果遍历到 right 链表的最后一个节点\n        // 偶数的话 right 链表会短一点 最后连接的时候\n        // left: 1->2->3->4->5 right: 8->7->6->5   \n        // 像这样会将 5 加到 left 的 4 和 5 之间，但是明显只有一个 5 这样添加就是有问题的\n        if(right.next==null){\n            //所以这里吧 lnext 赋值为 null, 后面就不会重复连接 5 这个节点\n            lnext=null;\n        }\n        //奇数个数的时候这样连接没问题\n        // 1 2 3 4 5 \n        // 9 8 7 6 5\n        //5.next=5\n        left.next = right;\n        //如果奇数个数到最后这一步 right 和 left 是同一个节点都为值是 5 的节点\n        //所以这里下面的直接覆盖了上面的\n        //5.next=null\n        right.next = lnext;\n        left = lnext;\n        right = rnext;\n    }\n}\n\n//反转\npublic static void res(ListNode node) {\n    ListNode pre = null;\n    ListNode cur = node;\n    ListNode nex = node;\n    while (cur != null) {\n        nex = nex.next;\n        cur.next = pre;\n        pre = cur;\n        cur = nex;\n    }\n}\n```\n\n也是之前的代码了，写的比较烂，但是思路还是比较清晰的，边界需要注意，速度还行 4ms  77% 。\n\n## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n**示例：**\n\n```java\n输入： 1->2->4, 1->3->4\n输出： 1->1->2->3->4->4\n```\n\n**解法一**\n\n常规迭代的做法\n\n```java\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode temp=new ListNode(0);\n        ListNode res=temp;\n        while(l1!=null&&l2!=null){\n            if(l2.val<l1.val){\n                temp.next=l2;\n                l2=l2.next;\n                temp=temp.next;\n            }else{\n                temp.next=l1;\n                l1=l1.next;\n                temp=temp.next;\n            }\n        }\n        temp.next=l1==null?l2:l1;\n        return res.next;\n}\n```\n归并分治的思想，期末考试的一道题\n\n**解法二**\n\n递归的做法\n\n```java\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode dummyNode=new ListNode(-1);\n    mergeTwoLists(l1,l2,dummyNode);\n    return dummyNode.next;\n}\n\npublic void mergeTwoLists(ListNode l1, ListNode l2,ListNode res) {\n    if(l1==null){\n        res.next=l2;\n        return;\n    }\n\n    if(l2==null){\n        res.next=l1;\n        return;\n    }\n\n    if(l1.val>l2.val){\n        res.next=l2;\n        mergeTwoLists(l1,l2.next,res.next);\n    }else{\n        res.next=l1;\n        mergeTwoLists(l1.next,l2,res.next);\n    }\n}\n```\n\n上面是我一开始自己写的，一点也不递归\n\n```java\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    if(l1==null) return l2;\n    if(l2==null) return l1;\n    ListNode dummyNode=new ListNode(-1);\n    if(l1.val<l2.val){\n        l1.next=mergeTwoLists(l1.next,l2);\n        return l1;\n    }else{\n        l2.next=mergeTwoLists(l1,l2.next);\n        return l2;\n    }\n}\n```\n\n这种看着就很简洁\n\n---\n## [23. 合并 K 个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n**示例：**\n\n```java\n输入：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出：1->1->2->3->4->4->5->6\n```\n\n**解法一：**\n\n```java\npublic ListNode mergeKLists(ListNode[] lists) {\n    if(lists.length==0)return null;\n    ListNode temp=lists[0];\n    for (int i=0;i<lists.length-1;i++){\n        temp=merge2List(temp,lists[i+1]);\n    }\n    return temp;\n}\n\npublic static ListNode merge2List(ListNode headA,ListNode headB){\n    ListNode dummyNode=new ListNode(-1);\n    ListNode res=dummyNode;\n    ListNode tempA=headA;\n    ListNode tempB=headB;\n    while(tempB!=null&&tempA!=null){\n        if(tempB.val>tempA.val){\n            res.next=tempA;\n            tempA=tempA.next;\n        } else{\n            res.next=tempB;\n            tempB=tempB.next;\n        }\n        res=res.next;\n    }\n    res.next=tempA==null?tempB:tempA;\n    return dummyNode.next;\n}\n```\n最先想到的方法，和前面的二路归并一样，把前两个归并的结果和后面的继续归并。速度太慢了 200ms 左右。.... 时间复杂度是`O(N^2)`.\n**解法二：**\n\n```java\npublic ListNode mergeKLists2(ListNode[] lists) {\n    if(lists.length==0)return null;\n    return divide(lists,0,lists.length-1);\n}\n\npublic static ListNode divide(ListNode[] lists,int left,int right){\n    if(left>=right)return lists[left];\n    int mid=left+((right-left)>>1);\n    ListNode l = divide(lists,left,mid);\n    ListNode r = divide(lists,mid+1,right);\n    return merge2List(l,r);\n}\n\npublic static ListNode merge2List(ListNode headA,ListNode headB){\n    if(headA==null)return headB;\n    if(headB==null)return headA;\n    ListNode dummyNode=new ListNode(-1);\n    ListNode res=dummyNode;\n    ListNode tempA=headA;\n    ListNode tempB=headB;\n    while(tempB!=null&&tempA!=null){\n        if(tempB.val>tempA.val){\n            res.next=tempA;\n            tempA=tempA.next;\n        } else{\n            res.next=tempB;\n            tempB=tempB.next;\n        }\n        res=res.next;\n    }\n    res.next=tempA==null?tempB:tempA;\n    return dummyNode.next;\n}\n```\n看起来很眼熟？没错就是归并排序的思路，利用分治的思想，先归并左边，再归并右边，然后 merge 左右的结果，时间复杂度为`O(NlogK)` （递归树深度为 logK，归并每一层时间复杂度都是 N)， 10ms 左右，N 是所有链表的元素个数，K 是链表个数。而且因为是链表空间复杂度也不高。另外这题也可以改成非递归的方式如下：\n```java\npublic ListNode mergeKLists3(ListNode [] lists){\n    if (lists.length == 0) {\n        return null;\n    }\n    int k = lists.length;\n    while (k > 1) {\n        for (int i = 0; i < k / 2; i++) {\n            //两两合并将结果保存在前半部分的节点中然后缩小一半的范围\n            lists[i] = merge2Lists(lists[i], lists[i + (k + 1) / 2]);\n        }\n        //缩小一半的范围\n        k = (k + 1) / 2;\n    }\n    return lists[0];\n}\n```\n**解法三：**\n\n```java\n//小根堆的方法\npublic ListNode mergeKLists4(ListNode[] lists) {\n    //利用一个按节点值最小次序排列的优先队列，每次取最小的节点加入返回链表中\n    if(lists.length < 1) return null;\n    Queue<ListNode> pq = new PriorityQueue<>((a, b) -> (a.val - b.val));\n    ListNode head = new ListNode(0);\n    ListNode cur = head;\n    for (ListNode p : lists){\n        if(p != null)\n        pq.offer(p);\n    }\n    while(!pq.isEmpty()) {\n        cur.next = pq.poll();\n        cur = cur.next;\n        if(cur.next != null)\n        //讲当前节点后一个节点加入队列\n        pq.offer(cur.next);\n    }\n    return head.next;\n}\n```\n\n利用了小根堆，Java 里面有小根堆可以直接用，思路就是每次把每条链表的头元素都放进小根堆里面然后找出最小的加到新链表中然后，最小的那个节点的链表向后移再加到小根堆里面，方法还是相当简洁的。但是用了 90ms 左右比较慢，时间复杂度`O(NlogK)`和上面是一样的，每次调整时间复杂度都是`logK`，需要调整`N`次 (K 为链表数量，N 为所有链表的元素个数），空间复杂度是 `O(K)`\n\n## [355. 设计推特](https://leetcode-cn.com/problems/design-twitter/)\n\n设计一个简化版的推特 (Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：\n\n1. **postTweet(userId, tweetId):** 创建一条新的推文\n2. **getNewsFeed(userId):** 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。\n3. **follow(followerId, followeeId):** 关注一个用户\n4. **unfollow(followerId, followeeId):** 取消关注一个用户\n\n**实例**\n\n```java\nTwitter twitter = new Twitter();\n\n// 用户 1 发送了一条新推文 （用户 id = 1, 推文 id = 5).\ntwitter.postTweet(1, 5);\n\n// 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。\ntwitter.getNewsFeed(1);\n\n// 用户 1 关注了用户 2.\ntwitter.follow(1, 2);\n\n// 用户 2 发送了一个新推文 （推文 id = 6).\ntwitter.postTweet(2, 6);\n\n// 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -> [6, 5].\n// 推文 id6 应当在推文 id5 之前，因为它是在 5 之后发送的。\ntwitter.getNewsFeed(1);\n\n// 用户 1 取消关注了用户 2.\ntwitter.unfollow(1, 2);\n\n// 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。\n// 因为用户 1 已经不再关注用户 2.\ntwitter.getNewsFeed(1);\n```\n\n**解法一**\n\n其实核心就是一个 k 路链表的归并，这里直接用的优先级队列，然后用 java8 的新特性简化了代码\n\n```java\nclass Twitter {\n    //全局时间戳\n    private  int timeStamp=0;\n    //Tweet 是有序链表，按照时间戳来排序\n    private  Map<Integer,Tweet> userTweetMap=new HashMap<>();\n    //followMap\n    private  Map<Integer,Set<Integer>> userFollowMap=new HashMap<>();;\n\n    public Twitter() {}\n\n    public void postTweet(int userId, int tweetId) {\n        Tweet oldHead=userTweetMap.get(userId);\n        userTweetMap.compute(userId,(k,v)->new Tweet(tweetId,++timeStamp)).next=oldHead;\n    }\n\n    public List<Integer> getNewsFeed(int userId) {\n        PriorityQueue<Tweet> pq=new PriorityQueue<>((t1,t2)->t2.time-t1.time);\n        List<Integer> feed=new ArrayList<>();\n        follow(userId,userId);\n        userFollowMap.get(userId).forEach(followerId->Optional.ofNullable(userTweetMap.get(followerId)).ifPresent(tw->pq.offer(tw)));\n        int count=0;\n        while(!pq.isEmpty() && count<10){\n            Tweet tw=pq.poll();\n            feed.add(tw.twId);\n            if(tw.next!=null){\n                pq.offer(tw.next);\n            }\n            count++;\n        }\n        return feed;\n    }\n\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\n    public void follow(int followerId, int followeeId) {\n        userFollowMap.computeIfAbsent(followerId,k->new HashSet<>()).add(followeeId);\n    }\n\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\n    public void unfollow(int followerId, int followeeId) {\n        Optional.ofNullable(userFollowMap.get(followerId)).ifPresent(set->set.remove(followeeId));\n    }\n}\n\nclass Tweet{\n    int twId;\n    int time;\n    Tweet next;\n    public Tweet(int twId,int time){\n        this.twId=twId;\n        this.time=time;\n    }\n}\n```\n\n## [430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list)\n\n您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。\n\n扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。\n\n**示例：**\n\n输入：\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL\n\n输出：\n1-2-3-7-8-11-12-9-10-4-5-6-NULL\n\n**说明：**\n\n给出以下多级双向链表：\n\n![mark](http://static.imlgw.top///20190303/DqC2qKF5h63V.png?imageslim)\n\n我们应该返回如下所示的扁平双向链表：\n\n![mark](http://static.imlgw.top///20190303/qOSn0TLmMuCt.png?imageslim)\n\n**解法一：**\n\n```java\n/*\n        这种解法思路还是比较清晰的\n        每次有子链的时候就直接把子链遍历到尾 然后添加到链表中形成新主链 把子链的入口节点 child 指定为 null\n        然后主链继续向后遍历所以整个遍历的次数就是整个链表元素的个数 O(M)\n*/\npublic static Node flatten1(Node head) {\n    if(head==null || head.next==null&&head.child==null){\n        return head;\n    }\n    Node cur=head;\n    Node nNext;\n    Node child;\n    while(cur!=null){\n        if(cur.child!=null){\n            //有子链表\n            child=cur.child;\n            //子链表的表头\n            nNext=cur.next;\n            //主链的下一节点\n            //连接子链表\n            cur.next=child;\n            //主链的下一节点为子链表头\n            child.prev=cur;\n            //子链表的前驱节点\n            //已经拼接到主链，孩子链置为空 （这步还很关键我开始一直忘设置为 null）\n            cur.child=null;\n            if(nNext==null){\n                //遍历到主链最后一个了\n                //所以没有下一个节点，后面的步骤不用继续但是也不能 Break 因为最后一个节点有可能还有子链表\n                continue;\n            }\n            while(child.next!=null){\n                //找到新主链的下一节点 （子链的最后一个）\n                child=child.next;\n            }\n            //连接以前的主链\n            child.next=nNext;\n            nNext.prev=child;\n        }\n        //主链表向后移动\n        cur=cur.next;\n    }\n    return head;\n}\n```\n**解法二：**\n\n```java\n    //标准的 DFS\n    public static Node flatten2(Node node) {\n       if(node==null){\n            return node;\n        }\n        Node head = node;\n        while (head!=null){\n            //我感觉这样会快一些\n             Node next = head.next;\n            if(head.child!=null){\n                next = head.next;\n                //子链表扁平化 返回头节点\n                Node nextLayer = flatten2(head.child);//子链表的头节点\n                //连接子链表头和主链\n                head.next = nextLayer;\n                nextLayer.prev = head;\n                //然后子链表置为 null\n                head.child = null;\n                //遍历到子链表的结尾\n                while (nextLayer.next!=null){\n                    nextLayer = nextLayer.next;\n                }\n                //连接子链表的尾部\n                nextLayer.next = next;\n                if(next!=null){\n                    next.prev = nextLayer;\n                }\n            }\n            //这里就直接跳过子链表 之前的是 head=head.next; 但是因为之前的子链表已经加到主链表中所以会浪费一些时间（子链表肯定是已经扁平化的肯定都没有子链表）\n            head = next;\n        }\n        return node;\n    }\n```\n\n两种方法都是看的评论里面的第二种我稍微改了下，直接跳过子链表效率会高很多，不过这题 case 也比较少看不出差异。\n\n---\n## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle)\n\n给定一个链表，判断链表中是否有环。\n\n为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。\n\n**示例 1：**\n\n```c\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n![mark](http://static.imlgw.top///20190303/H2wmyaG9uoiz.png?imageslim)\n\n**示例 2：**\n```c\n输入： head = [1,2], pos = 0\n输出： true\n解释： 链表中有一个环，其尾部连接到第一个节点。\n\n```\n![mark](http://static.imlgw.top///20190303/UqIc2XWwtxbo.png?imageslim)\n\n**示例 3：**\n\n```c\n输入： head = [1], pos = -1\n输出： false\n解释： 链表中没有环。\n\n```\n![mark](http://static.imlgw.top///20190303/dAg8QrxqJJga.png?imageslim)\n\n**进阶：**\n\n你能用 O(1)（即，常量）内存解决此问题吗？\n\n**解法一**\n\n有一点需要注意的是只有一个节点的情况应该是不考虑的直接 false\n```java\npublic static Boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null)\n                  return false;\n    //快慢指针 相遇的时候快指针回到头部 step 改为 1 再次相遇的时候就是环的 pos\n    //这题只是判断有没有环所以只要相遇就有环\n    ListNode slow=head;\n    ListNode fast=head.next;\n    while(slow!=fast){\n        //有环是不会走到尽头的\n        if(fast.next==null || fast.next.next==null){\n            return false;\n        }\n        fast=fast.next.next;\n        slow=slow.next;\n    }\n    return true;\n}\n```\n\n## [141. 环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。\n\n为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。\n\n**说明：** 不允许修改给定的链表。 ps: 上题的基础上返回入环的第一个节点\n\n```golang\n//UPDATE：2020.9.7 实行重写所有链表题的计划\n// A-->B-->C-->D   B 为入环点，D 为相遇点，相遇时 slow = AD, fast = AD+DB+BD\n// fast = 2*slow ==> AD = DB + BD ==> AB+BD = DB+BD ==> AB = DB\nfunc detectCycle(head *ListNode) *ListNode {\n    var fast, slow = head, head\n    for fast!=nil && fast.Next!=nil {\n        fast = fast.Next.Next\n        slow = slow.Next\n        if fast == nil { //无环\n            return nil\n        }\n        if fast == slow { //有环，next 一定不为 null\n            for head!=fast {\n                head = head.Next\n                fast = fast.Next\n            }\n            return head\n        }\n    }\n    return nil\n}\n```\n> 这种解法还是挺有意思的`快慢指针`，快指针一次走两步慢指针一次走一步在环上相遇的时候快指针回到头节点步数调整为 1，再>次相遇的>时候（这里有可能重合，当头节点就是入环节点的时候）就是入环节点。\n> 原理 :\n> A---->B---->C      分别为`头节点`，`入环节点`，`第一次相遇的节点`\n> 分析第一次相遇时快慢指针走过的路径可得\n> AB+BC+CB+BC=2(AB+BC)  快指针走过的路程肯定是慢指针的两倍\n> 化简最后就得到 AB=CB 所以他们`再次相遇`就是入环的节点\n\n---\n## [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n给定一个链表，旋转链表，将链表每个节点向右移动  k 个位置，其中 k 是非负数。\n\n**示例 1:**\n\n```java\n输入：1->2->3->4->5->NULL, k = 2\n输出：4->5->1->2->3->NULL\n解释：\n向右旋转 1 步：5->1->2->3->4->NULL\n向右旋转 2 步：4->5->1->2->3->NULL\n```\n\n**示例 2:**\n\n```java\n输入：0->1->2->NULL, k = 4\n输出：2->0->1->NULL\n解释：\n向右旋转 1 步：2->0->1->NULL\n向右旋转 2 步：1->2->0->NULL\n向右旋转 3 步：0->1->2->NULL\n向右旋转 4 步：2->0->1->NULL\n```\n\n**解法一**\n\n```java\npublic static ListNode rotateRight(ListNode head, int k) {\n    if(head==null||head.next==null){\n        return head;\n    }\n    //先获取下链表的长度，顺便记录 tail 的值\n    ListNode temp=head;\n    ListNode tail=head;\n    int length=0;\n    while(temp!=null){\n        length++;\n        if(temp.next==null){\n            tail=temp;\n            break;\n        }\n        temp=temp.next;\n    }\n    //将 K 化简\n    k=k%length;\n    if(k==0) return head;\n    temp=head;\n    int count=0;\n    //然后再遍历一遍链表在 length-k 的地方断开\n    while(temp!=null){\n        if(count==(length-k-1)){\n            tail.next=head;\n            head=temp.next;\n            temp.next=null;\n            return head;\n        }\n        count++;\n        temp=temp.next;\n    }\n    return head;\n}\n```\n虽然难度是 mid，但是感觉这题还是比较简单，我看见有一种比较好点的方法是在第一遍循环完之后将链表转换为`双向链表`然后再移动还是比较有意思的\n\n## [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list)\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n\n请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。\n\n**示例 1:**\n\n输入：`1->2->3->4->5->NULL`\n输出：`1->3->5->2->4->NULL`\n\n**示例 2:**\n\n输入：`2->1->3->5->6->4->7->NULL`\n输出：`2->3->6->7->1->5->4->NULL`\n\n**说明：**\n\n应当保持奇数节点和偶数节点的相对顺序。\n链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。\n\n**解法一**\n\n```java\n//奇偶链表\npublic static ListNode oddEvenList(ListNode head) {\n    if(head==null||head.next==null||head.next.next==null)return head;\n    // 1 2 3 4 5 6 7\n    // 1 2 3 4 5 6\n    ListNode pOdd=head;\n    ListNode pEven=head.next;\n    ListNode temp=pEven;\n    while(pEven!=null&&pEven.next!=null){\n        pOdd.next=pEven.next;\n        //奇数先走\n        pOdd=pOdd.next;\n        pEven.next=pOdd.next;\n        pEven=pEven.next;\n    }\n    pOdd.next=temp;\n    return head;\n}\n```\n很像踩石头过河的游戏，一道很简单的 mid，不知道为啥一开始抠了半天的边界。果然\n> 还是不熟悉啊。Add oil ! ! !\n\n## [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list)\n\n插入排序的动画演示如上篇文章。\n每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。\n插入排序算法：\n插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n重复直到所有输入数据插入完为止。\n\n**示例 1：**\n\n```java\n输入：4->2->1->3\n输出：1->2->3->4\n```\n\n**示例 2：**\n\n```java\n输入：-1->5->3->4->0\n输出：-1->0->3->4->5\n```\n\n**解法一**\n\n```java\n//beat 50%\npublic static  ListNode insertionSortList(ListNode head) {\n    if(head==null||head.next==null)return head;\n    //哑节点\n    ListNode dummyNode=new ListNode(Integer.MIN_VALUE);\n    System.out.println(dummyNode.val);\n    dummyNode.next=head;\n    ListNode tempNode=head;\n    //外循环内的指针\n    ListNode loopVariable=head.next;\n    ListNode loopPre=head;\n    //内循环的指针\n    ListNode tempPre=dummyNode;\n    while(loopVariable!=null){\n        //头插法\n        for (tempNode=dummyNode;tempNode!=loopVariable;tempNode=tempNode.next){\n            if(tempNode.val>loopVariable.val){\n                //System.out.println(loopVariable.val);\n                //printList(dummyNode.next);\n                //先处理好 loopVariable 的前后节点\n                loopPre.next=loopVariable.next;\n                //再处理 tempNode 前后的节点\n                loopVariable.next=tempNode;\n                tempPre.next=loopVariable;\n                //loopVariable 归位\n                loopVariable=loopPre;\n                break;\n            }\n            tempPre=tempNode;\n        }\n        loopPre=loopVariable;\n        loopVariable=loopVariable.next;\n    }\n    return dummyNode.next;\n}\n```\n上面的是我开始自己写的，但是提交后发现速度有点慢 40ms 50%左右 然后我有点不信把比较靠前的拷了一个 10ms😂前几名 10ms 以内的都是用的方法不是插入。...\n在研究别人 10ms 的代码时突然意识到了问题所在 我在进行插入的时候没有判断就时没有关心是不是应该进行插入操作，对于数组的插入排序是不用关心这个问题的，因为是反向遍历的 而这里是链表只能正向的遍历如果不判断就会浪费很多时间\n\n```java\n// 16ms  beat  70% 开始少写了一个 if 判断\npublic static  ListNode insertionSortList(ListNode head) {\n    if(head==null||head.next==null)return head;\n    //哑节点\n    ListNode dummyNode=new ListNode(Integer.MIN_VALUE);\n    System.out.println(dummyNode.val);\n    dummyNode.next=head;\n    ListNode tempNode=head;\n    //外循环内的指针\n    ListNode loopVariable=head.next;\n    ListNode loopPre=head;\n    //内循环的指针\n    ListNode tempPre=dummyNode;\n    while(loopVariable!=null){\n        //头插法\n        if(loopVariable.val<loopPre.val){\n            for (tempNode=dummyNode;tempNode!=loopVariable;tempNode=tempNode.next){\n                if(tempNode.val>loopVariable.val){\n                    //System.out.println(loopVariable.val);\n                    //printList(dummyNode.next);\n                    //先处理好 loopVariable 的前后节点\n                    loopPre.next=loopVariable.next;\n                    //再处理 tempNode 前后的节点\n                    loopVariable.next=tempNode;\n                    tempPre.next=loopVariable;\n                    //loopVariable 归位\n                    loopVariable=loopPre;\n                    break;\n                }\n                tempPre=tempNode;\n            }\n        }\n        loopPre=loopVariable;\n        loopVariable=loopVariable.next;\n    }\n    return dummyNode.next;\n}\n```\n这题整体思路就是按照插入排序的思路来的，值得注意的就是链表只能正向遍历，而且需要考虑保存的节点有两个，插入位置的前一个，以及待插入的前一个（头插法）。\n\n## [148. 排序链表](https://leetcode-cn.com/problems/sort-list)\n\n在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。\n\n**示例 1:**\n\n输入：4->2->1->3\n输出：1->2->3->4\n示例 2:\n\n输入：-1->5->3->4->0\n输出：-1->0->3->4->5\n\n>上面那题时间复杂度明显是 O(n2) 最坏，这题要求是 O(nlogn) 和常数空间上面的插入肯定不适合了\n\n**解法一**\n\n```java\n//归并排法\npublic static  ListNode sortList(ListNode head) {\n    if(head==null||head.next==null)return null;\n    return mergeSort(head);\n}\n\npublic static ListNode mergeSort(ListNode head){\n    if(head.next==null){\n        return head;\n    }\n    ListNode fast=head;\n    ListNode slow=head;\n    ListNode pre=head;\n    while(fast!=null&&fast.next!=null){\n        pre=slow;\n        fast=fast.next.next;\n        slow=slow.next;\n    }\n    pre.next=null;\n    //这里要注意断开两条链表不然后面不方便找中点\n    ListNode left = mergeSort(head);\n    //归并左边\n    ListNode right = mergeSort(slow);\n    //归并右边\n    return merge2list(left,right);\n    //返回 左右两条链表归并结果\n}\n\npublic static ListNode merge2list(ListNode headA,ListNode headB){\n    if(headA==null)return headB;\n    if(headB==null)return headA;\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=headA;\n    ListNode temp=dummyNode;\n    while(headA!=null&&headB!=null){\n        if(headA.val>headB.val){\n            temp.next=headB;\n            headB=headB.next;\n        } else{\n            temp.next=headA;\n            headA=headA.next;\n        }\n        temp=temp.next;\n    }\n    temp.next=headA==null?headB:headA;\n    return dummyNode.next;\n}\n```\n\n4ms 85%  标准的`归并操作`分治的思想，但是我还是扣了好长时间，最后还是看了别人的代码才知道，其实一开始就想到了`快慢指针找中点`但是感觉时间复杂度可能会变得更高就没那样做。还是太菜了时间复杂度都不会分析。这里有一个小地方就是找到中点之后要记得断开中点和后面链表的连接，这样会方便后面归并，不然就需要传递一个边界的指针那样又会有很多问题（没错我开始就是这么做的😭）\n\n下面这种是后来又写的`经典快排`，400ms，12% 我都怀疑我到底写了个啥？后来把插入拿来试了下 884+ms 然后又看了一遍才相信我写的是快排。\n\n```java\n//我自己写的快排\npublic static ListNode sortList4(ListNode head){\n    if(head==null||head.next==null)return head;\n    sortList(head,null);\n    return head;\n}\n\n//快排实现\npublic static void sortList(ListNode head,ListNode tail) {\n    if(tail==head){\n        return;\n    }\n    //确定枢纽元素\n    ListNode base=partion(head,tail);\n    sortList(head,base);\n    sortList(base.next,tail);\n}\n\n//看了下别人的博客也学到了一种快排的新思路\n//慢指针左边都是小于 base 枢纽元素的，快指针和慢指针中间都是大于等于 base 枢纽元素的\n//慢指针后面的都是未知区域\npublic static ListNode partion(ListNode head,ListNode tail){\n    ListNode base=head;\n    ListNode fast=head.next;\n    ListNode slow=head;\n    // 3  1  3  2  5  -1 0\n    //    s  f\n    while(fast!=tail){\n        if(fast.val<=base.val){\n            //交换两个节点的值\n            swap(fast,slow.next);\n            slow=slow.next;\n        }\n        fast=fast.next;\n    }\n    //归位\n    swap(head,slow);\n    //应该可以试试返回区间\n    return slow;\n}\n\npublic static void swap(ListNode a,ListNode b){\n    int temp=a.val;\n    a.val=b.val;\n    b.val=temp;\n}\n```\n\n> 实际上快排确实不适合链表（下面光速打脸）因为毕竟不是数组可以从两边开始遍历，链表每次都需要遍历整个链表才能划分好基准位置。\n\n看了下前几的代码发现了这个，`非标准的三向切分的快排`，为啥说是非标准呢？看下面代码就知道了，我给加了注释\n\n```java\npublic static ListNode sortList3(ListNode head) {\n    ListNode node = new ListNode(0);\n    node.next = head;\n    sort(node, null);\n    return node.next;\n}\n\nprivate  static void sort(ListNode from, ListNode to) {\n    if (from == null || from == to || from.next == to || from.next.next == to)return;\n    int v = from.next.val;\n    //基准元素\n    ListNode mid = from;\n    //切分点指针\n    ListNode equal = from.next;\n    //等于区域右边界\n    ListNode node = from.next;\n    //遍历用的指针\n    while (node.next != to) {\n        //node 不到头  左开右开区间（from,to）\n        if (node.next.val < v) {\n            //小于基准位置元素\n            //保存当前节点的下一个元素，用于插入节点\n            //小于基准元素的节点\n            ListNode currentNext = node.next.next;\n            //保存切分点的下一个元素，作用同上\n            ListNode midNext = mid.next;\n            //交换 node.next 和 mid\n            //纸上画一下就了解了\n            mid.next = node.next;\n            node.next.next = midNext;\n            node.next = currentNext;\n            //切分点后移\n            mid = mid.next;\n        } else if (node.next.val == v) {\n            //node 的下一个等于基准元素\n            //3 1 2 3 4 5 6\n            if (equal == node) {\n                //等于区域和 node.next==val 相邻了，直接跳过\n                equal = node.next;\n                node = node.next;\n            } else {\n                //将 node.next 插入 equal 后面\n                //然后 equal 向后移动\n                //和上面的类似\n                ListNode nodeNext = node.next.next;\n                ListNode equalNext = equal.next;\n                equal.next = node.next;\n                node.next.next = equalNext;\n                node.next = nodeNext;\n                equal = equal.next;\n            }\n        } else {\n            //大于直接跳过\n            node = node.next;\n        }\n    }\n    // [mid.next---equal] 为等于 val 的节点\n    sort(from, mid.next);\n    sort(equal, to);\n}\n```\n\n整体思路就是一共有三个指针，`mid`（切分点）  `equal`（等于区） `node`（遍历指针） node 从 from 遍历到 to，注意这里是`左开右开区间` 就是说头 from 和尾 to 都取不到，然后将小与 base 的节点插入到 mid 的后面，然后 mid 后移，等于区插入到 equal 的后面，最后形成的就是`[mid.next---equal]` 为等于 val 的节点，然后对子区域递归就 ok 了，这个用时 `4ms` 。还要继续加油啊！！！\n\n## [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer)\n\n给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。\n\n要求返回这个链表的深拷贝。 \n\n**示例：**\n\n![mark](http://static.imlgw.top///20190308/tR8e3eu2yqaq.png?imageslim)\n\n```c\n输入：\n`{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1}`\n解释：\n节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。\n节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。\n```\n**提示：**\n\n你必须返回给定头的拷贝作为对克隆列表的引用。\n\n**解法一** \n\n利用 Map 保存原链表和复制链表的对应关系\n\n```java\npublic static Node copyRandomList(Node head) {\n    Map<Node,Node> copNode =new HashMap<>();\n    Node temp=head;\n    while(temp!=null){\n        //建立对应关系\n        copNode.put(temp,new Node(temp.val,null,null));\n        temp=temp.next;\n    }\n    //再循环一次复制 next 和 Radom 节点\n    temp=head;\n    while(temp!=null){\n        copNode.get(temp).next=copNode.get(temp.next);\n        copNode.get(temp).random=copNode.get(temp.random);\n        temp=temp.next;\n    }\n    return copNode.get(head);\n}\n```\n第一个循环利用 Map 将原链表和拷贝链表形成对应关系，第二个循环就是直接给拷贝链表的 next 域和 random 域赋值。\n\n**解法二**\n\n奥义 影分身\n\n```java\npublic static Node copyRandomList2(Node head) {\n    if(head==null)return head;\n    Node temp=head;\n    //链表  奥义 - 影分身\n    while(temp!=null){\n        //这里直接将 next 域传入构造器完成和后面元素的连接\n        temp.next=new Node(temp.val,temp.next,null);\n        temp=temp.next.next;\n    }\n    temp=head;\n    //连接 random 域\n    while(temp!=null){\n        if(temp.random!=null){\n            temp.next.random=temp.random.next;\n        }\n        temp=temp.next.next;\n    }\n    temp=head;\n    // 分离\n    Node newHead=head.next;\n    Node next=null;\n    while(temp!=null){ //=将每个元素的 next 指向下一个的下一个\n        next=temp.next;\n        if(next!=null){\n            temp.next=next.next;\n        }\n        temp=next;\n    }\n    return newHead;\n}\n```\n为啥要叫影分身？因为帅。.. 这种方法比上面的要快一点可能是创建 hashMap 比较耗时间，其实分析这两种方法其实都是先把链表拷贝了一份，然后通过对应关系来连接拷贝链表的 next 和 random 域，map 是通过键值对的方式对应拷贝链表，这样可以方便的通过原链表找到拷贝链表的 random. 然后上面这种方法也是一样，在原链表每个节点后面 copy 一个节点，然后根据前一个节点的 random 来找拷贝节点的 random（前一个节点的 random 的 next) 主要就是找到一个对应关系。\n\n> tips: 这题 OJ 上的 0ms 是有问题的，这题本意肯定也不是这个\n>\n> \n>\n> ![mark](http://static.imlgw.top///20190308/p1GPgJVYaURp.png?imageslim)\n\n最开始能通过主要是 OJ 后台只判断了 val 的值，可以看出现在题目已经改了。现在肯定是跑不过的，可能是判断了 random 是不是 new 出来的（我试了下看了下返回这个）\n输入\n`{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1}`\n输出\n`{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":`\n\n`{\"$id\":\"3\",\"next\":null,\"random\":null,\"val\":2},\"val\":2},`\n\n`\"random\":{\"$id\":\"4\",\"next\":null,\"random\":null,\"val\":2},\"val\":1}`\n预期结果\n`{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1}`\n\n**解法三**\n\n重写了一遍，题目改了一点\n\n```java\npublic Node copyRandomList(Node head) {\n    if(head==null) return null;\n    Node temp=head;\n    while(temp!=null){\n        Node next=temp.next;\n        Node newNode=new Node(temp.val);\n        temp.next=newNode;\n        newNode.next=next;\n        temp=next;\n    }\n    temp=head;\n    //重写的时候想把 random 连接和分离一起做\n    //然后就错了。\n    //这里 next 域的变化就会导致后面 random 域的变化，最后结果就错了\n    while(temp!=null){\n        Node next=temp.next.next;\n        if(temp.random!=null){\n            temp.next.random=temp.random.next;\n        }\n        temp=next;\n    }\n    Node newHead=head.next;\n    temp=head;\n    //将每个元素的 next 域指向下一个的下一个就行了\n    while(temp!=null){\n        Node next=temp.next;\n        if(next!=null){\n            temp.next=next.next;\n        }\n        temp=next;\n    }\n    return newHead;\n}\n```\n\n## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n**示例：**\n\n给定 1->2->3->4, 你应该返回 2->1->4->3.\n\n**解法一**\n\n```java\npublic ListNode swapPairs(ListNode head) {\n    if(head==null||head.next==null)return head;\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    ListNode nex=head.next;\n    ListNode cur=head;\n    ListNode pre=dummyNode;\n    // -1|1 2 3 4\n    while(nex!=null){\n        pre.next=nex;\n        cur.next=nex.next;\n        nex.next=cur;\n        pre=cur;\n        if(cur.next==null){\n            return dummyNode.next;\n        }\n        cur=cur.next;\n        nex=cur.next;\n    }\n    return dummyNode.next;\n}\n```\n其实跟反转链表是一样的，三个指针分别记录前 中 后三个节点然后逆序，只不过步长不一样，这里 step 为 2，一次走两步， 我上面的代码可能写的有些乱，思路还是一样的\n\n**解法二**\n\n```java\n//递归版本\npublic ListNode swapPairs(ListNode head) {\n    if(head==null||head.next==null){\n        return head;\n    }\n    ListNode next=head.next;\n    head.next=swapPairs(next.next);\n    next.next=head;\n    return next;\n}\n```\n递归是真的简洁，我最开始写反转链表的递归就是这么写的😂\n\n## [25.K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。\n\n**示例 :**\n\n```java\n给定这个链表：1->2->3->4->5\n当 k = 2 时，应当返回：2->1->4->3->5\n当 k = 3 时，应当返回：3->2->1->4->5\n```\n\n**说明 :**\n\n- 你的算法只能使用常数的额外空间。\n- 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n**解法一**\n\n```java\n//非递归，理一下思路： 记录每次翻转前后的节点 然后翻转返回头 将每 K 个元素当成一个整体\npublic static ListNode reverseKGroup(ListNode head,int k) {\n    if(head==null||head.next==null)return head;\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    ListNode pre=dummyNode;\n    ListNode cur=head;\n    ListNode next=head;\n    ListNode temp;\n    while(next!=null){\n        //temp 保存 cur 方便后面连接  K+1 位置的元素\n        temp=cur;\n        //k 个一组翻转\n        int step=k;\n        while(step>0 && next!=null){\n            //next 走到 K+1 位置节点\n            next=next.next;\n            step--;\n            //小细节 k>链表长度时应该直接返回（我认为）等下提交了看看\n            //所以直接应该直接返回 （掉了 k 的值判断 因为有可能刚好有 k 个元素）\n            if(next==null&& step!=0){\n                return dummyNode.next;\n            }\n        }\n        //翻转 cur--next.prev 返回头节点\n        //连接 反转后的头节点\n        pre.next=reverse(cur,k);\n        temp.next=next;\n        //pre temp 向后移动\n        pre=temp;\n        cur=next;\n    }\n    return dummyNode.next;\n}\n\n// -1| 1 2 3 | 4 5 6 | 7 8\n//翻转链表并返回子链表\npublic static ListNode reverse(ListNode node,int k){\n    ListNode pre=null;\n    ListNode cur=node;\n    ListNode next=node;\n    while(k>0&&next!=null){\n        next=next.next;\n        cur.next=pre;\n        pre=cur;\n        cur=next;\n        k--;\n    }\n    //返回反转后的头节点\n    System.out.println(\"头\"+pre.val);\n    return pre;\n}\n```\n\n7ms 74% 也是我第一道做出来的困难题，[上一道困难题超时了](http://imlgw.top/2018/10/31/%E4%B8%80%E9%81%93LeetCode%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/)\n\n这题虽然说是困难题但是其实也不难，感觉就 mid 左右的水平，确实比上一题要复杂一点，但是只要思路理清楚其实也挺简单的，下面是我用 OneNote 画的一张图片。\n\n4 个指针分别对应 K 链表的 前一个 (pre)  K 链表的头节点 (cur) 没有翻转前的 K 链表的头节点 and **翻转后的尾节点 (temp)**   K 链表的后一个节点 (next)。然后其实就简单了，写一个翻转链表的函数然后返回头节点（也可以多加一个指针指向**翻转前的头节点**)，然后就简单了，next 指针一次走 K 步，走到 K+1 位置 同时也是**下一次 K 链表的头节点**，而 temp 则为下一次 K 链表的 pre... 然后循环这个过程就行了，其实写成递归会很简洁，但是我是真的不会写递归，太菜了 Orz\n\n![mark](http://static.imlgw.top///20190312/jl7moiy7PbjH.png?imageslim)\n\n**解法二**\n\n2020.2.23 时隔多年现在回头重新写了一个递归的写法，还是比较简洁的\n\n```java\n//时隔一年，回头自己写了一个递归的解法\npublic ListNode reverseKGroup(ListNode head, int k) {\n    if(head==null || k==1) return head;\n    int sum=0;\n    ListNode temp=head;\n    //预先计算链表的长度\n    while(temp!=null){\n        temp=temp.next;\n        sum++;\n    }\n    return reverse(head,k,sum);\n}\n\npublic ListNode reverse(ListNode head, int k,int remain) {\n    if(remain<k) return head; //ramain 不足 k 个 return \n    if(head==null) return head;\n    //正常的翻转操作\n    ListNode cur=head,pre=null,last=head;\n    int count=k;\n    while(count-- >0){\n        last=cur.next;\n        cur.next=pre;\n        pre=cur;\n        cur=last;\n    }\n    //下一次从 last 开始翻转，remain-k\n    head.next=reverse(last,k,remain-k);\n    return pre;\n}\n```\n**解法三**\n\n这题递归明显是不太符合要求的，空间复杂度不是常数的，如果有要求还是要写下面的解法\n\n```go\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    dummyNode := &ListNode{\n        Next: head,\n        Val:  -1,\n    }\n    pre := dummyNode\n    cur := head\n    //-1 | 1 2 3 4 5\n    for cur != nil {\n        for i := 0; i < k-1 && cur != nil; i++ {\n            cur = cur.Next\n        }\n        if cur == nil { //不足 k 个\n            break\n        }\n        next := cur.Next\n        cur.Next = nil \n        start := pre.Next\n        pre.Next = reverse(start)\n        start.Next = next\n        //这里要注意 pre=start\n        pre = start\n        cur = next\n    }\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var pre *ListNode\n    var cur = head\n    for cur != nil {\n        next := cur.Next\n        cur.Next = pre\n        pre = cur\n        cur = next\n    }\n    return pre\n}\n```\n隔一段时间就会重新写一遍，写肯定写的出来，就是要想清楚，最好搞个 case 在上面，一边模拟一边写\n> 做链表的题就是得细心啊，容易把自己绕进去，上面的解法就是看了题解才写出来的\n\n## [817. 链表组件](https://leetcode-cn.com/problems/linked-list-components)\n\n给定一个链表（链表结点包含一个整型值）的头结点 head。\n同时给定列表 G，该列表是上述链表中整型值的一个子集。\n返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。\n\n**示例 1：**\n\n```java\n输入：\nhead: 0->1->2->3\nG = [0, 1, 3]\n输出：2\n解释：\n链表中，0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。\n```\n\n**示例 2：**\n\n```java\n输入：\nhead: 0->1->2->3->4\nG = [0, 3, 1, 4]\n输出：2\n解释：\n链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。\n```\n\n**注意：**\n\n- 如果 N 是给定链表 head 的长度，1 <= N <= 10000。\n- 链表中每个结点的值所在范围为 [0, N - 1]。\n- 1 <= G.length <= 10000\n- G 是链表中所有结点的值的一个子集。\n\n**解法一**\n\n```java\npublic int numComponents(ListNode head, int[] G) {\n    if(head==null||head.next==null) return head;\n    ListNode temp=head;\n    int res=0;\n    while(temp!=null){\n        if(isInG(temp.val,G)){\n            while(temp!=null&&isInG(temp.val,G)){\n                temp=temp.next;\n            }\n            res++;\n            if(temp==null){\n                return res;\n            }\n        }\n        temp=temp.next;\n    }\n    return res;\n}\n\npublic static Boolean isInG(int val,int[] G){\n    for (int i=0;i<G.length;i++){\n        if(G[i]==val){\n            return true;\n        }\n    }\n    return false;\n}\n```\n首先想到的方法 91ms 19%..... 有点慢了，然后我稍微改了下。\n\n```java\npublic int numComponents2(ListNode head, int[] G) {\n    ListNode temp=head;\n    int res=0;\n    Boolean [] isInG=new Boolean[10000];\n    int j=0;\n    while(temp!=null){\n        for (int i=0;i<G.length;i++){\n            if(G[i]==temp.val){\n                isInG[j]=true;\n                break;\n            }\n        }\n        j++;\n        temp=temp.next;\n    }\n    temp=head;\n    for (int i=0;temp!=null;temp=temp.next,i++){\n        if(isInG[i]){\n            while(temp!=null&&isInG[i]){\n                temp=temp.next;\n                i++;\n            }\n            res++;\n            if(temp==null){\n                return res;\n            }\n        }\n    }\n    return res;\n}\n```\n   用了一个数组保存了每个位置的状态速度跟前面的差不多。主要问题就是那个数组的创建，这种创建方式用连续的下标来对应连续的链表的每个元素，每次都要遍历 G 才知道当前位置是不是在 G 中。\n\n   其实可以直接把当前节点的 val 作为数组的下标这样既有了对应关系也不用遍历 G. 可以说是很优秀了，但是实际上这样做是有前提条件的那就是链表中的元素值应该`没有负数`，还是题做少了啊 Orz。\n\n```java\npublic int numComponents3(ListNode head, int[] G) {\n    ListNode temp=head;\n    int res=0;\n    Boolean [] isInG=new Boolean[10000];\n    int j=0;\n    //换一种方式 以 node.val 作为数组的下标\n    for (int i:G){\n        isInG[i]=true;\n    }\n    while(temp!=null){\n        if(isInG[temp.val]){\n            while(temp!=null&&isInG[temp.val]){\n                temp=temp.next;\n            }\n            res++;\n            if(temp==null){\n                return res;\n            }\n        }\n        temp = temp.next;\n    }\n    return res;\n}\n```\n\n## [1019. 链表中的下一个更大节点](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/)\n\n给出一个以头节点 `head` 作为第一个节点的链表。链表中的节点分别编号为：`node_1, node_2, node_3, ...` 。\n\n每个节点都可能有下一个更大值（next larger **value**）：对于 `node_i`，如果其 `next_larger(node_i)` 是 `node_j.val`，那么就有 `j > i` 且  `node_j.val > node_i.val`，而 `j` 是可能的选项中最小的那个。如果不存在这样的 `j`，那么下一个更大值为 `0` 。\n\n返回整数答案数组 `answer`，其中 `answer[i] = next_larger(node_{i+1})` 。\n\n**注意：** 在下面的示例中，诸如 `[2,1,5]` 这样的**输入**（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。\n\n**示例 1：**\n\n```java\n输入：[2,1,5]\n输出：[5,5,0]\n```\n\n**示例 2：**\n\n```java\n输入：[2,7,4,3,5]\n输出：[7,0,5,5,0]\n```\n\n**示例 3：**\n\n```java\n输入：[1,7,5,1,9,2,5,1]\n输出：[7,9,9,9,0,5,0,0]\n```\n\n**提示：**\n\n1. 对于链表中的每个节点，`1 <= node.val <= 10^9`\n2. 给定列表的长度在 `[0, 10000]` 范围内\n\n**解法一**\n\n```java\npublic static int[] nextLargerNodes(ListNode head) {\n    //list 里面存元素\n    ArrayList<Integer> A = new ArrayList<>();\n    for (ListNode node = head; node != null; node = node.next)\n                A.add(node.val);\n    int[] res = new int[A.size()];\n    //栈里面存索引\n    Stack<Integer> stack = new Stack<>();\n    for (int i = 0; i < A.size(); ++i) {\n        while (!stack.isEmpty() && A.get(stack.peek()) < A.get(i))\n             res[stack.pop()] = A.get(i);\n        stack.push(i);\n    }\n    return res;\n}\n```\n\n新题，磨了好长时间，没做出来。真是菜啊 Orz，70ms，因为跑两遍。下面这个`14ms`可以说是相当快了，但，时间可能耗费在建立栈和 list 上了，看了下提交上的前几个都是用的数组，用数组模拟的栈。\n\n```java\n//和上面的方法差不多，但这个更快，上面那个跑了两遍\npublic static int[] nextLargerNodes3(ListNode head) {\n    int[] stack = new int[10000];\n    int[] res = new int[10000];\n    //temp 是链表的副本，相当于上面的 list\n    int[] temp = new int[10000];\n    //top 栈顶\n    int top = -1, i = 0;\n    ListNode node = head;\n    while (node != null) {\n        while (top != -1 && temp[stack[top]] < node.val){\n            //后一个大于当前节点，栈不为空\n            //pop 出比它小的元素并赋值 res，重新生成单调栈\n            res[stack[top--]] = node.val;\n        }\n        stack[++top] = i;\n        temp[i++] = node.val;\n        node = node.next;\n    }\n    return Arrays.copyOf(res, i);\n}\n```\n\n思路就是利用`单调栈`，栈里面存的索引对应的元素都是单调递减的，遇到不递减的就会一直 pop() 直到再次单调递减。这样很容易就找到了每个元素的下一个最大元素了。\n\n19.7.21 重新做了一遍这道题，第一遍还是没想出来，还是看了之前的代码\n\n```java\npublic static int[] nextLargerNodes5(ListNode head) {\n        List<Integer> list=new ArrayList<>();\n        ListNode temp=head;\n        while(temp!=null){\n            list.add(temp.val);\n            temp=temp.next;\n        }\n        int [] stack=new int[10000];\n        int stackIndex=-1;\n        int [] res=new int[10000];\n        for (int i=0;i<list.size();i++) {\n            while(stackIndex!=-1 && list.get(i)>list.get(stack[stackIndex])){\n                res[stack[stackIndex--]]=list.get(i);\n            }\n            //维护一个递减的栈\n            stack[++stackIndex]=i;\n        }\n        return  Arrays.copyOf(res, list.size());\n}\n```\n\n相比上面的方法一，采用了数组模拟队列（数据范围已经给定了），30ms，80% 。仔细看看代码发现其实第一个循环完全没有必要，可以一边遍历一边存进去。\n\n**一次遍历**\n\n```java\npublic static int[] nextLargerNodes6(ListNode head) {\n    List<Integer> list=new ArrayList<>();\n    ListNode temp=head;\n    int [] stack=new int[10000];\n    int stackIndex=-1;\n    int [] res=new int[10000];\n\n    for (int i=0;temp!=null;i++) {\n        list.add(temp.val);\n        while(stackIndex!=-1 && list.get(i)>list.get(stack[stackIndex])){\n            res[stack[stackIndex--]]=list.get(i);\n        }\n        //维护一个递减的栈\n        stack[++stackIndex]=i;\n        temp=temp.next;\n    }\n    return  Arrays.copyOf(res, list.size());\n}\n```\n\n优化后发现比之前还慢了。\n\n**数组模拟链表**\n\n```java\n public static int[] nextLargerNodes7(ListNode head) {\n        int [] list=new int[10000];\n        ListNode temp=head;\n        int [] stack=new int[10000];\n        int stackIndex=-1;\n        int [] res=new int[10000];\n\n        int i;\n        for ( i=0;temp!=null;i++) {\n            list[i]=temp.val;\n            while(stackIndex!=-1 && list[i]>list[stack[stackIndex]]){\n                res[stack[stackIndex--]]=list[i];\n            }\n            //维护一个递减的栈\n            stack[++stackIndex]=i;\n            temp=temp.next;\n        }\n        return  Arrays.copyOf(res, i);\n  }\n```\n\n这次提交了几次直接 8ms 100%了。\n","tags":["LeetCode","链表"],"categories":["算法"]},{"title":"常见的排序算法总结","url":"/2018/12/11/83535e94/","content":"\n## 常见排序算法总结\n关于排序的部分一直想总结下一直没时间，现在来总结下吧。gif 图来自微信上的文章 (**五分钟学算法**的公众号，挺不错干货挺多的），原理性的东西就不讲了，图讲的比我好。如果还是不懂可以看看《算法》里面的轨迹图，那个也很直观 \n\n### 冒泡排序 \n\n  ![weixin](http://static.imlgw.top/f02ace7b7fb9b810274e683c2be54a02_640_wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1.gif)\n\n```java\n//冒泡排序\nprivate static void MaoPaoSort(int []nums){\n    for (int i=nums.length-1;i>=0;i--){\n        for (int j=0;j<i;j++){\n            if(nums[j]>nums[j+1]){\n                swap(nums,j,j+1);\n            }\n        }\n    }\n}\n```\n### 选择排序\n\n![weixin](http://static.imlgw.top/640.gif)\n\n```java\n//选择排序\nprivate static void SelectSort(int []nums){\n    for (int i=0;i<nums.length;i++){\n        int min=nums[i];\n        for (int j=i+1;j<nums.length;j++){\n            if(nums[j]<min){\n                min=nums[j];\n                swap(nums,j,i);\n            }\n        }\n    }\n}\n```\n\n### 直接插入排序\n\n![weixin](http://static.imlgw.top/640%20%281%29.gif)\n\n```java\n//直接插入排序\nprivate static void InsertSort(int []nums){\n    for (int i=1;i<nums.length;i++){\n        for (int j=i;j>0&&nums[j]<nums[j-1];j--){\n            swap(nums,j,j-1);\n        }\n    }\n}\n```\n\n### 归并排序\n\n![weixin](http://static.imlgw.top/640%20%282%29.gif)\n\n#### 图上面的是递归版本的归并，实现如下\n\n```java\n//归并排序\nprivate static void MergerSort(int []nums){\n    help=new int[nums.length];\n    MergerSort(nums,0,nums.length-1);\n}\n\nprivate static void MergerSort(int []nums,int left,int right){\n    if(left>=right){\n        return;\n    }\n    //不能直接在这里创建数组，严重影响性能，可以在上面再套一层方法，或者采用 merger2 的方式（也不好，应该保证辅助数组只初始化一次）\n    //help=new int[nums.length];\n    int mid=left+((right-left)>>1);\n    MergerSort(nums,left,mid);\n    MergerSort(nums,mid+1,right);\n    merger(nums,left,mid,right);\n}\n\n//辅助数组\nprivate static int []help;\n\n//归并操作\nprivate static void merger(int []nums ,int left,int mid,int right){\n    int i=left,j=mid+1;\n    //其实没区别空间复杂度，都是 O(N) 后面这个会更加耗费时间\n    //int []help=new int[right-left+1];\n    for (int k=left;k<=right;k++){\n        //一边的到达尽头，先判断两个边界，不然就要想下面那样写\n        if(i>mid){\n            help[k]=nums[j++];\n        } else if(j>right){\n            help[k]=nums[i++];\n        } else if(nums[i]>nums[j]){\n            help[k]=nums[j++];\n        } else{\n            //相等的时候左边先进栈保证稳定性\n            help[k]=nums[i++];\n        }\n        /*// 2 \n            if( i<=mid &&j<=right && nums[i]>nums[j]){\n                help[k]=nums[j++];\n            }else if( i<=mid &&j<=right && nums[i]<=nums[j]){\n                //相等的时候左边先进栈保证稳定性\n                help[k]=nums[i++];\n            }else if(i>mid){\n                help[k]=nums[j++];\n            }else if(j>right){ \n                help[k]=nums[i++];\n            }*/\n    }\n    //复制\n    for (int k=left;k<=right;k++){\n        nums[k]=help[k];\n    }\n\n    /*while (p1 <= m && p2 <= r) {\n            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];\n        }\n        while (p1 <= m) {\n            help[i++] = arr[p1++];\n        }\n        while (p2 <= r) {\n            help[i++] = arr[p2++];\n        }\n        for (i = 0; i < help.length; i++) {\n            arr[l + i] = help[i];\n        }*/\n}\n```\n\n#### 非递归版本\n\n```java\n//归并排序（非递归，方向不一样，时间复杂度一样都为 O(NlogN)\nprivate static void MergerSortNoRecurse(int []nums){\n    help=new int[nums.length];\n    //控制合并的长度 \n    for (int sz=1;sz<nums.length;sz*=2){\n        //控制合并的向后移动\n        for (int i=0;i<nums.length-sz;i+=2*sz){\n            int r=i+2*sz-1<nums.length-1?i+2*sz-1:nums.length-1;\n            merger(nums,i,i+sz-1,r);\n        }\n    }\n}\n```\n\n### 三向切分的快排（荷兰国旗问题）\n\n![weixin](http://static.imlgw.top/640%20%283%29.gif)\n\n```java\n//快排 （不具有稳定性或者难以实现）\nprivate static void QuickSort(int []nums,int l,int r){\n    if(l>r){\n        return;\n    }\n    //随机一个数和 r 交换 ---随机快排\n    swap(nums, l + (int) (Math.random() * (r - l + 1)), r);\n    int []index=partition2(nums,l,r);\n    QuickSort(nums,l,index[0]-1);\n    QuickSort(nums,index[1]+1,r);\n}\n\npublic static int partition1(int []nums ,int l,int r){\n    int base = l;\n    //双指针\n    int lo = l, hi = r;\n    //这种 partition 的实现细节有点不好理解\n    //这种 partition 不能随机基准元素。\n    //参照了左神的代码发现其实可以在 partition 之前随机一个变量和 lo 交换，也有同样的效果也消除了输入的影响\n    while (lo < hi) {\n        //必须先从右往左，主要是为了归位的时候不出现问题\n        //比如这里选取的基准元素是 lo 也就是子数组的第一个元素，如果先从左往右最后交换的就是 lo 和一个比 lo 大的数然而比 lo 大的数应该放在右边\n        //反之如果选的是 hi 为基准就要先从左往右\n        // 7  0  1  2    10  11  22\n        while (nums[hi] >= nums[base] && lo < hi) {\n            hi--;\n        }\n        while (nums[lo] <= nums[base] && lo < hi) {\n            lo++;\n        }\n        if (lo < hi) {\n            swap(nums, lo, hi);\n        }\n    }\n    //归位 lo==hi\n    swap(nums, hi, base);\n    return lo;\n}\n\n//荷兰国旗优化的快排\npublic static int[] partition2(int []arr ,int l,int r){\n    // 7  0  1  2    10  11  22        \n    //小于区为空\n    int less=l-1;\n    //l ----> more 为待定区\n    int more=r;\n    while(l<more){\n        if(arr[l]<arr[r]){\n            swap(arr,++less,l++);\n        } else if(arr[l]>arr[r]){\n            //大于基准时 , 大于区扩大（大于区的前一个元素和当前元素交换，但是不知道大于区的前一个元素是什么情况，所以不能 l++)\n            swap(arr,--more,l);\n        } else{\n            l++;\n        }\n    }\n    //和大于区间的第一个交换 保证归位正确，如果选取的是以最左边为基准元素 这里就应该和 less 交换\n    //到这里  [less+1,more-1] 之间都是等于 基准元素 arr【r】 的\n    swap(arr,more,r);\n    //到这  [less+1,more] 之间都是等于 基准元素 arr【r】 的\n    return new int[]{less+1,more};\n}\n```\n\n### 堆排序\n\n![weixin](http://static.imlgw.top/640%20%284%29.gif)\n\n```java\n//堆排序\nprivate static void HeapSort(int []nums){\n    if(nums.length<2){\n        return;\n    }\n    //构建大根堆\n    for (int i=0; i<nums.length; i++) {\n        heapInsert(nums,i);\n    }\n    //交换堆顶和最后一个节点\n    int size= nums.length;\n    swap(nums,size-1,0);\n    size--;\n    while(size>1){\n        //调整\n        heapIfy(nums,0,size);\n        //每次都和最后一个孩子节点交换，然后 size--\n        swap(nums,--size,0);\n    }\n}\n\n//向上爬\nprivate static void heapInsert(int []nums, int index){\n    //迭代比较当前节点和父节点的值的大小\n    while(nums[index]>nums[(index-1)/2]){\n        swap(nums,index,(index-1)/2);\n        index=(index-1)/2;\n    }\n}\n\n//向下爬\n//index 位置的值变小后继续调整为大根堆\nprivate static void heapIfy(int []nums,int index,int size){\n    //左孩子\n    int left=index*2+1;\n    //节点有左孩子\n    while(left<size){\n        //判断是否有右孩子。....\n        //左右孩子里的最大值 有右孩子且右孩子大于左孩子\n        int largest=left+1<size && nums[left]<nums[left+1] ?left+1:left;\n        largest=nums[largest]>nums[index]?largest:index;\n        //最大值等于自己\n        if(largest==index){\n            break;\n        }\n        //交换大孩子节点和自己\n        swap(nums,largest,index);\n        //设置大孩子的 index 和左孩子\n        index=largest;\n        left=index*2+1;\n    }\n}\n```\n\n### 堆排序更优的做法\n\n上面的做法并不是最优的堆排序\n\n```java\npublic static void heapSort(int []nums){\n    int last=nums.length-1;\n    //N 构建大根堆\n    //从倒数第二层开始\n    for (int i=nums.length/2-1 ;i>=0;i--){\n        heapIfy(nums,i,last);\n    }\n    //printArray(nums);\n    while(last>=1){\n        swap(nums,0,last--);\n        heapIfy(nums,0,last);\n    }\n}\n\n//i 大根堆调整\npublic static void heapIfy(int[] nums,int i,int last){\n    //判断有没有子节点（左孩子）\n    int left=i*2+1;\n    while(left<=last){\n        int right=left+1;\n        //左右节点最大值\n        int larger=right<=last && nums[right] > nums[left]?right:left;\n        if(nums[larger]>nums[i]){\n            swap(nums,larger,i);\n            i=larger;\n            left=larger*2+1;\n        } else{\n            break;\n        }\n    }\n}\n\npublic static  void  swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n对比之前的方法，构造堆的方式发生了变化，上面那种通过自上而下的`insert`方式时间复杂度是`O(NlogN)`，其实仔细想想，这两种方式是完全相反的，insert 的方式，最后一层每个元素最坏都可能调整`logN`次，而最后一层也是元素最多的一层，这样一来复杂度就会大大增加，相反如果采用从底向上的`heapIfy`方式最后一层都只需要调整`1`次，而根节点需要调整`logN`次，而根节点**只有一个**时间复杂度就会大大降低，最终的时间复杂度就是 O(N)，[具体推算过程可以看这些回答](https://www.zhihu.com/question/20729324) \n\n**手推过程**\n\n![img](http://static.imlgw.top/image/20190617/kVuvnMfjuSns.png?imageslim)\n\n最后推得到得复杂度是小于`O(2N)`，也就是`O(N)`的时间复杂度，如果不是刷`leetCode` 看到了类似的题可能会一直被那样去写😂\n\n**再回首**\n\n时隔多年，又回头写了一个，写了大概半个小时左右，边写边回忆，感觉这个写法比上面好一点点，所以记录一下\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int[] nums=new int[N];\n        for(int i=0;i<N;i++)nums[i]=sc.nextInt();\n        heapSort(nums);\n        for(int i=0;i<N;i++)System.out.print(nums[i]+\" \");\n    }\n\n    public static void heapSort(int[] nums){\n        //求左右孩子\n        //       0 \n        //   1       2\n        // 3   4   5   6 \n        //7                 7/2=3  4/2=1 8/2=4\n        //O(N) 构建堆\n        for(int i=nums.length/2;i>=0;i--){ //从 2/n 开始 down 构建二叉树，不一定要精确，多一两个无所谓\n            down(nums,i,nums.length);\n        }\n\n        int index=0,tail=nums.length;\n        //堆排，将堆头放到尾部\n        while(tail>0){\n            swap(nums,index,--tail);\n            down(nums,index,tail);\n        }\n    }\n\n    public static void down(int[] nums,int index,int size){\n        //求左右孩子\n        //      0 \n        //  1       2\n        //3   4   5   6\n        while(index*2+1 < size){ //还有孩子\n            int left=index*2+1,right=left+1;\n            //左右子树中的较大\n            int largeIndex = right<size && nums[left]<nums[right] ? right:left;\n            if(nums[index] >= nums[largeIndex]){\n                return;\n            }\n            swap(nums,index,largeIndex);\n            index=largeIndex;\n        }\n    }\n\n    public static void swap(int[] nums,int a,int b){\n        int temp=nums[a];\n        nums[a]=nums[b];\n        nums[b]=temp;\n    }\n}\n```\n\n### 希尔排序\n\n实际上写排序就是基于插入排序的，在它之上进行了数学上的优化。\n\n![image](http://static.imlgw.top/640%20%285%29.gif)\n\t实际上从逆序对的角度来看，基于比较的排序就是为了消除逆序对的个数，而诸如冒泡选择每次都只是交换相邻的两个元素，每次交换最多只减少一个逆序对，而希尔排序扩大了这个间距，就增大了减少逆序对的可能。不过要研究他的时间复杂度就是数学上的研究的问题了，至于每次间距都减半这个也是根据大样本测试下这种递增序列性能会更好 O(∩_∩)O\n\n```java\n//插入排序的改进\nprivate static void ShellSort(int [] nums){\n    int h=nums.length>>1;\n    while(h>0){\n        for (int i=h;i<nums.length;i++){\n            //实际上是增大了插入排序的间隙，最后还是对进行一次插入排序，不过那个时候的数据已经是高度有序了\n            for (int j=i;j-h>=0&&nums[j]<nums[j-h];j-=h) {\n                swap(nums,j,j-h);\n            }\n        }\n        h=h>>1;\n    }\n}\n```\n\n---\n### BUG\n排个序还能排出 Bug？对的没错就是排出了 Bug🤣 看看我最开始写的交换函数\n\n```java\nprivate static void swap(int []nums,int a,int b){\n    nums[a]=nums[a]^nums[b];\n    nums[b]=nums[a]^nums[b];\n    nums[a]=nums[a]^nums[b];\n}\n```\n为了抖这个机灵付出了惨痛的代价，之前用 >> 拿来当除 2 操作的时候就忽略了`优先级`的问题。那这里的机灵有什么问题呢？一个数异或同一个数两次就还原没毛病啊？But 如果交换的两个数是同一个元素比如上面在数组中 a==b 时 nums[a] 异或了 3 次自己相当于`nums[a]^nums[a]^nums[a]^nums[a]=0^0=0`，最后就会出问题，其实开始前面的排序都没有出现问题，主要是后面的快排时发现了这个 Bug 因为快排为了避免数据分布的影响随机选取基准值，可能随机的是最后一个，而且快排的 partition 过程中也会有时也会自己和自己交换，最开始的第一步就是自己和直接交换，让小于区扩大。所以这个方法仅仅只能用来抖一抖机灵，没啥实际意义，以后还是要老老实实写，不然咋死的都不知道😁\n\n>  未完待续。..... 还有一类非基于比较的排序 桶排序之类的等后面再来总结加上去。\n\n### 对数器\n直接拿的左神的对数器😄，所有排序都是经过对数器测试的。 *talk is cheap show me the code*\n\n```java\nimport java.util.Arrays;\nimport java.util.Random;\npublic class Sorts{\n    public static void main(String[] args) {\n        /*int []nums={1,0,-1,-22,213,4,535,-112,99999};\n        //ShellSort(nums);\n        //MaoPaoSort(nums);\n        //SelectSort(nums);\n        //MergerSort(nums,0,nums.length-1);\n        QuickSort(nums,0,nums.length-1);\n        printArray(nums);*/\n        int testTime = 10000;\n        int maxSize = 10000;\n        int maxValue = 100;\n        Boolean succeed = true;\n        for (int i = 0; i < testTime; i++) {\n            int[] arr1 = generateRandomArray(maxSize, maxValue);\n            int[] arr2 = copyArray(arr1);\n            long time=System.currentTimeMillis();\n            //冒泡\n            //MaoPaoSort(arr1);\n            //选择\n            //SelectSort(arr1);\n            //插入\n            //InsertSort(arr1);\n            //归并\n            //MergerSort(arr1);\n            //非递归归并\n            //MergerSortNoRecurse(arr1);\n            //希尔\n            //ShellSort(arr1);\n            //快排\n            //QuickSort(arr1,0,arr1.length-1);\n            //堆排序\n            HeapSort(arr1);\n            long time2=System.currentTimeMillis();\n            if(i==0){\n                System.out.println(time2-time);\n            }\n            //系统排序\n            comparator(arr2);\n            if(i==0){\n                System.out.println(System.currentTimeMillis()-time2);\n            }\n            if (!isEqual(arr1, arr2)) {\n                succeed = false;\n                printArray(arr1);\n                printArray(arr2);\n                break;\n            }\n        }\n        System.out.println(succeed ? \"Nice!\" : \"Fucking fucked!\");\n    }\n    //初级排序算法\n    //************************************************************************\n    //冒泡排序\n    private static void MaoPaoSort(int []nums){\n        for (int i=nums.length-1;i>=0;i--){\n            for (int j=0;j<i;j++){\n                if(nums[j]>nums[j+1]){\n                    swap(nums,j,j+1);\n                }\n            }\n        }\n    }\n    //************************************************************************\n    //选择排序\n    private static void SelectSort(int []nums){\n        for (int i=0;i<nums.length;i++){\n            int min=nums[i];\n            for (int j=i+1;j<nums.length;j++){\n                if(nums[j]<min){\n                    min=nums[j];\n                    swap(nums,j,i);\n                }\n            }\n        }\n    }\n    //************************************************************************\n    //直接插入排序\n    private static void InsertSort(int []nums){\n        for (int i=1;i<nums.length;i++){\n            for (int j=i;j>0&&nums[j]<nums[j-1];j--){\n                swap(nums,j,j-1);\n            }\n        }\n    }\n    //************************************************************************\n    //插入排序的改进\n    private static void ShellSort(int [] nums){\n        int h=nums.length>>1;\n        while(h>0){\n            for (int i=h;i<nums.length;i++){\n                //实际上是增大了插入排序的间隙，最后还是对进行一次插入排序，不过那个时候的数据已经是高度有序了\n                for (int j=i;j-h>=0&&nums[j]<nums[j-h];j-=h) {\n                    swap(nums,j,j-h);\n                }\n            }\n            h=h>>1;\n        }\n    }\n    //************************************************************************\n    //归并排序\n    private static void MergerSort(int []nums){\n        help=new int[nums.length];\n        MergerSort(nums,0,nums.length-1);\n    }\n    private static void MergerSort(int []nums,int left,int right){\n        if(left>=right){\n            return;\n        }\n        //不能直接在这里创建数组，严重影响性能，可以在上面再套一层方法，或者采用 merger2 的方式（也不好，应该保证辅助数组只初始化一次）\n        //help=new int[nums.length];\n        int mid=left+((right-left)>>1);\n        MergerSort(nums,left,mid);\n        MergerSort(nums,mid+1,right);\n        merger(nums,left,mid,right);\n    }\n    //辅助数组\n    private static int []help;\n    //归并操作\n    private static void merger(int []nums ,int left,int mid,int right){\n        int i=left,j=mid+1;\n        //其实没区别空间复杂度，都是 O(N) 后面这个会更加耗费时间\n        //int []help=new int[right-left+1];\n        for (int k=left;k<=right;k++){\n            //一边的到达尽头，先判断两个边界，不然就要想下面那样写\n            if(i>mid){\n                help[k]=nums[j++];\n            } else if(j>right){\n                help[k]=nums[i++];\n            } else if(nums[i]>nums[j]){\n                help[k]=nums[j++];\n            } else{\n                //相等的时候左边先进栈保证稳定性\n                help[k]=nums[i++];\n            }\n            /*// 2 \n            if( i<=mid &&j<=right && nums[i]>nums[j]){\n                help[k]=nums[j++];\n            }else if( i<=mid &&j<=right && nums[i]<=nums[j]){\n                //相等的时候左边先进栈保证稳定性\n                help[k]=nums[i++];\n            }else if(i>mid){\n                help[k]=nums[j++];\n            }else if(j>right){ \n                help[k]=nums[i++];\n            }*/\n        }\n        //复制\n        for (int k=left;k<=right;k++){\n            nums[k]=help[k];\n        }\n        //asddsdasdasdasd\n        /*while (p1 <= m && p2 <= r) {\n            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];\n        }\n        while (p1 <= m) {\n            help[i++] = arr[p1++];\n        }\n        while (p2 <= r) {\n            help[i++] = arr[p2++];\n        }\n        for (i = 0; i < help.length; i++) {\n            arr[l + i] = help[i];\n        }*/\n    }\n    //归并排序（非递归，方向不一样，时间复杂度一样都为 O(NlogN)\n    private static void MergerSortNoRecurse(int []nums){\n        help=new int[nums.length];\n        //控制合并的长度 \n        for (int sz=1;sz<nums.length;sz*=2){\n            //控制合并的向后移动\n            for (int i=0;i<nums.length-sz;i+=2*sz){\n                int r=i+2*sz-1<nums.length-1?i+2*sz-1:nums.length-1;\n                merger(nums,i,i+sz-1,r);\n            }\n        }\n    }\n    //************************************************************************\n    //快排 （不具有稳定性或者难以实现）\n    private static void QuickSort(int []nums,int l,int r){\n        if(l>r){\n            return;\n        }\n        //随机一个数和 r 交换 ---随机快排\n        swap(nums, l + (int) (Math.random() * (r - l + 1)), r);\n        int []index=partition2(nums,l,r);\n        QuickSort(nums,l,index[0]-1);\n        QuickSort(nums,index[1]+1,r);\n    }\n    public static int partition1(int []nums ,int l,int r){\n        int base = l;\n        //双指针\n        int lo = l, hi = r;\n        //这种 partition 的实现细节有点不好理解\n        //这种 partition 不能随机基准元素。\n        //参照了左神的代码发现其实可以在 partition 之前随机一个变量和 lo 交换，也有同样的效果也消除了输入的影响\n        while (lo < hi) {\n            //必须先从右往左，主要是为了归位的时候不出现问题\n            //比如这里选取的基准元素是 lo 也就是子数组的第一个元素，如果先从左往右最后交换的就是 lo 和一个比 lo 大的数然而比 lo 大的数应该放在右边\n            //反之如果选的是 hi 为基准就要先从左往右\n            // 7  0  1  2    10  11  22\n            while (nums[hi] >= nums[base] && lo < hi) {\n                hi--;\n            }\n            while (nums[lo] <= nums[base] && lo < hi) {\n                lo++;\n            }\n            if (lo < hi) {\n                swap(nums, lo, hi);\n            }\n        }\n        //归位 lo==hi\n        swap(nums, hi, base);\n        return lo;\n    }\n    //荷兰国旗优化的快排\n    public static int[] partition2(int []arr ,int l,int r){\n        // 7  0  1  2    10  11  22        \n        //小于区为空\n        int less=l-1;\n        //l ----> more 为待定区\n        int more=r;\n        while(l<more){\n            if(arr[l]<arr[r]){\n                swap(arr,++less,l++);\n            } else if(arr[l]>arr[r]){\n                //大于基准时 , 大于区扩大（大于区的前一个元素和当前元素交换，但是不知道大于区的前一个元素是什么情况，所以不能 l++)\n                swap(arr,--more,l);\n            } else{\n                l++;\n            }\n        }\n        //和大于区间的第一个交换 保证归位正确，如果选取的是以最左边为基准元素 这里就应该和 less 交换\n        //到这里  [less+1,more-1] 之间都是等于 基准元素 arr【r】 的\n        swap(arr,more,r);\n        //到这  [less+1,more] 之间都是等于 基准元素 arr【r】 的\n        return new int[]{less+1,more};\n    }\n    //************************************************************************\n    //堆排序\n    private static void HeapSort(int []nums){\n        if(nums.length<2){\n            return;\n        }\n        //构建大根堆\n        for (int i=0; i<nums.length; i++) {\n            heapInsert(nums,i);\n        }\n        //交换堆顶和最后一个节点\n        int size= nums.length;\n        swap(nums,size-1,0);\n        size--;\n        while(size>1){\n            //调整\n            heapIfy(nums,0,size);\n            //每次都和最后一个孩子节点交换，然后 size--\n            swap(nums,--size,0);\n        }\n    }\n    //向上爬\n    private static void heapInsert(int []nums, int index){\n        //迭代比较当前节点和父节点的值的大小\n        while(nums[index]>nums[(index-1)/2]){\n            swap(nums,index,(index-1)/2);\n            index=(index-1)/2;\n        }\n    }\n    //向下爬\n    //index 位置的值变小后继续调整为大根堆\n    private static void heapIfy(int []nums,int index,int size){\n        //左孩子\n        int left=index*2+1;\n        //节点有左孩子\n        while(left<size){\n            //判断是否有右孩子。....\n            //左右孩子里的最大值 有右孩子且右孩子大于左孩子\n            int largest=left+1<size && nums[left]<nums[left+1] ?left+1:left;\n            largest=nums[largest]>nums[index]?largest:index;\n            //最大值等于自己\n            if(largest==index){\n                break;\n            }\n            //交换大孩子节点和自己\n            swap(nums,largest,index);\n            //设置大孩子的 index 和左孩子\n            index=largest;\n            left=index*2+1;\n        }\n    }\n    //************************************************************************\n    private static void swap(int []nums,int a,int b){\n        //不知道为啥快排交换的时候这样写会出现很多 0\n        //查询知道，当 a==b 时自己和直接交换，a 异或自己 4 次后 a==0.....\n        nums[a]=nums[a]^nums[b];\n        nums[b]=nums[a]^nums[b];\n        nums[a]=nums[a]^nums[b];\n        /*int temp=nums[a];\n        nums[a]=nums[b];\n        nums[b]=temp;*/\n    }\n    // for test  对数器\n    public static void comparator(int[] arr) {\n        Arrays.sort(arr);\n    }\n    // for test\n    public static int[] generateRandomArray(int maxSize, int maxValue) {\n        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());\n        }\n        return arr;\n    }\n    // for test\n    public static int[] copyArray(int[] arr) {\n        if (arr == null) {\n            return null;\n        }\n        int[] res = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = arr[i];\n        }\n        return res;\n    }\n    // for test\n    public static Boolean isEqual(int[] arr1, int[] arr2) {\n        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {\n            return false;\n        }\n        if (arr1 == null && arr2 == null) {\n            return true;\n        }\n        if (arr1.length != arr2.length) {\n            return false;\n        }\n        for (int i = 0; i < arr1.length; i++) {\n            if (arr1[i] != arr2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // for test\n    public static void printArray(int[] arr) {\n        if (arr == null) {\n            return;\n        }\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n​\t\t\n","tags":["数据结构","排序"],"categories":["算法"]},{"title":"NodeJS 模仿 Express 封装路由","url":"/2018/12/03/3b46123d/","content":"\n## NodeJS 模仿 Express 封装路由\n\n_最近才开始学 NodeJs 也不知道为啥就突然对这个很感兴趣，（可能 Java 写烦了😄)，感觉用这个开发还是挺快的，而且性能也很好，借此也了解下函数式编程的特点和异步编程的思想。_\n\n- ### 没封装前\n  原生的就差不多是这样的。\n\n```java\n\t/* \n\t    Node.js 未封装 1.0\n\t*/\n\tconst http = require(\"http\");\n\tconst fs = require(\"fs\");\n\tconst path = require(\"path\");\n\tconst querystring = require(\"querystring\"); //json 转换\n\tconst scores = require(\"./StudentScore.json\");\n\tconst template = require(\"art-template\");\n\thttp.createServer((req, resp) => {\n\t    if (req.url.startsWith(\"/query\") && req.method == 'GET') {\n\t        //这里可以采用模板为了和下面的对比一下\n\t        fs.readFile(path.join(__dirname, \"querypage.html\"), (err, content) => {\n\t            if (err) {\n\t                resp.writeHead(500, {\n\t                    'Content-Type': 'text/plain;charset=utf8'\n\t                });\n\t                resp.end('服务器错误');\n\t            }\n\t            resp.end(content);\n\t        });\n\t    } else\n\t    if (req.url.startsWith(\"/scores\")) {\n\t        let pdata = '';\n\t        //事件绑定\n\t        //获取数据（id）\n\t        req.on('data', (ck) => {\n\t            pdata += ck;\n\t        });\n\t        //在这里返回\n\t        req.on('end', () => {\n\t            let obj = querystring.parse(pdata); //将参数 的字符串转换成 对象\n\t            let result = scores[obj.stunum];\n\t            let content = template(path.join(__dirname, \"scores.art\"), result);\n\t            resp.end(content);\n\t        });\n\t    }\n\t}).listen(9999, () => {\n\t    console.log('Server is runing on 9999');\n\t});\n```\n\n- Express 的方式\n通过 const app=express(); 获得一个 app 的对象后面就通过这个来操作\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/D~KS%28D1%5B%5DUS5TBZPO7KTJ88.png)\n- 手动封装\n\n```java\n\tvar url = require('url');\n\t\n\t//封装方法改变 res  绑定 res.send()\n\tfunction changeRes(res) {\n\t\n\t    res.send = function(data) {\n\t\n\t        res.writeHead(200, {\n\t            \"Content-Type\": \"text/html;charset=utf-8\"\n\t        });\n\t\n\t        res.end(data);\n\t    }\n\t}\n\t\n\t//定义暴露的模块  return 里面定义的模块\n\tvar Server = function() {\n\t\n\t    var G = this; /*全局变量*/\n\t\n\t    //处理 get 和 post 请求\n\t    this._get = {};\n\t\n\t    this._post = {};\n\t\n\t    var app = function(req, res) {\n\t\n\t        changeRes(res);\n\t\n\t        //获取路由\n\t        var pathname = url.parse(req.url).pathname;\n\t        if (!pathname.endsWith('/')) {\n\t            pathname = pathname + '/';\n\t        }\n\t\n\t        //获取请求的方式 get  post\n\t        var method = req.method.toLowerCase();\n\t\n\t        if (G['_' + method][pathname]) {\n\t\n\t            if (method == 'post') { /*执行 post 请求*/\n\t\n\t                var postStr = '';\n\t                req.on('data', function(chunk) {\n\t\n\t                    postStr += chunk;\n\t                })\n\t                req.on('end', function(err, chunk) {\n\t                    //添加请求属性\n\t                    req.myBody = postStr; /*表示拿到 post 的值*/\n\t                    /*执行方法*/\n\t                    G['_' + method][pathname](req, res);\n\t                })\n\t            } else { /*执行 get 请求*/\n\t                G['_' + method][pathname](req, res); /*执行方法*/\n\t            }\n\t        } else {\n\t            res.end('no router');\n\t        }\n\t    }\n\t\n\t    //下面的都是为了做注册的操作\n\t    app.get = function(string, callback) {\n\t        if (!string.endsWith('/')) {\n\t            string = string + '/';\n\t        }\n\t        if (!string.startsWith('/')) {\n\t            string = '/' + string;\n\t\n\t        }\n\t\n\t        //    /login/\n\t        G._get[string] = callback;\n\t\n\t    }\n\t\n\t    app.post = function(string, callback) {\n\t        if (!string.endsWith('/')) {\n\t            string = string + '/';\n\t        }\n\t        if (!string.startsWith('/')) {\n\t            string = '/' + string;\n\t\n\t        }\n\t        //    /login/\n\t        G._post[string] = callback;\n\t\n\t        //G._post['dologin']=function(req,res){\n\t        //\n\t        //}\n\t    }\n\t\n\t    return app;\n\t\n\t}\n\t\n\tmodule.exports = Server();\n```\n\n- 封装后\n```java\n\tconst http = require(\"http\");\n\tconst url = require(\"url\");\n\t//引入自定义的路由模块\n\tconst myApp = require(\"./model/express-route.js\");\n\t\n\t//使用自定义的模块\n\thttp.createServer(myApp).listen(9999, () => {\n\t    console.log('Running 9999');\n\t});\n\t\n\tmyApp.get(\"/express\", (req, resp) => {\n\t    resp.send(\"模仿 Express 封装路由\");\n\t    console.log(req);\n\t});\n\tmyApp.post(\"/postExpress\", (req, resp) => {\n\t    resp.send(\"模仿 Express 封装路由\");\n\t    console.log(req.myBody);\n\t});\n```\n\n---\n通过这个体会下 Express 的封装\n","tags":["NodeJS","ES6","JavaScript"],"categories":["Web"]},{"title":"Java 爬虫实战（一） ：爬取斗图社所有 gif","url":"/2018/11/30/ada76fed/","content":"## Java 爬虫实战（一） ：爬取斗图社所有 gif\n最近开始玩爬虫 , 还是挺有意思的 , 虽然写爬虫一般都是用 Python 比较方便，但是也没有必要为了写爬虫再学一门语言 , 虽然也挺简单，但是还是对 Java 比较习惯，后面可能会学 Python 但是目前还是先用 java 写着玩玩。\n\n**目标** \n[斗图社 ]( https://doutushe.com/)  上所有的图片。\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/%408Q0%601FQB2A2E4D%5D9M8%40VW8.png)\n\n**技术选择**\nJsoup，最开始看见这个我看成了 Jsonp。我寻思着不是解决跨域的那个么？还能搞爬虫？这么牛掰的么😄\n关于 Jsoup 网上也有很多文档 [参考资料](http://www.open-open.com/jsoup/) \n还有一些其他的技术比如 httpclient+Xpath 还有 htmlunit 还有 selenium 等等，等以后学了后再来秀一秀 😁\n\n---\n\n其实我写的第一个爬虫是 copy 的别人的博客上的，不过它爬取的是京东的，我爬的是淘宝的\n我也只是想参考下他的结构，但是我感觉他的有些类没什么实际意义。然后我就直接自己写了。\n结构如下：\n\n- boot ：爬虫的入口\n- dao  ：dao\n- handle ：封装的处理查询结果集的类（这里没用）\n- model ：爬取的数据的模型\n- parse  ： 解析 html 的类\n- util     ： Jsoup 工具类和 dao 的工具类和 DB 模板类\n\n首先建立数据模型 DoutuModel\n\n```java\npublic class DoutuModel {\n\t    private Long id;\n\t    private String topic;\n\t    private String imgUrl;\n\t    private String title;\n\t\n\t    //数据库 id 自增\n\t    public DoutuModel(String topic, String imgUrl, String title) {\n\t        this.topic = topic;\n\t        this.imgUrl = imgUrl;\n\t        this.title = title;\n\t    }\n\t\n\t    public String getTopic() {\n\t        return topic;\n\t    }\n\t\n\t    public void setTopic(String topic) {\n\t        this.topic = topic;\n\t    }\n\t\n\t    public String getTitle() {\n\t        return title;\n\t    }\n\t\n\t    public void setTitle(String title) {\n\t        this.title = title;\n\t    }\n\t\n\t    public String getImgUrl() {\n\t        return imgUrl;\n\t    }\n\t\n\t    public void setImgUrl(String imgUrl) {\n\t        this.imgUrl = imgUrl;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public void setId(Long id) {\n\t        this.id = id;\n\t    }\n}\t\n```\n\n**主要记录下 parse 类**\n\n``` java\npublic static List<DoutuModel> getData2(String url) throws Exception {\n\t        //获取的数据，存放在集合中\n\t        List<DoutuModel> data = new ArrayList();\n\t        //采用 Jsoup 解析\n\t        //String url=\"https://doutushe.com/portal/article/index/id/5gK\";\n\t        String preurl = \"https://doutushe.com\";\n\t        //取到当前页的 document\n\t        //取到内容页的所有图片\n\t        int page = 1;\n\t        while (true) {\n\t            Document doc = JsoupUtils.getHtmlDocument(url);\n\t            Elements imgList = doc.select(\"div[class=col-xs-12 col-sm-8 col-lg-9]\").select(\"img.lazy\");\n\t            String topic = doc.select(\"blockquote>p\").text();\n\t            for (Element imgelement : imgList) {\n\t                //异步的坏处体现出来了，这个明显是懒加载，要找就找数据源，直接获取 src 获取不到\n\t                //String imgUrl= imgelement.attr(\"src\");\n\t                String imgUrl = imgelement.attr(\"data-original\");\n\t                String title = imgelement.attr(\"title\");\n\t                data.add(new DoutuModel(topic, imgUrl, title));\n\t                //System.out.println(topic + \":\" + imgUrl + \":\" + title);\n\t            }\n\t            Elements pageUrls = doc.select(\"ul.pager\").select(\"a\");\n\t            //爬一页休息 1 秒\n\t            if (page % 10 == 0) {\n\t                Thread.sleep(1000);\n\t                System.out.println(\"第\" + (page/10) + \"页采集完 , 暂停-------\");\n\t            }\n\t            //最后一页也有两个按钮。看来要多观察页面\n\t            /*if (pageUrls.size() < 2) {\n\t                //说明到最后一页了\n\t                break;\n\t            }*/\n\t            url = preurl + pageUrls.get(1).attr(\"href\");\n\t            if (!url.matches(preurl + \"/portal/article/index/id/[a-zA-Z0-9_]*\")) {\n\t                break;\n\t            }\n\t            page++;\n\t        }\n\t        //返回数据\n\t        return data;\n}\n```\n其实一开始写的一个版本是从主页面爬的先获取每一页的链接，再获取每一页的主题的链接，再获取每个主题下的图片链接，一个三重 for 循环，速度确实比较慢。\n\n后来发现每一页都有下一页的链接。然后就可以直接从页面上爬，两个循环就可以了，但是一开始我判断边界的时候用的是在下面的链接的数量小于 2 但是一开始爬了好长时间结果报错了。  然后我去看了下最后一页发现也有两个链接后面一个是全部的链接。 。\n\n ![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/AT5%7BUKZN%24M%5B59V%5B1OU0S%5B7N.png)\n而且和上面的 css 是一样的但是和前面的每一页的链接的后缀不一样，所以就直接用正则表达式匹配 url 的后缀是否匹配\nRegex ：https://doutushe.com/portal/article/index/id/[a-zA-Z0-9_]*  后面的就是直接匹配任意视频\n而最后一页的全部链接是 ： https://doutushe.com/portal/index/index 所以就匹配不上直接 break\n\n**爬图片的小细节** , 一开始没注意，他这个图片是懒加载的，也就是随着页面用 js 加载的， 直接 src 获取肯定获取不到的，因为 jsoup 是不支持异步的，用 js 操作的东西肯定爬不到。所以只能通过 data-orginal 获取。\n\ngithub  [仓库地址](https://github.com/imlgw/javaSpiders)\n\n---\n\n**结果**\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/X%28%7B%60H6YKH2LIW%24%25F2K4U53M.jpg)\n4243 张图片，后面可以自己写个脚本把图片全部下载到本地或者用迅雷之类的下载工具。\n\n---\n后面会尝试下更多爬虫技术像 htmlunit 这种支持异步的或者 selenium 这种直接操作浏览器的工具\n","tags":["爬虫","Java","misc"],"categories":["爬虫"]},{"title":"Spring-Security 遇到的小问题","url":"/2018/11/26/2dc72c90/","content":"## Spring Security 配置 intercept-url 的小问题\n\n文档： http://www.fengfly.com/document/springsecurity3/core-web-filters.html\n\n```java\n<bean id=\"filterInvocationInterceptor\"\n     class=\"org.springframework.security.intercept.web.FilterSecurityInterceptor\">\n  <property name=\"authenticationManager\" ref=\"authenticationManager\"/>\n  <property name=\"accessDecisionManager\" ref=\"accessDecisionManager\"/>\n  <property name=\"runAsManager\" ref=\"runAsManager\"/>\n  <property name=\"securityMetadataSource\">\n    <security:filter-security-metadata-source path-type=\"regex\">\n      <security:intercept-url pattern=\"\\A/secure/super/.*\\Z\" access=\"ROLE_WE_DONT_HAVE\"/>\n      <security:intercept-url pattern=\"\\A/secure/.*\\\" access=\"ROLE_SUPERVISOR,ROLE_TELLER\"/>\n    </security:filter-security-metadata-source>\n  </property>\n</bean>        \n```\n\n模式总是根据他们定义的顺序进行执行。因此很重要的是，把更确定的模式定义到列表的上面。 这会反映在你上面的例子中，更确定的/secure/super/模式放在没那么确定的 /secure/模式的上面。如果它们被反转了。/secure/会一直\n 被匹配，/secure/super/就永远也不会执行。\n\n----\n\n```java\n<http use-expressions=\"false\" entry-point-ref=\"casProcessingFilterEntryPoint\">\n\t\t<intercept-url pattern=\"/**\" access=\"ROLE_USER\"/>\n        <!--经过 SpringSecurity 的环境上下文，偶然发现一个小坑-->\n        <intercept-url pattern=\"/cart/*.do\" access=\"IS_AUTHENTICATED_ANONYMOUSLY\"/>\n        <csrf disabled=\"true\"/>\n        <!-- custom-filter 为过滤器， position 表示将过滤器放在指定的位置上，before 表示放在指定位置之前  ，after 表示放在指定的位置之后  -->\n        <custom-filter ref=\"casAuthenticationFilter\"  position=\"CAS_FILTER\" />\n        <custom-filter ref=\"requestSingleLogoutFilter\" before=\"LOGOUT_FILTER\"/>\n        <custom-filter ref=\"singleLogoutFilter\" before=\"CAS_FILTER\"/>\n    </http>\n```\n一个小问题，就是大范围在前面会覆盖后面的小范围所以像我上面那么写/cart/*.do 就不会执行相当于没写，起不到作用。","tags":["Bug","Spring"],"categories":["踩坑记录"]},{"title":"CAS 单点登陆系统 Demo","url":"/2018/11/17/65571397/","content":"##  单点登陆系统 --CAS\n- 关于 CAS 的介绍网上都有。这里主要记录如何使用，如何配置和集成一些框架。\n- CAS 架构图\n![OSS](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/CAS.PNG)\nCAS 的 SSO 实现方式可简化理解为： 1 个 Cookie 和 N 个 Session 。 CAS Server 创建 cookie，在所有应用认证时使用，各应用通过创建各自的 Session 来标识用户是否已登录。\n用 户在一个应用验证通过后，以后用户在同一浏览器里访问此应用时，客户端应用中的过滤器会在 session 里读取到用户信息，所以就不会去 CAS Server 认证。如果在此浏览器里访问别的 web 应用时，客户端应用中的过滤器在 session 里读取不到用户信息，就会去 CAS Server 的 login 接口认证，但这时 CAS Server 会读取到浏览器传来的 cookie （ TGC ），所以 CAS Server 不会要求用户去登录页面登录，只是会根据 service 参数生成一个 Ticket ，然后再和 web 应用做一个验 证 ticket 的交互而已。\n\n### 1. 配置 CAS 服务端\n从上面的架构图也可以大概知道 CAS 运作的方式，首先配置好 CAS 的 Server 端，直接将 CAS 的 war 包拷到 tomcat 的 webapp 目录下然后启动 tomcat 自动解压就可以了，这里我设置的 tomcat 的端口是 8888，地址栏输入 localhost:8888/cas 能看到 CAS 的登陆界面说明部署成功\n*  去除 https\n\tCAS 默认使用的是 HTTPS 协议，如果使用 HTTPS 协议需要 SSL 安全证书（需向特定的机构申请和购买） 。如果对安全要求不高或是在开发测试阶段，可使用 HTTP 协议。我们这里讲解通过修改配置，让 CAS 使用 HTTP 协议。\n\n\t* 修改 cas 的 WEB-INF/deployerConfigContext.xml 找到下面的配置\n<bean class=\"org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler\"\np:httpClient-ref=\"httpClient\"/>\n这里需要增加参数 p:requireSecure=\"false\"，requireSecure 属性意思为是否需要安全验证，即 HTTPS，false 为不采用\n   * 修改 cas 的/WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml\n找到下面配置\n    <bean id=\"ticketGrantingTicketCookieGenerator\" class=\"org.jasig.cas.web.support.CookieRetrievingCookieGenerator\"\n      p:cookieSecure=\"true\"\n      p:cookieMaxAge=\"-1\"\n      p:cookieName=\"CASTGC\"\n      p:cookiePath=\"/cas\" />\n   * 参数 p:cookieSecure=\"true\"，同理为 HTTPS 验证相关，TRUE 为采用 HTTPS 验证，FALSE 为不采用 https 验证。\n参数 p:cookieMaxAge=\"-1\"，是 COOKIE 的最大生命周期，-1 为无生命周期，即只在当前打开的窗口有效，关闭或重新打开其它窗口，仍会要求验证。可以根据需要修改为大于 0 的数字，比如 3600 等，意思是在 3600 秒内，打开任意窗口，都不需要验证。\n\t\t\n\t\t我们这里将 cookieSecure 改为 false , cookieMaxAge 改为 3600\n\n   * 修改 cas 的 WEB-INF/spring-configuration/warnCookieGenerator.xml\n\t\t<bean id=\"warnCookieGenerator\" class=\"org.jasig.cas.web.support.CookieRetrievingCookieGenerator\"\n\t\tp:cookieSecure=\"true\"\n\t\tp:cookieMaxAge=\"-1\"\n\t\tp:cookieName=\"CASPRIVACY\"\n\t\tp:cookiePath=\"/cas\" />\n我们这里将 cookieSecure 改为 false , cookieMaxAge 改为 3600\n- 配置数据源\n   - cas 有默认的密码但是实际中肯定是要从数据库中查的，所以我们需要配置下数据源\n   - 修改 cas 服务端中 web-inf 下 deployerConfigContext.xml ，添加如下配置\n\t\t```java\n\t\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" \n\t\t p:driverClass=\"com.mysql.jdbc.Driver\"\n\t\t p:jdbcUrl=\"jdbc:mysql://127.0.0.1:3306/pinyougoudb?characterEncoding=utf8\"\n\t\t p:user=\"root\"\n\t\t p:password=\"123456\" />\n\t\t<bean id=\"passwordEncoder\"\n\t\tclass=\"org.jasig.cas.authentication.handler.DefaultPasswordEncoder\" \n\t\t c:encodingAlgorithm=\"MD5\"\n\t\t p:characterEncoding=\"UTF-8\" />\n\t\t<bean id=\"dbAuthHandler\" \n\t\t class=\"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler\"\n\t\t p:dataSource-ref=\"dataSource\"\n\t\t p:sql=\"select password from tb_user where username = ?\"\n\t\t p:passwordEncoder-ref=\"passwordEncoder\"/>\n\t\t```\n  - 然后在配置文件开始部分找到如下配置\n\t\n\t```java\n\t <bean id=\"authenticationManager\" class=\"org.jasig.cas.authentication.PolicyBasedAuthenticationManager\">\n\t        <constructor-arg>\n\t            <map>               \n\t                <entry key-ref=\"proxyAuthenticationHandler\" value-ref=\"proxyPrincipalResolver\" />\n\t                <entry key-ref=\"primaryAuthenticationHandler\" value-ref=\"primaryPrincipalResolver\" />\n\t            </map>\n\t        </constructor-arg>      \n\t        <property name=\"authenticationPolicy\">\n\t            <bean class=\"org.jasig.cas.authentication.AnyAuthenticationPolicy\" />\n\t        </property>\n\t</bean>\n\t```\n\t其中 <entry key-ref=\"primaryAuthenticationHandler\" value-ref=\"primaryPrincipalResolver\" />一句是使用固定的用户名和密码，我们在下面可以看到这两个 bean , 如果我们使用数据库认证用户名和密码，需要将这句注释掉。\n\t添加下面这一句配置\n\t<entry key-ref=\"dbAuthHandler\" value-ref=\"primaryPrincipalResolver\"/>\n  - 将三个 jar 包加入到 cas 的 lib 目录下\n   ![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/casjar.PNG)\n\t第一个和第三个大家应该很熟悉了，中间的那个是 cas 对 jdbc 的支持包\n\t\n\n---\n### 2. 普通的 web 项目集成 CAS\n 普通的 web 项目也就是没有使用 Spring 之类的框架而采用 web.xml 配置的普通项目\n* 2.1 为了方便我这里采用 maven 配置，先添加相应的依赖\n\t\t\n```java\n        <!-- cas -->\n        <dependency>\n            <groupId>org.jasig.cas.client</groupId>\n            <artifactId>cas-client-core</artifactId>\n            <version>3.3.3</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>servlet-api</artifactId>\n            <version>2.5</version>\n            <scope>provided</scope>\n        </dependency>\n```\n一个是 cas 客户端的核心包，一个是 servlet 的包，因为后面会写一些 jsp\n然后添加 tomcat 插件我设置的端口为 9002\n* 2.2 因为是普通的 web 项目所以配置的方式主要是通过 web.xml 来配置，直接上配置\n\n\t```java\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n\t         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n\t         version=\"2.5\">\n\t    <!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置 -->\n\t    <listener>\n\t        <listener-class>org.jasig.cas.client.session.SingleSignOutHttpSessionListener</listener-class>\n\t    </listener>\n\t    <!-- 该过滤器用于实现单点登出功能，可选配置。 -->\n\t    <filter>\n\t        <filter-name>CAS Single Sign Out Filter</filter-name>\n\t        <filter-class>org.jasig.cas.client.session.SingleSignOutFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CAS Single Sign Out Filter</filter-name>\n\t        <url-pattern>/* </url-pattern>\n\t    </filter-mapping>\n\t    <!-- 该过滤器负责用户的认证工作，必须启用它 -->\n\t    <filter>\n\t        <filter-name>CASFilter</filter-name>\n\t        <filter-class>org.jasig.cas.client.authentication.AuthenticationFilter</filter-class>\n\t        <init-param>\n\t            <param-name>casServerLoginUrl</param-name>\n\t            <param-value>http://localhost:8888/cas/login</param-value>\n\t            <!--这里的 server 是服务端的 IP -->\n\t        </init-param>\n\t        <init-param>\n\t            <param-name>serverName</param-name>\n\t            <param-value>http://localhost:9002</param-value>\n\t        </init-param>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CASFilter</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t    <!-- 该过滤器负责对 Ticket 的校验工作，必须启用它 -->\n\t    <filter>\n\t        <filter-name>CAS Validation Filter</filter-name>\n\t        <filter-class>org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter</filter-class>\n\t        <init-param>\n\t            <param-name>casServerUrlPrefix</param-name>\n\t            <param-value>http://localhost:8888/cas</param-value>\n\t        </init-param>\n\t        <init-param>\n\t            <param-name>serverName</param-name>\n\t            <param-value>http://localhost:9002</param-value>\n\t        </init-param>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CAS Validation Filter</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t    <!-- 该过滤器负责实现 HttpServletRequest 请求的包裹， 比如允许开发者通过 HttpServletRequest 的 getRemoteUser() 方法获得 SSO 登录用户的登录名，可选配置。 -->\n\t    <filter>\n\t        <filter-name>CAS HttpServletRequest Wrapper Filter</filter-name>\n\t        <filter-class>\n\t            org.jasig.cas.client.util.*\n\t        </filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CAS HttpServletRequest Wrapper Filter</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t    <!-- 该过滤器使得开发者可以通过 org.jasig.cas.client.util.AssertionHolder 来获取用户的登录名。 比如 AssertionHolder.getAssertion().getPrincipal().getName()。 -->\n\t    <filter>\n\t        <filter-name>CAS Assertion Thread Local Filter</filter-name>\n\t        <filter-class>org.jasig.cas.client.util.AssertionThreadLocalFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CAS Assertion Thread Local Filter</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t</web-app>\n\n\t```\n\n  * 用户认证过滤器（必选）**AuthenticationFilter **在上面的配置中需要两个参数一个是 casServerLoginUrl 顾名思义就是 CASserver 登陆的地址，比如我的是 http://localhost:8888/cas/login ，第二个参数是** serverName** , 因为登陆成功后还是要返回你当前的应用所以需要将你当前的应用的地址传递给 CASserver 比如我的当前应用 http://localhost:9002/\n  * Ticket 的校验过滤器（必选）**Cas20ProxyReceivingTicketValidationFilter** 与上面的过滤器类似也需要那两个参数，\t\t\t\t\t\t\t  配置了这两个过滤器 CAS 就能正常运行了\n  * 单点登出过滤器 **SingleSignOutFilter**，顾名思义就是用于单点登出  \n  * 另外还有两个过滤器都是为了获取登陆名配置的过滤器，配置一个就行。    \n#\n* 2.3 编写 index.jsp(tomcat 默认打开的页面）\n\t\n\t```java\n\t<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"\n\t         pageEncoding=\"utf-8\"%>\n\t<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n\t<html>\n\t<head>\n\t    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n\t    <title>一品优购</title>\n\t</head>\n\t<body>\n\t 采用 web.xml 配置的普通的 web 模块\n\t<%=request.getRemoteUser()%>\n\t <a href=\"http://localhost:8888/cas/logout?service=http://www.imlgw.top\">退出登录</a>>\n\t</body>\n\t</html>\n\t\n\t```\n\t 如果想让 cas 退出后跳转到指定的页面而不是 CAS 默认的页面也需要修改配置\n\t 修改 cas 系统的配置文件 cas-servlet.xml\n\t <bean id=\"logoutAction\" class=\"org.jasig.cas.web.flow.LogoutAction\"\n\t p:servicesManager-ref=\"servicesManager\"\n\t p:followServiceRedirects=\"${cas.logout.followServiceRedirects:true}\"/>\n\t将 cas.logout.followServiceRedirects 改为 true 后，可以在退出时跳转页面到目标页面\n   然后就可以启动 cas 和你的应用来测试了。\n* 2.4 服务端界面改造\n   上面测试成功，但是真实的情况肯定不会用 cas 默认的那个页面做登陆需要改成你自己的登陆界面，然后你当前应用的登陆页面就没用了。\n  \n\t```java\n\t<!DOCTYPE >\n\t<%@ page pageEncoding=\"UTF-8\" %>\n\t<%@ page contentType=\"text/html; charset=UTF-8\" %>\n\t<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n\t<%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %>\n\t<%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %>\n\t<%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %>\n\t<html>\n\t\t<head>\n\t\t\t<meta charset=\"UTF-8\" />\n\t\t\t<title>Login</title>\n\t\t\t<link rel=\"stylesheet\" type=\"text/css\" href='bs/css/bootstrap.min.css' />\n\t\t\t<script type=\"text/javascript\" src=\"js/jquery.min.js\"></script>\n\t\t\t<script type=\"text/javascript\" src=\"bs/js/bootstrap.min.js\"></script>\n\t\t\t<style>\n\t\t\t\timg {\n\t\t\t\t\theight: 200px;\n\t\t\t\t\tborder-radius: 200px;\n\t\t\t\t}\n\t\t\t\t.panel-title{\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t\t.login {\n\t\t\t\t\twidth: 500px;\n\t\t\t\t\theight: 400px;\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\ttop: 20%;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\tmargin-left: -250px;\n\t\t\t\t}\n\t\t\t\t.sub{\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\n\t\t\t</style>\n\t\t</head>\n\t\n\t\t<body>\n\t\t\t<div class=\"panel panel-primary login\">\n\t\t\t\t<div class=\"panel-heading\">\n\t\t\t\t\t<div class=\"panel-title\">\n\t\t\t\t\t\t<img src=\"images/login.jpg\" />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"panel-body\">\n\t\t\t\t\t<!--自定义的登陆界面修改 1 -->\n\t\t\t\t\t<form:form method=\"post\" id=\"fm1\" commandName=\"${commandName}\" htmlEscape=\"true\" class=\"sui-form\">\n\t\t\t\t\t\n\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t\t\t\t<span class=\"input-group-addon\" id=\"basic-addon1\"><span class=\"glyphicon glyphicon-user\"></span></span>\n\t\t\t\t\t\t\t\t<!--自定义的登陆界面修改 2 -->\n\t\t\t\t\t\t\t\t<form:input  class=\"form-control\" aria-describedby=\"basic-addon1\" placeholder=\"Username\"  id=\"username\" size=\"25\" tabindex=\"1\" accesskey=\"${userNameAccessKey}\" path=\"username\" autocomplete=\"off\" htmlEscape=\"true\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t\t\t\t<span class=\"input-group-addon\" id=\"basic-addon1\"><span class=\"glyphicon glyphicon-lock\"></span></span>\n\t\t\t\t\t\t\t\t<!--自定义的登陆界面修改 3 -->\n\t\t\t\t\t\t\t\t<form:password class=\"form-control\" placeholder=\"password\" aria-describedby=\"basic-addon1\" id=\"password\" size=\"25\" tabindex=\"2\" path=\"password\"  accesskey=\"${passwordAccessKey}\" htmlEscape=\"true\" autocomplete=\"off\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"form-group sub\">\n\t\t\t\t\t\t\t<!--自定义的登陆界面修改 4 登陆框 -->\n\t\t\t\t\t\t\t<input type=\"hidden\" name=\"lt\" value=\"${loginTicket}\" />\n\t     \t \t\t\t\t<input type=\"hidden\" name=\"execution\" value=\"${flowExecutionKey}\" />\n\t      \t\t\t\t\t<input type=\"hidden\" name=\"_eventId\" value=\"submit\" />\n\t      \t\t\t\t\t<input class=\"btn btn-primary btn-lg\" name=\"submit\" accesskey=\"l\" value=\"登陆\" type=\"submit\" />\n\t      \t\t\t\t\t<!--自定义的登陆界面修改 4 错误提示框 -->\n\t      \t\t\t\t\t<form:errors path=\"*\" id=\"msg\" cssClass=\"errors\" element=\"div\" htmlEscape=\"false\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</form:form>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\n\t\t</body>\n\t\n\t</html>\n\t```\n\t可以直接将登陆的页面拷过来然后加上指令再根据 cas 的登陆页面稍加修改就可以了\n\n---\n### 3. Spring 项目集成 CAS 和 Spring-security\n* pom 依赖\n\t\n\t```java\n\t<properties>\n\t        <spring.version>4.2.0.RELEASE</spring.version>\n\t    </properties>\n\t    <dependencies>\n\t        <!-- Spring -->\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-context</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-beans</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-webmvc</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-jdbc</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-aspects</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-jms</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-context-support</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <!--spring-security-->\n\t        <dependency>\n\t            <groupId>org.springframework.security</groupId>\n\t            <artifactId>spring-security-web</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework.security</groupId>\n\t            <artifactId>spring-security-config</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>javax.servlet</groupId>\n\t            <artifactId>javax.servlet-api</artifactId>\n\t            <version>3.1.0</version>\n\t            <scope>provided</scope>\n\t        </dependency>\n\t        <!--集成包-->\n\t        <dependency>\n\t            <groupId>org.springframework.security</groupId>\n\t            <artifactId>spring-security-cas</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <!--cas-->\n\t        <dependency>\n\t            <groupId>org.jasig.cas.client</groupId>\n\t            <artifactId>cas-client-core</artifactId>\n\t            <version>3.3.3</version>\n\t            <exclusions>\n\t                <exclusion>\n\t                    <groupId>org.slf4j</groupId>\n\t                    <artifactId>log4j-over-slf4j</artifactId>\n\t                </exclusion>\n\t            </exclusions>\n\t        </dependency>\n\t    </dependencies>\n\t```\n\t添加 tomcat 插件指定端口为 9001\n* web.xml 配置\n```java\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n\t         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n\t         version=\"2.5\">\n\t\n\t    <context-param>\n\t        <param-name>contextConfigLocation</param-name>\n\t        <param-value>classpath:spring/spring-*.xml</param-value>\n\t    </context-param>\n\t    <listener>\n\t        <listener-class>\n\t            org.springframework.web.context.ContextLoaderListener\n\t        </listener-class>\n\t    </listener>\n\t\n\t    <filter>\n\t        <filter-name>springSecurityFilterChain</filter-name>\n\t        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>springSecurityFilterChain</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t\n\t</web-app>\n```\n主要配置 Spring 容器和 Spring-security 的过滤器\n- spring-security.xml 配置\n  其实就是把之前配置在 web.xml 里面的过滤器采用 Spring 的方式配置出来\n\n``` java\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\n\t             xmlns:beans=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t             xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd\">\n\t\n\t    <http pattern=\"/out.html\" security=\"none\"></http>\n\t    <!--   entry-point-ref  入口点引用 因为登陆交给 cas 或者其他的登陆系统，就不会在本系统做登陆需要指定登陆点-->\n\t    <http use-expressions=\"false\" entry-point-ref=\"casProcessingFilterEntryPoint\">\n\t        <intercept-url pattern=\"/**\" access=\"ROLE_USER\"/>\n\t        <csrf disabled=\"true\"/>\n\t        <!-- custom-filter 为过滤器， position 表示将过滤器放在指定的位置上，before 表示放在指定位置之前  ，after 表示放在指定的位置之后  -->\n\t        <custom-filter ref=\"casAuthenticationFilter\"  position=\"CAS_FILTER\" />\n\t        <custom-filter ref=\"requestSingleLogoutFilter\" before=\"LOGOUT_FILTER\"/>\n\t        <custom-filter ref=\"singleLogoutFilter\" before=\"CAS_FILTER\"/>\n\t    </http>\n\t\n\t    <!-- CAS 入口点 开始 -->\n\t    <beans:bean id=\"casProcessingFilterEntryPoint\" class=\"org.springframework.security.cas.web.CasAuthenticationEntryPoint\">\n\t        <!-- 单点登录服务器登录 URL -->\n\t        <beans:property name=\"loginUrl\" value=\"http://localhost:8888/cas/login\"/>\n\t        <beans:property name=\"serviceProperties\" ref=\"serviceProperties\"/>\n\t    </beans:bean>\n\t\n\t    <beans:bean id=\"serviceProperties\" class=\"org.springframework.security.cas.ServiceProperties\">\n\t        <!--service 配置自身工程的根地址+/login/cas   -->\n\t        <beans:property name=\"service\" value=\"http://localhost:9001/login/cas\"/>\n\t    </beans:bean>\n\t    <!-- CAS 入口点 结束 -->\n\t    <!-- 认证过滤器 开始 -->\n\t    <beans:bean id=\"casAuthenticationFilter\" class=\"org.springframework.security.cas.web.CasAuthenticationFilter\">\n\t        <beans:property name=\"authenticationManager\" ref=\"authenticationManager\"/>\n\t    </beans:bean>\n\t    <!-- 认证管理器 -->\n\t    <authentication-manager alias=\"authenticationManager\">\n\t        <authentication-provider  ref=\"casAuthenticationProvider\">\n\t        </authentication-provider>\n\t    </authentication-manager>\n\t    <!-- 认证提供者 -->\n\t    <beans:bean id=\"casAuthenticationProvider\"     class=\"org.springframework.security.cas.authentication.CasAuthenticationProvider\">\n\t        <beans:property name=\"authenticationUserDetailsService\">\n\t            <beans:bean class=\"org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper\">\n\t                <beans:constructor-arg ref=\"userDetailsService\" />\n\t            </beans:bean>\n\t        </beans:property>\n\t        <beans:property name=\"serviceProperties\" ref=\"serviceProperties\"/>\n\t        <!-- ticketValidator 为票据验证器 -->\n\t        <beans:property name=\"ticketValidator\">\n\t            <beans:bean class=\"org.jasig.cas.client.validation.Cas20ServiceTicketValidator\">\n\t                <beans:constructor-arg index=\"0\" value=\"http://localhost:8888/cas\"/>\n\t            </beans:bean>\n\t        </beans:property>\n\t        <beans:property name=\"key\" value=\"an_id_for_this_auth_provider_only\"/>\n\t    </beans:bean>\n\t    <!-- 认证类 -->\n\t    <beans:bean id=\"userDetailsService\" class=\"top.imlgw.demo.UserDetailServiceImpl\"/>\n\t\n\t    <!-- 认证过滤器 结束 -->\n\t\n\t    <!-- 单点登出  开始  -->\n\t    <beans:bean id=\"singleLogoutFilter\" class=\"org.jasig.cas.client.session.SingleSignOutFilter\"/>\n\t    <!--关联两个地址，相当于封装了前面的地址-->\n\t    <beans:bean id=\"requestSingleLogoutFilter\" class=\"org.springframework.security.web.authentication.logout.LogoutFilter\">\n\t        <beans:constructor-arg value=\"http://localhost:8888/cas/logout?service=http://localhost:9001/out.html\"/>\n\t        <beans:constructor-arg>\n\t            <beans:bean class=\"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler\"/>\n\t        </beans:constructor-arg>\n\t        <beans:property name=\"filterProcessesUrl\" value=\"/logout/cas\"/>\n\t    </beans:bean>\n\t    <!-- 单点登出  结束 -->\n\t\n\t</beans:beans>\n```\n\n- userDetailsService 编写\n  这是一个认证类是属于 Spring-security 的，如果不使用 CAS 那么这个类就是用来验证密码是否正确是否放行的。但是整合了 CAS 后就不用在里面做认证了，只是为了返回后面的角色集合。\n\n\t```java\n\tpackage top.imlgw.demo;\n\timport org.springframework.security.core.GrantedAuthority;\n\timport org.springframework.security.core.authority.SimpleGrantedAuthority;\n\timport org.springframework.security.core.userdetails.User;\n\timport org.springframework.security.core.userdetails.UserDetails;\n\timport org.springframework.security.core.userdetails.UserDetailsService;\n\timport org.springframework.security.core.userdetails.UsernameNotFoundException;\n\timport java.util.ArrayList;\n\timport java.util.List;\n\t\n\tpublic class UserDetailServiceImpl implements UserDetailsService {\n\t    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t        System.out.println(\"经过认证类\");\n\t        List<GrantedAuthority> authorities=new ArrayList();\n\t        //最开始把这里的 role 写错了，然后 cas 登陆成功后也一直被 403 forbid，因为 SpringSecurity 认证没通过，一直没放行\n\t        authorities.add(new SimpleGrantedAuthority(\"ROLE_USER\"));\n\t        //不通过本项目做登陆 所以密码无所谓，在执行这个方法的时候就已经登陆成功了\n\t        return new User(username,\"\",authorities);\n\t    }\n\t}\n\t\n\t```\n\n---\n### 4. 测试\n启动搭建好的两个服务器，和 casServer，然后测试在一个应用登陆后另一个能否进入 index 页面 .....\n\n---\nSpringBoot 集成 CAS 和 Spring-security 的后面再补充，因为 SpringBoot 还不太熟悉。","tags":["CAS","SSO"],"categories":["Web"]},{"title":"一道 LeetCode 引发的惨案","url":"/2018/10/31/96e09a6a/","content":"## 一道 LeetCode 搜索题引发的惨案\n ### 1. 先上 [题目](https://leetcode-cn.com/problems/word-ladder/) \n给定两个单词（_beginWord _和 _endWord_）和一个字典，找到从 _beginWord_ 到 _endWord_ 的最短转换序列的长度。转换需遵循如下规则：\n\n1.  每次转换只能改变一个字母。\n2.  转换过程中的中间单词必须是字典中的单词。\n [原题链接](https://leetcode-cn.com/problems/word-ladder/)\n\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/3V6EQ77R_%28%292SCR%248R%5B%245F7.png) \n\n其实这题明显是 BFS（广搜） 题目类型也说了是广搜，但是我不信邪写了 DFS（毕竟代码比较好写），然后惨案就发生了。\n\n```java\n   // 标记数组\n\t// 默认都是 0\n\tprivate static int[] mark;\n\n\tpublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n\t\t// 不存在\n\t\tmark = new int[wordList.size() + 1];\n\t\tif (!wordList.contains(endWord)) {\n\t\t\treturn 0;\n\t\t}\n\t\t// dfs 开始\n\t\tdfs(beginWord, endWord, wordList);\n\t\t// 无法转换\n\t\tif (min == Integer.MAX_VALUE) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn min + 1;\n\t}\n\n\tint min = Integer.MAX_VALUE;\n\n\t// dfs\n\tprivate void dfs(String beginWord, String endWord, List<String> wordList) {\n\t\t//当相等的时候\n\t\tif (beginWord.equals(endWord)) {\n\t\t\tint step = 0;\n\t\t\tfor (int i = 0; i < mark.length; i++) {\n\t\t\t\tif (mark[i] == 1) {\n\t\t\t\t\tstep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//更新最小值\n\t\t\tmin = step < min ? step : min;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < wordList.size(); i++) {\n\t\t\tif (mark[i] == 0 && cmp(beginWord, wordList.get(i))) {\n\t\t\t\tmark[i] = 1;\n\t\t\t\tdfs(wordList.get(i), endWord, wordList);\n\t\t\t\tmark[i] = 0;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// 写一个函数判段是否只变化了一个字母\n\tprivate boolean cmp(String s1, String s2) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (s1.charAt(i) != s2.charAt(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count == 1;\n\t}\n```\n结果直接 TLE 了，后来想了想 DFS 每次都会**尝试**所有情况，而给的例子后面的数据量也比较大，而且这题是要统计最短路径，要全部递归完才能确定最小值，我把数据拿来自己测试跑了好长时间都没跑出来，而 BFS 没有递归只是会耗费的空间会比较大。从这里也可以总结出来 DFS 跟适合判断是否存在是否可达之类的问题，BFS 更适合做找最短最小之类的问题。上 BFS 代码\n\n```java\n// 标记数组\n\t// 默认都是 0\n\tprivate static int[] mark;\n\t// 模拟队列\n\tclass Que {\n\t\tString word;\n\t\tint step;\n\t}\n\t//BFS\n\tpublic int ladderLengthBFS(String beginWord, String endWord, List<String> wordList){\n        // 不存在\n\t\tmark = new int[wordList.size() + 1];\n\t\tif (!wordList.contains(endWord)) {\n\t\t\treturn 0;\n\t\t}\n\t\t// BFS\n\t\tint head = 0, tail = 0;\n\t\t// 初始化队列\n\t\tQue[] que = new Que[wordList.size() + 1];\n\t\t// 循环促使话述祖\n\t\tfor (int i = 0; i < que.length; i++) {\n\t\t\tque[i] = new Que();\n\t\t}\n\t\tque[tail].word = beginWord;\n\t\tque[tail].step = 1;\n\t\ttail++;\n\t\tint flag=0;\n\t\twhile (head < tail) {\n\t\t\t// 遍历字典\n\t\t\tfor (int i = 0; i < wordList.size(); i++) {\n\t\t\t\tif (mark[i] == 0 && cmp(wordList.get(i), que[head].word)) {\n\t\t\t\t\tque[tail].word = wordList.get(i);\n\t\t\t\t\t//这里是从 head 开始的，所以应该是 head 的步数+1\n\t\t\t\t\tque[tail].step=que[head].step+1;\n\t\t\t\t\t// 标记为已经走过\n\t\t\t\t\tmark[i] = 1;\n\t\t\t\t   if (que[tail].word.equals(endWord)) {\n\t\t\t\t\t//到这里说明已经到终点了，而且是最短的，之后的最多就是相等\n\t\t\t\t\t//跳出循环\n                       flag=1;\n                       break;\n\t\t\t    \t}\n                    tail++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n            if(flag==1){\n                break;\n            }\n\t\t\t// 每次检查完一个单词就将其出队列\n\t\t\thead++;\n\t\t}\n\t\treturn que[tail].step;\n    }\n\n\t// 写一个函数判段没吃是否只变化了一个字母\n\tprivate boolean cmp(String s1, String s2) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (s1.charAt(i) != s2.charAt(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count == 1;\n\t}\n```\n\nPS：刚刚修改了下代码，我也佩服自己 BFS 都还没搞清楚就直接上了代码，然后结果居然还是对的，之前在 if 判断队尾元素是不是和 endWord 相等后还维护了一个最小值 min，后来想了想不对，最后一个和 endWord 相等的元素已经进栈了，已经是最短的了，后面的即使可以转换到也最多只能和当前的相等了。 如果只是为了统计最小值就可以直接 break 了。那如果不仅仅要统计最小值还要记录路径要怎么搞？\n### 2. [加强版](https://leetcode-cn.com/problems/word-ladder-ii/) 单词接龙 2\n是一道困难等级的题，需要在上面的基础上找出所有的最短的路径。\n\n```java\n// 内部类\n\tclass Que {\n\t\tString word;\n\t\tint step;\n\t\tQue prev;\n\t\tpublic String toString(){\n\t\t\treturn (word + \":\" + step);\n\t\t}\t\t \n\t}\n\n\t//返回值\n\tprivate  List<List<String>> res=new ArrayList<>();\n\n\t\n\t//BFS\n\tpublic List<List<String>> ladderLengthBFS(String beginWord, String endWord, List<String> wordList){\n        //返回值\n\t\t//List<List<String>> res=new ArrayList<>();\n\t\t\n        // 不存在\n\t\tmark = new int[wordList.size() + 1];\n\t\tif (!wordList.contains(endWord)) {\n\t\t\treturn res;\n\t\t}\n\t\t// BFS\n\t\tint head = 0, tail = 0;\n\t\t// 初始化队列\n\t\tQue[] que = new Que[wordList.size() + 1];\n\t\t// 循环促使话述祖\n\t\tfor (int i = 0; i < que.length; i++) {\n\t\t\tque[i] = new Que();\n\t\t}\n\t\t//先把第一个单词放进去\n\t\tque[tail].word = beginWord;\n\t\tque[tail].step = 1;\n\t\ttail++;\n\t\tList<Que> quelist=new ArrayList<>();\n\t\twhile (head < tail) {\n\t\t\t// 遍历字典\n\t\t\tfor (int i = 0; i < wordList.size(); i++) {\n\t\t\t\tif (mark[i] == 0 && cmp(wordList.get(i), que[head].word)) {\n\t\t\t\t\tque[tail].word = wordList.get(i);\n\t\t\t\t\t//这里是从 head 开始的，所以应该是 head 的步数+1\n\t\t\t\t\tque[tail].step=que[head].step+1;\n\t\t\t\t\t//que[head].next=que[tail];\n\t\t\t\t\t// 标记为已经走过\n\t\t\t\t\tmark[i] = 1;\n\t\t\t\t   if (que[tail].word.equals(endWord)) {\t\n\t\t\t\t   \t\t//记录最小值\n\t\t\t\t   \t\tmin=que[tail].step;\n\t\t\t\t   \t\t//到这里队列后面就不用再插入元素了\n\n\t\t\t\t   \t\t//2. 把之前走过的路在下一个 head\n\n\t\t\t\t   \t\t//将队列变成 list\n\t\t\t\t   \t\tfor(int j=0;j<=tail;j++){\n\t\t\t\t   \t\t\tquelist.add(que[j]);\n\t\t\t\t   \t\t}\n\t\t\t\t   \t\tmarkDfs= new int[wordList.size() + 1]; \n\t\t\t\t   \t\t// 1. 用 DFS 试一下\n\t\t\t\t   \t\tdfsBfs(que[0],endWord,quelist);\n\t\t\t    \t}\n                    tail++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 每次检查完一个单词就将其出队列\n\t\t\thead++;\n\t\t}\n\t\treturn res;\n    }\n\n    private void dfsBfs(Que beginWord,String endWord,List<Que> ques){\n    \tint step = 0;\n\t\tfor (int i = 0; i < markDfs.length; i++) {\n\t\t\t\tif (markDfs[i] == 1) {\n\t\t\t\t\tstep++;\n\t\t\t\t}\n\t\t}\n\t\tif(step>=min) return;\n\t\tif(step+1==min&&endWord.equals(beginWord.word)){\n\t\t\tList<String> list=new ArrayList<>();\n\t\t\tStack<String> stack=new Stack<>();\n\t\t\tSystem.out.println(beginWord.word+\":\"+step);\n\t\t\tQue temp=beginWord;\n\t\t\t\t//找到一条\n\t\t\t\tfor(int i=0;i<min;i++){\n\t\t\t\t\tstack.push(temp.word);\n\t\t\t\t\tSystem.out.print(temp.word+\"<--\");\n\t\t\t\t\ttemp=temp.prev;\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t\tfor(int i=0;i<min;i++){\n\t\t\t\t\tlist.add(stack.pop());\n\t\t\t\t}\n\t\t\t\tres.add(list);\n\t\t\t\tSystem.out.println(res);\n\t\t\treturn;\n\t\t}\n\n\t\t\n\t\tfor (int i = 0; i < ques.size(); i++) {\n\t\t\tif (markDfs[i] == 0 && cmp(beginWord.word,ques.get(i).word)){\n\t\t\t\tmarkDfs[i] = 1;\n\t\t\t\t//连接两个节点\n\t\t\t\t//beginWord.next=ques.get(i);\n\t\t\t\tques.get(i).prev=beginWord;\n\t\t\t\tdfsBfs(ques.get(i), endWord, ques);\n\t\t\t\tmarkDfs[i] = 0;\n\t\t\t}\n\t\t}\n\t\treturn;\n    }\n\n\t// private int step = 0;\n\tint min = Integer.MAX_VALUE;\n\n\t// 写一个函数判段没吃是否只变化了一个字母\n\tprivate boolean cmp(String s1, String s2) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (s1.charAt(i) != s2.charAt(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count == 1;\n\t}\n```\n整体上在 Que 上增加了一个 prev 的指针，遍历路径，一开始是用的 BFS 不过我想的太简单了，我只是把最后一个节点出队列然后再 BFS，后来发现不行（居然还跑过了 24 个测试案例），实际上这题我还是没有做出来，但是上面的方法应该是没问题的就是会 TLE😭，大概思路就是先 BFS 缩短 DFS 需要遍历的字典然后控制每次递归的身体不能超过 BFS 的到的最短路径\n![img9](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/blog.PNG) 一开始只能跑几个数据的，优化下能跑几十个的，但是还是太慢了，毕竟是一道难题等以后学了相关的东西再来试试看能不能做出来吧。\n\n---\n算法，学着挺有意思，就是头有点凉。","tags":["算法","数据结构","搜索"],"categories":["算法"]},{"title":"你有 FreeBug 么？--->Spring-solr","url":"/2018/10/05/8e2bbf7a/","content":"## FreeBug ? 哎呦，不错喔。\n 昨天从上午 10 点开始一直到晚上 11：58 才把那几个 Bug 给解决了，前两个 Bug 确实蛮奇怪的，特别是第一个 Bug , 最后一个 Bug.... 纯属智障。把这几个 Bug 记录下┗|｀O′|┛ \n### ***Bug1***:\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/9642SBM2%60QFX4AMO1C%5D~A%5BM.png)\n意思是没找到 TbItemMapper 的 select 方法还有这个类的其他方法。\n估计是 xml 文件没有加载到 classes 路径下，之前一直好好的然后昨天突然抽风了，百度了下叫我把 xml 文件随便的改动下在里面加个空格换行之类的，然后就好了。\n### ***Bug2***:\n![img9](https://p4.cdn.img9.top/ipfs/Qmcg5dscbhYgod9vdN2SHaxywdaCPVgY28jX4imd53TH6J?4.png)\n看着这些个 Bug 真的是一脸懵，写 main 方法执行就一点问题没有，首先是一波百度，说是 jar 包冲突了主要是 HttpClient 的冲突，然后我就尝试了下 idea 的 maven 依赖视图\n![img9](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/DJQYP%604SGOCL_VP%28LGN%7B_TN.png )\n然后发现 dubbo 和 spring-data-solr 都有 httpclient 包和 httpcore 而且版本不一致，然后果断的把 dubbo 里面的 httpclient 和 httpcore 给 exclusion 了，不看不知道，整个项目的 maven 依赖好乱，有好多依赖冲突，不过没影响使用我就没有去改，怕再改出什么问题。你以为改完之后 bug 就结束了？\n### ***Bug3***:\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/%60Z3GBQ~K%29%7D%60DX%60P%60Q%257%25%7B%25S.png) 在 controller 层疯狂报错，service 层一点问题没有！[oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/NLKUXAM~LPOZ7K%60%28%29D52%40VD.png) 可以，又一个 FreeBug，在纠结了几个小时后看了一眼代码发现\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/L20FMBQ%28XNRQV6Y6%24ITFEYA.png) 原来这里写掉了东西，返回了一个 solr 的结果集也没有实现序列化返回出去了前台也根本就解析不了难怪会再前台报错。\n\nps: 之前一直用的 img9.top 的无限图床，前几天突然崩溃了博客的图片都失效了，之前也有一个送的阿里云的 oss 的包所以就想拿那个当图床，这篇文章里面的图片也都是在 oss 上的，img9 虽然也还可以但是是个去中心化的图床不好管理确实难搞，等有时间就用 java 写一个自动化的图床工具玩玩。","tags":["Bug","Solr","Spring"],"categories":["踩坑记录"]},{"title":"可以获取最小值的栈","url":"/2018/09/27/6f1b786d/","content":"## 如何实现可以获取最小值的栈？\n这个问题是很久之前在微信公众号上看见的一个问题，突然想起来就来操作一下。\n开发环境   : sublime+MinGW\n先附上我自己实现的栈的结构\n\n```java\n//定义链栈的节点的结构体 \ntypedef struct  StackNode\n{\n\tint data;\n\tstruct StackNode *next;\n}StackNode,*LinkStackPtr;\n\n//链栈的结构体\ntypedef struct LinkStack\n{\n\t//栈顶\n\tLinkStackPtr top;\n\t//总数量\n\tint count;\n}LinkStack;\n\n//初始化栈\nLinkStack *init(){\n\tLinkStack *stack=(LinkStack*)malloc(sizeof(LinkStack));\n\tif (stack==NULL)\n\t{\n\t\tprintf(\"动态开辟空间失败\");\n\t}else\n\t\t//初始化空栈\n\t\tstack->top=NULL;\n\t\tstack->count=0;\n\t\treturn stack;\n}\n\n//创建节点\nLinkStackPtr  creatNode(){\n\tLinkStackPtr stack;\n\t//开辟空间\n\tstack =(LinkStackPtr)malloc(sizeof(StackNode));\n\tif(stack==NULL){\n\t\tprintf(\"动态开辟空间失败\");\n\t}\n\tscanf(\"%d\",&(stack->data));\n\tstack->next=NULL;\n\treturn stack;\n}\n\n//压栈\nvoid push(LinkStack * s){\n\t//创建节点\n\tLinkStackPtr newStack= creatNode();\n\t//保存当前的节点\n\tLinkStackPtr currentTopStack=s->top;\n\t//栈顶变为刚进栈的元素\n\ts->top=newStack;\n\t//连接\n\tnewStack->next=currentTopStack;\n\t//数目加一\n\ts->count++;\n}\n\n//弹栈\nvoid pop(LinkStack *s){\n\t//将栈顶弹出\n\tLinkStackPtr topStack=s->top;\n\ts->top=topStack->next;\n\ts->count--;\n\tfree(topStack);\n}\n```\n\n### **Solution 1**：\n在进栈的时候用一个变量保存当前的最小值每次进栈就会和最小值比较如果比最小值要小就会更新这个变量的值，出栈的时候比较麻烦，如果最小值被弹出去了就需要遍历整个栈来获取最小值。\n- Implement：\n\n```java\ntypedef struct  StackNode\n{\n\tint data;\n\tstruct StackNode *next;\n}StackNode,*LinkStackPtr;\n\n//链栈的结构体\ntypedef struct LinkStack\n{\n\t//栈顶\n\tLinkStackPtr top;\n\t//总数量\n\tint count;\n\t//最小值\n\tint min;\n}LinkStack;\n\n//进栈\nvoid push(LinkStack * s){\n\t//创建节点\n\tLinkStackPtr newStack= creatNode();\n\t//**********************************\n\tif(s->count==0){\n\t\ts->min=newStack->data;\t\n\t}else if(s->min>newStack->data){\n\t\ts->min=newStack->data;\n\t}\n\t//*********************************\n\t//保存当前的节点\n\tLinkStackPtr currentTopStack=s->top;\n\t//栈顶变为刚进栈的元素\n\ts->top=newStack;\n\t//连接\n\tnewStack->next=currentTopStack;\n\t//数目加一\n\ts->count++;\n}\n\n//弹栈\nvoid pop(LinkStack *s){\n\t//将栈顶弹出\n\tLinkStackPtr topStack=s->top;\n\t//从第二个开始比较\n\tLinkStackPtr stackNode=topStack->next;\n\t//弹出去的那个节点的数据\n\tint min=topStack->data;\n\ts->top=topStack->next;\n\ts->count--;\n\tfree(topStack);\n\t//如果弹出的是最小值就需要从当前栈顶遍历数组获取最小值\n\tif(min==s->min){\n\t\tmin=stackNode->data;\n\t  do{\n\t  \tif(min>stackNode->data){\n\t  \t\tmin=stackNode->data;\n\t  \t}\n\t\tstackNode=stackNode->next;\n\t   }while(stackNode!=NULL);\t\n\t}\n\ts->min=min;\n}\n```\n这种方法进栈时间复杂度为 O(1), 但是出栈时间复杂度为 O(n). 显然不是很优雅。\n\n### **Solution 2**：\n空间换时间利用一个辅助栈，辅助栈里面存放最小值，辅助栈进栈时判断进栈的元素和当前栈顶的元素大小跟小就可以进栈。所以最小值就是辅助栈的栈顶元素，出栈时如果出栈的元素是最小值节点那辅助栈也同时弹栈 再取栈顶元素。\n- Implement：\n\n```java\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//定义链栈的节点的结构体 \ntypedef struct  StackNode\n{\n\tint data;\n\tstruct StackNode *next;\n}StackNode,*LinkStackPtr;\n\n//链栈的结构体\ntypedef struct LinkStack\n{\n\t//栈顶\n\tLinkStackPtr top;\n\t//总数量\n\tint count;\n\t//辅助栈\n\tstruct LinkStack *mins;\n}LinkStack;\n\n//初始化栈\nLinkStack *init(){\n\tLinkStack *stack=(LinkStack*)malloc(sizeof(LinkStack));\n\tif (stack==NULL)\n\t{\n\t\tprintf(\"动态开辟空间失败\");\n\t}else\n\t\t//初始化空栈\n\t\tstack->top=NULL;\n\t\tstack->count=0;\n\t\treturn stack;\n}\n\n//创建节点\nLinkStackPtr  creatNode(){\n\tLinkStackPtr stack;\n\t//开辟空间\n\tstack =(LinkStackPtr)malloc(sizeof(StackNode));\n\tif(stack==NULL){\n\t\tprintf(\"动态开辟空间失败\");\n\t}\n\tscanf(\"%d\",&(stack->data));\n\tstack->next=NULL;\n\treturn stack;\n}\n\n//进栈\nvoid push(LinkStack * s){\n\t//创建节点\n\tLinkStackPtr newStack= creatNode();\n\t//保存当前的节点\n\tLinkStackPtr currentTopStack=s->top;\n\n\t//开辟空间 用于添加到辅助栈中，之前直接操作 newStack，指针地址导致后面辅助栈和主栈混合到了一起，\n\tLinkStackPtr minStackNode =(LinkStackPtr)malloc(sizeof(StackNode));\n\tif(minStackNode==NULL){\n\t\tprintf(\"动态开辟空间失败\");\n\t}\n\tminStackNode->data=newStack->data;\n\tminStackNode->next=NULL;\n\n\t//栈顶变为刚进栈的元素\n\ts->top=newStack;\n\t//辅助栈\n\tLinkStack *mins=s->mins;\n\t//保存辅助栈当前栈顶\n\tLinkStackPtr  currentMinsTop=mins->top;\n\tif(s->count==0){\n\t   mins->top=newStack;\n\t   newStack->next=NULL;\n    }else\n    \t//如果进栈的元素比当前辅助栈的栈顶小\n    \t//相等的要进栈\n    \tif(newStack->data<=mins->top->data){\n    \t\tmins->top=minStackNode;\n    \t\t//连接\n    \t\tmins->top->next=currentMinsTop;\n    \t\tmins->count++;\n    \t}\n\t//连接\n\ts->top->next=currentTopStack;\n\t//数目加一\n\ts->count++;\n}\n\n//弹栈\nvoid pop(LinkStack *s){\n\t//将栈顶弹出\n\tLinkStackPtr topStack=s->top;\n    //辅助栈\n\tLinkStack * mins=s->mins;\n\t//保存辅助栈栈顶元素便于销毁\n\tLinkStackPtr minsTopStack=mins->top;\n\ts->top=topStack->next;\n\ts->count--;\n\t//弹出的元素是最小值\n\tif (topStack->data==mins->top->data)\n\t{\n\t\t//辅助栈同时弹栈\n\t\tmins->top=minsTopStack->next;\n\t\tmins->count--;\n\t\tfree(minsTopStack);\n\t}\n\tfree(topStack);\n}\n\n//遍历栈（栈顶到栈底）\nvoid printStack(LinkStack *stack){\n\t//当前栈顶\n\tLinkStackPtr stackNode=stack->top;\n\tdo{\n\t\tprintf(\"%d\\n\",stackNode->data);\n\t\tstackNode=stackNode->next;\n\t}while(stackNode!=NULL);\n}\n\nint main(int argc, char const *argv[])\n{\n\t//申明并初始化栈结构\n\tLinkStack *stack=init();\n\t//初始化这个链栈的辅助（C 语言学的不好原谅这些很奇怪的操作）\n\tstack->mins=init();\n\tpush(stack);\n\tprintf(\"*******进栈******\\n\");\n\tprintStack(stack);\n\tprintf(\"*********辅助栈*******\\n\");\n\tprintStack(stack->mins);\n\tprintf(\"*******最小值******\\n\");\n\tprintf(\"%d\\n\", stack->mins->top->data);\n\tpop(stack);\n\tprintf(\"*******出栈******\\n\");\n\tprintStack(stack);\n\tprintf(\"*******最小值******\\n\");\n\tprintf(\"%d\\n\", stack->mins->top->data);\n\tprintf(\"*********辅助栈*******\\n\");\n\tprintStack(stack->mins);\n\treturn 0;\n}\n```\n明显这个方法进栈出栈时间复杂度都是 O(1)，空间复杂度相对会高一点，其实空间复杂度还可以优化，可以在辅助栈里面存索引，这样进栈时会避免存入相同的最小值，如  2 1 1 1 1 1 存到辅助栈就是  2 1 1 1 1 1 后面的 1 都是重复的，如果存索引就是 0 1 进栈时跟之前一样，出栈时判断索引是否和辅助栈存的索引一致，不一致就不动。这里因为这个是个链栈 , 要根据索引取值并不方便所以就不实现了。\n\n这里我把代码全部贴上来了，C 语言确实学的不怎么样，所以里面会有一些奇怪的操作，这个算法本身很简单但是用 C 语言一实现就会有一堆问题，昨天进栈的时候一个指针把辅助栈和主栈搞混了一直有 bug, 今天早上上课才想起来，毕竟 C 语言写的少 hahahaha,  所以后面我打算以后会同时用 C 语言和 Java 都实现一遍。\n","tags":["算法","数据结构"],"categories":["算法"]},{"title":"Spring-Redis 遇到的 bug","url":"/2018/09/24/bea4831e/","content":"\n##   两个小 bug 记录一下\n1.  Spring-data-redis 和 jedis 整合的版本问题报错如下：\n```java\n严重：Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisTemplate' defined in URL [jar:file:/E:/repository/com/pyg/pyg-common/0.0.1-SNAPSHOT/pyg-common-0.0.1-SNAPSHOT.jar!/spring/applicationContext-redis.xml]: Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.<init>(Ljava/lang/ClassLoader;)V\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1578)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)\nat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:305)\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:301)\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196)\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:772)\nat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:834)\nat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:537)\nat org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:446)\nat org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:328)\nat org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:107)\nat org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4939)\nat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5434)\nat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\nat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)\nat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\nat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.<init>(Ljava/lang/ClassLoader;)V\nat org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.<init>(JdkSerializationRedisSerializer.java:53)\nat org.springframework.data.redis.core.RedisTemplate.afterPropertiesSet(RedisTemplate.java:117)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1637)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1574)\n... 21 more\n```\n\n 报错原因：Spring-data-reids 和 jedis 的版本冲突（应该也和 Spring 的版本有关系，别人跟我一样的包都可以运行）。\n我测试成功的版本：\n<jedis.version>2.6.2</jedis.version>\n<spring.version>4.2.0.RELEASE</spring.version>\n<spring-data-redis.version>1.4.2.RELEASE</spring.version>\n\n2. Spring 加载配置文件的问题\n因为同时配置了 MySql 和 Redis 的配置文件而且不是同一个工程所以不是同时初始化然后出现了以下的问题。\n同个模块中如果出现多个 context:property-placeholder ，location properties 文件后， 运行时出现 Could not resolve placeholder 'key' in string value${key}。原因是在加载第一个 context:property-placeholder 时 会扫描所有的 bean，而有的 bean 里面出现第二个 context:property-placeholder 引入的 properties 的占位符${key}， 此时还没有加载第二个 property-placeholder，所以解析不了${key}。\n解决办法一，可以将通过模块的多个 property-placeholder 合并为一个，将初始化放在一起。\n方法二，添加 ignore-unresolvable=\"true \"，这样可以在加载第一个 property-placeholder 时出现解析不了的占位符进行忽略掉\n\nps：目前的计划是先把品优购这个项目做完，然后搞一搞微信小程序之类的开发，然后开始着手研究源码，对 Spring 的源码非常好奇有种特别想了解她的欲望 hahahahahaha....  看源码肯定会涉及到设计模式也顺便学一学，再就是数据结构和算法，这学期也正在学也不用着急跟着老师的进度再加自己的自学补充，这个东西也不是说今天学完了就会了的东西，大二上学期主要的打算就是这个了，还有就是不能挂科！！！！, 再往后就是打算学下安卓和安卓逆向，不过暂时只是个打算😄。再往后就是大三了，还没打算到那个时候，想想还真快，不知不觉就一年过去了。Come on , add oil ! ! ! @imlgw\n","tags":["Redis","Bug","Spring"],"categories":["踩坑记录"]},{"title":"双向循环链表","url":"/2018/08/18/680ae0e/","content":"## C 实现的双向循环链表\n很久没有用 C 了，都忘了，昨天下午又复习了一下然后实现了这个双向循环链表，后面每种数据结构都会在这里实现记录下来。\n开发环境   : sublime+MinGW \n```java\n#include <stdio.h>\n#include <stdlib.h>\n//定义结构体\ntypedef struct Node\n{\n\tint data;\n\tstruct Node *perv;\n\tstruct Node *next;\n}Node;\n\nint length;\n\n//初始化节点\nNode* createNode(){\n\tNode * node;\n\t//开辟空间\n\tnode =(Node*)malloc(sizeof(Node));\n\tif(node==NULL){\n\t\tprintf(\"动态开辟空间失败\");\n\t}\n\tscanf(\"%d\",&(node->data));\n\tnode->perv=NULL;\n\tnode->next=NULL;\n\treturn node;\n}\n\n//初始化链表 \nNode* createList(int n)\n{\n    Node *tail,*p,*head;\n    //初始化头结点 （这个节点只是个标志，标志链表的头并不存储数据，只是为了操作的统一性）\n    head=(Node*)malloc(sizeof(Node));\n    int i;\n    if(n >= 1)   //结点的个数 >= 1 的时候\n    {\n        p = createNode();\n        head->next = p;\n        p->perv=head;\n        tail = p;\n    }\n    for(i = 2;i <= n;i++)    //生成第一个结点以后的结点，并建立双向链表的关系 \n    {\n        p = createNode();\n        tail->next = p;\n        p->perv = tail;\n        //尾指针后移\n        tail = p;\n    }\n    //连接头尾\n    head->perv=tail;\n    tail->next=head;\n    //链表的长度\n    length = n;\n    if(n >= 1)\n        return (head);\n    else\n        return 0;    \n} \n\n//在头尾插入节点   （实际上这两个方法都可以通过下面的 insAnywhere 完成，主要为了效率，如果是尾结点插入 getEle() 时间复杂度过高）\n//insAnywhere(head,0);\nvoid insHead(Node* head){\n\tNode *p=createNode();\n\tNode *q;\n\t//保存第一个节点\n\tq=head->next;\n\t//连接头结点\n\thead->next=p;\n\tp->perv=head;\n\t//连接之前的第一个节点\n\tp->next=q;\n\tq->perv=p;\n\t++length;\n}\n\n//insAnywhere(head,length);\nvoid insTail(Node* head){\n\tNode *p=createNode();\n\t//先保存下之前的尾指针\n\tNode *tail=head->perv;\n\t//连接头尾\n\thead->perv=p;\n\tp->next=head;\n\t//连接之前的尾指针\n\ttail->next=p;\n\tp->perv=tail;\n\t++length;\n}\n\n//取得某一位置的节点  时间复杂度为 O(n)\nNode * getEle(Node* head,int n){\n\t//将第一个节点赋值给 p\n\tNode *p=head;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tp=p->next;\n\t}\n\treturn p;\n}\n\n//获取链表的长度\nint getLength(){\n\treturn length;\n}\n\n//任意位置插入，因为设置了头节点所以插入的操作具有一致性\nvoid insAnywhere(Node *head,int n){\n\tNode *newNode=createNode();\n\t//取得对应位置的值\n\tNode *currentNode=getEle(head,n);\n\t//保存当前位置的下一个\n\tNode *nextNode;\n\t//保存下一个节点\n\tnextNode=currentNode->next;\n\t//连接当前结点\n\tcurrentNode->next=newNode;\n\tnewNode->perv=currentNode;\n\t//连接之前的下一个节点\n\tnewNode->next=nextNode;\n\tnextNode->perv=newNode;\n\t++length;\n}\n\n//任意位置的删除\nvoid delNode(Node *head,int n){\n\tNode *delNode=getEle(head,n);\n\t/*printf(\"%d\\n\", delNode->data);\n\tprintf(\"--------------\\n\");*/\n\t//先保存当前节点的后一节点\n\tNode *nextNode=delNode->next;\n\t//将后一个节点接在当前节点的前一个的后面\n\tdelNode->perv->next=nextNode;\n\tnextNode->perv=delNode->perv;\n\t//free 这个节点\n\tfree(delNode);\n}\n\n//遍历链表\nvoid printlnAll(Node *head){\n\tNode *p=head->next;\n   do{\n   \t  printf(\"%d\\n\", p->data);\n   \t  p=p->next;\n   }while(p!=head);\n\t// while(p->next!=head){\n\t// \tprintf(\"%d\\n\", p->data);\n\t// \t//指针后移\n\t// \tp=p->next;\n\t// }\n}\n\nint main(int argc, char const *argv[])\n{\n\n\tNode* createList(int n);\n\tNode* createNode();\n\n\tNode *head=createList(3);\n\tprintf(\"遍历链表、n\");\n\tprintlnAll(head);\n\t\n\tinsHead(head);\n\t//insAnywhere(head,0);\n\tprintf(\"在头插入节点后、n\");\n\tprintlnAll(head);\n\n\tinsTail(head);    //下面的也可以但是效率比较低\n\t//insAnywhere(head,getLength());\n\tprintf(\"在尾插入节点后、n\");\n\tprintlnAll(head);\n\n\t//在第一个元素后面插入元素\n\tprintf(\"---------在第一个元素后面插入元素-----\\n\");\n\tinsAnywhere(head,1);\n\tprintlnAll(head);\n\n\t//删除最后面的节点\n\tprintf(\"---------删除最后面的节点-------\\n\");\n\tdelNode(head,6);\n\tprintlnAll(head);\n\n\t//删除第一个后面的节点\n\tprintf(\"-------删除第一个后面的节点---------\\n\");\n\tdelNode(head,2);\n\t//printf(\"%d\\n\", head->next->data);\n\tprintlnAll(head);\n\treturn 0;\n}\n```\n- 线性表\n![image](http://p0.cdn.img9.top/ipfs/QmUS62kkfTx4trGRmMukDCFuJNxrKDR2P2DdoERRqf1pcr?0.png)\n这里面的链式存储结构里面的 *静态链表* 挺有意思的，不用指针实现链式结构。\n线性表的这两种结构实际上是后面其他数据结构的基础，顺序储存结构和链式储存结构也各有优劣。\n![image](http://p1.cdn.img9.top/ipfs/QmUWbnXLv86uwuCrWkp2ft6fax7TgZ1kryaCPKrWTGidsy?1.PNG)\n\n注：代码中的 String 是我自定义的。\n\n```java\ntypedef struct{\n\t//长度\n\tint length;\n\t//内容\n\tchar *str;\n\t//最大值\n\tint maxLength;\n}String;\n\nvoid init(String *s,int max,char * string){\n\tint i;\n\ts->maxLength=max;\n\ts->length=strlen(string);\n\t//开辟空间\n\ts->str=(char*)malloc(sizeof(char)*max);\n\t//赋值\n\tfor(i=0;i<s->length;i++){\n\t\ts->str[i]=string[i];\n\t}\n}\n\n```\n","tags":["算法","数据结构"],"categories":["算法"]},{"title":"Hexo 添加其他的评论系统","url":"/2018/07/01/bbbb4402/","content":"\n## 最近换了一个 Hexo 的主题，也就是现在的这款，但是支持的评论系统两个已经关了，还有一个会被墙。所以就自己来加了一个\n\n### 首先注册并登录 LiveRe\n登陆注册过程就不多说了\n   选择 city 版的安装，会得到一段代码 \n### 在个人博客中加入 LiveRe 代码\n\n首先去如路径：hexo_bolg/themes/your-theme/layout/_partial/post 下创建 livere.ejs 代码。livere.ejs 的内容就是上一步中获取的代码：\n\n```\n<!-- 来必力 City 版安装代码 -->\n<div id=\"lv-container\" data-id=\"city\" data-uid=\"MTAyMC8zMzM5MC85OTQ2\">\n    <script type=\"text/javascript\">\n   (function(d, s) {\n       var j, e = d.getElementsByTagName(s)[0];\n\n       if (typeof LivereTower === 'function') { return; }\n\n       j = d.createElement(s);\n       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';\n       j.async = true;\n\n       e.parentNode.insertBefore(j, e);\n   })(document, 'script');\n    </script>\n<noscript> 为正常使用来必力评论功能请激活 JavaScript</noscript>\n</div>\n<!-- City 版安装代码已完成 -->\n```\n\n然后修改路径：hexo_bolg/themes/your-theme/layout/_partial 下的 article.ejs 文件，在`<% if (!index && post.comments){ %>` 代码块下添加如下代码：\n\n```\n<% if (!index){ %>\n  <% if (post.comments){ %>\n  <%- partial('post/livere') %>\n  <% } else { %>\n    <div class=\"lv-container\"></div>\n  <% } %>\n<% } %>\n```\n![](http://p0.cdn.img9.top/ipfs/QmWwSjQj5zqz5mAgEtYjgTBRXRqBapvZMaEzArt8xRqQm2?0.jpg)\n\n~~此时 LiveRe 已经添加 OK 了，重新部署你的博客然后刷新页面就可以看到博客中添加好了 LiveRe 评论~~\n换了 Valine\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"Nmap 学习","url":"/2018/06/17/d5f81032/","content":"\n## Nmap 简介\n   Nmap 是一个开源免费的网络发现和安全审计工具 ， 全称是 NetWork  Mapper , 采用 c++语言编写。纯命令行界面，Nmap 官方提供了一个 Zenmap 的图形界面。\n\n- 关于端口\n\t·\t默认情况下，Namp 会扫描 1000 个最有可能开放的 TCP 端口\n·   open：开放\n·   closed：关闭\n·   filtered：被屏蔽\n·   unfiltered：没有屏蔽还需要确认\n·   open | filtered : 开放或者屏蔽\n·   close | filtered : 关闭或屏蔽\n# 使用\n - 主机扫描\n 1. nmap  192.168.1.100 直接扫描，会扫描常用前 1000 个端口 扫描我的宿主机\n2. nmap -F 192.168.1.100  快速扫描，会扫描常用的前 100 个端口\n3. -v  显示扫描过程\nroot@kali:~# nmap -v -F  192.168.1.100\nStarting Nmap 7.70 ( https://nmap.org ) at 2018-06-17 00:55 EDT\nInitiating Ping Scan at 00:55\nScanning 192.168.1.100 [4 ports]\nCompleted Ping Scan at 00:55, 0.05s elapsed (1 total hosts)\nInitiating Parallel DNS resolution of 1 host. at 00:55\nCompleted Parallel DNS resolution of 1 host. at 00:55, 0.01s elapsed\nInitiating SYN Stealth Scan at 00:55\nScanning 192.168.1.100 [100 ports]\nDiscovered open port 135/tcp on 192.168.1.100\nDiscovered open port 139/tcp on 192.168.1.100\nDiscovered open port 445/tcp on 192.168.1.100\nDiscovered open port 3306/tcp on 192.168.1.100\nDiscovered open port 443/tcp on 192.168.1.100\nIncreasing send delay for 192.168.1.100 from 0 to 5 due to 43 out of 142 dropped probes since last increase.\nCompleted SYN Stealth Scan at 00:55, 7.68s elapsed (100 total ports)\nNmap scan report for 192.168.1.100\nHost is up (1.8s latency).\nNot shown: 94 closed ports\nPORT     STATE    SERVICE\n135/tcp  open     msrpc\n139/tcp  open     netbios-ssn\n443/tcp  open     https\n445/tcp  open     microsoft-ds\n514/tcp  filtered shell\n3306/tcp open     mysql\nRead data files from: /usr/bin/../share/nmap\nNmap done: 1 IP address (1 host up) scanned in 7.88 seconds\nRaw packets sent: 166 (7.280KB) | Rcvd: 163 (6.688KB)\n4. -sV  返回端口对应的服务信息（好慢）\n5. -O  返回对应服务的系统信息\n- 主机发现\n\t我们可以通过 namp 来嗅探整个局域网，扫描出局域网中在线的主机，通过 ICMP ECHO 扫描出在线的主机 （ping 的底层原理） \n  1. nmap -sS 192.168.1.100 隐蔽扫描 -sS ，也就是 SYN 扫描，只管发送数据包\n  2. 查看存活主机\nnmap -sP 192.168.239.* 或者 192.168.239.0/24\n  3. 扫描主机的所有端口\nnmap -p 1-65535 192.168.239.133\n  4. 扫描主机的操作系统\nnmap -O 192.168.239.133\n  5. 查看主机个服务的版本详细信息\nnmap -sV 192.168.239.133\n- 常见的 Nmap 扫描类型参数\n -sT :TCP connect 扫描 ，类似 Metasploit 中的 tcp 扫描\n -sS : TCP SYN 扫描，类似于 Metasploit 中的 syn 扫描模块\n -sF/-sX/-sN : 这些扫描通过发送一些特殊的标志位以避开设备或软件的监测\n -sP : 通过发送 ICMP echo 请求探测主机是否存货原理同 Ping.\n -sU : 探测主机开放了那些 UDP 端口。\n -sA : TCP ACK 扫描，类似与 Metasploit 里的 ack 扫描模块\n - 常见的 Nmap 扫描选项\n-Pn : 在扫描之前不发送 ICMP echo 请求测试目标是否活跃\n-O ：启用对于 TCP/IP 协议栈的特征扫描以获取远程主机的操作系统\n-F ：快速扫描\n-p ：端口范围\n","tags":["Kali","Nmap"],"categories":["渗透"]},{"title":"Redis 集群搭建","url":"/2018/05/27/3e4345d9/","content":"# Redis 集群搭建\n# 一、Redis 简介\n\n### 1．关于关系型数据库和 nosql 数据库\n   关系型数据库是基于关系表的数据库，最终会将数据持久化到 [磁盘]() 上，而 nosql 数据  库是基于特殊的结构，并将数据存储到 [内存]() 的数据库。从性能上而言，nosql 数据库  要优于关系型数据库，从安全性上而言关系型数据库要优于 nosql 数据库，所以在实  际开发中一个项目中 nosql 和关系型数据库会一起使用，达到性能和安全性的双保证\n### 2 . Redis 的安装\n这里关于 Redis 的安装不想多说，实际生产中都是将 Reids 安装在 Linux 上的，这里主要是说集群的搭建。\n### 3. Redis 的使用\n   我也是第一次接触 Redis，使用其实也没什么说的 [菜鸟教程](http://www.runoob.com/redis/redis-tutorial.html) 上都有，挺简单的。\n### 3. 集群的搭建\nRedis 要做集群必须要有至少三个节点否则他的投票机制无法运行\n必须要有超过半数的节点都认为某一台 Redis 机器挂掉了才会认为集群挂掉了\n![Redis](http://p3.cdn.img9.top/ipfs/QmX5E7BViadysS6bZLs7Eeu1VSkvCHEEcUrkSVgWBjwNCx?3.png)\n\n这里再看看 Redis 集群的架构图！[Redis](http://p3.cdn.img9.top/ipfs/QmZ6PpYPozPHppvXGRBMY5LgnrsjAqDaT2s1NoUCT8EFuD?3.png)\n架构细节：\n\n(1) 所有的 redis 节点彼此互联 (PING-PONG 机制）, 内部使用二进制协议优化传输速度和带宽。\n\n(2) 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。\n\n(3) 客户端与 redis 节点直连，不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可\n\n(4)redis-cluster 把所有的物理节点映射到 [0-16383]slot 上，cluster 负责维护 node<->slot<->value\nRedis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点，所以 Redis 节点最多也就 16384 个节点最少 3 个节点。\n- 开始搭建\n 这里搭建的是有 3 个节点的最小的集群为保证集群的高可用每个节点都有一台备份机一共需要 6 台服务器，就需要开 6 个虚拟机这里其实做测试没那个必要，搭建一个伪分布式的就可以了，在一台虚拟机上搭建 6 个 Redis 实例\n- 集群搭建环境\n1、使用 ruby 脚本搭建集群。需要 ruby 的运行环境。\n安装 ruby\nyum install ruby\nyum install rubygems\n（我虚拟机 yum 的时候一直报错无法解析，然后加了 DNS 后报 404 很奇怪 然后 yum makecache 后就好了）\n2、安装 ruby 脚本运行使用的包 [redis-3.0.0.gem](https://pan.baidu.com/s/1bW6EUyeEevR5h1cT-g51mQ)。\n gem install redis-3.0.0.gem\n这个脚本在你 Redis 源代码的 src 目录下 redis-trib.rb 这个脚本\n 3、创建 6 个 Redis 实例\n直接 copy5 份编译后的 Redis 文件然后改下端口 把 redis.conf（在 Redis 源代码下 copy 过来）里 cluster-enabled yes 前注释去掉\n 3 、启动 6 个 Redis 这里可以写一个 shell\n```java\ncd redis01\n./redis-server redis.conf\ncd ..\ncd redis02\n./redis-server redis.conf\ncd ..\ncd redis03\n./redis-server redis.conf\ncd ..\ncd redis04\n./redis-server redis.conf\ncd ..\ncd redis05\n./redis-server redis.conf\ncd ..\ncd redis06\n./redis-server redis.conf\ncd ..\n```\n4、用 Ruby 搭建集群 只需要这条命令集群就搭建完毕了\n./redis-trib.rb create --replicas 1 192.168.25.3:7001 192.168.25.3:7002 192.168.25.3:7003 192.168.25.3:7004 192.168.25.3:7005 192.168.25.3:7006\n补 ：这里的 ip 不要写 127.0.0.1 不然连接集群的时候就会报 Too many Cluster redirections? 错误 亲测。我不是写的 127.0.0.1 我是因为后来虚拟机 ip 变了然后\nreplicas 后面参数 1 代表每个节点会有一台备份机所以后面的 ip 和端口号必须是偶数\n### 4. 集群的使用\n    redis01/redis-cli -p 7002 -c \n后面的 c 代表连接的是集群 如果不加 c 就是单机的 如果存入数据的槽位不对应就会报错当然这是在命令行下的使用，windows 下也有一些 Redis 的客户端。这里主要讲用 Java 代码连接 Redis 这就要用到 Jedis 了跟 JDBC 那一套差不多 这里直接讲在淘淘中实际是怎么用的吧\n这里有两个版本集群版和单机版 平常测试就用单机版所以可以先写一个接口，抽取一些常用的方法\n\n```java\npackage redis;\npublic interface JedisClient {\n\n\tString set(String key, String value);\n\tString get(String key);\n\tBoolean exists(String key);\n\tLong expire(String key, int seconds);\n\tLong ttl(String key);\n\tLong incr(String key);\n\tLong hset(String key, String field, String value);\n\tString hget(String key, String field);\n\tLong hdel(String key, String... field);\n}\n\n```\n然后写各自的实现类\n- 单机版\n\n```java\npackage redis;\nimport lombok.Getter;\nimport lombok.Setter;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\n@Getter@Setter\npublic class JedisClientPool implements JedisClient {\n\t\n\tprivate JedisPool jedisPool;\n\n\t@Override\n\tpublic String set(String key, String value) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tString result = jedis.set(key, value);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String get(String key) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tString result = jedis.get(key);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Boolean exists(String key) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tBoolean result = jedis.exists(key);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long expire(String key, int seconds) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.expire(key, seconds);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long ttl(String key) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.ttl(key);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long incr(String key) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.incr(key);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long hset(String key, String field, String value) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.hset(key, field, value);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String hget(String key, String field) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tString result = jedis.hget(key, field);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long hdel(String key, String... field) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.hdel(key, field);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n}\n\n```\n- 集群版\n\n```java\npackage redis;\nimport lombok.Getter;\nimport lombok.Setter;\nimport redis.clients.jedis.JedisCluster;\n\n@Getter@Setter\npublic class JedisClientCluster implements JedisClient {\n\t\n\tprivate JedisCluster jedisCluster;\n\n\t@Override\n\tpublic String set(String key, String value) {\n\t\treturn jedisCluster.set(key, value);\n\t}\n\n\t@Override\n\tpublic String get(String key) {\n\t\treturn jedisCluster.get(key);\n\t}\n\n\t@Override\n\tpublic Boolean exists(String key) {\n\t\treturn jedisCluster.exists(key);\n\t}\n\n\t@Override\n\tpublic Long expire(String key, int seconds) {\n\t\treturn jedisCluster.expire(key, seconds);\n\t}\n\n\t@Override\n\tpublic Long ttl(String key) {\n\t\treturn jedisCluster.ttl(key);\n\t}\n\n\t@Override\n\tpublic Long incr(String key) {\n\t\treturn jedisCluster.incr(key);\n\t}\n\n\t@Override\n\tpublic Long hset(String key, String field, String value) {\n\t\treturn jedisCluster.hset(key, field, value);\n\t}\n\n\t@Override\n\tpublic String hget(String key, String field) {\n\t\treturn jedisCluster.hget(key, field);\n\t}\n\n\t@Override\n\tpublic Long hdel(String key, String... field) {\n\t\treturn jedisCluster.hdel(key, field);\n\t}\n\n}\n\n```\n- 使用\n   使用的时候就可以写个 bean 然后在需要的时候就可以直接注入了\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:aop=\"http://www.springframework.org/schema/aop\"\n\txmlns:tx=\"http://www.springframework.org/schema/tx\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:mybatis-spring=\"http://mybatis.org/schema/mybatis-spring\"\n\txsi:schemaLocation=\"http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\n\t\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd\n\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd\">\n\t<!--单机版-->\n    <!-- \t<bean id=\"jedisClientPool\" class=\"redis.JedisClientPool\">\n\t\t<property name=\"jedisPool\" ref=\"jedisPool\" />\n\t</bean>\n\t<bean id=\"jedisPool\" class=\"redis.clients.jedis.JedisPool\">\n\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t<constructor-arg name=\"port\" value=\"6379\"/>\n\t</bean> -->\n\t<!--集群版-->\n\t<bean id=\"jedisClientCluster\" class=\"redis.JedisClientCluster\">\n\t\t<property name=\"jedisCluster\" ref=\"jedisCluster\"/>\t\t\n\t</bean>\n\t\n\t<bean id=\"jedisCluster\" class=\"redis.clients.jedis.JedisCluster\">\n\t\t<constructor-arg name=\"nodes\">\n\t\t\t<set>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7001\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7002\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7003\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7004\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7005\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7006\"/>\n\t\t\t\t</bean>\n\t\t\t</set>\n\t\t</constructor-arg>\t\t\t\n\t</bean>\n</beans>\n```\n这里在集群的时候遇到了问题就是我上面提到的 ip 的问题不要写 127.0.0.1 要写实际的内网 ip 以后如果 ip 变了就只能重新来一次了，那个命令我试了下执行第二次，报错说我那个节点不为空，**也许**把数据清空了就可以了。\n- 测试\n```java\n\t@Test\n\tpublic void testRedis() {\n\t\t//初始化 Spring 容器\n\t\tApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext-redis.xml\");\n\t\t//从容器中获取 jedisClient 对象 （单机版） \n\t\tJedisClient jedisClient=applicationContext.getBean(JedisClient.class);\n\t\tjedisClient.set(\"testRedis\", \"Hello World\");\n\t\tSystem.out.println(jedisClient.get(\"testRedis\"));\n\t}\n```\n","tags":["淘淘商城","Redis","集群搭建"],"categories":["Web"]},{"title":"Mybatis 逆向工程对 text 的特殊处理","url":"/2018/05/23/d2be9bab/","content":"# Mybatis 对 Mysql 中 text 类型的特殊处理\n- 昨天晚上在做 cms 的 crud 的时候遇到的问题，编辑的时候不回显内容，然后 f12 看了下响应的 json 里面 content 也为 null，然后去 service 里面把那个 pojo 加了 toString 把几条数据直接打印出来 因为用了分页然后打印出来的也并不是数据\n\n（下次再来探究分页插件） 然后注释掉在打印发现还是没有然后我试了下单独查询，根据主键查询查出来的居然用有！！！这就很奇怪了。我当时就以为是 byexample 的 mapper 有问题 哈哈哈~~ 其实还是自己框架学的不好的问题\n\n```java\npublic EasyUIJsonResult listContent(long categoryId,int page,int rows) {\n\t\tEasyUIJsonResult result=new EasyUIJsonResult();\n\t\t\n\t\t//测试过程中发现 PageHelper 的一些问题 等下再来研究\n\t\t//PageHelper.startPage(page, rows);\n\t\tTbContentExample example =new TbContentExample();\n\t\texample.createCriteria().andCategoryIdEqualTo(categoryId);\n\t\tList<TbContent> contents = dao.selectByExample(example);\n\t\tPageInfo<TbContent> info=new PageInfo<>(contents);\n\t\n\t\t//加上 PageHelper 后这里打印出来的就不是 contents 对象了就是 Page 对象\n\t\t//而且查出来的数据里面 content 为 null （数据库中有 猜想可能是逆向工程有问题）;\n\t\tSystem.out.println(contents);\n\t\t\n\t\t//测试下单独查询 主键查询没问题 取的到 content\n\t\tSystem.out.println(dao.selectByPrimaryKey((long)42));\n\t\t\n\t\t//单独测试下只查一个    也没有\n\t\tTbContentExample example2 =new TbContentExample();\n\t\tCriteria criteria2 = example2.createCriteria();\n\t\tcriteria2.andCategoryIdEqualTo((long)90);\n\t\tSystem.out.println(dao.selectByExample(example2 ));\n\t\t\n\t\tresult.setTotal(info.getTotal());\n\t\tresult.setRows(contents);\n\t\treturn result;\n\t}\n```\n- 然后就面向百度了一波，还真就查到了遇到跟我一样的问题 [同道中人](https://ask.csdn.net/questions/205320)\nselectByExampleWithBLOBs 用这个方法就可以了 看名字就知道更这个有关哈哈哈\n然后就愉快的解决了！[image](http://p1.cdn.img9.top/ipfs/QmVhiMUQoFbiHc8BJxFtSzCUxVrZffnj9vYD7yM5YmCjGL?1.png)\n- 不仅仅是 select update 也有这个方法\n```java\npublic interface TbContentMapper {\n    int countByExample(TbContentExample example);\n\n    int deleteByExample(TbContentExample example);\n\n    int deleteByPrimaryKey(Long id);\n\n    int insert(TbContent record);\n\n    int insertSelective(TbContent record);\n\n    List<TbContent> selectByExampleWithBLOBs(TbContentExample example);\n\n    List<TbContent> selectByExample(TbContentExample example);\n\n    TbContent selectByPrimaryKey(Long id);\n\n    int updateByExampleSelective(@Param(\"record\") TbContent record, @Param(\"example\") TbContentExample example);\n\n    int updateByExampleWithBLOBs(@Param(\"record\") TbContent record, @Param(\"example\") TbContentExample example);\n\n    int updateByExample(@Param(\"record\") TbContent record, @Param(\"example\") TbContentExample example);\n\n    int updateByPrimaryKeySelective(TbContent record);\n\n    int updateByPrimaryKeyWithBLOBs(TbContent record);\n\n    int updateByPrimaryKey(TbContent record);\n}\n```\n","tags":["技术","框架"],"categories":["Web"]},{"title":"SpringMVC - 处理静态资源 （转）","url":"/2018/05/21/eb5cc3c6/","content":"## **【1】第一种示例与解决办法**\n\n将 DispatcherServlet 请求映射设置为 / ，将会拦截所有的请求。不能访问静态资源。\n\n**解决办法：**\n\n在 SpringMVC 的配置文件中配置如下标签解决\n\n```java\n<mvc:default-servlet-handler/>\n```\n\n其 XSD 文档说明如下：\n\n```java\n/*配置一个 handler 通过转发请求到 servlet 容器的默认 servlet 来处理静态资源*/\nConfigures a handler for serving static resources by forwarding to the Servlet container's default Servlet.\n\n/*使用该 handler 将会允许 DispatcherServlet 的 url-pattern 为'/'; 同时使用 servlet 容器的默认 servlet 处理静态资源*/\nUse of this handler allows using a \"/\" mapping with the DispatcherServlet \nwhile still utilizing the Servlet container to serve static resources. \n\n/*该 handler 将会转发所有请求到默认 servlet*/\nThis handler will forward all requests to the default Servlet. \n\n/*因此将该 handler 的执行顺序放到所有请求处理的最后是非常重要的！！！*/\nTherefore it is important that it remains last in the order of all other URL HandlerMappings. \n\n/*使用<mvc:annotation-driven/>标签或者设置 HandlerMapping instance 的 order 来确保 DefaultServletHttpRequestHandler 的 order 最大。*/\nThat will be the case if you use the \"annotation-driven\" element \nor alternatively if you are setting up your customized HandlerMapping instance \nbe sure to set its \"order\" property to a value lower than \nthat of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE.\n```\n\n![image](https://img-blog.csdn.net/20170914152551033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**解释如下：**\n\n`<mvc:default-servlet-handler/>`将在 SpringMVC 的上下文中定义一个 DefaultServletHttpRequestHandler 来处理静态资源（其实就是将请求转发给默认的 servlet)。\n\n一般 WEB 服务器默认的 servlet 的名称为 default。若所使用的 WEB 服务器默认的 Servlet 名称不是 default，则需要通过 default-servlet-name 属性指定！\n\n![image](https://img-blog.csdn.net/20170224143539025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n* * *\n\n**不同服务器下默认 servlet 名字对应如下：**\n\n```java\nTomcat, Jetty, JBoss, and GlassFish  默认 Servlet 的名字 -- \"default\"\nGoogle App Engine 默认 Servlet 的名字 -- \"_ah_default\"\nResin 默认 Servlet 的名字 -- \"resin-file\"\nWebLogic 默认 Servlet 的名字  -- \"FileServlet\"\nWebSphere  默认 Servlet 的名字 -- \"SimpleFileServlet\"\n```\n\n![这里写图片描述](https://img-blog.csdn.net/20170914154653746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n* * *\n\n**【Tips：】**\n\n使用上述配置，你会发现正常的 Controller 跳转失效了！\n\nXSD 说明最后一段话如下：\n\n```java\n/*使用<mvc:annotation-driven/>标签或者设置 HandlerMapping instance 的 order 来确保 DefaultServletHttpRequestHandler 的 order 最大。*/\nThat will be the case if you use the \"annotation-driven\" element \nor alternatively if you are setting up your customized HandlerMapping instance \nbe sure to set its \"order\" property to a value lower than \nthat of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE.\n```\n\n也就是说，要么配置`<mvc:annotation-driven />`标签，要么手动注册请求映射处理 bean 于 xml 中，并设置 order 属性值，以其实现框架中处理请求映射的 bean 的 order 值小于 DefaultServletHttpRequestHandler 的 order 属性值！！！\n\n常用的解决方式为配置`<mvc:annotation-driven />`标签，详情点击查看 [请求映射失效](http://blog.csdn.net/j080624/article/details/66969987)。\n\n点击查看 [controller 映射失效](http://blog.csdn.net/J080624/article/details/66969987)\n\n* * *\n\n## **【2】第二种示例与解决办法**\n\n解决静态资源的思路是，在 SpringMVC.xml 中，拦截设置为”*.do”，而不是”/”。\n\n这样就不会拦截静态资源的请求。\n\n需要注意的是，如果项目中用到了 shiro 或者其他权限框架。那么需要注意你的 shiro.xml 配置，示例如下：\n\n```java\n  <bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n        <!-- Shiro 的核心安全接口，这个属性是必须的 -->\n        <property name=\"securityManager\" ref=\"securityManager\"/>\n        <!-- loginUrl 认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由 formAuthenticationFilter 进行表单认证 -->\n        <property name=\"loginUrl\" value=\"/login\"/>\n\n        <!-- Shiro 连接约束配置，即过滤链的定义 -->\n        <property name=\"filterChainDefinitions\">\n            <value>\n                <!-- /** = anon 所有 url 都可以匿名访问 -->\n                <!-- 对静态资源设置匿名访问 -->\n                /images/** = anon\n                /js/** = anon\n                /styles/** = anon\n                <!-- 验证码，可匿名访问 -->\n                /validateCode = anon  <!--验证码-->\n                /doLogin = anon\n\n                <!-- /** = authc 所有 url 都必须认证通过才可以访问 -->\n                /**=authc\n                <!--请求 logout，shrio 擦除 sssion-->\n                /logout=logout\n            </value>\n        </property>\n    </bean>\n```\n\n需要注意的是虽然 SpringMVC 拦截的是。do，但是由于使用了 shiro（或者你的其他权限框架），那么未登录情况下是不能直接访问除 shiro 配置文件里面允许匿名访问的路径之外的静态资源文件。\n\n举个例子，你把静态资源文件放在了项目根目录，但是参考上面配置文件，显然不在匿名访问路径列表之内，所以会提示你先登录，登录之后才可访问项目根目录的静态资源文件。\n\n*   未登录前访问项目根目录下 1.jpg , 跳到登录页面：\n\n![image](https://img-blog.csdn.net/20170518094647021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n*   登录后访问项目根目录下 1.jpg :\n\n![image](https://img-blog.csdn.net/20170518094717006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n另外，建议最好参考 shiro 配置文件，比如 1.jpg 放到 images 文件夹下，那么不用登录就可以直接访问。\n\n![image](https://img-blog.csdn.net/20170518094833869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n* * *\n\n## **【3】第三种示例与解决办法**\n\n**通过配置，避免静态资源被拦截，示例如下：**\n\n```java\n <!-- 静态资源访问（不拦截此目录下的东西的访问） -->\n    <mvc:resources location=\"/js/\" mapping=\"/js/**\"/>\n    <mvc:resources location=\"/css/\" mapping=\"/css/**\"/>\n    <mvc:resources location=\"/images/\" mapping=\"/images/**\"/>\n    <mvc:resources location=\"/bootstrap/\" mapping=\"/bootstrap/**\"/>\n```\n\n该标签的 xsd 说明文档如下：\n\n```\n/*配置 handler 为静态资源，如 images，js 和 CSS 文件并进行缓存头优化，以便在 Web 浏览器中高效加载。*/\nConfigures a handler for serving static resources such as \nimages, js, and, css files with cache headers optimized for efficient loading in a web browser. \n/*允许为任何可以通过 spring 处理的路径资源提供服务*/\nAllows resources to be served out of any path that is reachable via Spring's Resource handling.\n```\n\n注册的 handler 如下：\n\n```java\norg.springframework.web.servlet.resource.ResourceHttpRequestHandler\n```\n\n**即，该标签注册 ResourceHttpRequestHandler 为静态资源的访问提供服务。**\n\n该 handler 的 javadoc 如下所示：\n\n```java\n{@code HttpRequestHandler} that serves static resources in an optimized way according to the guidelines of Page Speed, YSlow, etc.\n\n * <p>The {@linkplain #setLocations \"locations\"} property takes a list of Spring\n * {@link Resource} locations from which static resources are allowed to\n * be served by this handler. Resources could be served from a classpath location,\n * e.g. \"classpath:/META-INF/public-web-resources/\", allowing convenient packaging\n * and serving of resources such as .js, .css, and others in jar files.\n```\n\n* * *\n\n## **【4】第四种示例与解决办法**\n\n确切说这里只解决不通过 controller 而直接访问 jsp 的问题。\n\n`<mvc:view-controller/>`直接访问 view-name 对应的 jsp\n\n*   jsp 路径依据视图解析器配置。\n\n```java\n    <!-- mvc:view-controller 可使其直接访问路径 -->  \n    <mvc:view-controller path=\"/i18n\" view-name=\"i18n\"/>\n\n    <mvc:view-controller path=\"/i18n2\" view-name=\"i18n2\"/>\n```\n","tags":["技术","Spring","转载"],"categories":["Web"]},{"title":"Spring 请求参数获取的几种方式（转）","url":"/2018/05/17/81b3fc53/","content":"# [springmvc 请求参数获取的几种方法](http://www.cnblogs.com/xiaoxi/p/5695783.html)\n**1、直接把表单的参数写在 Controller 相应的方法的形参中，适用于 get 方式提交，不适用于 post 方式提交。**\n\n```java \n    /** * 1. 直接把表单的参数写在 Controller 相应的方法的形参中\n      * @param username\n     * @param password\n     * @return\n     */ @RequestMapping(\"/addUser1\") public String addUser1(String username,String password) {\n        System.out.println(\"username is:\"+username);\n        System.out.println(\"password is:\"+password); return \"demo/index\";\n    }\n```\nurl 形式：[http://localhost/SSMDemo/demo/addUser1?username=lixiaoxi&password=111111](http://localhost/SSMDemo/demo/addUser1?username=lixiaoxi&password=111111) 提交的参数需要和 Controller 方法中的入参名称一致。\n\n**2、通过 HttpServletRequest 接收，post 方式和 get 方式都可以。**\n\n```java\n   /** 2、通过 HttpServletRequest 接收\n    * @param request\n     * @return\n     */ @RequestMapping(\"/addUser2\") public String addUser2(HttpServletRequest request) {\n        String username=request.getParameter(\"username\");\n        String password=request.getParameter(\"password\");\n        System.out.println(\"username is:\"+username);\n        System.out.println(\"password is:\"+password); return \"demo/index\";\n    }\n```\n\n**3、通过一个 bean 来接收，post 方式和 get 方式都可以。**\n(1) 建立一个和表单中参数对应的 bean\n\n```java\npackage demo.model; public class UserModel { private String username; private String password; public String getUsername() { return username;\n    } public void setUsername(String username) { this.username = username;\n    } public String getPassword() { return password;\n    } public void setPassword(String password) { this.password = password;\n    }\n\n}\n```\n\n(2) 用这个 bean 来封装接收的参数\n\n```java\n /** * 3、通过一个 bean 来接收\n      * @param user\n     * @return\n     */ @RequestMapping(\"/addUser3\") public String addUser3(UserModel user) {\n        System.out.println(\"username is:\"+user.getUsername());\n        System.out.println(\"password is:\"+user.getPassword()); return \"demo/index\";\n    }\n```\n**4、通过@PathVariable 获取路径中的参数**\n\n```java\n/*** 4、通过@PathVariable 获取路径中的参数\n      * @param username\n     * @param password\n     * @return\n     */ @RequestMapping(value=\"/addUser4/{username}/{password}\",method=RequestMethod.GET) public String addUser4(@PathVariable String username,@PathVariable String password) {\n        System.out.println(\"username is:\"+username);\n        System.out.println(\"password is:\"+password); return \"demo/index\";\n    }\n```\n例如，访问 [http://localhost/SSMDemo/demo/addUser4/lixiaoxi/111111](http://localhost/SSMDemo/demo/addUser4/lixiaoxi/111111) 路径时，则自动将 URL 中模板变量{username}和{password}绑定到通过@PathVariable 注解的同名参数上，即入参后 username=lixiaoxi、password=111111。\n**5、使用@ModelAttribute 注解获取 POST 请求的 FORM 表单数据**\nJsp 表单如下：\n```java\n<form action =\"<%=request.getContextPath()%>/demo/addUser5\" method=\"post\"> 用户名：&nbsp;<input type=\"text\" name=\"username\"/><br/> 密&nbsp;&nbsp; 码：&nbsp;<input type=\"password\" name=\"password\"/><br/>\n     <input type=\"submit\" value=\"提交\"/> \n     <input type=\"reset\" value=\"重置\"/> \n</form> \n```\nJava Controller 如下：\n\n```java \n/** * 5、使用@ModelAttribute 注解获取 POST 请求的 FORM 表单数据\n     * @param user\n     * @return\n     */ @RequestMapping(value=\"/addUser5\",method=RequestMethod.POST) public String addUser5(@ModelAttribute(\"user\") UserModel user) {\n        System.out.println(\"username is:\"+user.getUsername());\n        System.out.println(\"password is:\"+user.getPassword()); return \"demo/index\";\n    } \n```\n\n \n\n**6、用注解@RequestParam 绑定请求参数到方法入参**\n当请求参数 username 不存在时会有异常发生，可以通过设置属性 required=false 解决，例如：@RequestParam(value=\"username\", required=false)\n\n```java \n/** * 6、用注解@RequestParam 绑定请求参数到方法入参\n      * @param username\n     * @param password\n     * @return\n     */ @RequestMapping(value=\"/addUser6\",method=RequestMethod.GET) public String addUser6(@RequestParam(\"username\") String username,@RequestParam(\"password\") String password) {\n        System.out.println(\"username is:\"+username);\n        System.out.println(\"password is:\"+password); return \"demo/index\";\n    }\n```","tags":["Spring","转载"],"categories":["Web"]},{"title":"FastDFS 学习","url":"/2018/05/16/ac3c0a62/","content":"# FastDFS 学习笔记\n- FastDFS 简介\n\tFastDFS 服务端有两个角色：跟踪器（tracker）和存储 [节点](https://baike.baidu.com/item/%E8%8A%82%E7%82%B9)（storage）。跟踪器主要做调度工作，在访问上起负载均衡的作用。\n存储节点存储文件，完成文件管理的所有功能：就是这样的存储、同步和提供存取接口，FastDFS 同时对文件的 metadata 进行管理。所谓文件的 meta data 就是文件的相关属性，以键值对（key value）方式表示，如：width=1024，其中的 key 为 width，value 为 1024。文件 metadata 是 [文件属性](https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7) 列表，可以包含多个键值对。\n跟踪器和存储节点都可以由一台或多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。\n为了支持大容量，存储 [节点](https://baike.baidu.com/item/%E8%8A%82%E7%82%B9)（服务器）采用了分卷（或分组）的组织方式。[存储系统](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F) 由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台 [存储服务器](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8) 组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了 [冗余备份](https://baike.baidu.com/item/%E5%86%97%E4%BD%99%E5%A4%87%E4%BB%BD) 和负载均衡的作用。\n在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。\n当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了 [存储系统](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F) 的容量。\nFastDFS 中的文件标识分为两个部分：卷名和文件名，二者缺一不可。\n- 大胆分析\n这里在淘淘的后台上传图片的时候用到了，确实好用也是 c 语言开发的 搭配* Nginx *贼方便，确实佩服那些搞** C **的大佬，上面的说法不够直白文字总是苍白的 (￣▽￣)~*让我来强行解释一波！[image](http://p1.so.qhmsg.com/bdr/_240_/t0183119f547ca0bbc6.png)\n上面说到了** FastDFS **主要有两个节点\n 1. 储存节点 Storage  \n顾名思义就是用来储存文件的服务器这个图中的是比较复杂的情况这里有一个 stroage 群里又分了很多组每个组里又有很多服务器（这里的服务器里面储存的文件是一样的 会自动同步 方便加机器）\n  2. 监控节点 Tracker \n这个就跟 [zookeper](http://www.so.com/link?m=a0NGOfhwBC5nSFnUTBxpX2uhRysff5w5UsQFEqgCBRrJbwZpybFckcSRdwhuJdbgSApcIIqhL0gq5D6eIbBJ5pN22O2Z0k6ENTFGSjrRpsgETp2Dl) 作用有点像先上图\n![image](http://p0.cdn.img9.top/ipfs/QmZynH9DgJJbePkn35LjhRTc6xyyWL64jNT6QU6jyBnrXE?0.png\n)\n这个是上传的过程可以看到客户端要上传图片都是通过 Tracker 的而储存节点也会定时向 Tracker 发送状态的信息监控 Storage 的状态\n`可以看出上面 Client 在上传图片成功后 Storage 返回了一个 file_id 然后客户端就会储存这个 id 那客户端是如何通过这个 id 访问到这个图片的呢？ ---没错就是 Nginx 用 Nginx 来处理这些静态资源再好不过了`\n- 使用\n 说了这么多来实际用用看吧  \n   1. 首先我们要在虚拟机上安装 FastDFS 并配置 Nginx 这个过程比较复杂也不是我们重点关心的问题是运维应该关心的问题这里有一个搭建好的最简单的 [FastDFS 服务器](https://pan.baidu.com/s/1u5FLtQu71CueAJwq63ji6A) 开机就可以直接用服务都是开机自启动的  \n  2. 然后我们要有客户端这里 FastDFS 作者已经写好了 JAVA 的客户端我们直接拿来用就好了 [fastdfs_client 的 jar 包](https://pan.baidu.com/s/1KY5BKUr6f1PlCRR7hyhRSA)\n  3. 开始使用吧  \n\n``` java\n@Test\n\tpublic void testUpload() throws Exception {\n\n\t\t//1、加载配置文件，配置文件中的内容就是 tracker 服务的地址。\n\t\t//配置文件内容：tracker_server=192.168.25.133:22122\n\t\tClientGlobal.init(\"D:\\\\JavaDemo\\\\taoshop-web\\\\src\\\\main\\\\resources\\\\conf\\\\client.conf\");\n\t\t//2、创建一个 TrackerClient 对象。直接 new 一个。\n\t\tTrackerClient trackerClient =new TrackerClient();\n\t\t//3、使用 TrackerClient 对象创建连接，获得一个 TrackerServer 对象。\n\t\tTrackerServer trackerServer = trackerClient.getConnection();\n\t\t//4、创建一个 StorageServer 的引用，值为 null\n\t\tStorageServer storageServer =null;\n\t\t//5、创建一个 StorageClient 对象，需要两个参数 TrackerServer 对象、StorageServer 的引用\n\t\tStorageClient storageCilent =new StorageClient(trackerServer,storageServer);\n\t\t//6、使用 StorageCilent 上传文件\n\t\tString[] strings = storageCilent.upload_file(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\image\\\\222.jpg\",\"jpg\", null);\n\t\tfor (String string : strings) {\n\t\t\tSystem.out.println(string);\n\t\t}\n```\n这里最后也就是为了的到 StorageServer 对象 我们可以写个工具类方便我们上传，将得到的 file 信息直接放在虚拟机 ip/后面\n![image](http://p3.so.qhimgs1.com/bdr/_240_/t0151a407cda74a2153.png) 成功访问到了这张图片！还是很方便的。\n- 在淘淘商城中的运用\n   在淘淘中主要是用在后台的图片上传上的 这里用的是 ssm 的组合 SpringMVC 上传图片首先要有 commons.io 和 fileupload 的 jar 包还有配置多媒体解析器\n在这里我也遇到了一个小问题 他在这里用的是* KingEditor* 上传图片时要求返回的格式是\n```  java\n  //成功时\n  { \n        \"error\" : 0,\n        \"url\" : \"http://www.example.com/path/to/file.ext\"\n}\n//失败时\n{\n        \"error\" : 1,\n        \"message\" : \"错误信息\"\n}\n```\n我直接返回的一个 map 然后前台解析不出来出现了问题后来用 fastJson 把 map 转成 json 后就好了但是其实传还是传到了图片服务器上去了\n\n- 在做这个的时候还遇到了一些奇怪的问题就是如果修改代码后马上重新启动项目会报错 clean 一下就好了。","tags":["入门","FastDFS","淘淘商城"],"categories":["运维"]},{"title":"Nginx 学习","url":"/2018/05/13/dda0de9c/","content":"# Nginx 学习笔记\n- Nginx 简介\n  _Nginx_ (engine x) 是一个高性能的 [HTTP](https://baike.so.com/doc/5366073-5601774.html) 和 [反向代理](https://baike.so.com/doc/5345781-5581226.html) 服务器，也是一个 IMAP/POP3/SMTP[服务器](https://baike.so.com/doc/4487696-4696885.html)。Nginx 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点（俄文：Рамблер) 开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。\n其将源代码以类 BSD 许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011 年 6 月 1 日，nginx 1.0.4 发布。\nNginx 是一款 [轻量级](https://baike.so.com/doc/585215-619452.html) 的 [Web](https://baike.so.com/doc/4230501-4432285.html) 服务器/[反向代理](https://baike.so.com/doc/5345781-5581226.html) 服务器及 [电子邮件](https://baike.so.com/doc/928072-980969.html)(IMAP/POP3) 代理服务器，并在一个 BSD-like 协议下发行。其特点是占有内存少，[并发](https://baike.so.com/doc/6916691-7138566.html) 能力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx 网站用户有：百度、京东、[新浪](https://baike.so.com/doc/2204905-2333035.html)、网易、[腾讯](https://baike.so.com/doc/1038695-1098608.html)、淘宝等。\n\t\n- Nginx 主要作用\n1. (Http 服务器）处理静态文件\n![image](http://p0.cdn.img9.top/ipfs/QmdiKx1JUr7y9TabUQNNqu5dP8AwdsHSHe9QMwa487rsaS?0.png)\n像这样配置的话当访问 *localhost:80* 时就会访问到相对当前路径下的 html 文件夹下的 index.html 或者 index.htm\n2. 反向代理\n    **反向代理** 也是 nginx 用的最多的地方，既然有反向代理那就肯定有 **正向代理** 先来理解下正向代理！[image](https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/zhidao/pic/item/a2cc7cd98d1001e96d753f76b10e7bec54e79779.jpg)\n正向代理其实就是代理上网，**客户端**发送请求到代理服务器然后代理服务器转交请求给**目标服务器**目标服务器响应给代理服务器代理服务器再响应给**客户端**也就起到了代理的作用\n那反向代理是什么呢？\n![image](https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/zhidao/pic/item/a8014c086e061d95f3f21c4172f40ad162d9ca17.jpg)\n正向代理针对的是**客户端**而反向代理正对的是**服务端**\n当用户发送一个请求给 ServerB 然后 ServerB 判断用户是什么请求\n是请求 Server1 就转发给 Server1... 在生产中前端用一个 Nginx 处理用户的请求再分发到不同的后端服务器。\n**配置**\n```java\nupstream sina{\n\tserver 192.168.125.3:8080;\n    }\n    server {\n        listen       80;\n        server_name  www.sina.com.cn;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            proxy_pass   http://sina;\n            index  index.html index.htm;\n        }\n\n    }\n\n     upstream sohu{\n\tserver 192.168.125.3:8081;\n    }\n    server {\n        listen       80;\n        server_name  www.sohu.com;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n\t\t\t#交给谁代理\n            proxy_pass   http://sohu;\n            index  index.html index.htm;\n        }\n\n    }\n```\n\n像这样配置客户端访问通过一个公网 ip 入口先到达 Nginx 然后转发给对应的服务器当用户访问* www.sohu.com *时就会转发给 http://sohu 这个就是上面的 upstream sohu{...} 交给它处理\n3. 负载均衡和容错\n\t负载均衡就是在反向代理的中间加上的 就是在 upstream 里面加一个 server，最简单的负载均衡就是轮询一人一次刷新就换 (*默认的就是轮询*) 当然你也可以根据服务器性能配置权重权重越大访问到的机会越大\n\n```java\nupstream sina{\n\tserver 192.168.125.3:8080;\n\t#weigth 是权重\n\tserver 192.168.25.148:8082 weight=2;\n    }\n    server {\n        listen       80;\n        server_name  www.sina.com.cn;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            proxy_pass   http://sina;\n            index  index.html index.htm;\n         }\n       }\n```\n由于 Nginx 是我们网站的入口如果 Nginx 挂掉后面的服务就都失效了这时候就可以加备用 Nginx 服务器用 keepalive+Nginx 实现主备！[image](http://p0.cdn.img9.top/ipfs/Qmc3nC82Xsh1QANbUfAdDGUmTL2KJ2bQzoYzge7VHvRRWu?0.png)\n","tags":["Nginx"],"categories":["Web"]},{"title":"Hexo 第一篇博客","url":"/2018/05/10/80494c7d/","content":"第一篇 Hexo 博客\n=====\n- 才开始接触* markdown *不太熟悉，不过感觉还是很有意思的 😂  \n\n![image](http://p4.cdn.img9.top/ipfs/QmcPovxCWmXZdSB7GYz1RJUp1twhrnHEeZMDnidv4S5kvB?4.jpg\n)\n- 本来是想把这个博客放到我的阿里云上的，但是感觉日常写写博客也够了，移过去可以自己写写后台但感觉有点麻烦，等到以后有时间了再来折腾，日常用用这个静态的就够了 用了 cdn 加速访问速度还可以😉\n- 其实之前自己也自己做了一个博客 前台后台都是自己写的 前端不太熟悉用的 bs，后台是 ssm 的 本来想上线的 但是感觉太丑了了而且后台的代码也还有问题😂放张图对比下\n![image](http://p1.cdn.img9.top/ipfs/Qmc73XD1sHrvpEM2Wn8DMSXZcvRGjSW2x7GJPuzhjJa68c?1.jpg\n) 就这个画风 响应式也被我禁用了 实在是响应的太诡异了 再看看* material* \n `Hexo 的一款主题` \n![image](http://p1.cdn.img9.top/ipfs/QmcghHet9V1iE2CXxYnUh9VbwQq6STX3ZpsZqs6ruy657h?1.png)\n\n---\n ![mark](http://static.imlgw.top///20190127/0ddQkCXFDNyh.png?imageslim) 第 2 个主题\n\n---\n\n目前的是第三个\n\n- 认认真真的写博客了。","tags":["入门","Hexo","体验"],"categories":["Hexo"]}]