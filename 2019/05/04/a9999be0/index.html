<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="Tadow 的博客">
    <meta property="og:type" content="website">
    <meta name="description" content="Tadow 的博客">
    <meta name="keyword"  content="Tadow, Resolmi, imlgw, 半岛铁盒, 算法, Java, Golang">
    <link rel="shortcut icon" href="https://fav.farm/💭">

    <title>
        
        LeetCode 数组 - Tadow 碎碎念
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Tadow 碎碎念" type="application/atom+xml">
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Keep It Simple, Stupid </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar radius">
            <img src="https://static.imlgw.top/blog/20220821160037.png" />
        </div>
        <div class="name">
            <i>Tadow</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <!-- <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li> -->
            <li >
                <a href="/categories">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>分类</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            
            <li >
                <a href="/selfhosted">
                    <i class="iconfont icon-guidang1"></i>
                    <span>自建</span>
                </a>
            </li>

            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>收藏</span>
                </a>
            </li>

            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode-%E6%95%B0%E7%BB%84"><span class="toc-text">LeetCode 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">15. 三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">16. 最接近的三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">18. 四数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">26. 删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II"><span class="toc-text">80. 删除排序数组中的重复项 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-text">31. 下一个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#556-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-III"><span class="toc-text">556. 下一个更大元素 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-text">169. 多数元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#229-%E6%B1%82%E4%BC%97%E6%95%B0-II"><span class="toc-text">229. 求众数 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="toc-text">41. 缺失的第一个正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">442. 数组中重复的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">448. 找到所有数组中消失的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">125. 验证回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D"><span class="toc-text">345. 反转字符串中的元音字母</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">88. 合并两个有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#532-%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">532. 逆序对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">315. 计算右侧小于当前元素的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-text">118. 杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-II"><span class="toc-text">119. 杨辉三角 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-text">54. 螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II"><span class="toc-text">59. 螺旋矩阵 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-text">48. 旋转图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86"><span class="toc-text">498. 对角线遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1424-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86-II"><span class="toc-text">1424. 对角线遍历 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text">215. 数组中的第 K 个最大元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">347. 前 K 个高频元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">295. 数据流的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E5%8A%A0%E4%B8%80"><span class="toc-text">66. 加一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"><span class="toc-text">67. 二进制求和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-text">415. 字符串相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="toc-text">43. 字符串相乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi"><span class="toc-text">8. 字符串转换整数 (atoi)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="toc-text">1071. 字符串的最大公因子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84"><span class="toc-text">914. 卡牌分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">165. 比较版本号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-text">6. Z 字形变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">392. 判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">189. 旋转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF"><span class="toc-text">1232. 缀点成线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-text">1233. 删除子文件夹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">5. 最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#336-%E5%9B%9E%E6%96%87%E5%AF%B9"><span class="toc-text">336. 回文对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">409. 最长回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%85%A1"><span class="toc-text">680. 验证回文字符串 Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1332-%E5%88%A0%E9%99%A4%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">1332. 删除回文子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-text">435. 无重叠区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#263-%E4%B8%91%E6%95%B0"><span class="toc-text">263. 丑数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1333-%E9%A4%90%E5%8E%85%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">1333. 餐厅过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5313-%E6%97%B6%E9%92%9F%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%B9%E8%A7%92"><span class="toc-text">5313. 时钟指针的夹角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5169-%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E9%9A%94%E5%87%A0%E5%A4%A9"><span class="toc-text">5169. 日期之间隔几天</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-III"><span class="toc-text">557. 反转字符串中的单词 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-text">151. 翻转字符串里的单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-01-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9"><span class="toc-text">面试题 01.06. 字符串压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. 除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5341-%E6%9C%80%E5%90%8E-K-%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">5341. 最后 K 个数的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-64-%E6%B1%82-1-2-%E2%80%A6-n"><span class="toc-text">面试题 64. 求 1+2+…+n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#470-%E7%94%A8-Rand7-%E5%AE%9E%E7%8E%B0-Rand10"><span class="toc-text">470. 用 Rand7() 实现 Rand10()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#384-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84"><span class="toc-text">384. 打乱数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-text">面试题 61. 扑克牌中的顺子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1103-%E5%88%86%E7%B3%96%E6%9E%9C-II"><span class="toc-text">1103. 分糖果 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-text">1013. 将数组分成和相等的三个部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%EF%BC%88%E7%89%9B%E5%AE%A2%EF%BC%89"><span class="toc-text">调整数组顺序使奇数位于偶数前面（牛客）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0"><span class="toc-text">836. 矩形重叠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#892-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF"><span class="toc-text">892. 三维形体的表面积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF"><span class="toc-text">463. 岛屿的周长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#999-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F"><span class="toc-text">999. 车的可用捕获量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F"><span class="toc-text">289. 生命游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0"><span class="toc-text">204. 计数质数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#171-Excel-%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7"><span class="toc-text">171. Excel 表列序号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#168-Excel-%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0"><span class="toc-text">168. Excel 表列名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95"><span class="toc-text">724. 寻找数组的中心索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F"><span class="toc-text">945. 使数组唯一的最小增量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-text">面试题 05. 替换空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-text">面试题 45. 把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#179-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-text">179. 最大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#334-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">334. 递增的三元子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6"><span class="toc-text">172. 阶乘后的零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#793-%E9%98%B6%E4%B9%98%E5%87%BD%E6%95%B0%E5%90%8E-K-%E4%B8%AA%E9%9B%B6"><span class="toc-text">793. 阶乘函数后 K 个零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="toc-text">73. 矩阵置零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-16-11-%E8%B7%B3%E6%B0%B4%E6%9D%BF"><span class="toc-text">面试题 16.11. 跳水板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NC82-%E8%8B%B9%E6%9E%9C%E6%A0%91"><span class="toc-text">NC82. 苹果树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#453-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89"><span class="toc-text">453. 最小移动次数使数组元素相等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#696-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2"><span class="toc-text">696. 计数二进制子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">844. 比较含退格的字符串</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-bg" id="search-bg"></div>
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> Keep It Simple, Stupid </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        LeetCode 数组
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-05-04 00:00:00</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#LeetCode" title="LeetCode">LeetCode</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#数组" title="数组">数组</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h2 id="LeetCode-数组"><a href="#LeetCode-数组" class="headerlink" title="LeetCode 数组"></a>LeetCode 数组</h2><blockquote>
<p>善用 ctrl+f</p>
</blockquote>
<h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h2><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
<p><strong>说明：</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：<span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>

<p>两数之和的变种，看见<strong>有序</strong>其实也可以使用二分来做，但是时间复杂度是<code>O(NlogN)</code>，相对较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers==<span class="literal">null</span>||numbers.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">        <span class="type">int</span> sum=numbers[right]+numbers[left];</span><br><span class="line">        <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;<span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对撞指针</strong>，很基础的题。</p>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p>
<p><img src="http://static.imlgw.top///20190505/1uze479AHHLo.png?imageslim" alt="mark"></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=height.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="type">int</span> minHight=height[i]&gt;height[j]?height[j]:height[i];</span><br><span class="line">                max=max&gt;(j-i)*minHight ? max:(j-i)*minHight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>522ms，13% 垫底了，别问，问就是暴力🤣</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=height.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> head=<span class="number">0</span>,tail=len-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;len)&#123;</span><br><span class="line">            tail=len-<span class="number">1</span>; <span class="comment">//开始改的时候这一句忘了加</span></span><br><span class="line">            <span class="keyword">while</span>(head!=tail)&#123;</span><br><span class="line">                <span class="type">int</span> minHight=height[tail]&gt;height[head]?height[head]:height[tail];</span><br><span class="line">                max=max&gt;(tail-head)*minHight ? max:(tail-head)*minHight;</span><br><span class="line">                <span class="keyword">if</span>(height[head]&lt;=height[tail])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tail--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>212ms，40%，利用双指针稍微优化了下，依然是遍历找每个柱的最大值，但是尾指针在移动时先判断下，如果比头指针大就直接 break，因为<strong>已经是最大值</strong>了，tail 是从右向左移动的</p>
<blockquote>
<p>开始改的时候忘了将尾指针归位，结果还对了，而且 90%的 beats….. 哈哈哈，误打误撞搞了个最优解出来。</p>
</blockquote>
<p><strong>解法二</strong></p>
<p>上面两种其实都是暴力，时间复杂度都很高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//update: 2020.4.18</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(height==<span class="literal">null</span> || height.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        max=Math.max((right-left)*Math.min(height[left],height[right]),max);</span><br><span class="line">        <span class="comment">//if(left&lt;right)&#123; 隐约记得之前也这样写过。没想到这次又在这里 WA 了</span></span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标准</strong>的最优解，这题主要考察的就是双指针，两个指针一头一尾，先算出这个头尾的面积大小，然后下一步思考怎么扩大这个区域的面积，结合题上面的图（最左边为头，最右边为尾）</p>
<p><img src="http://static.imlgw.top///20190505/1uze479AHHLo.png?imageslim" alt="mark"></p>
<p>这个时候如果移动尾指针，明显面积只可能减小，所以只有移动头指针才有可能增大这个区域的面积，这样一来就可以省掉很多没必要的计算，有点像贪心，时间复杂度 O(N)</p>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://i.loli.net/2019/05/14/5cda71129045d93180.png" alt="rainwatertrap.png"></p>
<p>上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code> 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<blockquote>
<p>我最开始思路是填满后用总面积减数组和，跑过了 130+个，有一种特殊的跑不过了，懒得去处理那个边界了，不太优雅</p>
</blockquote>
<p>这个题目的关键就是每个柱子能接的水是<strong>左右最长柱子（都大于当前柱子）中的较小的那个减去当前柱子</strong>。</p>
<p>所以我们可以用两个数组分别存储每个柱子左右的最长柱子（做预处理），这样就得到了一种有点动态规划意思的解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span> []height)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="literal">null</span> || height.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=height.length;</span><br><span class="line">    <span class="type">int</span>[] leftMax=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    leftMax[<span class="number">0</span>]=height[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[] rightMax=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    rightMax[len-<span class="number">1</span>]=height[len-<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左右最大柱子包含当前柱子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++) &#123;</span><br><span class="line">        leftMax[i]=Math.max(leftMax[i-<span class="number">1</span>],height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        rightMax[i]=Math.max(rightMax[i+<span class="number">1</span>],height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        res+=Math.min(rightMax[i],leftMax[i])-height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<strong>双指针</strong>就行空间的优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span> []height)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="literal">null</span> || height.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=height.length;</span><br><span class="line">    <span class="type">int</span> leftMax=<span class="number">0</span>,rightMax=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=len-<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        leftMax=Math.max(leftMax,height[left]);</span><br><span class="line">        rightMax=Math.max(rightMax,height[right]);</span><br><span class="line">        <span class="comment">//leftMax 小于 rightMax, 那么靠近 leftMax 的柱子 left 可以接的雨水就可以确定了</span></span><br><span class="line">        <span class="keyword">if</span> (leftMax&lt;rightMax) &#123;</span><br><span class="line">            res+=leftMax-height[left]; </span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//反之 leftMax 大于 rightMax, 那么考近 rightMax 的柱子 right 可以接的最多的雨水就可以 i 确定了</span></span><br><span class="line">            res+=rightMax-height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人感觉这个是最好理解的版本，我这里最开始的哪个版本不是这样写的，当时自己肯定也没搞懂，包括现在我也没搞懂那种写法</p>
<p><img src="http://static.imlgw.top/blog/20200129/Dy8M19G4XwSn.png?imageslim" alt="[图片来自 liweiwei1419 大佬](https://leetcode-cn.com/u/liweiwei1419/)"></p>
<p>这两种情况对应的就是循环中的 if 的两个分支，双指针向中间靠拢，当<code>leftMax</code>小于<code>rightMax</code>的时候我们不用去考虑当前<code>left</code>柱子右边实际的最大的右边的柱子是谁，我们只需要知道<code>left</code>柱子 左边最大值<code>leftMax</code>的值就 ok，因为此时<code>left</code> 柱子能接水的量是由<code>leftMax</code>决定的，反之对应第二种情况，<code>right</code>柱子的接水量则是由<code>rightMax</code> 决定的，最后遍历完所有的柱子就可以确定整体的接水量</p>
<blockquote>
<p>这里的 if 分支的条件有的解法中写的是 leftMax &lt; nums[right] 甚至 nums[left] &lt; nums[right] 这也是我上面说的不理解的地方，因为这样写也是可以 AC 的😅，后面有时间再回头看看吧</p>
</blockquote>
<p><strong>解法二</strong></p>
<p>还有一种很巧妙的方法，也比较好理解，找到最大值，然后分别对两边的柱子进行遍历，如果当前的柱子小于前面柱子的最大值，就说明一定可以接到水，这个过程中需要记录柱子左边和右边的最大值，用于计算可以接水的量，最后计算总和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap5</span><span class="params">(<span class="type">int</span> []height)</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> n=height.length,idx=<span class="number">0</span>,lefth=<span class="number">0</span>,righth=<span class="number">0</span>,area=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) idx=height[idx]&lt;=height[i]?i:idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;idx;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&lt;lefth) area+=lefth-height[i]; </span><br><span class="line">        <span class="keyword">else</span> lefth=height[i]; <span class="comment">//更新最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;idx;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&lt;righth) area+=righth-height[i]; </span><br><span class="line">        <span class="keyword">else</span> righth=height[i]; <span class="comment">//更新最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法三</strong></p>
<p>利用栈的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap6</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); <span class="comment">//栈里面维护一个递减序列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> ( ! stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123; <span class="comment">//当遍历的元素大于栈顶元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> stack.pop(); <span class="comment">//栈顶弹出来</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">            res += (Math.min(height[i],height[stack.peek()]) - height[tmp]) * (i - stack.peek() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护递减序列</span></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种有点不好理解，其实是按照层来计算的，栈里面是递减的元素，如果读到比栈顶大的元素就<strong>按层</strong>计算递减栈<strong>底部元素</strong>到<strong>当前元素</strong>能蓄水的面积。</p>
<blockquote>
<p>2020/1/29 回顾</p>
<p>这个解法其实就是单调栈😂，当时还是菜鸟根本就不懂，现在回头一看就懂了 hahaha~ </p>
<p>放到 <a href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/#%E5%8D%95%E8%B0%83%E6%A0%88">单调栈专题</a> 里面解释了</p>
</blockquote>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>想太多了，没做出来，看了评论才做出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">// 先排序  o(nlogn)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> list;</span><br><span class="line">    <span class="comment">// 完备性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len-<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//大于 0 了，后面的和加起来肯定&gt;0 了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组，相同的元素只需要遍历一遍，不然会重复</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 一次去重优化</span></span><br><span class="line">        <span class="comment">//当前元素的下一个元素。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//尾元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[L] + nums[R];</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                <span class="comment">//-4 -1 -1 0 1 2</span></span><br><span class="line">                <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++;</span><br><span class="line">                <span class="comment">//二次去重优化</span></span><br><span class="line">                <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--;</span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)&#123; <span class="comment">//小于 0 所以要增大 L, 逼近 0 else R--;</span></span><br><span class="line">                 L++;   </span><br><span class="line">            &#125; <span class="keyword">else</span> R--; <span class="comment">//大于 0 就减小 R</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码思路就是遍历数组，然后从** i <strong>位置后面的数组中找能和</strong> i <strong>凑成一对的元素，这里关键就是这里怎么找这两个元素 满足 nums[L]+nums[R]=-nums[i]，问题就转化成了上面的</strong>两数之和<strong>，但是这里用暴力法肯定是过不了的，hashMap 这里也不好用，所以这里我们可以先给数组排个序，然后利用</strong>双指针对撞**，逐渐逼近 0，还有一个很需要注意的地方就是二次去重，如下图</p>
<p><img src="http://static.imlgw.top///20190505/5YlNbCLe57fb.png?imageslim" alt="mark"></p>
<p>当找到一组时有可能 L，R 的下一个位置的值没变这样就会导致重复。</p>
<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h2><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [-<span class="number">1</span>，<span class="number">2</span>，<span class="number">1</span>，-<span class="number">4</span>], 和 target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 <span class="number">2.</span> (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>跟上面的题其实是一样的，这里主要时为了检测下自己上面的搞懂了没</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||len&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> closest=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//跳过重复元素提高效率</span></span><br><span class="line">        <span class="type">int</span> L=i+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> R=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            <span class="type">int</span> sum=nums[L]+nums[R]+nums[i];</span><br><span class="line">            closest=Math.abs(closest-target)&gt;Math.abs(sum-target)?sum:closest;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(L&lt;R &amp;&amp; nums[R]==nums[R-<span class="number">1</span>])R--;</span><br><span class="line">                R--;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(L&lt;R &amp;&amp; nums[L]==nums[L+<span class="number">1</span>])L++;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一遍** bugfree**，其实都挺简单，这两题我一直在考虑别的算法，我想的是排序后从两遍向中间然后。.. 就不 bb 了，反之很多没考虑到的地方。</p>
<h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h2><p>给定一个包含 n 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 a，b，c 和 d ，使得 <code>a + b + c + d</code> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>]，和 target = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [-<span class="number">2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>和三数之和一样，但是更加繁琐了，提交了 5，6 次才 AC，还是看了别人的代码的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> n=nums.length;</span><br><span class="line">    <span class="comment">//0 0 -1 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="comment">//这里我开始写的是和后一个比较，0，0，0，0 这种过不了</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]+nums[n-<span class="number">1</span>]+nums[n-<span class="number">2</span>]+nums[n-<span class="number">3</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n-<span class="number">2</span>;j++) &#123;</span><br><span class="line">            <span class="comment">//同上</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]+nums[j+<span class="number">2</span>]+nums[j+<span class="number">1</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]+nums[n-<span class="number">2</span>]+nums[n-<span class="number">1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> two=nums[i]+nums[j];</span><br><span class="line">            <span class="comment">//左右边界</span></span><br><span class="line">            <span class="type">int</span> left=j+<span class="number">1</span>,right=n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span> (target-two==nums[left]+nums[right]) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//想清楚什么时候跳，放外面就错了</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])&#123;left++;&#125;;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>])&#123;right--;&#125;;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target-two&gt;nums[left]+nums[right]) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>实不相瞒，这题一开始我暴力做的，冒泡的思想，太蠢了😅 ，注意题目要求空间复杂度 O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针，真的用的挺多的。</p>
<h2 id="80-删除排序数组中的重复项-II"><a href="#80-删除排序数组中的重复项-II" class="headerlink" title="80. 删除排序数组中的重复项 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. 删除排序数组中的重复项 II</a></h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = <span class="number">7</span>, 并且原数组的前五个元素被修改为 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢？</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度，它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>上面题目加一点，在前后相等的时候判断 index 前是否已经有两个相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=nums[i-<span class="number">1</span>] || (nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; nums[index-<span class="number">2</span>]!=nums[index-<span class="number">1</span>]))&#123;</span><br><span class="line">            nums[index++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h2><p>给定一个数组 <em>nums</em> 和一个值 <em>val</em>，你需要<strong>原地</strong>移除所有数值等于 <em>val</em> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>目标元素多时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标元素少时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[--n];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>:</p>
<ul>
<li><p>必须在原数组上操作，不能拷贝额外的数组。</p>
</li>
<li><p>尽量减少操作次数。</p>
</li>
</ul>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            nums[index++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">        nums[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是借助上面题目的思路，最后再补 0 就 ok 了，其实也还可以优化下</p>
<p><strong>解法二</strong></p>
<p>保持<code>[0,m)</code> 为非 0 元素，遇到非 0 元素就和右边界进行交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>; <span class="comment">//[0,m) 为非 0 元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=m)&#123;</span><br><span class="line">                <span class="type">int</span> temp=nums[i];</span><br><span class="line">                nums[i]=nums[m];</span><br><span class="line">                nums[m]=temp;   </span><br><span class="line">            &#125;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>直接上最优解吧，这题暴力法 O(N!)，空间也超过了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||len&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">//找到第一个峰值左相邻的元素（从左到右）</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逆序的，没有最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i==-<span class="number">1</span>)&#123;</span><br><span class="line">            reverse(nums,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到峰值右边 [i+1 , len-1] 最后一个比 i 大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=len-<span class="number">1</span>;j&gt;i;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[i])&#123;</span><br><span class="line">                swap(nums,j,i);</span><br><span class="line">                reverse(nums,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=start,j=nums.length-<span class="number">1</span>;i&lt;j;i++,j--) &#123;</span><br><span class="line">        swap(nums,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一步，逆序找到第一个峰值的左边第一个元素 <code>a[i-1]</code>。</p>
</li>
<li><p>将峰值右边的<strong>最小的</strong>比<code>a[i-1]</code>大的<code>a[j]</code>（其实就是<code>右边最后一个比它大的元素</code>) 元素与** a[i-1] **交换。</p>
</li>
<li><p>翻转刚刚调整过<code>a[i-1]</code>后面的逆序的数组 (<code>a[i]--&gt;a[len-1]</code>)。</p>
</li>
</ul>
<p><img src="http://static.imlgw.top/blog/20190728/G6uqlPyjPLdV.png?imageslim" alt="mark"></p>
<p>至于为什么这样做自己模拟下就懂了，逆序部分是没有下一个比它大的排列的，所以如果想让整个排列变大只能从这个逆序的排列里面选一个比逆序前最后一个’’稍微’’大一点的元素与之交换，然后将整个逆序的部分翻转就是下一个排列，这题看了题解后处理边界又处理了半天，<strong>循环里面的循环边界条件一定要注意</strong></p>
<h2 id="556-下一个更大元素-III"><a href="#556-下一个更大元素-III" class="headerlink" title="556. 下一个更大元素 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-iii/">556. 下一个更大元素 III</a></h2><p>给定一个 32 位正整数 n，你需要找到最小的 32 位整数，其与 n 中存在的位数完全相同，并且其值大于 n。如果不存在这样的 32 位整数，则返回-1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">12</span></span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">21</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>和上面那一题一样，权当复习了一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextGreaterElement</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(n/<span class="number">10</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sb.append(n%<span class="number">10</span>);</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(n);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    <span class="type">char</span>[] nums=sb.reverse().toString().toCharArray();</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&gt;nums[i-<span class="number">1</span>]) &#123; <span class="comment">//逆序的峰值 i</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=len-<span class="number">1</span>;j&gt;=i;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j]&gt;nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums,j,i-<span class="number">1</span>);</span><br><span class="line">                    reverse(nums,i,len-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> Long.valueOf(<span class="keyword">new</span> <span class="title class_">String</span>(nums))&gt;Integer.MAX_VALUE?-<span class="number">1</span>:Integer.valueOf(<span class="keyword">new</span> <span class="title class_">String</span>(nums));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=begin,j=end;i&lt;j;i++,j--) &#123;</span><br><span class="line">        swap(nums,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">char</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>分治法， (<code>HashMap</code>或者排序什么的方法就不说了，笔试可以那样写，面试就不能这样了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> majorityElement(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lo==hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> leftMode=majorityElement(nums,lo,mid);</span><br><span class="line">    <span class="type">int</span> rightMode=majorityElement(nums,mid+<span class="number">1</span>,hi);</span><br><span class="line">    <span class="keyword">if</span> (leftMode==rightMode) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightMode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countMode(nums,lo,mid,leftMode)&gt;countMode(nums,mid+<span class="number">1</span>,hi,rightMode)?leftMode:rightMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countMode</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> mode)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=left;i&lt;=right;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode==nums[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并不是最优解，时间复杂度<code>O(NlogN)</code>，只是一种思路吧，而且是通用的求众数的方法</p>
<p><strong>解法二</strong></p>
<p>摩尔投票法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res=nums[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum==<span class="number">0</span>) &#123;</span><br><span class="line">            res=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将众数看做 1, 其他的看作-1, 最后和一定是大于 0 的</span></span><br><span class="line">        <span class="keyword">if</span> (res!=nums[i]) &#123;</span><br><span class="line">            sum--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法三</strong></p>
<p>刚刚看见一种解法，当作求第 k 大，用快选就行了，时间复杂度<code>O(N)</code></p>
<h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h2><p>给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。</p>
<p><strong>说明：</strong> 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>和上面的方法一样，抵消去除三个不同的元素对众数没有任何影响，但是最后需要判断是否都是符合条件的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//update：2020.4.23 用 go 在 web 上随手写了一个，感觉比之前 java 写的哪个好理解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="comment">//超过 n/3 的元素最多 2 个</span></span><br><span class="line">    cand1:=<span class="number">-1</span> <span class="comment">//设置成 nums 中不存在的值比较好，比如-1</span></span><br><span class="line">    count1:=<span class="number">0</span></span><br><span class="line">    cand2:=<span class="number">-1</span></span><br><span class="line">    count2:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,num:=<span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> num==cand1&#123; <span class="comment">//投 1</span></span><br><span class="line">            count1++</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> num==cand2&#123; <span class="comment">//投 2</span></span><br><span class="line">            count2++</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//都不投</span></span><br><span class="line">            <span class="keyword">if</span> count1==<span class="number">0</span> &#123;</span><br><span class="line">                cand1=num</span><br><span class="line">                count1=<span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> count2==<span class="number">0</span>&#123;</span><br><span class="line">                cand2=num</span><br><span class="line">                count2=<span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count1--</span><br><span class="line">                count2--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp1:=<span class="number">0</span></span><br><span class="line">    temp2:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,num:= <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> num==cand1&#123;</span><br><span class="line">            temp1++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num==cand2&#123;</span><br><span class="line">            temp2++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> temp1&gt;<span class="built_in">len</span>(nums)/<span class="number">3</span> &#123;</span><br><span class="line">        res=<span class="built_in">append</span>(res,cand1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> temp2&gt;<span class="built_in">len</span>(nums)/<span class="number">3</span> &#123;</span><br><span class="line">        res=<span class="built_in">append</span>(res,cand2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>Head 题，想到了桶排序，但是空间不符合要求，看了评论扣了半天边界也没抠出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="comment">//将每个元素归位，我开始只有一层循环，那样会漏掉很多元素（可能被交换的元素后面也需要交换），这样的就是一次直接到位。</span></span><br><span class="line">        <span class="keyword">while</span>(nums[i]&gt;=<span class="number">1</span>&amp;&amp;nums[i]&lt;=nums.length&amp;&amp;nums[nums[i]-<span class="number">1</span>]!=nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp=nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">            nums[nums[i]-<span class="number">1</span>]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也是桶排序的思想，不过这里是利用交换来定位每个元素，首相我们将原数组看作桶，题目要求的正整数，所以我们桶中存的应该是<code>【1，nums.length】</code>，也就是 0 位置应该存放的是 1，1 位置存放的应该是 2…. 再归位后重新遍历数组，如果某个位置的<code>nums[i]!=i+1</code> 就说明这个是第一个缺失的正数，遍历完了之后没有找到，全部对应上了，那就说明我们缺少的第一个正数是<code>nums.length+1</code></p>
<p><strong>Update:2020.6.27</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> nums[i]&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;<span class="built_in">len</span>(nums) &amp;&amp; nums[i]!=i+<span class="number">1</span> &amp;&amp; nums[nums[i]<span class="number">-1</span>]!=nums[i]&#123;</span><br><span class="line">            nums[nums[i]<span class="number">-1</span>],nums[i]=nums[i],nums[nums[i]<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i,n := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> n!=i+<span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>不考虑空间复杂度利用桶排序的思想</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> [] bucket=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;=nums.length)&#123;</span><br><span class="line">                bucket[nums[i]-<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//代表这个桶有元素了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bucket.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lc 上提交后的空间消耗居然比上面的还小一点😂</p>
<h2 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></h2><p>给定一个整数数组 a，其中 1 ≤ a[i] ≤ n （n 为数组长度）, 其中有些元素出现两次而其他元素出现一次。</p>
<p>找到所有出现两次的元素。</p>
<p>你可以不用到任何额外空间并在 O(n) 时间复杂度内解决这个问题吗？</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>同上，抽屉原理，直接秒掉这三题 hard，mid，easy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=i+<span class="number">1</span> &amp;&amp; nums[i]!=nums[nums[i]-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="type">int</span> temp=nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">            nums[nums[i]-<span class="number">1</span>]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]!=i+<span class="number">1</span>) &#123;</span><br><span class="line">            res.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>技巧性的思路，和上一题一样，将对应位置置反，如果遇到已经置反的就说明当前位置重复了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5 1 1 3 2</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[Math.abs(nums[i])-<span class="number">1</span>]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            res.add(Math.abs(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        nums[Math.abs(nums[i])-<span class="number">1</span>]=-Math.abs(nums[Math.abs(nums[i])-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为 O(n) 的情况下完成这个任务吗？你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>首先想到的解法，利用的和上面缺失的第一个正数一样的思路，抽屉原理，归位每个数字，最后没有归为的 index 就是消失的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//nums[i]=i+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=i+<span class="number">1</span> &amp;&amp; nums[nums[i]-<span class="number">1</span>]!=nums[i])&#123;</span><br><span class="line">            <span class="type">int</span> temp=nums[i];</span><br><span class="line">            nums[i]=nums[temp-<span class="number">1</span>];</span><br><span class="line">            nums[temp-<span class="number">1</span>]=temp;</span><br><span class="line">            <span class="comment">//nums[i]=nums[nums[i]-1]; 最开始的错误写法</span></span><br><span class="line">            <span class="comment">//nums[nums[i]-1]=temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]!=i+<span class="number">1</span>) &#123;</span><br><span class="line">            res.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间写出了一个小<code>bug</code>，交换两个元素的时候先交换了<code>nums[i]</code>，导致了后面的<code>nums[nums[i]+1]</code> 发生了变化，然后就死循环了😂，调试了一下才看出来，太菜了</p>
<p><strong>解法二</strong></p>
<p>很巧妙的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//很巧妙</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//nums[i]=i+1</span></span><br><span class="line">    <span class="comment">//5 1 4 2 3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        nums[Math.abs(nums[i])-<span class="number">1</span>]=-Math.abs(nums[Math.abs(nums[i])-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            res.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目给定了数值的范围就是<code>[1,n]</code>所以可以遍历每个元素，将该元素正确位置的值取反置为负数</p>
<p>比如 <code>5 1 1 3 2</code> 遍历到 5 的时候就会将末尾的 2 变为-2，依次类推，最后得到的就是<code>[-5,-1,-1,3,-2]</code> ，最后再遍历一遍，其中值为正数的元素的索引+1 就是消失的数字</p>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h2><p>给定一个包含红色、白色和蓝色，一共 <em>n</em> 个元素的数组，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p><strong>注意：</strong><br>不能使用代码库中的排序函数来解决这道题。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出 0、1 和 2 元素的个数，然后按照 0、1、2 的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<p><strong>解法一</strong></p>
<p>题目上已经有了提示，很直观的做法就是利用桶排序的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] bucket=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//基于桶排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        bucket[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//重新构造出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[index]&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i]=index;</span><br><span class="line">        bucket[index]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还有更优秀的做法，利用<strong>三向切分快排</strong>的思想（荷兰国旗问题）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> less=-<span class="number">1</span>,more=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=more)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[l]&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            swap(nums,++less,l++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            swap(nums,more--,l);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123; </span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;race a car&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>easy 题，对撞指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span>||s.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s=s.toLowerCase();</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">char</span> lch=s.charAt(left);</span><br><span class="line">        <span class="type">char</span> rch=s.charAt(right);</span><br><span class="line">        <span class="keyword">if</span>(isNumOrchar(lch) &amp;&amp; isNumOrchar(rch))&#123;</span><br><span class="line">            <span class="comment">//System.out.println(lch+&quot;,&quot;+rch);</span></span><br><span class="line">            <span class="keyword">if</span>(lch==rch)&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((!isNumOrchar(lch)) &amp;&amp; isNumOrchar(rch))&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isNumOrchar(lch) &amp;&amp; !isNumOrchar(rch))&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">isNumOrchar</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>) || (ch&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;z&#x27;</span>) || (ch&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp;  ch&lt;=<span class="string">&#x27;Z&#x27;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码写多了，不够简洁，其实可以直接用** Character **的 API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i))) i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j))) j--;</span><br><span class="line">        <span class="keyword">if</span> (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a></h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: &quot;hello&quot;</span><br><span class="line">Output: &quot;holle&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: &quot;leetcode&quot;</span><br><span class="line">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseVowels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span>||s.length()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] ss=s.toCharArray();</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; !isYy(ss[left]))&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; !isYy(ss[right]))&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(left++,right--,ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ss);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">isYy</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">    <span class="type">char</span> temp=Character.toLowerCase(ch);</span><br><span class="line">    <span class="keyword">return</span> temp==<span class="string">&#x27;a&#x27;</span>|| temp==<span class="string">&#x27;e&#x27;</span>||temp==<span class="string">&#x27;i&#x27;</span>||temp==<span class="string">&#x27;o&#x27;</span>||temp==<span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">char</span>[] s)</span>&#123;</span><br><span class="line">    <span class="type">char</span> temp=s[a];</span><br><span class="line">    s[a]=s[b];</span><br><span class="line">    s[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的对撞指针题</p>
<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>典型的二路归并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums1.length&lt;=<span class="number">0</span>||nums2.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">    <span class="type">int</span> i1=<span class="number">0</span>,i2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i1&lt;m&amp;&amp;i2&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i1]&lt;=nums2[i2]) &#123;</span><br><span class="line">            res[i]=nums1[i1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i1]&gt;nums2[i2] )&#123;</span><br><span class="line">            res[i]=nums2[i2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i1&gt;=m)&#123;</span><br><span class="line">        System.arraycopy(nums2,i2,res,i2+m,n-i2);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        System.arraycopy(nums1,i1,res,i1+n,m-i1);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(res,<span class="number">0</span>,nums1,<span class="number">0</span>,res.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1ms ，98%beats.</p>
<p><strong>解法二</strong></p>
<p>看了下评论区发现自己还是太年轻了，原来这题是可以在** O(1) **的空间复杂度下完成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge3</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums1.length&lt;=<span class="number">0</span>||nums2.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i1=m-<span class="number">1</span>,i2=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=m+n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i]=nums2[i2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i]=nums1[i1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i1]&gt;nums2[i2]) &#123;</span><br><span class="line">            nums1[i]=nums1[i1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i1]&lt;=nums2[i2] )&#123;</span><br><span class="line">            nums1[i]=nums2[i2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并后的长度确定，nums1 的空间也足够，所以完全可以从后往前，从大到小，从而避免了使用额外的空间储存结果，学到了学到了👏</p>
<p><strong>解法三</strong></p>
<p>时隔多年，LeetCode 打卡又做了一遍，这次直接想到了最优解，而且代码很简洁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> m, <span class="type">int</span>[] B, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> )  <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> len=A.length,ai=m-<span class="number">1</span>,bi=n-<span class="number">1</span>,i=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ai&gt;=<span class="number">0</span> &amp;&amp; bi&gt;=<span class="number">0</span>) A[i--]=A[ai] &gt; B[bi] ? A[ai--]:B[bi--];</span><br><span class="line">    <span class="keyword">while</span>(bi&gt;=<span class="number">0</span>) A[i--]=B[bi--];</span><br><span class="line">    <span class="comment">//ai 剩余的不用管</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="532-逆序对"><a href="#532-逆序对" class="headerlink" title="532. 逆序对"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/reverse-pairs/description">532. 逆序对</a></h2><p>（来自领扣）</p>
<p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。给你一个数组，求出这个数组中逆序对的总数。<br>概括：如果 a[i] &gt; a[j] 且 i &lt; j， a[i] 和 a[j] 构成一个逆序对。</p>
<p><strong>样例 1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">3</span>) 是逆序对</span><br></pre></td></tr></table></figure>

<p><strong>样例 2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">没有逆序对</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="literal">null</span> || A.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversePairs(A,<span class="number">0</span>,A.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] A,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> l=reversePairs(A,left,mid);</span><br><span class="line">    <span class="type">long</span> r=reversePairs(A,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">return</span> merge(A,left,mid,right)+l+r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] help=<span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//小于等于的时候让 i 先进栈</span></span><br><span class="line">        <span class="comment">//help[index++]=nums[i]&lt;=nums[j] ? nums[i++]:nums[j++];</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;=nums[j]) &#123;</span><br><span class="line">            help[index++] = nums[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            help[index++] = nums[j++];</span><br><span class="line">            res+= mid-i+<span class="number">1</span>; <span class="comment">//j 和 i-mid 间的所有元素形成逆序对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        help[index++]=nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">        help[index++]=nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;help.length;k++) &#123;</span><br><span class="line">        nums[left+k]=help[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序的思路，最开始我是在每次 i&gt;j 和最后收尾的时候 res++，然后结果总是不对，然后取查了答案才意识到不能这样算，当<code>nums[i] &gt; nums[j]</code> 的时候，<code>i~j</code> 形成的逆序对其实不只一个，而是<code>[i,mid]</code> 区间的所有元素，如果你只是+1 的话就会漏掉许多情况，因为下一步 <code>j++</code> 就会将 <code>j</code> 向后移动，那些情况就考虑不到了</p>
<h2 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h2><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>] </span><br><span class="line">解释：</span><br><span class="line"><span class="number">5</span> 的右侧有 <span class="number">2</span> 个更小的元素 (<span class="number">2</span> 和 <span class="number">1</span>).</span><br><span class="line"><span class="number">2</span> 的右侧仅有 <span class="number">1</span> 个更小的元素 (<span class="number">1</span>).</span><br><span class="line"><span class="number">6</span> 的右侧有 <span class="number">1</span> 个更小的元素 (<span class="number">1</span>).</span><br><span class="line"><span class="number">1</span> 的右侧有 <span class="number">0</span> 个更小的元素。</span><br></pre></td></tr></table></figure>

<p><strong>错误解法一</strong></p>
<p>这个 bug 我大概看了有两三个小时，人都看傻了，必须放上来纪念下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span>&#123;</span><br><span class="line">    idx <span class="type">int</span></span><br><span class="line">    val <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSmaller</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    count:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line">    elements:=<span class="built_in">make</span>([]Element,n)</span><br><span class="line">    <span class="keyword">for</span> i,num:=<span class="keyword">range</span> nums&#123;</span><br><span class="line">        elements[i].idx=i</span><br><span class="line">        elements[i].val=num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(elements);</span><br><span class="line">    mergeSort(elements,<span class="number">0</span>,n<span class="number">-1</span>,count)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(num []Element,left <span class="type">int</span>,right <span class="type">int</span>,count []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> left&gt;=right&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid:=left+(right-left)/<span class="number">2</span></span><br><span class="line">    mergeSort(num,left,mid,count)</span><br><span class="line">    mergeSort(num,mid+<span class="number">1</span>,right,count)</span><br><span class="line">    merge(num,left,mid,right,count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(num []Element,left <span class="type">int</span>,mid <span class="type">int</span>,right <span class="type">int</span>,count []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    help:=<span class="built_in">make</span>([]<span class="type">int</span>,right-left+<span class="number">1</span>)</span><br><span class="line">    i:=left</span><br><span class="line">    j:=mid+<span class="number">1</span></span><br><span class="line">    index:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i&lt;=mid &amp;&amp; j&lt;=right &#123;</span><br><span class="line">        <span class="keyword">if</span> num[i].val&lt;=num[j].val&#123; <span class="comment">//说明 j 前面的元素都小于 i</span></span><br><span class="line">            count[num[i].idx]+=(j-mid<span class="number">-1</span>)</span><br><span class="line">            help[index]=num[i].val</span><br><span class="line">            i++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            help[index]=num[j].val</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i&lt;=mid&#123;</span><br><span class="line">        count[num[i].idx]+=(j-mid<span class="number">-1</span>)</span><br><span class="line">        help[index]=num[i].val</span><br><span class="line">        index++</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j&lt;=right&#123;</span><br><span class="line">        help[index]=num[j].val</span><br><span class="line">        index++</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=left;i&lt;=right;i++&#123;</span><br><span class="line">        num[i].val=help[i-left]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始用 go 写的，调了半天没调出来，我以为是 go 的啥问题（刚学 go 不太熟）然后用 Java 又写了一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">countSmaller</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Pair[] pair=<span class="keyword">new</span> <span class="title class_">Pair</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            pair[i]=<span class="keyword">new</span> <span class="title class_">Pair</span>(i,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] count=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        mergeSort(pair,<span class="number">0</span>,nums.length-<span class="number">1</span>,count);</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count.length;i++)&#123;</span><br><span class="line">            res.add(count[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(Pair[] nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span>[] count)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(nums,left,mid,count);</span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,right,count);</span><br><span class="line">        merge(nums,left,mid,right,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Pair [] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] count)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//出 Bug 的地方，应该用 Pair[] </span></span><br><span class="line">        <span class="type">int</span>[] helper=<span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i].value&gt;nums[j].value)&#123;</span><br><span class="line">                helper[index++]=nums[j++].value;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count[nums[i].index]+=j-mid-<span class="number">1</span>;</span><br><span class="line">                helper[index++]=nums[i++].value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            count[nums[i].index]+=j-mid-<span class="number">1</span>;</span><br><span class="line">            helper[index++]=nums[i++].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">            helper[index++]=nums[j++].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;helper.length;k++)&#123;</span><br><span class="line">            <span class="comment">//这里无形之中将索引和数据的对应关系打乱了。</span></span><br><span class="line">            nums[left+k].value=helper[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">            index=i;</span><br><span class="line">            value=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是不对，和之前 go 的结果是一样的，这段代码我反复地看了 3 个小时，楞是没看出来哪里写错了，我是真的菜啊！！！！！！！！！</p>
<p><strong>解法一</strong></p>
<p>其实和逆序对的解法是类似的，思路都在注释中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">countSmaller</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Pair[] pair=<span class="keyword">new</span> <span class="title class_">Pair</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        pair[i]=<span class="keyword">new</span> <span class="title class_">Pair</span>(i,nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] count=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    mergeSort(pair,<span class="number">0</span>,nums.length-<span class="number">1</span>,count);</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count.length;i++)&#123;</span><br><span class="line">        res.add(count[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(Pair[] nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span>[] count)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(nums,left,mid,count);</span><br><span class="line">    mergeSort(nums,mid+<span class="number">1</span>,right,count);</span><br><span class="line">    merge(nums,left,mid,right,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Pair [] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] count)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">    Pair[] helper=<span class="keyword">new</span> <span class="title class_">Pair</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i].value&gt;nums[j].value)&#123;</span><br><span class="line">            helper[index++]=nums[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//i&lt;=j 那么 mid+1~j-1 的肯定都比 i 小</span></span><br><span class="line">            <span class="comment">//(j-1)-(mid+1)+1=j-mid-1</span></span><br><span class="line">            count[nums[i].index]+=j-mid-<span class="number">1</span>;</span><br><span class="line">            helper[index++]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        <span class="comment">//j 没了，那么所有的 j 的元素都比 i 小</span></span><br><span class="line">        <span class="comment">//等价于 right-mid</span></span><br><span class="line">        count[nums[i].index]+=j-mid-<span class="number">1</span>;</span><br><span class="line">        helper[index++]=nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">        helper[index++]=nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;helper.length;k++)&#123;</span><br><span class="line">        nums[left+k]=helper[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        index=i;</span><br><span class="line">        value=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这题还可以用<strong>树状数组</strong>解，但是我暂时还不会，后面有时间学了再来补充，其实还可以用线段树，二叉搜索树等等，有点麻烦，算了</p>
</blockquote>
<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h2><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">5</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>递归专题里面的题目，所以直接用递归来实现了下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">    generate(<span class="number">1</span>, res.get(<span class="number">0</span>), res, numRows);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRow, List&lt;Integer&gt; preRow, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> rowMax)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rowMax == numRow) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    row.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preRow.size(); i++) &#123;</span><br><span class="line">        row.add(preRow.get(i - <span class="number">1</span>) + preRow.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    row.add(<span class="number">1</span>);</span><br><span class="line">    res.add(row);</span><br><span class="line">    generate(numRow + <span class="number">1</span>,row,res,rowMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾递归，很鸡肋。</p>
<h2 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h2><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">3</span></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">long</span> cur=<span class="number">1</span>;</span><br><span class="line">       res.add((<span class="type">int</span>)cur);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">           cur=cur*(rowIndex-i+<span class="number">1</span>)/i;</span><br><span class="line">           res.add((<span class="type">int</span>)cur);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接利用组合数的公式，m 列第 n 个元素等于 C(n-1,M-1)</p>
<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给定一个包含 m x n 个元素的矩阵（m 行，n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>这题很久之前做过，这次又来做的时候还是没做出来，忘了之前咋做的了，用模拟的方法搞了半天，没搞出来，然后瞄了一眼之前写的才写出来。…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">spiralOrder2</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a: 行</span></span><br><span class="line">    <span class="comment">//b: 列</span></span><br><span class="line">    <span class="type">int</span> la=<span class="number">0</span>,lb=<span class="number">0</span>,ra=matrix.length-<span class="number">1</span>,rb=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">while</span>(lb&lt;=rb &amp;&amp; la&lt;=ra)&#123;</span><br><span class="line">        <span class="comment">//缓存各个坐标</span></span><br><span class="line">        <span class="type">int</span> tla=la,tlb=lb,tra=ra,trb=rb;</span><br><span class="line">        <span class="comment">//特殊情况，特殊处理</span></span><br><span class="line">        <span class="keyword">if</span>(tla==tra)&#123;<span class="comment">//同一行</span></span><br><span class="line">            <span class="keyword">while</span>(tlb&lt;=trb)&#123;</span><br><span class="line">                res.add(matrix[tla][tlb++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tlb==trb)&#123;<span class="comment">//同一列</span></span><br><span class="line">            <span class="keyword">while</span>(tla&lt;=tra)&#123;</span><br><span class="line">                res.add(matrix[tla++][tlb]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">while</span>(tlb&lt;rb)&#123;</span><br><span class="line">                res.add(matrix[tla][tlb++]);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//向下</span></span><br><span class="line">            <span class="keyword">while</span>(tla&lt;ra)&#123;</span><br><span class="line">                res.add(matrix[tla++][tlb]);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//向右</span></span><br><span class="line">            <span class="keyword">while</span>(trb&gt;lb)&#123;</span><br><span class="line">                res.add(matrix[tra][trb--]);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">while</span>(tra&gt;la)&#123;</span><br><span class="line">                res.add(matrix[tra--][trb]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向内靠拢（缩圈）</span></span><br><span class="line">        la++;</span><br><span class="line">        lb++;</span><br><span class="line">        ra--;</span><br><span class="line">        rb--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟的方式相对要复杂点，需要记录每个节点是否访问然后在选择，这里的方式就很巧妙，直接按层遍历，由外到内，不用考虑那么多。时间复杂度<code>O(NM)</code>空间复杂度<code>O(NM)</code>。</p>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<blockquote>
<p>UPDATE(2020.12.17)：更新了通用的解法，对应 <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/758/">AcWing756. 蛇形矩阵</a>，美化了下代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="type">int</span> <span class="variable">la</span> <span class="operator">=</span> <span class="number">0</span>, lb = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ra</span> <span class="operator">=</span> n-<span class="number">1</span>, rb = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (la &lt;= ra &amp;&amp; lb &lt;= rb) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tla</span> <span class="operator">=</span> la, tlb = lb;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tra</span> <span class="operator">=</span> ra, trb = rb;</span><br><span class="line">            <span class="keyword">if</span> (la == ra) &#123;</span><br><span class="line">                <span class="keyword">while</span> (tlb &lt;= rb) res[la][tlb++] = v++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lb == rb) &#123;</span><br><span class="line">                <span class="keyword">while</span> (tla &lt;= ra) res[tla++][rb] = v++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (tlb &lt; rb) res[la][tlb++] = v++;</span><br><span class="line">            <span class="keyword">while</span> (tla &lt; ra) res[tla++][rb] = v++;</span><br><span class="line">            <span class="keyword">while</span> (trb &gt; lb) res[ra][trb--] = v++;</span><br><span class="line">            <span class="keyword">while</span> (tra &gt; la) res[tra--][lb] = v++;</span><br><span class="line">            la++; lb++;</span><br><span class="line">            ra--; rb--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                System.out.print(res[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一题的简化版，2020.2.11 白板写的，还行</p>
<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>说明：</strong></p>
<p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Given <span class="type">input</span> <span class="variable">matrix</span> <span class="operator">=</span> </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Given <span class="type">input</span> <span class="variable">matrix</span> <span class="operator">=</span></span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>这题和上面哪一题放在一起很有必要，很类似的题型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="literal">null</span> || matrix.length==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=matrix.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> lx=<span class="number">0</span>,ly=<span class="number">0</span>,rx=len,ry=len;</span><br><span class="line">    <span class="keyword">while</span>(lx&lt;=rx)&#123;</span><br><span class="line">        <span class="comment">//len=ry-ly;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp=matrix[lx][ly+i];</span><br><span class="line">            matrix[lx][ly+i]=matrix[rx-i][ly];</span><br><span class="line">            matrix[rx-i][ly]=matrix[rx][ry-i];</span><br><span class="line">            matrix[rx][ry-i]=matrix[lx+i][ry];</span><br><span class="line">            matrix[lx+i][ry]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缩圈</span></span><br><span class="line">        len-=<span class="number">2</span>; <span class="comment">//写 ry-ly 可能会好一点，无所谓</span></span><br><span class="line">        lx++;ly++;</span><br><span class="line">        rx--;ry--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上一题一样，都是从整体出发，从外层到内层，考虑每一层的前<code>n-1</code>个节点的旋转过程，这个过程需要自己在纸上画一画，空想容易搞错</p>
<p><strong>解法二</strong></p>
<p>新学到的解法，挺有意思的，整体沿对角线交换，然后每行沿中点交换，这个其实可以通过观察数组结构得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="literal">null</span> || matrix.length&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> N=matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[j][i];</span><br><span class="line">            matrix[j][i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,k=N-<span class="number">1</span>;j&lt;k;j++,k--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[i][k];</span><br><span class="line">            matrix[i][k]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diagonal-traverse/">498. 对角线遍历</a></h2><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出：[1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure>

<p> <img src="https://s1.ax1x.com/2020/05/01/JXlfOg.png" alt="JXlfOg.png"></p>
<p><strong>说明：</strong></p>
<ol>
<li>给定矩阵中的元素总数不会超过 100000 。</li>
</ol>
<p><strong>解法一</strong></p>
<p>因为是先做的下面的那一题，所以我这里直接延用了前面的思路，借助了 map 额外的空间，其实做复杂了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助额外空间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">if</span> matrix == <span class="literal">nil</span> || m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    hmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">    flagRow := <span class="literal">false</span> <span class="comment">//行开头标志位</span></span><br><span class="line">    <span class="keyword">for</span> i, row := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">        flagColumn := flagRow <span class="comment">//列标志位</span></span><br><span class="line">        <span class="keyword">for</span> j, num := <span class="keyword">range</span> row &#123;</span><br><span class="line">            <span class="keyword">if</span> flagColumn &#123;</span><br><span class="line">                hmap[i+j] = <span class="built_in">append</span>(hmap[i+j], num)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hmap[i+j] = <span class="built_in">append</span>([]<span class="type">int</span>&#123;num&#125;, hmap[i+j]...)</span><br><span class="line">            &#125;</span><br><span class="line">            flagColumn = !flagColumn</span><br><span class="line">        &#125;</span><br><span class="line">        flagRow = !flagRow</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m*n; i++ &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, hmap[i]...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>模拟，不过是从整体上模拟，比较好的解法，不借助 map</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较好的解法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">if</span> matrix == <span class="literal">nil</span> || m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    leftX := <span class="number">0</span></span><br><span class="line">    leftY := <span class="number">0</span></span><br><span class="line">    rightX := <span class="number">0</span></span><br><span class="line">    rightY := <span class="number">0</span></span><br><span class="line">    flag := <span class="literal">true</span></span><br><span class="line">    <span class="comment">//左右端点沿着矩形边缘移动就行了</span></span><br><span class="line">    <span class="keyword">for</span> leftX &lt; m &amp;&amp; leftY &lt; n &#123;</span><br><span class="line">        help(matrix, leftX, leftY, rightX, rightY, flag, &amp;res)</span><br><span class="line">        <span class="keyword">if</span> leftX == m<span class="number">-1</span> &#123; <span class="comment">//左端点到达边界</span></span><br><span class="line">            leftY++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftX++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rightY == n<span class="number">-1</span> &#123; <span class="comment">//右端点到达边界</span></span><br><span class="line">            rightX++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightY++</span><br><span class="line">        &#125;</span><br><span class="line">        flag = !flag <span class="comment">//反转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 (lx,ly) 和 (rx,ry) 之间的点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">help</span><span class="params">(matrix [][]<span class="type">int</span>, lx, ly, rx, ry <span class="type">int</span>, flag <span class="type">bool</span>, res *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> lx &gt;= rx &amp;&amp; ly &lt;= ry &#123;</span><br><span class="line">        <span class="keyword">if</span> flag &#123;</span><br><span class="line">            *res = <span class="built_in">append</span>(*res, matrix[lx][ly])</span><br><span class="line">            lx--</span><br><span class="line">            ly++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *res = <span class="built_in">append</span>(*res, matrix[rx][ry])</span><br><span class="line">            rx++</span><br><span class="line">            ry--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1424-对角线遍历-II"><a href="#1424-对角线遍历-II" class="headerlink" title="1424. 对角线遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diagonal-traverse-ii/">1424. 对角线遍历 II</a></h2><p>给你一个列表 <code>nums</code> ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://s1.ax1x.com/2020/05/01/JOOOEt.png" alt="JOOOEt.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://s1.ax1x.com/2020/05/01/JOXkEq.png" alt="JOXkEq.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i].length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i][j] &lt;= 10^9</code></li>
<li><code>nums</code> 中最多有 <code>10^5</code> 个数字。</li>
</ul>
<p><strong>解法一</strong></p>
<p>186th 周赛的 t3，还是挺有意思的，这题我拿到的第一想法其实是找一下关系直接排序，但是实际上有更好的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(nums [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//最大的行列值</span></span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, row := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j, num := <span class="keyword">range</span> row &#123;</span><br><span class="line">            <span class="comment">//逆序添加</span></span><br><span class="line">            m[i+j] = <span class="built_in">append</span>([]<span class="type">int</span>&#123;num&#125;, m[i+j]...)</span><br><span class="line">            n = max(n, i+j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//res := make([]int, n)</span></span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, m[i]...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的解法其实和 N 皇后里面对行列的处理是一样的，两条对角线，一条行列和相等，一条行列差相等</p>
<blockquote>
<p>这题我还看到了至少 3 种不同的方法，有一种把这个数组旋转一下，然后当成二叉树，直接做 BFS 层次遍历😂，脑洞挺大的</p>
</blockquote>
<h2 id="215-数组中的第-K-个最大元素"><a href="#215-数组中的第-K-个最大元素" class="headerlink" title="215. 数组中的第 K 个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第 K 个最大元素</a></h2><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<blockquote>
<p>这题必须多说几句</p>
</blockquote>
<p><strong>解法一</strong></p>
<p>大根堆的做法（首先想到的方法，不是常规用堆的做法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//构建了大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        siftUp(nums,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        swap(nums,<span class="number">0</span>,size);<span class="comment">//和堆顶交换 K 次</span></span><br><span class="line">        siftDown(nums,<span class="number">0</span>,--size);<span class="comment">//重新调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(nums[i]&gt;nums[(i-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">        swap(nums,i,(i-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        i=(i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i 变小 下沉</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="comment">//判断有没有子节点（左孩子）</span></span><br><span class="line">    <span class="type">int</span> left=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;size)&#123;</span><br><span class="line">        <span class="type">int</span> right=left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点最大值</span></span><br><span class="line">        <span class="type">int</span> larger=left+<span class="number">1</span>&lt;size &amp;&amp; nums[left]&lt;nums[left+<span class="number">1</span>] ?left+<span class="number">1</span>:left;</span><br><span class="line">        <span class="keyword">if</span>(nums[larger]&gt;nums[i])&#123;</span><br><span class="line">            swap(nums,larger,i);</span><br><span class="line">            i=larger;</span><br><span class="line">            left=larger*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>70%左右的 beat，当时感觉还行，时间复杂度应该是<code>O(KlogN)</code>，后来越想越不对，又去看了下堆排序，发现我之前写的堆排序都是有问题的</p>
<p><strong>优化后的大根堆做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> last=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=nums.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        siftDown(nums,i,last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        swap(nums,<span class="number">0</span>,last);</span><br><span class="line">        siftDown(nums,<span class="number">0</span>,--last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i 变小 下沉</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> last)</span>&#123;</span><br><span class="line">    <span class="comment">//判断有没有子节点（左孩子）</span></span><br><span class="line">    <span class="type">int</span> left=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=last)&#123;</span><br><span class="line">        <span class="type">int</span> right=left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点最大值</span></span><br><span class="line">        <span class="type">int</span> larger=right&lt;=last &amp;&amp; nums[right] &gt; nums[left]?right:left;</span><br><span class="line">        <span class="keyword">if</span>(nums[larger]&gt;nums[i])&#123;</span><br><span class="line">            swap(nums,larger,i);</span><br><span class="line">            i=larger;</span><br><span class="line">            left=larger*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>95% beat，比上面的要快很多，相比之前的方法，构造堆的方式发生了变化，上面那种通过自上而下的 insert 方式时间复杂度是 O(NlogN)，其实想想，这两种方式是完全相反的，insert 的方式，最后一层每个元素最坏都可能调整<code>logN</code>次，而最后一层也是元素最多的一层，这样一来复杂度就会大大增加，相反如果采用从底向上的<code>swim</code>方式最后一层都只需要调整<code>1</code>次，而根节点需要调整<code>logN</code>次，而根节点只有一个，时间复杂度就会大大降低，最终的时间复杂度就是<code>O(N)</code>，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20729324">具体推算可以看这篇文章</a>， 现在的时间复杂度才真的是<code>O(KlogN)</code></p>
<p><img src="http://static.imlgw.top/image/20190617/kVuvnMfjuSns.png?imageslim" alt="mark"></p>
<blockquote>
<p>💥💥 上面这两种做法是有问题的，失去了用堆的优势，大根堆的做法必须要阿将整个堆构建完成后才能去找 topk 这样的话内存消耗比较大，应该维护一个小根堆，这样如果数据量很大的时候不用全读入内存中，  这题因为是我自己实现的堆，所以建堆的复杂度是 O(N)（如果使用官方的 API，建堆的时间复杂度就是 NlogN），最终大根堆小根堆复杂度取决于 K 和 N 的大小关系，但是面试的时候最好不要说用大根堆的做法</p>
</blockquote>
<p><strong>解法二</strong></p>
<p>小根堆的做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> size=nums.length;</span><br><span class="line">    <span class="comment">//先维护一个大小为 k 的小根堆 , 这里要注意 k 不是下标，k=index+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k/<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapIfy(nums,i,k);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//再从 k 开始向里面插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=k;i&lt;size;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[<span class="number">0</span>]) &#123; <span class="comment">//大于小根堆堆顶，进取代它</span></span><br><span class="line">            <span class="comment">//小根堆求第 K 大，保证这个堆的元素是整个堆的前 k 大的元素，堆顶就是第 k 大</span></span><br><span class="line">            swap(nums,i,<span class="number">0</span>);</span><br><span class="line">            heapIfy(nums,<span class="number">0</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小于堆顶就不用管了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小根堆调整</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">heapIfy</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> right &lt; size &amp;&amp; nums[right] &lt; nums[left] ? right: left;</span><br><span class="line">        <span class="keyword">if</span>(nums[small]&lt;nums[i]) &#123;</span><br><span class="line">            swap(nums,small,i);</span><br><span class="line">            i=small;</span><br><span class="line">            left=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[l];</span><br><span class="line">    nums[l] = nums[r];</span><br><span class="line">    nums[r] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2ms，99%beat，一般情况下的 topK 问题，如果用堆解决的话应该都是采用<strong>小根堆</strong>这种做法来做，时间复杂度为<code>O(NlogK)</code>，维护一个大小为 k 的小根堆，然后再遍历后面 n-k 个元素，依次和当前最小堆的堆顶比较（当前 topK 中的最小元素，堆顶），如果比它小就和它交换然后调整堆，这样就始终保持了这个堆是当前的 topK 小，最后的堆顶就是第 K 大的元素。</p>
<p><em>关于节省空间的问题，其实很好理解，去找一个 OJ 试一下就懂了</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> K=sc.nextInt();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num=sc.nextInt(); <span class="comment">//一个个的读入，而不是一起读入</span></span><br><span class="line">            queue.add(num);</span><br><span class="line">            <span class="keyword">if</span>(queue.size()&gt;K)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法三</strong></p>
<p>其实还有一类做法，利用<code>快排+二分</code>的思想，一般也被称为快选</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=nums.length;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//分治</span></span><br><span class="line">        <span class="type">int</span> base=partion(nums,left,right); <span class="comment">//拿到划分点</span></span><br><span class="line">        <span class="keyword">if</span>(base&lt;n-k)&#123;</span><br><span class="line">            left=base+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(base&gt;n-k)&#123;</span><br><span class="line">            right=base-<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[base];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partion</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//随机取值</span></span><br><span class="line">    swap(nums,left,left+(<span class="type">int</span>) (Math.random() * (right - left + <span class="number">1</span>)));</span><br><span class="line">    <span class="type">int</span> base=left;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;nums[base])&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=nums[base])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    swap(nums,left,base);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最好用<strong>随机</strong>的** partition<strong>，我试了下</strong>不随机<strong>大概<code>50+ms 30%beat</code>，这种随机的大概<code>3ms 97%beats </code>，差距还是很大的，时间复杂度是</strong> O(N)**</p>
<blockquote>
<p>至于为什么是 O(N)，我们可以来分析下，这里<strong>假设每次划分都是差不多中点的位置</strong>，如果是快排，那么在** partition <strong>之后依然需要两边的子数组进行</strong> partition<strong>，分治整个递归栈的高度就是<code>logN</code>，每层都是 N，所以整体的复杂度就</strong> O(NlogN)**…. 扯远了，回到正题</p>
<p>来说说我们这里为什么是 O(N)，这里我们沿用前面的分析过程，递归栈深度依然是<code>logN</code>，但是我们在这里第一次确定划分点的相对** k <strong>的位置后，下一步</strong>只需要划分其中一边的元素，不用对另一边的元素继续**，也就是 n/2，再往下就是 n/4，n/8，n/16 ….   而 <code>(1+1/2+1/4+1/8+......1/2^n)n &lt;=2n</code> ，也就是说整体的复杂度是低于 O(2N) 的，所以这里复杂度就是 O(N)</p>
</blockquote>
<p><strong>三切分快排优化</strong></p>
<p>ACWing 上交的，wa 了好几次，发现是二分写错了，哎，二分真难，其实还可以做一下随机处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> K=sc.nextInt()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) nums[i]=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=N-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span>[] equ=partition(nums,left,right);</span><br><span class="line">            <span class="keyword">if</span>(K&gt;equ[<span class="number">1</span>])&#123;</span><br><span class="line">                left=equ[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(K&lt;equ[<span class="number">0</span>])&#123;</span><br><span class="line">                right=equ[<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(nums[equ[<span class="number">0</span>]]);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(nums[left]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="type">int</span> less=left-<span class="number">1</span>,more=right,base=nums[right];</span><br><span class="line">        <span class="type">int</span> i=left;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;base)&#123;</span><br><span class="line">                swap(nums,++less,i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;base)&#123;</span><br><span class="line">                swap(nums,--more,i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//归位</span></span><br><span class="line">        swap(nums,right,more++);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;less+<span class="number">1</span>,more-<span class="number">1</span>&#125;; <span class="comment">//返回等于区域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=nums[a];</span><br><span class="line">        nums[a]=nums[b];</span><br><span class="line">        nums[b]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Update: 2020.6.28</strong></p>
<p>用 go 重写下，又写了半天。真的菜，主要是最后划分元素的时候，区间只有 1 也应该继续划分，也就是<code>left &lt;= right</code>，上面的解法就没考虑这个，而是在循环退出后返回 left，实际上并不是好方法。（后面还是会再写的，尽量缩短 code 时间）</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 2 3 4 5 6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    k = <span class="built_in">len</span>(nums) - k <span class="comment">//转换下</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right&#123; <span class="comment">//第一个 WA 点，这里是最容易写错的</span></span><br><span class="line">        mid := partition(nums, left, right)</span><br><span class="line">        <span class="keyword">if</span> mid[<span class="number">1</span>] &lt; k&#123;</span><br><span class="line">            left = mid[<span class="number">1</span>]+<span class="number">1</span> <span class="comment">//WA 点</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> mid[<span class="number">0</span>] &gt; k&#123;</span><br><span class="line">            right = mid[<span class="number">0</span>]<span class="number">-1</span> <span class="comment">//WA 点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid[<span class="number">0</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, left <span class="type">int</span>, right <span class="type">int</span>)</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    base := left</span><br><span class="line">    <span class="keyword">var</span> less = left</span><br><span class="line">    <span class="keyword">var</span> more = right+<span class="number">1</span> <span class="comment">//WA 点</span></span><br><span class="line">    <span class="keyword">var</span> i = left</span><br><span class="line">    <span class="keyword">for</span> i &lt; more&#123; <span class="comment">//WA 点</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[base]&#123;</span><br><span class="line">            less++</span><br><span class="line">            nums[less], nums[i] = nums[i], nums[less]</span><br><span class="line">            i++</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[i] &gt; nums[base]&#123;</span><br><span class="line">            more--</span><br><span class="line">            nums[more], nums[i] = nums[i], nums[more]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[less], nums[base] = nums[base], nums[less]</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;less,more<span class="number">-1</span>&#125; <span class="comment">//WA 点，注意配合上面的二分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法四</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31498036">BFPRT 算法</a> 大佬们提出来的根据上面快排改进而来，其实面试把小根堆和快排的解法答出来应该就差不多了，这个解法还是有些不容易写出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findKthLargest(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid=findMid(nums,l,r);</span><br><span class="line">    swap(nums,mid,l);</span><br><span class="line">    <span class="type">int</span> m=partition(nums,l,r);</span><br><span class="line">    <span class="keyword">if</span>(m==nums.length-k)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的类似了</span></span><br><span class="line">    <span class="keyword">if</span>(m&gt;nums.length-k)&#123;</span><br><span class="line">        <span class="keyword">return</span> findKthLargest(nums,l,m-<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findKthLargest(nums,m+<span class="number">1</span>,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中位数的中位数，主要的核心就是在这里</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">findMid</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="type">int</span> leftSub=l;</span><br><span class="line">    <span class="comment">//分组求中位数，5 等分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=l;i&lt;r-<span class="number">4</span>;i+=<span class="number">5</span>) &#123;</span><br><span class="line">        insertSort(nums,i,i+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//将每一组的中位数统一放到左侧，用于递归</span></span><br><span class="line">        swap(nums,leftSub++,i+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理剩下的不足 5 个的</span></span><br><span class="line">    <span class="keyword">if</span> (r-l&lt;<span class="number">4</span>) &#123;</span><br><span class="line">        insertSort(nums,l,r);</span><br><span class="line">        swap(nums,leftSub,l+(r-l)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到了</span></span><br><span class="line">    <span class="keyword">if</span>(l==leftSub)&#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMid(nums,l,leftSub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五等分的插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&gt;=l&amp;&amp;nums[j]&lt;nums[i];j--) &#123;</span><br><span class="line">            swap(nums,j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排 partition</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> base=left;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;nums[base])&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=nums[base])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    swap(nums,left,base);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31498036">具体的时间复杂度证明</a>，当 n 取 5 时候，在划分的时候<strong>至少</strong>会大于** 3n/10 **的元素，避免了极端情况，保证在最坏情况下也不会太坏。</p>
<p><img src="http://static.imlgw.top/image/20190617/Lc4M5f2qkegH.png?imageslim" alt="mark"></p>
<p>如上图，每一列为分好的一组元素，中间黄色部分为每组的中位数，红色块为<strong>中位数的中位数</strong>，这个中位数至少会大于等于左上角黑框框住的部分，所以在划分的时候会保证至少减小大约 3n/10 的规模。</p>
<p>所以时间复杂度   <code>T(N)&lt;=T(n/5)+T( 7n/10)+c*n</code>  总体时间复杂度** O(N)**，至于为什么不用其他的元素可以看看上面的那篇文章。</p>
<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">你可以假设给定的 k 总是合理的，且 <span class="number">1</span> ≤ k ≤ 数组中不相同的元素的个数。</span><br><span class="line">你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span><br></pre></td></tr></table></figure>

<p>也是 TopK 问题，但是这题其实还有个条件，<code>不会给出有歧义的数据</code> ，举个例子</p>
<p><code>nums=[1,1,1,2,2,2,3,3,3] ，k=2</code> 这样的就是有歧义的</p>
<p>但是题目中也没有规定这样的如何处理，经过测试，发现官方的解在遇到这种情况会抛一个异常。</p>
<p><strong>解法一</strong></p>
<p>大根堆的做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">topKFrequent</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; fre=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="comment">//fre.get(i) nums[i] 出现的频次</span></span><br><span class="line">        fre.put(nums[i],fre.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1:3,2:3,3:1</span></span><br><span class="line">    PriorityQueue&lt;HashMap.Entry&lt;Integer,Integer&gt;&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="keyword">new</span> <span class="title class_">ComparatorMap</span>());</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Entry ent:fre.entrySet()) &#123;</span><br><span class="line">        pq.add(ent);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        res.add(pq.poll().getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ComparatorMap</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;HashMap.Entry&lt;Integer,Integer&gt;&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getValue()-o1.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用大根堆不太好，容易爆内存，但是在这一题可以保证顺序，<code>但是题目并没有要求顺序</code>，时间复杂度<del>O(KlogN)</del></p>
<p>这里错了，建堆的时间复杂度就是<code>O(NlogN)</code>了，只有自己手写的堆，采用自底向上的方式建堆时间复杂度才是 O(N) ，可以参考 <a href="http://imlgw.top/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%9B%B4%E4%BC%98%E7%9A%84%E5%81%9A%E6%B3%95">之前的文章</a> ，这也是上面 topK 问题中提到的</p>
<p><strong>解法二</strong></p>
<p>小根堆的做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UPDATE：2020.9.7 之前的解法太丑陋了</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; freq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        freq.put(nums[i], freq.getOrDefault(nums[i], <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int[0]: count int[1]: val </span></span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//freq.forEach();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : freq.keySet()) &#123;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;freq.get(key), key&#125;);</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        res[i++] = pq.poll()[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度<code>O(NlogK)</code>因为只维护了一个 K 大小的小根堆 ，时间复杂度和大根堆<del>O(KlogN)</del> <code>O(NlogN)</code>相比会快很多，除此之外，如果 N 和 K 很接近的话可以考虑<code>O(Nlog(N-K))</code> 的做法，维护一个 N-K 的大根堆，里面存频率最低的那些元素，最后返回其他的元素（no code， just talk）</p>
<p><strong>解法三</strong></p>
<p>桶排序，这题的最优解应该就是桶排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">topKFrequent</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; fre=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="comment">//记录 nums[i] 出现的频次</span></span><br><span class="line">        fre.put(nums[i],fre.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; [] bucket=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (Integer num:fre.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bucket[fre.get(num)]==<span class="literal">null</span>)&#123;</span><br><span class="line">            bucket[fre.get(num)]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//桶排序</span></span><br><span class="line">        bucket[fre.get(num)].add(num); <span class="comment">//所有出现 fre.get(num) 次的元素构成一条链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> topk=bucket.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从后向前遍历（从频次大到小）</span></span><br><span class="line">        <span class="comment">//指针移动到合适的位置</span></span><br><span class="line">        <span class="keyword">while</span>(bucket[topk]==<span class="literal">null</span>&amp;&amp;topk&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            topk--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.addAll(bucket[topk--]);</span><br><span class="line">        <span class="keyword">if</span>(res.size()==k)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桶排序的思路，时间复杂度<code>O(N)</code>，空间复杂度也是<code>O(N)</code>，在 leetcode 提交三种方法的差距不大，可能是数据量太少了</p>
<p><strong>解法四</strong> (UPDATE:2020.9.7)</p>
<p>基于快选的做法，时间复杂度 O(N)，之前一直懒得写，今天补一下</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> freq = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        freq[nums[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nodes []*Node</span><br><span class="line">    <span class="keyword">for</span> val, count := <span class="keyword">range</span> freq &#123;</span><br><span class="line">        nodes = <span class="built_in">append</span>(nodes, &amp;Node&#123;val, count&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7 0 1 2 9 10</span></span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> left, right = <span class="number">0</span>, <span class="built_in">len</span>(nodes) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := partition(nodes, left, right)</span><br><span class="line">        <span class="keyword">if</span> mid == k<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= mid; i++ &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, nodes[i].Val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> mid &gt; k<span class="number">-1</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []*Node, i <span class="type">int</span>, j <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//7 9 10 0 1 2</span></span><br><span class="line">    <span class="comment">//随机下会好一点</span></span><br><span class="line">    <span class="keyword">var</span> base = i</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j].Count &lt;= nums[base].Count &#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i].Count &gt;= nums[base].Count &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i], nums[base] = nums[base], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addNum(<span class="number">1</span>)</span><br><span class="line">addNum(<span class="number">2</span>)</span><br><span class="line">findMedian() -&gt; <span class="number">1.5</span></span><br><span class="line">addNum(<span class="number">3</span>) </span><br><span class="line">findMedian() -&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<ul>
<li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li>
<li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li>
</ul>
<p><strong>解法一</strong></p>
<p>这题很久之前就听人讲过，不过忘记了，最佳策略就是利用小根堆+大根堆，分别维护前半部分和后半部分的最值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; minQue=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxQue=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MedianFinder295</span><span class="params">()</span> &#123;</span><br><span class="line">    minQue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    maxQue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    minQue.add(num);</span><br><span class="line">    maxQue.add(minQue.poll());</span><br><span class="line">    <span class="keyword">if</span>(minQue.size()&lt;maxQue.size())&#123;</span><br><span class="line">        minQue.add(maxQue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(minQue.size()==maxQue.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> (minQue.peek()+maxQue.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minQue.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前半部分用大跟堆，后半部分小根堆，每次将一个堆的最值放到另一个堆中，这样保证了大跟堆的最大值一定小于小根堆的最小值，另外我们还需要保证两个堆的差距不能大于 1，这里我将多的放到小根堆中，最后在奇数的时候将小根堆的堆顶弹出就可以了</p>
<h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></h2><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：输入数组表示数字 <span class="number">123</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：输入数组表示数字 <span class="number">4321</span>。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>模拟进位</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(digits) - <span class="number">1</span></span><br><span class="line">    carry := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        digits[n] += carry</span><br><span class="line">        carry = digits[n] / <span class="number">10</span></span><br><span class="line">        digits[n] %= <span class="number">10</span></span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry == <span class="number">1</span> &#123;</span><br><span class="line">        digits = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">1</span>&#125;, digits...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和</a></h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为非空字符串且只包含数字 1 和 0。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：a = <span class="string">&quot;11&quot;</span>, b = <span class="string">&quot;1&quot;</span></span><br><span class="line">输出：<span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：a = <span class="string">&quot;1010&quot;</span>, b = <span class="string">&quot;1011&quot;</span></span><br><span class="line">输出：<span class="string">&quot;10101&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>这题和下面的题目是我有意放在一起的，这题也可以作为大数相加的模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br><span class="line">    <span class="type">int</span> idxA=a.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> idxB=b.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> carry=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//int carry=0;</span></span><br><span class="line">    <span class="keyword">while</span>(idxA &gt;=<span class="number">0</span> || idxB &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> bina=idxA&gt;=<span class="number">0</span>?a.charAt(idxA):<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> binb=idxB&gt;=<span class="number">0</span>?b.charAt(idxB):<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(bina == <span class="string">&#x27;1&#x27;</span> &amp;&amp; binb ==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            res.append(carry?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            carry=<span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((bina == <span class="string">&#x27;1&#x27;</span> &amp;&amp; binb ==<span class="string">&#x27;0&#x27;</span>) ||(bina == <span class="string">&#x27;0&#x27;</span> &amp;&amp; binb ==<span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">            res.append(carry?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(carry?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            carry=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idxA--;idxB--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry) res.append(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>上面的解法是完全的模拟解法，不够优雅</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br><span class="line">    <span class="type">int</span> idxA=a.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> idxB=b.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idxA &gt;=<span class="number">0</span> || idxB &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum=carry;</span><br><span class="line">        sum+=idxA&gt;=<span class="number">0</span>?a.charAt(idxA)-<span class="number">48</span>:<span class="number">0</span>;</span><br><span class="line">        sum+=idxB&gt;=<span class="number">0</span>?b.charAt(idxB)-<span class="number">48</span>:<span class="number">0</span>;</span><br><span class="line">        res.append(sum%<span class="number">2</span>);</span><br><span class="line">        carry=sum/<span class="number">2</span>;</span><br><span class="line">        idxA--;idxB--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
<p><strong>注意：</strong></p>
<ol>
<li>num1 和 num2 的长度都小于 5100.</li>
<li>num1 和 num2 都只包含数字 0-9.</li>
<li>num1 和 num2 都不包含任何前导零。</li>
<li>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</li>
</ol>
<p><strong>解法一</strong></p>
<p>一开始没找到这题，后面偶然发现的，随手写一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> m=num1.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n=num2.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">0</span> || m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a= m&gt;=<span class="number">0</span>?num1.charAt(m)-<span class="number">48</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b= n&gt;=<span class="number">0</span>?num2.charAt(n)-<span class="number">48</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=a+b+carry;</span><br><span class="line">        carry=sum/<span class="number">10</span>;</span><br><span class="line">        sb.append(sum%<span class="number">10</span>);</span><br><span class="line">        m--;n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry==<span class="number">1</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;2&quot;</span>, num2 = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出：<span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;123&quot;</span>, num2 = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出：<span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li>num1 和 num2 的长度小于 110。</li>
<li>num1 和 num2 只包含数字 0-9。</li>
<li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li>
<li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li>
</ol>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">multiply2</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="comment">// 1 2 3 </span></span><br><span class="line">    <span class="comment">// 4 5 6</span></span><br><span class="line">    <span class="comment">// 501 6</span></span><br><span class="line">    <span class="type">int</span> n1=num1.length();</span><br><span class="line">    <span class="type">int</span> n2=num2.length();</span><br><span class="line">    <span class="comment">//n1*n2 结果最长为 n1+n2</span></span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[n1+n2];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n1-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=n2-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="comment">//主要就是对这个 i+j+1 的理解</span></span><br><span class="line">            res[i+j+<span class="number">1</span>]+=(num1.charAt(i)-<span class="number">48</span>)*(num2.charAt(j)-<span class="number">48</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            res[i-<span class="number">1</span>]+=res[i]/<span class="number">10</span>;</span><br><span class="line">            res[i]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉前面多余的 0</span></span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;res.length-<span class="number">1</span>&amp;&amp;res[index]==<span class="number">0</span>) &#123; </span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=index;i&lt;res.length;i++) &#123;</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是模拟的手算的过程，关键的地方就是 <code>i+j+1</code> 的理解</p>
<p><img src="http://static.imlgw.top/blog/20190928/4xnHi4yd4hwA.png?imageslim" alt="mark"></p>
<p><strong>解法二</strong></p>
<p>其实仔细分析，会发现上面的代码其实有很多多余的操作，比如去掉前面的 0，因为两个<strong>非 0 的数相乘</strong>，最后的结果最多 n1+n2 位，最少 n1+n2-1 位，所以前面的 0 <strong>最多就一个</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n1=num1.length();</span><br><span class="line">    <span class="type">int</span> n2=num2.length();</span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[n1+n2];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n1-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=n2-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="comment">//注意这里的 i+j+1</span></span><br><span class="line">            res[i+j+<span class="number">1</span>]+=(num1.charAt(i)-<span class="number">48</span>)*(num2.charAt(j)-<span class="number">48</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理进位（其实这里 res[0] 是不可能大于 10 的），模拟下知道了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            res[i-<span class="number">1</span>]+=res[i]/<span class="number">10</span>;</span><br><span class="line">            res[i]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.length;i++) &#123;</span><br><span class="line">        <span class="comment">//前面最多只有一个 0（除了两个数中有一个为 0 的时候）</span></span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; res[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法三</strong></p>
<p>其实上面的进位和计算对应位置的值可以同时处理，这是最接近人手算的思路了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//update: 2020.4.16 在 web 上重新推了一遍</span></span><br><span class="line"><span class="comment">//idx : 0 1 2</span></span><br><span class="line"><span class="comment">//i :   4 5 6</span></span><br><span class="line"><span class="comment">//j :   1 2 3</span></span><br><span class="line"><span class="comment">//   ——————————</span></span><br><span class="line"><span class="comment">//    1 3 6 8 (i+j+1)</span></span><br><span class="line"><span class="comment">//    9 1 2</span></span><br><span class="line"><span class="comment">//  4 5 6</span></span><br><span class="line"><span class="comment">//  ——————————</span></span><br><span class="line"><span class="comment">//0 1 2 3 4 5</span></span><br><span class="line"><span class="comment">//0 5 6 0 8 8  </span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num1==<span class="literal">null</span> || num2==<span class="literal">null</span>) <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="type">int</span> n1=num1.length(),n2=num2.length();</span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[n1+n2];</span><br><span class="line">    <span class="comment">//如果想同时处理进位的话就必须倒推</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n1-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n2-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="type">int</span> sum=res[i+j+<span class="number">1</span>]+(num1.charAt(i)-<span class="number">48</span>)*(num2.charAt(j)-<span class="number">48</span>);</span><br><span class="line">            res[i+j+<span class="number">1</span>]=sum%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//res[i+j] 会超过 10, 但是由于我们是倒推的，所以这个会在下一轮进行处理，否则就无法处理了</span></span><br><span class="line">            res[i+j]+=sum/<span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//n*m 位数 乘积应该是 (m+n-1 ~ m+n) 位</span></span><br><span class="line">    <span class="comment">//前两个为 0 一定是 0</span></span><br><span class="line">    <span class="keyword">if</span>(res[<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; res[<span class="number">1</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="comment">//去除前导 0（最多一个）</span></span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]==<span class="number">0</span> &amp;&amp; i==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h2><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 <code>[−231,  231 − 1]</code>。如果数值超过这个范围，请返回  <code>INT_MAX (231 − 1)</code> 或 <code>INT_MIN (−231)</code> </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;42&quot;</span></span><br><span class="line">输出：<span class="number">42</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;   -42&quot;</span></span><br><span class="line">输出：-<span class="number">42</span></span><br><span class="line">解释：第一个非空白字符为 <span class="string">&#x27;-&#x27;</span>, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -<span class="number">42</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;4193 with words&quot;</span></span><br><span class="line">输出：<span class="number">4193</span></span><br><span class="line">解释：转换截止于数字 <span class="string">&#x27;3&#x27;</span> ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>之前一直很排斥这道题，知道这次朋友阿里面试问了这道题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span> || str.length()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> MAX=Integer.MAX_VALUE,MIN=Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//过滤空格</span></span><br><span class="line">    <span class="keyword">while</span>(index&lt;str.length()&amp;&amp;str.charAt(index)==<span class="string">&#x27; &#x27;</span>)index++;</span><br><span class="line">    <span class="keyword">if</span>(index==str.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//取正负号</span></span><br><span class="line">    <span class="type">char</span> firstChar=str.charAt(index);</span><br><span class="line">    <span class="type">boolean</span> positive=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!isDigit(firstChar))&#123;</span><br><span class="line">        <span class="keyword">if</span>(firstChar!=<span class="string">&#x27;+&#x27;</span>&amp;&amp;firstChar!=<span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        index++;</span><br><span class="line">        positive = firstChar!=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正负数的边界</span></span><br><span class="line">    <span class="type">int</span> limit=positive?-MAX:MIN;</span><br><span class="line">    <span class="comment">//过滤 0</span></span><br><span class="line">    <span class="keyword">while</span>(index&lt;str.length()&amp;&amp;str.charAt(index)==<span class="string">&#x27;0&#x27;</span>)index++;</span><br><span class="line">    <span class="comment">//取每一位，在非字符截止</span></span><br><span class="line">    <span class="keyword">while</span>(index&lt;str.length()&amp;&amp;isDigit(str.charAt(index)))&#123;</span><br><span class="line">        <span class="type">int</span> digit=str.charAt(index++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(res&lt;(limit+digit)/<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> positive?MAX:MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里的 res&gt;=limit</span></span><br><span class="line">        res=res*<span class="number">10</span>-digit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if(index!=str.length()) return 0; //中途遇到非数字（也是合法的）</span></span><br><span class="line">    <span class="keyword">return</span> positive?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考了<code>Integer.parseInt(String s, int radix)</code>方法对边界的处理方式，<strong>用负数来表示正负数的边界</strong></p>
<ol>
<li><p>这样正数的边界就是<code>-INT_MAX</code>, 负数是<code>INT_MIN</code></p>
</li>
<li><p>然后我们同样也用负数来保存结果，<code>res=res\*10-digit</code></p>
</li>
<li><p>我们需要保证这个值是在<code>INT</code>范围内的，也就是 res*10-digit&gt;=limit （负边界）</p>
</li>
<li><p>所以我们需要对<code>res</code>做判断，但是直接判断可能会溢出，所以进行移项，变换为 <code>res&lt;(limit+digit)/10</code></p>
</li>
<li><p>最后如果是正数就返回 <code>-res</code>, 负数就返回<code>res</code></p>
</li>
</ol>
<p>还是十分巧妙的 👏👏</p>
<h2 id="1071-字符串的最大公因子"><a href="#1071-字符串的最大公因子" class="headerlink" title="1071. 字符串的最大公因子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子</a></h2><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p>
<p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：str1 = <span class="string">&quot;ABCABC&quot;</span>, str2 = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;ABC&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：str1 = <span class="string">&quot;ABABAB&quot;</span>, str2 = <span class="string">&quot;ABAB&quot;</span></span><br><span class="line">输出：<span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：str1 = <span class="string">&quot;LEET&quot;</span>, str2 = <span class="string">&quot;CODE&quot;</span></span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>首先想到的方法，其实也是根据辗转相除法来的（这种好像叫更相减损术 ?）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6 4 gcd(6,4)=gcd(4,2)=gcd(2,0) return 2</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">gcdOfStrings</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str1.equals(str2))&#123;</span><br><span class="line">        <span class="keyword">return</span> str1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用减法替代除法求余数</span></span><br><span class="line">    <span class="keyword">while</span>(str1.length()&gt;=str2.length() &amp;&amp; index1&lt;str1.length() &amp;&amp; index2&lt;str2.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1.charAt(index1)!=str2.charAt(index2)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        index2++;</span><br><span class="line">        index1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//gcd(str2, 余数）</span></span><br><span class="line">    <span class="keyword">return</span> gcdOfStrings(str2,str1.substring(index1,str1.length()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>数学方法，比较巧妙</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">gcdOfStrings</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(str1+str2).equals(str2+str1))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(gcd(str1.length(),str2.length()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个条件充分性的证明还是有点不太理解，不过后面的最大公因子的长度就是 str1 和 str2 长度倒是可以通过反证来证明出来，这里直接 copy 题解 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/tan-tan-zheng-ming-wei-shi-yao-liang-zi-fu-chuan-c/">大佬</a> 的证明</p>
<p>假设两字符串的长度分别为 l1, l2, 他们的最大公约数是 k。<br>现已知道两字符串存在最大公因子（第一行代码），假设该字串的长度为<code>k&#39;</code>。</p>
<p>下面开始反证，<br>若<code>k&#39; &lt; k</code>，而根据题意<code>k&#39;</code>也为<code>l1, l2</code> 的公约数，则<code>k&#39;</code>必能被<code>k</code>整除，这说明我们可以将该字串的长度扩充到<code>k</code>，同时保持它仍然为<code>str1</code>和<code>str2</code>的公因子，所以这种情况下这个长度为<code>k</code>的公因子就不是最大公因子。<br>若<code>k&#39; &gt; k</code>， 根据题意<code>k&#39;</code>为<code>l1</code>, <code>l2</code> 的公约数， 而 k 为最大公约数，而这时出现了一个比最大公约数还大的公约数，这是矛盾的，所以这种情况也是不可能的。</p>
<p>综合以上，最大公因子的长度必然等于两串长度的最大公约数。</p>
<h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/">914. 卡牌分组</a></h2><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<ul>
<li>每组都有 X 张牌。</li>
<li>组内所有的牌上都写着相同的整数。</li>
</ul>
<p>仅当你可选的 X &gt;= 2 时返回 true。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">3</span>,<span class="number">3</span>]，[<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= deck.length &lt;= 10000</code></li>
<li><code>0 &lt;= deck[i] &lt; 10000</code></li>
</ul>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasGroupsSizeX</span><span class="params">(<span class="type">int</span>[] deck)</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;deck.length;i++)&#123;</span><br><span class="line">        map.put(deck[i],map.getOrDefault(deck[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer key:map.keySet()) &#123;</span><br><span class="line">        <span class="type">int</span> freq=map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(g==-<span class="number">1</span>) &#123;</span><br><span class="line">            g=freq;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(freq&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            g=gcd(freq,g);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g&gt;=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wa 一次就知道咋做了，一开始以为只要所有元素出现次数可以整除就行了，wa 了之后就意识到只要求一个最大公约数就可以了</p>
<p><strong>解法二</strong></p>
<p>给定了范围，直接用数组模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasGroupsSizeX2</span><span class="params">(<span class="type">int</span>[] deck)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] hash=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;deck.length;i++)&#123;</span><br><span class="line">        hash[deck[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;hash.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i]&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            g= g!=-<span class="number">1</span>?gcd(g,hash[i]):hash[i];</span><br><span class="line">            <span class="keyword">if</span>(g==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//优化，提前终止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g&gt;=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></h2><p>比较两个版本号 version1 和 version2。<br>如果 <code>version1 &gt; version2</code> 返回 1，如果 <code>version1 &lt; version2</code> 返回 -1， 除此之外返回 0。</p>
<p>你可以假设版本字符串非空，并且只包含数字和 . 字符。</p>
<p> . 字符不代表小数点，而是用于分隔数字序列。</p>
<p>例如，<code>2.5</code>  不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p>
<p>你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;0.1&quot;</span>, version2 = <span class="string">&quot;1.1&quot;</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;1.0.1&quot;</span>, version2 = <span class="string">&quot;1&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;7.5.2.4&quot;</span>, version2 = <span class="string">&quot;7.5.3&quot;</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;1.01&quot;</span>, version2 = <span class="string">&quot;1.001&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：忽略前导零，“<span class="number">01</span>” 和 “<span class="number">001</span>” 表示相同的数字 “<span class="number">1</span>”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;1.0&quot;</span>, version2 = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “<span class="number">0</span>”。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。</li>
<li>版本字符串不以点开始或结束，并且其中不会有两个连续的点。</li>
</ol>
<p><strong>解法一</strong></p>
<p>貌似笔试喜欢出这题，挺简单的，用 java 分割的时候要注意 <code>&quot;.&quot;</code> 是一个正则表达式，匹配任意单个字符，我们如果要将它看作一个普通字符需要加上双斜线<code>&quot;\\.&quot;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">    String[] v1=version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    String[] v2=version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="type">int</span> len1=v1.length,len2=v2.length;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1 || j&lt;len2) &#123;</span><br><span class="line">        <span class="type">int</span> a=Integer.valueOf(i&lt;len1?v1[i++]:<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="type">int</span> b=Integer.valueOf(j&lt;len2?v2[j++]:<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a&lt;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a&gt;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string <span class="title function_">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;LEETCODEISHIRING&quot;</span>, numRows = <span class="number">3</span></span><br><span class="line">输出：<span class="string">&quot;LCIRETOESIIGEDHN&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;LEETCODEISHIRING&quot;</span>, numRows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;LDREOEIIECIHNTSG&quot;</span></span><br><span class="line">解释：</span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>比较脑残，但是勉强还是过了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span> || s.length()&lt;=<span class="number">0</span> || numRows==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=s.length();</span><br><span class="line">    <span class="comment">//足够的空间</span></span><br><span class="line">    <span class="type">int</span>[][] strs=<span class="keyword">new</span> <span class="title class_">int</span>[((len/((numRows-<span class="number">1</span>)*<span class="number">2</span>))+<span class="number">1</span>)*(numRows-<span class="number">1</span>)][numRows];</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            strs[x][y++]=s.charAt(index++);</span><br><span class="line">            <span class="keyword">if</span> (y==numRows-<span class="number">1</span>) &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            strs[x++][y--]=s.charAt(index++);</span><br><span class="line">            <span class="keyword">if</span> (y==<span class="number">0</span>) &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;strs[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i][j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                sb.append((<span class="type">char</span>)strs[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是将字符按照之字形填入一个二维数组中，然后按规则取出来就 ok，最优解看了，明天再来写！</p>
<p><strong>解法二</strong></p>
<p>今天还是不够清晰，后天再写</p>
<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列</a></h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;abc&quot;</span>, t = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">返回 <span class="literal">true</span>.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;axc&quot;</span>, t = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">返回 <span class="literal">false</span>.</span><br></pre></td></tr></table></figure>

<p><strong>后续挑战 :</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span> || t==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sindex=<span class="number">0</span>,tindex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sindex&lt;s.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tindex&lt;t.length() &amp;&amp; sindex&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(sindex)==t.charAt(tindex)) &#123;</span><br><span class="line">                sindex++;</span><br><span class="line">            &#125;</span><br><span class="line">            tindex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tindex==t.length()) &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sindex==s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改成递归（多练习递归）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subsequence(s,t,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">subsequence</span><span class="params">(String s,String t,<span class="type">int</span> sindex,<span class="type">int</span> tindex)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sindex == s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上下 if 不能交换，可能最后一个才相等</span></span><br><span class="line">    <span class="keyword">if</span> (tindex == t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.charAt(sindex)==t.charAt(tindex)?subsequence(s,t,sindex+<span class="number">1</span>,tindex+<span class="number">1</span>):subsequence(s,t,sindex,tindex+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大量的 s 字符串 处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence3</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="comment">//预处理</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; hash=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">        hash.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++) &#123;</span><br><span class="line">        hash.get(t.charAt(i)-<span class="string">&#x27;a&#x27;</span>).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过上面的预处理，后面的处理就会很快，不用再遍历 t 字符串</span></span><br><span class="line">    <span class="type">int</span> lastIndex=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; indexList=hash.get(s.charAt(i)-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> temp=binarySearch(indexList,lastIndex);</span><br><span class="line">        <span class="keyword">if</span> (temp==indexList.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastIndex=indexList.get(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个比 target 大的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;Integer&gt; list,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=list.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (list.get(mid)&gt;target) &#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">向右旋转 <span class="number">1</span> 步：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步：[<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步：[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>,<span class="number">99</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br><span class="line">解释：</span><br><span class="line">向右旋转 <span class="number">1</span> 步：[<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步：[<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法 </li>
</ul>
<p><strong>解法一</strong></p>
<p>常规解法，每次保留数组最后一个元素，从后往前将每个元素赋值为前一个元素的值，这样就相当于将数组整体向后循环移动一次，循环移动 k 次就是最后的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">1</span>||k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    k=k%len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp=nums[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=len-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">            nums[j]=nums[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[<span class="number">0</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度较高，<code>O(NK)</code> Java 可以过，但是 C/C++可能过不了</p>
<p><strong>解法二</strong></p>
<p>这个做法就相当巧妙了，三次翻转🐂🍺</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//翻转的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">1</span>||k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    k=k%len;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    reverse(nums,<span class="number">0</span>,len-k-<span class="number">1</span>);</span><br><span class="line">    reverse(nums,len-k,len-<span class="number">1</span>);</span><br><span class="line">    reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        swap(nums,left++,right--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>O(N)</code> 应该是最优解了</p>
<h2 id="1232-缀点成线"><a href="#1232-缀点成线" class="headerlink" title="1232. 缀点成线"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/">1232. 缀点成线</a></h2><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p>
<p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 <code>true</code>，否则请返回  <code>false</code></p>
<p><strong>解法一</strong></p>
<p>10.20 竞赛第一题，判断给定的点是不是再一条直线上，判断和前两个点是不是在一条直线上，注意不要直接除算斜率，那样是不准确的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkStraightLine</span><span class="params">(<span class="type">int</span>[][] coordinates)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;coordinates.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((coordinates[i][<span class="number">1</span>]-coordinates[i-<span class="number">1</span>][<span class="number">1</span>])*(coordinates[i-<span class="number">1</span>][<span class="number">0</span>]-coordinates[i-<span class="number">2</span>][<span class="number">0</span>])!=</span><br><span class="line">           (coordinates[i][<span class="number">0</span>]-coordinates[i-<span class="number">1</span>][<span class="number">0</span>])*(coordinates[i-<span class="number">1</span>][<span class="number">1</span>]-coordinates[i-<span class="number">2</span>][<span class="number">1</span>]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1233-删除子文件夹"><a href="#1233-删除子文件夹" class="headerlink" title="1233. 删除子文件夹"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/">1233. 删除子文件夹</a></h2><p>你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。</p>
<p>我们这样定义「子文件夹」：</p>
<ul>
<li><p>如果文件夹 <code>folder[i]</code> 位于另一个文件夹 <code>folder[j]</code> 下，那么 <code>folder[i]</code> 就是 <code>folder[j]</code> 的子文件夹。<br>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：</p>
</li>
<li><p><code>/</code> 后跟一个或者多个小写英文字母。<br>例如，<code>/leetcode</code> 和 <code>/leetcode/problems</code> 都是有效的路径，而空字符串和 <code>/</code> 不是。</p>
</li>
</ul>
<p> <strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：folder = [<span class="string">&quot;/a&quot;</span>,<span class="string">&quot;/a/b&quot;</span>,<span class="string">&quot;/c/d&quot;</span>,<span class="string">&quot;/c/d/e&quot;</span>,<span class="string">&quot;/c/f&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;/a&quot;</span>,<span class="string">&quot;/c/d&quot;</span>,<span class="string">&quot;/c/f&quot;</span>]</span><br><span class="line">解释：<span class="string">&quot;/a/b/&quot;</span> 是 <span class="string">&quot;/a&quot;</span> 的子文件夹，而 <span class="string">&quot;/c/d/e&quot;</span> 是 <span class="string">&quot;/c/d&quot;</span> 的子文件夹。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：folder = [<span class="string">&quot;/a&quot;</span>,<span class="string">&quot;/a/b/c&quot;</span>,<span class="string">&quot;/a/b/d&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;/a&quot;</span>]</span><br><span class="line">解释：文件夹 <span class="string">&quot;/a/b/c&quot;</span> 和 <span class="string">&quot;/a/b/d/&quot;</span> 都会被删除，因为它们都是 <span class="string">&quot;/a&quot;</span> 的子文件夹。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：folder = [<span class="string">&quot;/a/b/c&quot;</span>,<span class="string">&quot;/a/b/d&quot;</span>,<span class="string">&quot;/a/b/ca&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;/a/b/c&quot;</span>,<span class="string">&quot;/a/b/ca&quot;</span>,<span class="string">&quot;/a/b/d&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= folder.length &lt;= 4 * 10^4</li>
<li>2 &lt;= folder[i].length &lt;= 100</li>
<li>folder[i] 只包含小写字母和 /</li>
<li>folder[i] 总是以字符 / 起始</li>
<li>每个文件夹名都是唯一的</li>
</ul>
<p><strong>解法一</strong></p>
<p><code>2019.10.20</code>的竞赛题，当时没做出来。一直超时，太菜了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeSubfolders</span><span class="params">(String[] folder)</span> &#123;</span><br><span class="line">    Arrays.sort(folder);</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> root=<span class="number">0</span>;</span><br><span class="line">    res.add(folder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;folder.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!folder[i].startsWith(folder[root]+<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            res.add(folder[i]);</span><br><span class="line">            root=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时我想到了排序，但是并没处理好，排序之后还是傻傻的一个个去对比，其实排序后就很清楚了</p>
<p><code>folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]</code> 题目其实也在暗示我们要排序，给的 case 都是排好序的</p>
<p>当然这里很精髓的一步就是在对比的时候在 <code>folder[root]</code> 后面加上一个 <code>&quot;/&quot;</code> ，这样就不会将 <code>a/b/c</code> 判断为 <code>a/b/ca</code> 的根目录了~</p>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">注意：<span class="string">&quot;aba&quot;</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>是面试经常考的一题，还是挺有意思的，除了这个还有几道回文的题我放在动态规划专题中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span> || s.length()&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res=s.charAt(<span class="number">0</span>)+<span class="string">&quot;&quot;</span>;<span class="comment">//只有 1 个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        String even=palindrome(s,i-<span class="number">1</span>,i); <span class="comment">//偶数长度回文，从两个字符中间开始扩散</span></span><br><span class="line">        String odd=palindrome(s,i,i); <span class="comment">//奇数长度回文，从某一个字符开始扩散</span></span><br><span class="line">        String temp=odd.length()&gt;even.length()?odd:even;</span><br><span class="line">        <span class="keyword">if</span> (temp.length()&gt;res.length()) &#123;</span><br><span class="line">            res=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">palindrome</span><span class="params">(String s,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;=s.length()-<span class="number">1</span> &amp;&amp; s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">        i--;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(i+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果采用暴力法的话就是枚举所有子串，判断是不是回文串，最后求个最长的，时间复杂度<code>O(N^3)</code> ，但是我们可以利用回文的特征，利用中心扩散法，以<code>str</code>的<strong>各个位置</strong>作为中心，向两边扩散，最后求得最大值，注意得这里说的是<strong>各个位置</strong>，这个里面其实就包含了元素之间的间隙，其实整体思路还是挺简单的，但经过我们小小的转换思路，时间复杂度就降低到了<code>O(N^2)</code>，当然，这里还不是最优解，最优应该是 <a target="_blank" rel="noopener" href="https://oi-wiki.org/string/manacher/">Manacher</a> （马拉车）算法，等后面有时间我再来研究这种算法</p>
<h2 id="336-回文对"><a href="#336-回文对" class="headerlink" title="336. 回文对"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-pairs/">336. 回文对</a></h2><p>Difficulty: <strong>困难</strong></p>
<p>给定一组 <strong>互不相同</strong> 的单词， 找出所有<strong>不同</strong>的索引对<code>(i, j)</code>，使得列表中的两个单词， <code>words[i] + words[j]</code> ，可拼接成回文串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：[<span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;dcba&quot;</span>,<span class="string">&quot;lls&quot;</span>,<span class="string">&quot;s&quot;</span>,<span class="string">&quot;sssll&quot;</span>]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>]] </span><br><span class="line">解释：可拼接成的回文串为 [<span class="string">&quot;dcbaabcd&quot;</span>,<span class="string">&quot;abcddcba&quot;</span>,<span class="string">&quot;slls&quot;</span>,<span class="string">&quot;llssssll&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：[<span class="string">&quot;bat&quot;</span>,<span class="string">&quot;tab&quot;</span>,<span class="string">&quot;cat&quot;</span>]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">解释：可拼接成的回文串为 [<span class="string">&quot;battab&quot;</span>,<span class="string">&quot;tabbat&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>枚举单词的所有前缀 or 后缀，如果除了前缀 or 后缀剩余部分是回文串，并且在 dict 中存在前缀 or 后缀的翻转，那么这两个单词就能构成回文对</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">palindromePairs</span><span class="params">(words []<span class="type">string</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dict = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line">        dict[reverse(words[i])] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= <span class="built_in">len</span>(words[i]); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> idx, ok := dict[words[i][:j]]; ok &amp;&amp; idx != i &amp;&amp; isPalindrome(words[i][j:]) &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;i, idx&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里需要判断下 j!=0，避免重复的判断，s[0:] == s[:len(s)]</span></span><br><span class="line">            <span class="keyword">if</span> idx, ok := dict[words[i][j:]]; j != <span class="number">0</span> &amp;&amp; ok &amp;&amp; idx != i &amp;&amp; isPalindrome(words[i][:j]) &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;idx, i&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bs = []<span class="type">byte</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(bs)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        bs[i], bs[j] = bs[j], bs[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属于比较暴力的解法，这题也可以使用马拉车&amp;字典树，这里我就不多写了</p>
<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>
<p><strong>注意：</strong><br>假设字符串的长度不会超过 1010。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="string">&quot;abccccdd&quot;</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">我们可以构造的最长的回文串是<span class="string">&quot;dccaccd&quot;</span>, 它的长度是 <span class="number">7</span>。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>和上面的题目名字一样，但是请注意审题！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> || s.length()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] hash=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        hash[s.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Arrays.sort(hash);</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;<span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=hash.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                res+=hash[i]; <span class="comment">//偶数直接加</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                res+=(hash[i]-<span class="number">1</span>); <span class="comment">//奇数减一再加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag?res+<span class="number">1</span>:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></h2><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;aba&quot;</span></span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;abca&quot;</span></span><br><span class="line">输出：True</span><br><span class="line">解释：你可以删除 c 字符。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>字符串只包含从 a-z 的小写字母。字符串的最大长度是 50000。</li>
</ol>
<p><strong>解法一</strong></p>
<p>模拟就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> || s.length()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left++;right--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> valid(s,left+<span class="number">1</span>,right) || valid(s,left,right-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(String s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left++;right--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1332-删除回文子序列"><a href="#1332-删除回文子序列" class="headerlink" title="1332. 删除回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">1332. 删除回文子序列</a></h2><p>给你一个字符串 s，它仅由字母 ‘a’ 和 ‘b’ 组成。每一次删除操作都可以从 s 中删除一个回文 <strong>子序列</strong>。</p>
<p>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</p>
<p>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</p>
<p>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ababa&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：字符串本身就是回文序列，只需要删除一次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;abb&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="string">&quot;abb&quot;</span> -&gt; <span class="string">&quot;bb&quot;</span> -&gt; <span class="string">&quot;&quot;</span>. </span><br><span class="line">先删除回文子序列 <span class="string">&quot;a&quot;</span>，然后再删除 <span class="string">&quot;bb&quot;</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;baabb&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="string">&quot;baabb&quot;</span> -&gt; <span class="string">&quot;b&quot;</span> -&gt; <span class="string">&quot;&quot;</span>. </span><br><span class="line">先删除回文子序列 <span class="string">&quot;baab&quot;</span>，然后再删除 <span class="string">&quot;b&quot;</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅包含字母 ‘a’  和 ‘b’</li>
</ul>
<p><strong>解法一</strong></p>
<p>某一次周赛的第一题，乍一看最长回文子串？最长回文序列？这题当时还是难到了不少人，我那次没参加，后台听说了第一题是个坑，然后这里审题的时候就很注意，没踩坑😁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removePalindromeSub</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span> || s.length()&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=s.length()-<span class="number">1</span>;i&lt;=j;i++,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目说了只有两个字母 a 和 b，而且要删除的是<strong>回文子序列</strong>，这样一说就清楚了，这才是简单题的水准呐~还是挺有意思的，脑筋急转弯 hahaha</p>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意：</p>
<ul>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：移除 [<span class="number">1</span>,<span class="number">3</span>] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：你需要移除两个 [<span class="number">1</span>,<span class="number">2</span>] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>动态规划，其实和最长递增子序列是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="literal">null</span> || intervals.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span>[]dp=<span class="keyword">new</span> <span class="title class_">int</span>[intervals.length];</span><br><span class="line">    <span class="type">int</span> max=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.length;i++) &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;=intervals[j][<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i]=Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max=Math.max(max,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals.length-max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>171ms，8%，感觉快要过不了了。本来是是写的记忆化递归的，结果过不了。卡在倒数第二个 case 上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Pair,Integer&gt; cache=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//TLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals2</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> intervals.length-dfs(intervals,<span class="number">0</span>,Integer.MIN_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//背包问题，返回最多可以留下的区间</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] intervals,<span class="type">int</span> index,<span class="type">int</span> prev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index==intervals.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Pair key=<span class="keyword">new</span> <span class="title class_">Pair</span>(index,prev);</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=dfs(intervals,index+<span class="number">1</span>,prev);</span><br><span class="line">    <span class="keyword">if</span> (intervals[index][<span class="number">0</span>]&gt;=prev) &#123;</span><br><span class="line">        res=Math.max(res,dfs(intervals,index+<span class="number">1</span>,intervals[index][<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(key,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>贪心，时间复杂度降低为线性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="literal">null</span> || intervals.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照起点排序，重叠的时候选择保留结尾小的那一个</span></span><br><span class="line">    <span class="comment">//Arrays.sort(intervals,(a,b)-&gt;a[0]-b[0]); lambda 初始化效率会低一点</span></span><br><span class="line">    Arrays.sort(intervals,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span>[] b)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> prev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]&gt;=intervals[prev][<span class="number">1</span>]) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            prev=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&lt;intervals[prev][<span class="number">1</span>])&#123;</span><br><span class="line">            prev=i; <span class="comment">//选择结尾小的那一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals.length-res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照起点排序，在重叠的时候优先选择结尾小的哪一个，这样就可能得到更多的区间组合，关于这个算法的正确性我就不证明了</p>
<h2 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a></h2><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">6</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">6</span> = <span class="number">2</span> × <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">8</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">8</span> = <span class="number">2</span> × <span class="number">2</span> × <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">14</span></span><br><span class="line">输出：<span class="literal">false</span> </span><br><span class="line">解释：<span class="number">14</span> 不是丑数，因为它包含了另外一个质因数 <span class="number">7</span>。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><code>1</code> 是丑数。</li>
<li>输入不会超过 <code>32</code> 位有符号整数的范围：<code>[−231,  231 − 1]</code>。</li>
</ol>
<p><strong>解法一</strong></p>
<p>直接暴力，还是比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num%<span class="number">2</span>==<span class="number">0</span>?isUgly(num/<span class="number">2</span>):<span class="literal">false</span> || num%<span class="number">3</span>==<span class="number">0</span>?isUgly(num/<span class="number">3</span>):<span class="literal">false</span> || num%<span class="number">5</span>==<span class="number">0</span>?isUgly(num/<span class="number">5</span>):<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1333-餐厅过滤器"><a href="#1333-餐厅过滤器" class="headerlink" title="1333. 餐厅过滤器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/">1333. 餐厅过滤器</a></h2><p>给你一个餐馆信息数组 <code>restaurants</code>，其中  <code>restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]</code>。你必须使用以下三个过滤器来过滤这些餐馆信息。</p>
<p>其中素食者友好过滤器 <code>veganFriendly</code> 的值可以为 <code>true</code> 或者 <code>false</code>，如果为 <code>true</code> 就意味着你应该只包括 <code>veganFriendlyi</code> 为 <code>true</code> 的餐馆，为 <code>false</code> 则意味着可以包括任何餐馆。此外，我们还有最大价格 <code>maxPrice</code> 和最大距离 <code>maxDistance</code> 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。</p>
<p>过滤后返回餐馆的 <code>id</code>，按照 <code>rating</code> 从高到低排序。如果 <code>rating</code> 相同，那么按 <code>id</code> 从高到低排序。简单起见， <code>veganFriendlyi</code> 和 <code>veganFriendly</code> 为 <code>true</code> 时取值为 1，为 <code>false</code> 时，取值为 0 。</p>
<p><strong>示例一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：restaurants = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">40</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">30</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">1</span>]], veganFriendly = <span class="number">1</span>, maxPrice = <span class="number">50</span>, maxDistance = <span class="number">10</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>] </span><br><span class="line">解释： </span><br><span class="line">这些餐馆为：</span><br><span class="line">餐馆 <span class="number">1</span> [id=<span class="number">1</span>, rating=<span class="number">4</span>, veganFriendly=<span class="number">1</span>, price=<span class="number">40</span>, distance=<span class="number">10</span>]</span><br><span class="line">餐馆 <span class="number">2</span> [id=<span class="number">2</span>, rating=<span class="number">8</span>, veganFriendly=<span class="number">0</span>, price=<span class="number">50</span>, distance=<span class="number">5</span>]</span><br><span class="line">餐馆 <span class="number">3</span> [id=<span class="number">3</span>, rating=<span class="number">8</span>, veganFriendly=<span class="number">1</span>, price=<span class="number">30</span>, distance=<span class="number">4</span>]</span><br><span class="line">餐馆 <span class="number">4</span> [id=<span class="number">4</span>, rating=<span class="number">10</span>, veganFriendly=<span class="number">0</span>, price=<span class="number">10</span>, distance=<span class="number">3</span>]</span><br><span class="line">餐馆 <span class="number">5</span> [id=<span class="number">5</span>, rating=<span class="number">1</span>, veganFriendly=<span class="number">1</span>, price=<span class="number">15</span>, distance=<span class="number">1</span>] </span><br><span class="line">在按照 veganFriendly = <span class="number">1</span>, maxPrice = <span class="number">50</span> 和 maxDistance = <span class="number">10</span> 进行过滤后，我们得到了餐馆 <span class="number">3</span>, 餐馆 <span class="number">1</span> 和 餐馆 <span class="number">5</span>（按评分从高到低排序）。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：restaurants = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">40</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">30</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">1</span>]], veganFriendly = <span class="number">0</span>, maxPrice = <span class="number">50</span>, maxDistance = <span class="number">10</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">解释：餐馆与示例 <span class="number">1</span> 相同，但在 veganFriendly = <span class="number">0</span> 的过滤条件下，应该考虑所有餐馆。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：restaurants = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">40</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">30</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">1</span>]], veganFriendly = <span class="number">0</span>, maxPrice = <span class="number">30</span>, maxDistance = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= restaurants.length &lt;= 10^4</code></li>
<li><code>restaurants[i].length == 5</code></li>
<li><code>1 &lt;= idi, ratingi, pricei, distancei &lt;= 10^5</code></li>
<li><code>1 &lt;= maxPrice, maxDistance &lt;= 10^5</code></li>
<li><code>veganFriendlyi</code> 和 <code>veganFriendly</code> 的值为 0 或 1 。</li>
<li>所有 <code>idi</code> 各不相同。</li>
</ul>
<p><strong>解法一</strong></p>
<p>看到这个题，javaer 不用 stream 可太可惜了 hahaha</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">filterRestaurants</span><span class="params">(<span class="type">int</span>[][] restaurants, <span class="type">int</span> veganFriendly, <span class="type">int</span> maxPrice, <span class="type">int</span> maxDistance)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(restaurants)</span><br><span class="line">        .filter(r-&gt; (veganFriendly==<span class="number">1</span>?r[<span class="number">2</span>]==veganFriendly:<span class="literal">true</span>) &amp;&amp; r[<span class="number">4</span>]&lt;=maxDistance &amp;&amp; r[<span class="number">3</span>]&lt;=maxPrice)</span><br><span class="line">        .sorted((r1,r2)-&gt;r1[<span class="number">1</span>]!=r2[<span class="number">1</span>]?r2[<span class="number">1</span>]-r1[<span class="number">1</span>]:r2[<span class="number">0</span>]-r1[<span class="number">0</span>])</span><br><span class="line">        .map(r-&gt;r[<span class="number">0</span>])</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5313-时钟指针的夹角"><a href="#5313-时钟指针的夹角" class="headerlink" title="5313. 时钟指针的夹角"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/angle-between-hands-of-a-clock/">5313. 时钟指针的夹角</a></h2><p>给你两个数 <code>hour</code> 和 <code>minutes</code> 。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60 单位制）。</p>
<p>这题就懒得 copy 了，19 场双周赛的第三题，不应该是 mid 题的。</p>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">angleClock</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minutes)</span> &#123;</span><br><span class="line">    <span class="type">double</span> m=minutes/<span class="number">60.0</span> * <span class="number">360</span>;</span><br><span class="line">    <span class="type">double</span> h=((hour/<span class="number">12.0</span>)*<span class="number">360</span>)%<span class="number">360</span> + <span class="number">30</span>*minutes/<span class="number">60.0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(Math.abs(m-h),<span class="number">360</span>-Math.abs(m-h));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>化简一下是 <strong>h 时 m 分的夹角为：5.5m-30h</strong></p>
<h2 id="5169-日期之间隔几天"><a href="#5169-日期之间隔几天" class="headerlink" title="5169. 日期之间隔几天"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-days-between-two-dates/">5169. 日期之间隔几天</a></h2><p>请你编写一个程序来计算两个日期之间隔了多少天。</p>
<p>日期以字符串形式给出，格式为 <code>YYYY-MM-DD</code>。</p>
<p><strong>解法一</strong></p>
<p>177 周赛的 T1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">daysBetweenDates</span><span class="params">(String date1, String date2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.abs(LocalDate.parse(date1).until(LocalDate.parse(date2),ChronoUnit.DAYS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做 LeetCode 少数导包了的题🤣</p>
<p><strong>解法二</strong></p>
<p>copy 大佬的原生解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] months = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">daysBetweenDates</span><span class="params">(String date1, String date2)</span> &#123;</span><br><span class="line">    String[] d1 = date1.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    String[] d2 = date2.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">day1</span> <span class="operator">=</span> getYears(Integer.valueOf(d1[<span class="number">0</span>]) - <span class="number">1</span>) + getMonths(Integer.valueOf(d1[<span class="number">0</span>]), Integer.valueOf(d1[<span class="number">1</span>]) - <span class="number">1</span>) + Integer.valueOf(d1[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">day2</span> <span class="operator">=</span> getYears(Integer.valueOf(d2[<span class="number">0</span>]) - <span class="number">1</span>) + getMonths(Integer.valueOf(d2[<span class="number">0</span>]), Integer.valueOf(d2[<span class="number">1</span>]) - <span class="number">1</span>) + Integer.valueOf(d2[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> Math.abs(day1 - day2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getYears</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (year - <span class="number">1971</span>) * <span class="number">365</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1971</span>; i &lt;= year; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRun(i)) &#123;</span><br><span class="line">            ++sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMonths</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= month; ++i) &#123;</span><br><span class="line">        sum += months[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRun(year) &amp;&amp; month &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        ++sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRun</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;Let&#x27;s take LeetCode contest&quot;</span></span><br><span class="line">输出：<span class="string">&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot;</span> </span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格</p>
<p><strong>解法一</strong></p>
<p>原生的做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s+=<span class="string">&quot; &quot;</span>;<span class="comment">//统一操作</span></span><br><span class="line">    <span class="type">char</span>[] cs=s.toCharArray();</span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;cs.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cs[i]==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            reverse(cs,start,i-<span class="number">1</span>);</span><br><span class="line">            start=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs,<span class="number">0</span>,cs.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=left,j=right;i&lt;j;i++,j--) &#123;</span><br><span class="line">        <span class="type">char</span> temp=s[i];</span><br><span class="line">        s[i]=s[j];</span><br><span class="line">        s[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a></h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;the sky is blue&quot;</span></span><br><span class="line">输出：<span class="string">&quot;blue is sky the&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;  hello world!  &quot;</span></span><br><span class="line">输出：<span class="string">&quot;world! hello&quot;</span></span><br><span class="line">解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;a good   example&quot;</span></span><br><span class="line">输出：<span class="string">&quot;example good a&quot;</span></span><br><span class="line">解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<p><strong>进阶：</strong></p>
<p>请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。</p>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> || s.length()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Deque&lt;String&gt; stack=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.length() &amp;&amp; s.charAt(i)!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(s.substring(j,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(stack.pop());</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        sb.append(<span class="string">&quot; &quot;</span>+stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较原生的做法，最开始写的借助 split 等方法的，比较简单就不多说了</p>
<p><strong>解法二</strong></p>
<p>原地的做法，比较繁琐，后面有时间再来实现下</p>
<ol>
<li>翻转整个字符</li>
<li>翻转单个字符</li>
<li>去除多余空格</li>
</ol>
<h2 id="面试题-01-06-字符串压缩"><a href="#面试题-01-06-字符串压缩" class="headerlink" title="面试题 01.06. 字符串压缩"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/compress-string-lcci/">面试题 01.06. 字符串压缩</a></h2><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串 aabcccccaaa 会变为 a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a 至 z）。</p>
<p>case 就不粘了</p>
<p><strong>解法一</strong></p>
<p>直接写就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">compressString</span><span class="params">(String S)</span> &#123;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;S.length())&#123;</span><br><span class="line">        sb.append(S.charAt(index));</span><br><span class="line">        <span class="type">int</span> r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;S.length()-<span class="number">1</span>&amp;&amp;S.charAt(index)==S.charAt(index+<span class="number">1</span>))&#123;</span><br><span class="line">            ++index;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(r);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length()&lt;S.length()?sb.toString():S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h2><p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">24</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">说明：请不要使用除法，且在 O(n) 时间复杂度内完成此题。</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p>
<p><strong>解法一</strong></p>
<p>还行，独立的想到了解法，没啥好说的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="literal">null</span> || nums.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] left=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>]; </span><br><span class="line">    left[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//left[i]: [0 ~ i-1] 的累积</span></span><br><span class="line">    <span class="type">int</span>[] right=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    right[nums.length]=<span class="number">1</span>; <span class="comment">//right[i]: [i ~ nums.length-1] 的累积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++) &#123;</span><br><span class="line">        left[i]=left[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        right[i]=right[i+<span class="number">1</span>]*nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//1 2 3</span></span><br><span class="line">    res[<span class="number">0</span>]=right[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        res[i]=left[i]*right[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>O(1) 进阶版有时间再来补</p>
<h2 id="5341-最后-K-个数的乘积"><a href="#5341-最后-K-个数的乘积" class="headerlink" title="5341. 最后 K 个数的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/">5341. 最后 K 个数的乘积</a></h2><p>请你实现一个「数字乘积类」<code>ProductOfNumbers</code>，要求支持下述两种方法：</p>
<ol>
<li>add(int num)</li>
</ol>
<ul>
<li>将数字 num 添加到当前数字列表的最后面。</li>
</ul>
<ol start="2">
<li>getProduct(int k)</li>
</ol>
<ul>
<li>返回当前数字列表中，最后 k 个数字的乘积。</li>
<li>你可以假设当前列表中始终 至少 包含 k 个数字。</li>
<li>题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;ProductOfNumbers&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;getProduct&quot;</span>,<span class="string">&quot;getProduct&quot;</span>,<span class="string">&quot;getProduct&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;getProduct&quot;</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[<span class="number">0</span>],[<span class="number">2</span>],[<span class="number">5</span>],[<span class="number">4</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">8</span>],[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="literal">null</span>,<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="type">ProductOfNumbers</span> <span class="variable">productOfNumbers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductOfNumbers</span>();</span><br><span class="line">productOfNumbers.add(<span class="number">3</span>);        <span class="comment">// [3]</span></span><br><span class="line">productOfNumbers.add(<span class="number">0</span>);        <span class="comment">// [3,0]</span></span><br><span class="line">productOfNumbers.add(<span class="number">2</span>);        <span class="comment">// [3,0,2]</span></span><br><span class="line">productOfNumbers.add(<span class="number">5</span>);        <span class="comment">// [3,0,2,5]</span></span><br><span class="line">productOfNumbers.add(<span class="number">4</span>);        <span class="comment">// [3,0,2,5,4]</span></span><br><span class="line">productOfNumbers.getProduct(<span class="number">2</span>); <span class="comment">// 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20</span></span><br><span class="line">productOfNumbers.getProduct(<span class="number">3</span>); <span class="comment">// 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40</span></span><br><span class="line">productOfNumbers.getProduct(<span class="number">4</span>); <span class="comment">// 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0</span></span><br><span class="line">productOfNumbers.add(<span class="number">8</span>);        <span class="comment">// [3,0,2,5,4,8]</span></span><br><span class="line">productOfNumbers.getProduct(<span class="number">2</span>); <span class="comment">// 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 </span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add 和 getProduct 两种操作加起来总共不会超过 <span class="number">40000</span> 次。</span><br><span class="line"><span class="number">0</span> &lt;= num &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= <span class="number">40000</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>176 周赛的第二题，思路倒是很容易想到，维护一个前缀积，然后用全积除以对应 k 位置的就行了，但是细节的处理出了大问题 haha~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; product=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProductOfNumbers</span><span class="params">()</span> &#123;</span><br><span class="line">    product=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    product.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>)&#123; <span class="comment">//重新构建</span></span><br><span class="line">        product=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        product.add(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        product.add(num*product.getLast());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1| 1 0 2 3  k=3</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getProduct</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=product.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product.getLast()/product.get(product.size()-k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始维护了所有的前缀积，结果后面的 case 过不了，出现了除 0 异常，很显然把 0 换成 1，后面的 case 大了之后累乘的结果太大了，溢出为 0 了。</p>
<p>上面代码的处理方式是参考了大佬的解法，遇到 0 的时候就直接重置队列，最后如果 k 大于队列长度说明这个序列肯定是包含了 0，直接返回 0 就可以了</p>
<h2 id="面试题-64-求-1-2-…-n"><a href="#面试题-64-求-1-2-…-n" class="headerlink" title="面试题 64. 求 1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">面试题 64. 求 1+2+…+n</a></h2><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">9</span></span><br><span class="line">输出：<span class="number">45</span></span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li>1 &lt;= n &lt;= 10000</li>
</ul>
<p><strong>解法一</strong></p>
<p>我一开始想的是把 <code>n*(n-1)/2</code>  展开，变成平方，用 pow 代替，除 2 用移位代替，但是想了想感觉 pow 底层应该也是用了乘</p>
<p>所以还是得用递归，但是递归必须有出口，这里的关键就是怎么停止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="comment">//逻辑与短路</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> (n &gt; <span class="number">0</span>) &amp;&amp; ((sum += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></h2><p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。</p>
<p>不要使用系统的 Math.random() 方法。</p>
<p><strong>解法一</strong></p>
<p>拒绝采样，两次 Rand7() 拒绝大于 40 的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a,b,idx;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        a=rand7();</span><br><span class="line">        b=rand7();</span><br><span class="line">        idx=a+(b-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(idx&gt;<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+(idx-<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概率论里面学过的，都忘了</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38nhYn.png" alt="38nhYn.png"></p>
<p>期望其实还可以更低，这里后面有时间再来研究</p>
<h2 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a></h2><p>打乱一个没有重复元素的数组。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以数字集合 1, 2 和 3 初始化数组。</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3] 的排列返回的概率应该相同。</span></span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设数组到它的初始状态 [1,2,3]。</span></span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机返回数组 [1,2,3] 打乱后的结果。</span></span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>洗牌算法，确保至少会出现<code>N!</code>种情况，且每种情况出现的概率是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] origin=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] nums=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">Random random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nums=nums;</span><br><span class="line">    origin=nums.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reset() &#123;</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shuffle() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="comment">//从尾部开始这样对于 Java 会简单一点点</span></span><br><span class="line">        <span class="type">int</span> rand=(<span class="type">int</span>)(random.nextInt(i+<span class="number">1</span>)); <span class="comment">//随机【0,i】的元素</span></span><br><span class="line">        swap(nums,i,rand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-61-扑克牌中的顺子"><a href="#面试题-61-扑克牌中的顺子" class="headerlink" title="面试题 61. 扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">面试题 61. 扑克牌中的顺子</a></h2><p>从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2～10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<p>数组长度为 5 </p>
<p>数组的数取值为 [0, 13] .</p>
<p><strong>解法一</strong></p>
<p>只有 5 张牌，先排除对子，然后求最大和最小的牌面之差就行了，小于等于 4 就肯定是顺子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] bucket=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">14</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        bucket[nums[i]]++;</span><br><span class="line">        <span class="comment">//有非 0 的对子，直接 false</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span> &amp;&amp; bucket[nums[i]] &gt;<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录起手牌和最大牌</span></span><br><span class="line">    <span class="type">int</span> start=-<span class="number">1</span>,end=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">13</span>;end==-<span class="number">1</span>||start==-<span class="number">1</span>;i++,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i]==<span class="number">1</span> &amp;&amp; start==-<span class="number">1</span>) start=i;</span><br><span class="line">        <span class="keyword">if</span>(bucket[j]==<span class="number">1</span> &amp;&amp; end==-<span class="number">1</span>) end=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小于等于 4 就行，多的用 0 补</span></span><br><span class="line">    <span class="keyword">return</span> end-start&lt;=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码可以优化成一个循环内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缩减成一个循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] bucket=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">14</span>];</span><br><span class="line">    <span class="type">int</span> min=<span class="number">14</span>,max=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(bucket[nums[i]]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        bucket[nums[i]]++;</span><br><span class="line">        min=Math.min(min,nums[i]);</span><br><span class="line">        max=Math.max(max,nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max-min&lt;=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1103-分糖果-II"><a href="#1103-分糖果-II" class="headerlink" title="1103. 分糖果 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distribute-candies-to-people/">1103. 分糖果 II</a></h2><p>排排坐，分糖果。</p>
<p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p>
<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p>
<p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p>
<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>
<p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：candies = <span class="number">7</span>, num_people = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[<span class="number">0</span>] += <span class="number">1</span>，数组变为 [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]。</span><br><span class="line">第二次，ans[<span class="number">1</span>] += <span class="number">2</span>，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]。</span><br><span class="line">第三次，ans[<span class="number">2</span>] += <span class="number">3</span>，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>]。</span><br><span class="line">第四次，ans[<span class="number">3</span>] += <span class="number">1</span>（因为此时只剩下 <span class="number">1</span> 颗糖果），最终数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：candies = <span class="number">10</span>, num_people = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[<span class="number">0</span>] += <span class="number">1</span>，数组变为 [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]。</span><br><span class="line">第二次，ans[<span class="number">1</span>] += <span class="number">2</span>，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]。</span><br><span class="line">第三次，ans[<span class="number">2</span>] += <span class="number">3</span>，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]。</span><br><span class="line">第四次，ans[<span class="number">0</span>] += <span class="number">4</span>，最终数组变为 [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candies &lt;= 10^9</code></li>
<li><code>1 &lt;= num_people &lt;= 1000</code></li>
</ul>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力模拟</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] distributeCandies(<span class="type">int</span> candies, <span class="type">int</span> num_people) &#123;</span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[num_people];</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;candies&gt;<span class="number">0</span>;i++) &#123;</span><br><span class="line">        res[index%num_people]+=Math.min(candies,i);</span><br><span class="line">        candies-=i;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数学的方法：每个人得到的糖果分批次的都是一个等差数列，可以通过求和公式直接算，过程有点繁琐，后面有时间再来研究</p>
<h2 id="1013-将数组分成和相等的三个部分"><a href="#1013-将数组分成和相等的三个部分" class="headerlink" title="1013. 将数组分成和相等的三个部分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/">1013. 将数组分成和相等的三个部分</a></h2><p>  给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p>
<p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">6</span>,<span class="number">6</span>,-<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">0</span> + <span class="number">2</span> + <span class="number">1</span> = -<span class="number">6</span> + <span class="number">6</span> - <span class="number">7</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">2</span> + <span class="number">0</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,-<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,-<span class="number">9</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span> = <span class="number">5</span> - <span class="number">2</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">1</span> - <span class="number">9</span> + <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>3 &lt;= A.length &lt;= 50000</li>
<li>-10^4 &lt;= A[i] &lt;= 10^4</li>
</ol>
<p><strong>解法一</strong></p>
<p>这个解法算是被群友误导了的，群里面有人说这题是前缀和，然后我就往哪个上面想的，其实没必要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canThreePartsEqualSum</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preSum=<span class="keyword">new</span> <span class="title class_">int</span>[A.length+<span class="number">1</span>];</span><br><span class="line">    preSum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A.length;i++)&#123;</span><br><span class="line">        preSum[i]=preSum[i-<span class="number">1</span>]+A[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;preSum.length-<span class="number">2</span>;i++)&#123; <span class="comment">//保证剩下 2 个</span></span><br><span class="line">        <span class="keyword">if</span>(preSum[A.length]-preSum[i]==preSum[i]*<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;preSum.length-<span class="number">1</span>;j++)&#123; <span class="comment">//保证剩下 1 个</span></span><br><span class="line">                <span class="keyword">if</span>(preSum[A.length]-preSum[i]==(preSum[j]-preSum[i])*<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="comment">//System.out.println(i+&quot; &quot;+j);</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>这才是正常的思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canThreePartsEqualSum</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.length;i++) sum+=A[i];</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>,tempSum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//i 到达 A.length-1 保证有第 3 段，否则有可能 target=0 只分为两段就没了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.length-<span class="number">1</span>;i++)&#123; </span><br><span class="line">        tempSum+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(tempSum==sum/<span class="number">3</span>)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            tempSum=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题的 WA 点就是 sum=0 的时候，有可能按照划分的逻辑只将数组划分为两段，所以要注意边界</p>
<h2 id="调整数组顺序使奇数位于偶数前面（牛客）"><a href="#调整数组顺序使奇数位于偶数前面（牛客）" class="headerlink" title="调整数组顺序使奇数位于偶数前面（牛客）"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&&tqId=11166&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">调整数组顺序使奇数位于偶数前面（牛客）</a></h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>解法一</strong></p>
<p>其实就是稳定的排序，插入，冒泡，归并都可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reOrderArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; array[j-<span class="number">1</span>]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                swap(array,j,j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=array[a];</span><br><span class="line">    array[a]=array[b];</span><br><span class="line">    array[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rectangle-overlap/">836. 矩形重叠</a></h2><p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。</p>
<p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形，判断它们是否重叠并返回结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：rec1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>], rec2 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：rec1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], rec2 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>两个矩形 <code>rec1</code> 和 <code>rec2</code> 都以含有四个整数的列表的形式给出。</li>
<li>矩形中的所有坐标都处于 <code>-10^9</code> 和 <code>10^9</code> 之间。</li>
<li><code>x</code> 轴默认指向右，<code>y</code> 轴默认指向上。</li>
<li>你可以仅考虑矩形是正放的情况。</li>
</ol>
<p><strong>解法一</strong></p>
<p>憨憨解法，最后还被一个大 case 越界给卡了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRectangleOverlap</span><span class="params">(<span class="type">int</span>[] rec1, <span class="type">int</span>[] rec2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x=Math.max(rec2[<span class="number">2</span>]-rec1[<span class="number">0</span>],rec1[<span class="number">2</span>]-rec2[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> y=Math.max(rec2[<span class="number">3</span>]-rec1[<span class="number">1</span>],rec1[<span class="number">3</span>]-rec2[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">long</span> maxX=((<span class="type">long</span>)rec1[<span class="number">2</span>]-(<span class="type">long</span>)rec1[<span class="number">0</span>]+(<span class="type">long</span>)rec2[<span class="number">2</span>]-(<span class="type">long</span>)rec2[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">long</span> maxY=((<span class="type">long</span>)rec1[<span class="number">3</span>]-(<span class="type">long</span>)rec1[<span class="number">1</span>]+(<span class="type">long</span>)rec2[<span class="number">3</span>]-(<span class="type">long</span>)rec2[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> x&lt;maxX &amp;&amp; y &lt;maxY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRectangleOverlap</span><span class="params">(<span class="type">int</span>[] rec1, <span class="type">int</span>[] rec2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(rec1[<span class="number">3</span>]&lt;=rec2[<span class="number">1</span>]||rec2[<span class="number">3</span>]&lt;=rec1[<span class="number">1</span>]||rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>]||rec2[<span class="number">2</span>]&lt;=rec1[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/">892. 三维形体的表面积</a></h2><p>在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。</p>
<p>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。</p>
<p>请你返回最终形体的表面积。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">34</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">32</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">46</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= N &lt;= 50</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 50</code> </li>
</ul>
<p><strong>解法一</strong></p>
<p>做加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法思路</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">surfaceArea</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="literal">null</span> || grid.length&lt;=<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> N=grid.length;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++) &#123;</span><br><span class="line">            <span class="comment">//正面，背面暴露的面积</span></span><br><span class="line">            res+= Math.max(j&lt;N-<span class="number">1</span>?grid[i][j+<span class="number">1</span>]-grid[i][j]:grid[i][j],<span class="number">0</span>);</span><br><span class="line">            res+= Math.max(j&gt;<span class="number">0</span>?grid[i][j-<span class="number">1</span>]-grid[i][j]:grid[i][j],<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//左和右边暴露的面积</span></span><br><span class="line">            res+= Math.max(i&lt;N-<span class="number">1</span>?grid[i+<span class="number">1</span>][j]-grid[i][j]:grid[i][j],<span class="number">0</span>);</span><br><span class="line">            res+= Math.max(i&gt;<span class="number">0</span>?grid[i-<span class="number">1</span>][j]-grid[i][j]:grid[i][j],<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//上和下的面积</span></span><br><span class="line">            res+= grid[i][j]!=<span class="number">0</span>?<span class="number">2</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我太蠢了，开始直接分别算 6 个面，然后发现有坑，又去算坑的面积。结果就陷进去了</p>
<p><strong>解法二</strong></p>
<p>巧妙的减法思路，算贴合的时候的重合的面积</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//巧妙的减法思路</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">surfaceArea</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="literal">null</span> || grid.length&lt;=<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> N=grid.length;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                x+=grid[i][j]-<span class="number">1</span>;</span><br><span class="line">                count+=grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; grid[i-<span class="number">1</span>][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                y+=Math.min(grid[i][j],grid[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">1</span> &amp;&amp; grid[i][j-<span class="number">1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                y+=Math.min(grid[i][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count*<span class="number">6</span>-<span class="number">2</span>*x-<span class="number">2</span>*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p>
<p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>偶然翻到的题，发现和上面的是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和 892 类似的解法，简化版</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,up=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    up++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count*<span class="number">4</span>-(up+left)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看到题解区有大佬 dfs 的，通过方格的变化统计有效的边，比如从 1-&gt;0 就可以增加一条边，而从 1-&gt;边界又可以增加一条边，还是挺秒的</p>
</blockquote>
<h2 id="999-车的可用捕获量"><a href="#999-车的可用捕获量" class="headerlink" title="999. 车的可用捕获量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/available-captures-for-rook/">999. 车的可用捕获量</a></h2><p>题目太长，不想复制了，模拟题，题目意思搞清楚就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRookCaptures</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] direction=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">                    <span class="type">int</span> nx=i+direction[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> ny=j+direction[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">while</span>(nx&gt;=<span class="number">0</span> &amp;&amp; nx&lt;board.length &amp;&amp; ny&gt;=<span class="number">0</span> &amp;&amp; ny&lt;board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[nx][ny]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(board[nx][ny]==<span class="string">&#x27;p&#x27;</span>)&#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        nx+=direction[k][<span class="number">0</span>];</span><br><span class="line">                        ny+=direction[k][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/game-of-life/">289. 生命游戏</a></h2><p>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<ol>
<li><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</p>
</li>
<li><p>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</p>
</li>
<li><p>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</p>
</li>
<li><p>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</p>
</li>
</ol>
<p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<ul>
<li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li>
<li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li>
</ul>
<p><strong>解法一</strong></p>
<p>bugfree</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] dir=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(board==<span class="literal">null</span> || board.length&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m=board.length,n=board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">boolean</span>[][] change=<span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="number">0</span> &amp;&amp; aliveCell(board,i,j,change)==<span class="number">3</span>)&#123;</span><br><span class="line">                board[i][j]=<span class="number">1</span>;</span><br><span class="line">                change[i][j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> alive=aliveCell(board,i,j,change);</span><br><span class="line">                <span class="keyword">if</span>(alive&lt;<span class="number">2</span> || alive&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j]=<span class="number">0</span>;</span><br><span class="line">                    change[i][j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">aliveCell</span><span class="params">(<span class="type">int</span>[][] board,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">boolean</span>[][] change)</span>&#123;</span><br><span class="line">    <span class="type">int</span> alive=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;dir.length;k++)&#123;</span><br><span class="line">        <span class="type">int</span> nx=x+dir[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ny=y+dir[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(valid(board,nx,ny)&amp;&amp;(board[nx][ny]==<span class="number">1</span> &amp;&amp; !change[nx][ny] || (board[nx][ny]==<span class="number">0</span> &amp;&amp; change[nx][ny])))&#123;</span><br><span class="line">            alive++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> alive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span>[][] board,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;board.length &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;board[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我理解的原地就是在原数组上做修改，但是并没有说不能用额外空间吧。但是看了评论区大佬们都不是这样写的，都是用的位运算，用 int 空的位保存状态，最后移位，懒得写了，感觉没啥意思，水题</p>
<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a></h2><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：小于 <span class="number">10</span> 的质数一共有 <span class="number">4</span> 个，它们是 <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">厄拉多塞筛法</a> 简称埃式筛</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] prime=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    <span class="comment">//为了不那么别扭</span></span><br><span class="line">    Arrays.fill(prime,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i])&#123;</span><br><span class="line">            <span class="comment">//从 i*i 开始，i*(i-1) 已经被前面的统计了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                prime[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;prime.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i]) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="171-Excel-表列序号"><a href="#171-Excel-表列序号" class="headerlink" title="171. Excel 表列序号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-number/">171. Excel 表列序号</a></h2><p>给定一个 Excel 表格中的列名称，返回其相应的列序号。</p>
<p>例如，</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
...
</code></pre>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;A&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;AB&quot;</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;ZY&quot;</span></span><br><span class="line">输出：<span class="number">701</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>朋友作业帮面试问了这道题，其实就是进制的转换，写了个回转的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//26 进制转 10 进制</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> || s.length()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,n=s.length();</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        res+=(s.charAt(i)-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>)*temp;</span><br><span class="line">        temp*=<span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10 进制转 26 进制</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">numberToTitle</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(s!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//这个 s-1 要注意啊 woc</span></span><br><span class="line">        res.append((<span class="type">char</span>)((s-<span class="number">1</span>)%<span class="number">26</span>+<span class="number">65</span>));</span><br><span class="line">        s=(s-<span class="number">1</span>)/<span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="168-Excel-表列名称"><a href="#168-Excel-表列名称" class="headerlink" title="168. Excel 表列名称"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel 表列名称</a></h2><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; A</span><br><span class="line"><span class="number">2</span> -&gt; B</span><br><span class="line"><span class="number">3</span> -&gt; C</span><br><span class="line">...</span><br><span class="line"><span class="number">26</span> -&gt; Z</span><br><span class="line"><span class="number">27</span> -&gt; AA</span><br><span class="line"><span class="number">28</span> -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">28</span></span><br><span class="line">输出：<span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">701</span></span><br><span class="line">输出：<span class="string">&quot;ZY&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">numberToTitle</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(s!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//这个 s-1 要注意啊 woc</span></span><br><span class="line">        res.append((<span class="type">char</span>)((s-<span class="number">1</span>)%<span class="number">26</span>+<span class="number">65</span>));</span><br><span class="line">        s=(s-<span class="number">1</span>)/<span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go 写法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToTitle</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n&gt;<span class="number">0</span>&#123;</span><br><span class="line">        res=<span class="type">string</span>((n<span class="number">-1</span>)%<span class="number">26</span>+<span class="string">&#x27;A&#x27;</span>)+res</span><br><span class="line">        n=(n<span class="number">-1</span>)/<span class="number">26</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724. 寻找数组的中心索引"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-pivot-index/">724. 寻找数组的中心索引</a></h2><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组<strong>“中心索引”</strong>的方法。</p>
<p>我们是这样定义数组<strong>中心索引</strong>的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">索引 <span class="number">3</span> (nums[<span class="number">3</span>] = <span class="number">6</span>) 的左侧数之和 (<span class="number">1</span> + <span class="number">7</span> + <span class="number">3</span> = <span class="number">11</span>)，与右侧数之和 (<span class="number">5</span> + <span class="number">6</span> = <span class="number">11</span>) 相等。</span><br><span class="line">同时，<span class="number">3</span> 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li>
<li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li>
</ul>
<p><strong>解法一</strong></p>
<p>唉，不知道为啥，直接写了个前缀后缀和判断的，很暴力直白的思路，咋就想不到简单的思路？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//前缀和，后缀和</span></span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre:=<span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>) <span class="comment">//i 之前的元素和，不包含 i</span></span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    last:=<span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>) <span class="comment">//(i-1) 之后元素和，不包含 (i-1)</span></span><br><span class="line">    last[n]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,j := <span class="number">1</span>,n<span class="number">-1</span>;i&lt;=n &amp;&amp; j&gt;=<span class="number">0</span>; i,j = i+<span class="number">1</span>,j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">//这里其实只要代入值验证第一次的转移是正确的就行了，不用考虑太多</span></span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>]</span><br><span class="line">        last[j]=last[j+<span class="number">1</span>]+nums[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">        <span class="comment">//联系上面数组的定义思考这里的判断</span></span><br><span class="line">        <span class="keyword">if</span> pre[i]==last[i+<span class="number">1</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>简单的思路，脑子瓦特了一下没想到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,num:= <span class="keyword">range</span> nums&#123;</span><br><span class="line">        sum+=num</span><br><span class="line">    &#125;</span><br><span class="line">    temp:=<span class="number">0</span> <span class="comment">//包含了边界 0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> temp*<span class="number">2</span>+nums[i]==sum&#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        temp+=nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="945-使数组唯一的最小增量"><a href="#945-使数组唯一的最小增量" class="headerlink" title="945. 使数组唯一的最小增量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/">945. 使数组唯一的最小增量</a></h2><p>给定整数数组 A，每次 <em>move</em> 操作将会选择任意 <code>A[i]</code>，并将其递增 <code>1</code>。</p>
<p>返回使 <code>A</code> 中的每个值都是唯一的最少操作次数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：经过一次 move 操作，数组将变为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：经过 <span class="number">6</span> 次 move 操作，数组将变为 [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>]。</span><br><span class="line">可以看出 <span class="number">5</span> 次或 <span class="number">5</span> 次以下的 move 操作是不能让数组的每个值唯一的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 40000</code></li>
<li><code>0 &lt;= A[i] &lt; 40000</code></li>
</ol>
<p><strong>解法一</strong></p>
<p>之前写了，没记录，这次 PDD 笔试考了这题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minIncrementForUnique</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    <span class="type">int</span> move=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;=A[i-<span class="number">1</span>])&#123;</span><br><span class="line">            move+=A[i-<span class="number">1</span>]-A[i];</span><br><span class="line">            A[i]=A[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> move;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暴力的解法很好想，首先肯定要排序，然后遇到小于等于前面的时候就<code>move+1</code>，直到不相等，但是这里是可以优化的，一次次的加没有啥意义，可以直接一步到位直接从<code>A[i]</code>增加到<code>A[i-1]+1</code></p>
<blockquote>
<p>这题还有一些方法优化，首先是排序可以用桶排序，然后还可以用并查集（比较麻烦），或者也有数学分析找规律的方法</p>
</blockquote>
<h2 id="面试题-05-替换空格"><a href="#面试题-05-替换空格" class="headerlink" title="面试题 05. 替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">面试题 05. 替换空格</a></h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;We are happy.&quot;</span></span><br><span class="line">输出：<span class="string">&quot;We%20are%20happy.&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= s 的长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>这题的标准做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] res=<span class="keyword">new</span> <span class="title class_">char</span>[s.length()*<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            res[idx++]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            res[idx++]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            res[idx++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[idx++]=s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res,<span class="number">0</span>,idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>原题是要求 O(1) 空间的，这里虽然无法做到，但是可以模拟下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原题目的要求应该是在 O(1) 空间下，但是 Java 的 String 是不可变的</span></span><br><span class="line"><span class="comment">//所以不可能 O(1), 我们需要改一下函数签名</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(<span class="comment">/*StringBuilder*/</span> String ss)</span> &#123;</span><br><span class="line">    StringBuilder s=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(ss); <span class="comment">//这里是为了验证</span></span><br><span class="line">    <span class="type">int</span> oldLen=s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;oldLen;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>) s.append(<span class="string">&quot;xx&quot;</span>); <span class="comment">//扩充字符长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> newLen=s.length();</span><br><span class="line">    <span class="comment">//逆序，避免覆盖</span></span><br><span class="line">    <span class="type">int</span> i=oldLen-<span class="number">1</span>,j=newLen-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> c=s.charAt(i--);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            s.setCharAt(j--,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            s.setCharAt(j--,<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">            s.setCharAt(j--,<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s.setCharAt(j--,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-45-把数组排成最小的数"><a href="#面试题-45-把数组排成最小的数" class="headerlink" title="面试题 45. 把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">面试题 45. 把数组排成最小的数</a></h2><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">&quot;102&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="string">&quot;3033459&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt; nums.length &lt;= 100</code></li>
</ul>
<p><strong>说明：</strong></p>
<p>输出结果可能非常大，所以你需要返回一个字符串而不是整数；拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p>
<p><strong>解法一</strong></p>
<p>一开始贼 sb，想了一大堆有的没的😅<br><img src="https://upload.cc/i1/2020/06/22/zOQcTL.png" alt="UTOOLS1592838604659.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    String[] strs=<span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) strs[i]=nums[i]+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    Arrays.sort(strs,(a,b)-&gt;(a+b).compareTo(b+a));</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(String i:strs) sb.append(i);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然绕了一大圈，所幸还是自己做出来了，但是为什么这样就是对的呢？其实这里我也是想当然了，严谨的应该对这个排序规则的传递性进行证明，也就是<code>xy&gt;yx &amp;&amp; yz&gt;zy ==&gt; xz&gt;xz ?</code>这个成立，排序的结果才是对的，这里我就不 copy 了，证明也不是很难，大家可以去原题 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/378553">题解区</a> 看看</p>
<h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a></h2><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">210</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">9534330</span></span><br><span class="line">说明：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</span><br></pre></td></tr></table></figure>
<p><strong>解法一</strong></p>
<p>和上一题一摸一样，借机学习下 golang 的自定义排序</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> p[i]+p[j] &gt; p[j]+p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    strs := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        strs[i] = strconv.Itoa(n)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Sort(StringSlice(strs))</span><br><span class="line">    <span class="comment">//return strings.Join(strs,&quot;&quot;) 要去前导 0...</span></span><br><span class="line">    <span class="comment">// var res = &quot;&quot;</span></span><br><span class="line">    <span class="comment">// var idx = 0</span></span><br><span class="line">    <span class="comment">// for idx &lt; len(strs)-1 &amp;&amp; strs[idx] == &quot;0&quot; &#123;</span></span><br><span class="line">    <span class="comment">//     idx++</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for idx &lt; len(strs) &#123;</span></span><br><span class="line">    <span class="comment">//     res += strs[idx]</span></span><br><span class="line">    <span class="comment">//     idx++</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    res := strings.Join(strs, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &#123; <span class="comment">//第一个为 0 肯定就全部是 0 了。.. 前面的写法明显没动脑子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了大佬们的提交记录发现 go 1.8 在 sort 包中引入了</p>
<p><code>func Slice(slice interface&#123;&#125;, less func(i, j int) bool)</code></p>
<p>通过这个就不用很麻烦的去实现 3 个函数了，只需要实现<code>Less</code>比较器就可以了（其实这才是正常的做法，其他语言中也都是类似的，其他两个<code>len</code>和<code>swap</code>感觉意义不大，一般不会改这两个函数，完全可以自动生成）</p>
<blockquote>
<p>看评论区又看到一个很好的 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-number/solution/zui-da-shu-bi-jiao-gui-ze-chuan-di-xing-yi-ji-suan/344160">反证的思路</a>，大致意思就是：假设存在序列<code>&quot;...ab...&quot;</code>为最大数，且不满足该排序规则<code>ab&gt;ba</code>，也就是说<code>ab&lt;ba</code>，那我们交换序列中 ab 的位置变为<code>&quot;...ba...&quot;</code>很明显<code>&quot;...ba...&quot;</code>&gt;<code>&quot;...ab...&quot;</code>，与假设矛盾，所以最大数一定满足该排序规则</p>
</blockquote>
<h2 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h2><p>Difficulty: <strong>中等</strong></p>
<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p>
<p>数学表达式如下：</p>
<blockquote>
<p>如果存在这样的 <em>i, j, k, _ 且满足 0 ≤ _i</em> &lt; <em>j</em> &lt; <em>k</em> ≤ <em>n</em>-1，<br>使得 <em>arr[i]</em> &lt; <em>arr[j]</em> &lt; <em>arr[k]</em> ，返回 true ; 否则返回 false 。</p>
</blockquote>
<p><strong>说明：</strong> 要求算法的时间复杂度为 O(<em>n</em>)，空间复杂度为 O(<em>1</em>) 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>题目限制了空间复杂度 O(1) 时间复杂度 O(N)，所以利用额外空间的方案就不适用了，我们只需要记录当前元素<strong>之前的最小值</strong>，和最小值<strong>右边的次小值</strong>就 ok 了，在循环中不断的更新这两个值</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increasingTriplet</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> INT_MAX = <span class="type">int</span>(^<span class="type">uint</span>(<span class="number">0</span>)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> a = INT_MAX</span><br><span class="line">    <span class="keyword">var</span> b = INT_MAX</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= a&#123;</span><br><span class="line">            a = nums[i]</span><br><span class="line">            <span class="comment">//b = a 这里不用更新次小值，因为我们要保证 a 在 b 前面</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[i] &lt;= b&#123;</span><br><span class="line">            b = nums[i]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很可惜是在看了题解区才明白，真的菜啊，一开始想劈叉了，我一直在考虑中间的元素，想怎么求左右的最小最大值。</p>
<h2 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h2><p>Difficulty: <strong>简单</strong></p>
<p>给定一个整数 <em>n_，返回 _n</em>! 结果尾数中零的数量。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="number">3</span>! = <span class="number">6</span>, 尾数中没有零。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">5</span>! = <span class="number">120</span>, 尾数中有 <span class="number">1</span> 个零。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> 你算法的时间复杂度应为 <em>O</em>(log <em>n</em>)。</p>
<p><strong>解法一</strong></p>
<p>首先需要明确题目要求什么，<code>n!</code>结尾 0 的个数，直接算阶乘的值显然是不可能的，值会很大很容易溢出，而且大数相乘的时间复杂度也很高</p>
<p>我们考虑下末尾的 0 是怎么来的，我们知道一个数 x10，末尾就会多一个 0，这里也一样，所以我们要求的就是在阶乘的过程中乘了多少个 10，那么 10 从哪里来呢？</p>
<p>我们将 10 拆解成<code>2*5</code>，问题就又转化成了，阶乘中产生了多少对<code>2*5</code>的因子，注意这个并不是单纯指 1~n 中某一个值 2，或者 5，而是中间每个数拆分出来的因子，比如 15 就拆分成 3*5，中间就有一个 5 的因子，现在问题明确了，我们如何去求 2 或者 5 的因子个数呢？</p>
<p>根据<strong>短板理论</strong>，很明显这两个因子我们只需要求其中<strong>个数较少</strong>的那一个就可以了，少的那个一定可以找到配对的另一个因子，举个例子，假设我们<code>n!</code>中产生了 2 个** 5 的因子<strong>，和 5 个</strong> 2 的因子**，那么很明显最后我们最后配对的<code>2x5</code>只有 2 对，也就是结尾会有 2 个 0，那么 2 和 5 我们求哪一个呢？或者说 2 和 5 的因子数量一定会有固定的大小关系么？</p>
<p>其实上面的问题凭直觉就能看出来，明显 5 的个数会少一些，应该求 5 的个数，但是秉承着严谨的态度，我们还是应该实际的算一算，而且后面 code 的时候也是需要算的</p>
<p>首先看 2 的个数，我们每隔 2 个数就会产生一个 2 的因子，比如 2，4，6，8，10…，但是同时有的数会有多个因子，这个里面也会产生 2，比如 4 就可以拆解成<code>2x2</code>，也就是每隔<code>4</code>个元素，抛开原来每隔<code>2</code>个元素产生的 2，会额外的再产生一个 2 的因子，同理 8 可以拆解成<code>2x2x2</code>，也就是所每隔 8 个元素又会产生一个额外的 2，所以总体的 n! 中，包含 2 的因子个数是 <code>n/2 + n/4 + n/8 + ...</code>，同理也可推出 5 的因子个数，如下：<br><img src="http://static.imlgw.top/blog/20200630/lFrypQIJu57J.png?imageslim" alt="mark"><br>很明显同样项数 m 的情况下，5 的因子的个数要更少，所以我们直接求因子 5 的个数就行了</p>
<p>有了上面的结论，代码就很容易写了，直接模拟就行了，时间复杂度<code>O(log(5,N))</code></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trailingZeroes</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span>&#123;</span><br><span class="line">        n /= <span class="number">5</span></span><br><span class="line">        count += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="793-阶乘函数后-K-个零"><a href="#793-阶乘函数后-K-个零" class="headerlink" title="793. 阶乘函数后 K 个零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function/">793. 阶乘函数后 K 个零</a></h2><p>Difficulty: <strong>困难</strong></p>
<p> <code>f(x)</code> 是 <code>x!</code> 末尾是 0 的数量。（回想一下 <code>x! = 1 * 2 * 3 * ... * x</code>，且<code>0! = 1</code>）</p>
<p>例如， <code>f(3) = 0</code> ，因为 3! = 6 的末尾没有 0；而 <code>f(11) = 2</code> ，因为 11!= 39916800 末端有 2 个 0。给定 <code>K</code>，找出多少个非负整数<code>x</code> ，有 <code>f(x) = K</code> 的性质。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入：K = <span class="number">0</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：<span class="number">0</span>!, <span class="number">1</span>!, <span class="number">2</span>!, <span class="number">3</span>!, and <span class="number">4</span>! 均符合 K = <span class="number">0</span> 的条件。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入：K = <span class="number">5</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有匹配到这样的 x!，符合 K = <span class="number">5</span> 的条件。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>  <code>K</code>是范围在 <code>[0, 10^9]</code> 的整数<strong>。</strong></li>
</ul>
<p><strong>解法一</strong></p>
<p>上一题的逆向，挺有意思的，可惜了，一开始没想出来，我知道答案肯定是 0 or 5 但是不知道咋验证了。明明上一题之前就做过了，真菜啊，看了评论区才恍然大悟</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ans: 0 or 5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preimageSizeFZF</span><span class="params">(K <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//n/5 + n/25 + ... +  = K ==&gt; n &lt; 5*K</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">var</span> right = <span class="number">5</span>*K+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> zero = trailingZeroes(mid)</span><br><span class="line">        <span class="keyword">if</span> zero == K &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> zero &gt; K &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//172. 阶乘后的 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trailingZeroes</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n/=<span class="number">5</span></span><br><span class="line">        count += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-matrix-zeroes/">73. 矩阵置零</a></h2><p>Difficulty: <strong>中等</strong></p>
<p>给定一个 m*n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<ul>
<li>  一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li>
<li>  一个简单的改进方案是使用 O(m+n) 的额外空间，但这仍然不是最好的解决方案。</li>
<li>  你能想出一个常数空间的解决方案吗？</li>
</ul>
<p><strong>解法一</strong></p>
<p>傻逼题</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    r, c := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]); j++&#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>&#123;</span><br><span class="line">            r = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(matrix); i++&#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>&#123;</span><br><span class="line">            c = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span>; i &lt; <span class="built_in">len</span>(matrix); i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]); j++&#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>&#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j :=<span class="number">1</span>; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]); j++&#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(matrix);i++&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span>; i &lt; <span class="built_in">len</span>(matrix); i++&#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> j :=<span class="number">0</span>; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]); j++&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r &#123;</span><br><span class="line">        <span class="keyword">for</span> j :=<span class="number">0</span>; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]); j++&#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c &#123;</span><br><span class="line">        <span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(matrix); i++&#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-16-11-跳水板"><a href="#面试题-16-11-跳水板" class="headerlink" title="面试题 16.11. 跳水板"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diving-board-lcci/">面试题 16.11. 跳水板</a></h2><p>Difficulty: <strong>简单</strong></p>
<p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为<code>shorter</code>，长度较长的木板长度为<code>longer</code>。你必须正好使用<code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。</p>
<p>返回的长度需要从小到大排列。</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter = <span class="number">1</span></span><br><span class="line">longer = <span class="number">2</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">输出： &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  0 &lt; shorter &lt;= longer</li>
<li>  0 &lt;= k &lt;= 100000</li>
</ul>
<p><strong>解法一</strong></p>
<p>tag 里面有递归，记忆化什么的。加上看见群友的讨论，又先入为主了，唉，写了半天的回溯，想着怎么去重，突然意识到直接一个循环就能解决了。菜啊</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divingBoard</span><span class="params">(shorter <span class="type">int</span>, longer <span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> shorter == longer&#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123; k * shorter&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= k; i++&#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, i * longer + (k - i) * shorter)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NC82-苹果树"><a href="#NC82-苹果树" class="headerlink" title="NC82. 苹果树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/145b8d917c1e44c0b2b2462433b3029d?tpId=110&&tqId=33503&rp=1&ru=/ta/job-code&qru=/ta/job-code/question-ranking">NC82. 苹果树</a></h2><p>牛牛有一个苹果园。又到了一年一度的收获季，牛牛现在要去采摘苹果买给市场的摊贩们。<br>牛牛的果园里面有 n 棵苹果树，第 i 棵苹果树上有 a[i] 个果子。<br>牛牛为了保证果子的新鲜程度，每天都会去苹果树上采摘果子。<br>牛牛特意安排一个计划表：</p>
<p>计划 m 天去采摘果子。对于第 i 天，它会去所有果树上轮流采摘 b[i] 个果子。<br>如果对于第 i 天，某棵果树上没有 b[i] 个果子，那么它只会把当前果树上的果子采摘完。</p>
<p>牛牛想知道它每天能供应多少个苹果给市场的摊贩们。</p>
<p><strong>输入</strong></p>
<ul>
<li>1 &lt;= a[i] , b[i] &lt;= 1e9</li>
<li>1 &lt;= len(a), len(b) &lt;= 1e5</li>
</ul>
<p><strong>示例 1</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入 : [<span class="number">10</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>]</span><br><span class="line">输出 : [<span class="number">15</span>,<span class="number">17</span>,<span class="number">2</span>]</span><br><span class="line">说明 :</span><br><span class="line">苹果树上的果子变化 [<span class="number">10</span>,<span class="number">20</span>,<span class="number">10</span>]--&gt;[<span class="number">5</span>,<span class="number">15</span>,<span class="number">5</span>]--&gt;[<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>]--&gt;[<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>在牛客看见是头条二面的一道题，找到了牛客对应的题目，尝试了下，首先写了楼主的 前缀和+二分的解法</p>
<p>很可惜通过率 0，报错的数据很大，一看就知道溢出了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前缀和+二分的做法（容易溢出，random 稍微调大点就溢出了，过不了 OJ）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] solve2 (<span class="type">int</span>[] a, <span class="type">int</span>[] b) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="literal">null</span> || a.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> b.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">al</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span>[] preSum = <span class="keyword">new</span> <span class="title class_">long</span>[al];</span><br><span class="line">    preSum[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; al; i++)&#123;</span><br><span class="line">        preSum[i] = preSum[i-<span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span>[] res = <span class="keyword">new</span> <span class="title class_">long</span>[d];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; d; i++)&#123;</span><br><span class="line">        sb += b[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> search(a, sb);</span><br><span class="line">        <span class="keyword">if</span>(idx == -<span class="number">1</span>)&#123;</span><br><span class="line">            res[i] = sb * al - sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[i] = preSum[idx] + sb * (al-idx-<span class="number">1</span>) - sum;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小于 target 的最后一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; target)&#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>双指针的解法，还是很巧妙的，这题如果考虑去减掉每棵树的果子其实就走远了，那样时间复杂度肯定是 O(N^2) 的，其实我们完全不用每次都把果子的数量给减掉，首先我们对果树进行排序，这样方便进行区间的摘取，对整体分区变为 <code>无剩余 | 剩余不足 | 剩余足够</code>三个区间</p>
<p>每次摘取都是将前 n 天的合并起来一起摘，然后看<strong>剩余不足</strong>和<strong>剩余足够</strong>分界线在哪里，剩余不足的部分就直接加起来，然后减去前<code>n-1</code>天在该果树上采摘的数量，得到就是剩下的当天可以采摘的数量，之后这部分<strong>剩余不足</strong>的就变成了<strong>无剩余</strong></p>
<p>最后，在分界线以后的部分就都是剩余足够的部分，直接乘法计算就行了（小心溢出）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正解 双指针，时间复杂度 O(m+n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] solve (<span class="type">int</span>[] a, <span class="type">int</span>[] b) &#123;</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span>[] res = <span class="keyword">new</span> <span class="title class_">long</span>[b.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">        sb += b[i];</span><br><span class="line">        <span class="keyword">while</span>(p &lt; a.length &amp;&amp; a[p] &lt; sb)&#123;</span><br><span class="line">            <span class="comment">//该果树果子不够了，拿取剩下所有的</span></span><br><span class="line">            res[i] += (a[p] - (sb - b[i]));</span><br><span class="line">            <span class="comment">//下一颗果树</span></span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后面的都够</span></span><br><span class="line">        res[i]+=(a.length - p) * (<span class="type">long</span>)b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实和解法一的思路类似，但是这种做法不考虑溢出且时间复杂度更低</p>
</blockquote>
<h2 id="453-最小移动次数使数组元素相等"><a href="#453-最小移动次数使数组元素相等" class="headerlink" title="453. 最小移动次数使数组元素相等"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">453. 最小移动次数使数组元素相等</a></h2><p>Difficulty: <strong>简单</strong></p>
<p>给定一个长度为 <em>n</em> 的<strong>非空</strong>整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 <em>n</em> - 1 个元素增加 1。</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">只需要 <span class="number">3</span> 次移动（注意每次移动会增加两个元素的值）：</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  =&gt;  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]  =&gt;  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]  =&gt;  [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>n-1 个元素+1，就相当于 1 个元素-1，思维的转换，题目就变得简单了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMoves</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> min = math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; min &#123;</span><br><span class="line">            min = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        res += (nums[i]-min)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="696-计数二进制子串"><a href="#696-计数二进制子串" class="headerlink" title="696. 计数二进制子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a></h2><p>Difficulty: <strong>简单</strong></p>
<p>给定一个字符串 <code>s</code>，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<p><strong>示例 1 :</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;00110011&quot;</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：有 <span class="number">6</span> 个子串具有相同数量的连续 <span class="number">1</span> 和 <span class="number">0</span>：“<span class="number">0011</span>”，“<span class="number">01</span>”，“<span class="number">1100</span>”，“<span class="number">10</span>”，“<span class="number">0011</span>” 和 “<span class="number">01</span>”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“<span class="number">00110011</span>”不是有效的子串，因为所有的 <span class="number">0</span>（和 <span class="number">1</span>）没有组合在一起。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 :</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;10101&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有 <span class="number">4</span> 个子串：“<span class="number">10</span>”，“<span class="number">01</span>”，“<span class="number">10</span>”，“<span class="number">01</span>”，它们具有相同数量的连续 <span class="number">1</span> 和 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>  <code>s.length</code> 在 1 到 50,000 之间。</li>
<li>  <code>s</code> 只包含“0”或“1”字符。</li>
</ul>
<p><strong>解法一</strong></p>
<p>将字符转换为连续字符个数的排列，比如 111100011000–&gt;4323，然后我们将相邻两个数的最小值加入结果集就行了，3+2+2=7，下面的解法合并了两步操作</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBinarySubstrings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">var</span> last, cur = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> Min = <span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;<span class="keyword">if</span> a&lt;b &#123;<span class="keyword">return</span> a&#125;;<span class="keyword">return</span> b&#125;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p &lt; n &#123;</span><br><span class="line">        c := s[p]</span><br><span class="line">        <span class="keyword">for</span> p &lt; n &amp;&amp; s[p] == c &#123;</span><br><span class="line">            p++</span><br><span class="line">            cur++</span><br><span class="line">        &#125;</span><br><span class="line">        res += Min(cur, last)</span><br><span class="line">        last = cur</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h2><p>Difficulty: <strong>简单</strong></p>
<p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p></p>
<p>

<p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p>
<p><strong>注意</strong>：如果对空文本输入退格字符，文本继续为空。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;ab#c&quot;</span>, T = <span class="string">&quot;ad#c&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;ab##&quot;</span>, T = <span class="string">&quot;c#d#&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;a##c&quot;</span>, T = <span class="string">&quot;#a#c&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;a#c&quot;</span>, T = <span class="string">&quot;b&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li> <code>1 &lt;= S.length &lt;= 200</code></li>
<li> <code>1 &lt;= T.length &lt;= 200</code></li>
<li> <code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</li>
</ol>
<p><strong>进阶：</strong></p>
<ul>
<li>  你可以用 <code>O(N)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li>
</ul>
<p><strong>解法一</strong></p>
<p>O（N）空间的就不写了，随便搞搞就行了，关键是 O(1) 空间的解法，这里核心就是双指针从后想前扫描，然后注意边界就 ok 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String S, String T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> S.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> T.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        i = back(S, i);</span><br><span class="line">        j = back(T, j);</span><br><span class="line">        <span class="comment">//都匹配完了</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个匹配完了，两个对位字符不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || S.charAt(i) != T.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i--; j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//都匹配完了</span></span><br><span class="line">    <span class="keyword">return</span> i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">back</span><span class="params">(String s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || s.charAt(i) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/imlgw">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://imlgw.top">Tadow</a></span>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/publish/query/indexFirst.action">鄂ICP备18011208号</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




<script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"right","hOffset":0,"vOffset":-70},"mobile":{"show":false,"scale":0.2},"log":false});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://giscus.app/client.js"
  data-repo="imlgw/imlgw.github.io"
  data-repo-id="MDEwOlJlcG9zaXRvcnkxMzMyMDY4NDg="
  data-category="Announcements"
  data-category-id="DIC_kwDOB_CTQM4CQ7v8"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="top"
  data-theme="light"
  data-lang="zh-CN"
  data-loading="lazy"
  crossorigin="anonymous"
  async>
</script>



</html>
